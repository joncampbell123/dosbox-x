
arch "x86";
description "Machine-parsable list of opcodes";
charset_encoding "UTF-8"; /* default */

/* predefined variables:
   codesize == 16 || codesize == 32 || codesize == 64: word code access size (affects code handling)
   datasize == 16 || datasize == 32 || datasize == 64: word data access size (affects data handling)
   dsreg: default segment OR segment override
   CS, DS, ES, FS, GS, SS: segment registers
   reg: general register, operand (regw if word, regb if byte)
   regb: general register, byte operand (AH, AL, etc)
   regw: general register, word operand (AX, BX, CX, etc if 16-bit, EAX, EBX, etc if 32-bit)
   sreg: segment register, operand
   rm: register/memory operand, word operand
   rmb: register/memory operand, byte operand
   rmw: register/memory operand, byte operand
   mrm: mod/reg/rm (with optional scalar/index/byte if 32-bit addressing with the right combination)
   accum: AX/EAX
   base: BX/EBX
   counter: CX/ECX
   daccum: DX/EDX
   srcidx: SI/ESI
   dstidx: DI/EDI
   immb: 8-bit immediate
   immw: word immediate
   sib: scalar/index/byte
   flags: flags register (FLAGS if 16-bit, EFLAGS if 32-bit)
   flags(...): specific flags (bitmask)
   stackp: stack pointer (SP/ESP)
   basep: base pointer (BP/EBP)
   stackdataw: word value on stack [SS:stackp]
   ip: instruction pointer (IP/EIP)
   cpulevel: 0=8086 1=80186 2=286 3=386 4=486 5=Pentium
*/

/* avoid copy-pasta */
common opcode "ADD" param(dst,src) {
    modifies flags(CF,PF,AF,ZF,SF,OF);

    /* dst += src */
    input dst,src; /* reads dst, src */
    output dst; /* writes dst */
}

common opcode "OR" param(dst,src) {
    modifies flags(CF,PF,AF,ZF,SF,OF);

    /* dst |= src */
    input dst,src; /* reads dst, src */
    output dst; /* writes dst */
}

common opcode "ADC" param(dst,src) {
    modifies flags(CF,PF,AF,ZF,SF,OF);

    /* dst += src + CF */
    input dst,src,flags(CF); /* reads dst, src, CF flag */
    output dst; /* writes dst */
}

common opcode "SBB" param(dst,src) {
    modifies flags(CF,PF,AF,ZF,SF,OF);

    /* dst -= src + CF */
    input dst,src,flags(CF); /* reads dst, src, CF flag */
    output dst; /* writes dst */
}

common opcode "AND" param(dst,src) {
    modifies flags(CF,PF,AF,ZF,SF,OF);

    /* dst &= src */
    input dst,src; /* reads dst, src */
    output dst; /* writes dst */
}

common opcode "SUB" param(dst,src) {
    modifies flags(CF,PF,AF,ZF,SF,OF);

    /* dst -= src */
    input dst,src; /* reads dst, src */
    output dst; /* writes dst */
}

common opcode "PUSH" param(src) {
    modifies stackp; /* stackp -= word size */
    output stackdataw;
    input src;
}

common opcode "POP" param(dst) {
    modifies stackp; /* stackp += word size */
    input stackdataw;
    output src;
}

opcode sequence(0x00 mrm) name "ADD" { /* ADD r/m, reg */ common opcode "ADD" param(rmb,regb); }
opcode sequence(0x01 mrm) name "ADD" { /* ADD r/m, reg */ common opcode "ADD" param(rmw,regw); }
opcode sequence(0x02 mrm) name "ADD" { /* ADD reg, r/m */ common opcode "ADD" param(regb,rmb); }
opcode sequence(0x03 mrm) name "ADD" { /* ADD reg, r/m */ common opcode "ADD" param(regw,rmw); }
opcode sequence(0x04 immb) name "ADD" { /* ADD AL, imm */ common opcode "ADD" param(AL,immb); }
opcode sequence(0x05 immw) name "ADD" { /* ADD AX, imm */ common opcode "ADD" param(accum,immw); }
opcode sequence(0x06) name "PUSH" { /* PUSH ES */ common opcode "PUSH" param(ES); }
opcode sequence(0x07) name "POP" { /* POP ES */ common opcode "POP" param(ES); }

opcode sequence(0x08 mrm) name "OR" { /* OR r/m, reg */ common opcode "OR" param(rmb,regb); }
opcode sequence(0x09 mrm) name "OR" { /* OR r/m, reg */ common opcode "OR" param(rmw,regw); }
opcode sequence(0x0A mrm) name "OR" { /* OR reg, r/m */ common opcode "OR" param(regb,rmb); }
opcode sequence(0x0B mrm) name "OR" { /* OR reg, r/m */ common opcode "OR" param(regw,rmw); }
opcode sequence(0x0C immb) name "OR" { /* OR AL, imm */ common opcode "OR" param(AL,immb); }
opcode sequence(0x0D immw) name "OR" { /* OR AX, imm */ common opcode "OR" param(accum,immw); }
opcode sequence(0x0E) name "PUSH" { /* PUSH CS */ common opcode "PUSH" param(CS); }

opcode sequence(0x0F) name "POP" { /* POP CS */
    if cpulevel == 0 {
        common opcode "POP" param(CS);
    }
    else {
        reject; /* prefix, not opcode, this rule does not apply */
    }
}

opcode sequence(0x10 mrm) name "ADC" { /* ADC r/m, reg */ common opcode "ADC" param(rmb,regb); }
opcode sequence(0x11 mrm) name "ADC" { /* ADC r/m, reg */ common opcode "ADC" param(rmw,regw); }
opcode sequence(0x12 mrm) name "ADC" { /* ADC reg, r/m */ common opcode "ADC" param(regb,rmb); }
opcode sequence(0x13 mrm) name "ADC" { /* ADC reg, r/m */ common opcode "ADC" param(regw,rmw); }
opcode sequence(0x14 immb) name "ADC" { /* ADC AL, imm */ common opcode "ADC" param(AL,immb); }
opcode sequence(0x15 immw) name "ADC" { /* ADC AX, imm */ common opcode "ADC" param(accum,immw); }
opcode sequence(0x16) name "PUSH" { /* PUSH ES */ common opcode "PUSH" param(SS); }
opcode sequence(0x17) name "POP" { /* POP ES */ common opcode "POP" param(SS); }

opcode sequence(0x18 mrm) name "SBB" { /* SBB r/m, reg */ common opcode "SBB" param(rmb,regb); }
opcode sequence(0x19 mrm) name "SBB" { /* SBB r/m, reg */ common opcode "SBB" param(rmw,regw); }
opcode sequence(0x1A mrm) name "SBB" { /* SBB reg, r/m */ common opcode "SBB" param(regb,rmb); }
opcode sequence(0x1B mrm) name "SBB" { /* SBB reg, r/m */ common opcode "SBB" param(regw,rmw); }
opcode sequence(0x1C immb) name "SBB" { /* SBB AL, imm */ common opcode "SBB" param(AL,immb); }
opcode sequence(0x1D immw) name "SBB" { /* SBB AX, imm */ common opcode "SBB" param(accum,immw); }
opcode sequence(0x1E) name "PUSH" { /* PUSH ES */ common opcode "PUSH" param(DS); }
opcode sequence(0x1F) name "POP" { /* POP ES */ common opcode "POP" param(DS); }

opcode sequence(0x20 mrm) name "AND" { /* AND r/m, reg */ common opcode "AND" param(rmb,regb); }
opcode sequence(0x21 mrm) name "AND" { /* AND r/m, reg */ common opcode "AND" param(rmw,regw); }
opcode sequence(0x22 mrm) name "AND" { /* AND reg, r/m */ common opcode "AND" param(regb,rmb); }
opcode sequence(0x23 mrm) name "AND" { /* AND reg, r/m */ common opcode "AND" param(regw,rmw); }
opcode sequence(0x24 immb) name "AND" { /* AND AL, imm */ common opcode "AND" param(AL,immb); }
opcode sequence(0x25 immw) name "AND" { /* AND AX, imm */ common opcode "AND" param(accum,immw); }

opcode sequence(0x28 mrm) name "SUB" { /* SUB r/m, reg */ common opcode "SUB" param(rmb,regb); }
opcode sequence(0x29 mrm) name "SUB" { /* SUB r/m, reg */ common opcode "SUB" param(rmw,regw); }
opcode sequence(0x2A mrm) name "SUB" { /* SUB reg, r/m */ common opcode "SUB" param(regb,rmb); }
opcode sequence(0x2B mrm) name "SUB" { /* SUB reg, r/m */ common opcode "SUB" param(regw,rmw); }
opcode sequence(0x2C immb) name "SUB" { /* SUB AL, imm */ common opcode "SUB" param(AL,immb); }
opcode sequence(0x2D immw) name "SUB" { /* SUB AX, imm */ common opcode "SUB" param(accum,immw); }

