From a3c34881cd99fe2b2a11cc248ea7c91ccbdaf8e8 Mon Sep 17 00:00:00 2001
From: Heydojo <white.tw.tw@gmail.com>
Date: Thu, 15 Mar 2018 12:30:47 +0000
Subject: [PATCH 1/8] Adding updated libmt32emu_2_3_0

---
 src/mt32/Analog.cpp                                |  424 ++++
 src/mt32/Analog.h                                  |   53 +
 src/mt32/BReverbModel.cpp                          |  825 ++++---
 src/mt32/BReverbModel.h                            |  110 +-
 src/mt32/Enumerations.h                            |  187 ++
 src/mt32/File.cpp                                  |   56 +-
 src/mt32/File.h                                    |   55 +-
 src/mt32/FileStream.cpp                            |   84 +-
 src/mt32/FileStream.h                              |   30 +-
 src/mt32/LA32FloatWaveGenerator.cpp                |  359 +++
 src/mt32/LA32FloatWaveGenerator.h                  |  132 ++
 src/mt32/LA32Ramp.cpp                              |   43 +-
 src/mt32/LA32Ramp.h                                |   13 +-
 src/mt32/LA32WaveGenerator.cpp                     |   95 +-
 src/mt32/LA32WaveGenerator.h                       |   52 +-
 src/mt32/MemoryRegion.h                            |  132 ++
 src/mt32/MidiEventQueue.h                          |   71 +
 src/mt32/MidiStreamParser.cpp                      |  289 +++
 src/mt32/MidiStreamParser.h                        |  124 ++
 src/mt32/Part.cpp                                  |  160 +-
 src/mt32/Part.h                                    |   30 +-
 src/mt32/Partial.cpp                               |  258 ++-
 src/mt32/Partial.h                                 |   80 +-
 src/mt32/PartialManager.cpp                        |  122 +-
 src/mt32/PartialManager.h                          |   33 +-
 src/mt32/Poly.cpp                                  |  164 +-
 src/mt32/Poly.h                                    |   34 +-
 src/mt32/ROMInfo.cpp                               |   68 +-
 src/mt32/ROMInfo.h                                 |   35 +-
 src/mt32/SampleRateConverter.cpp                   |  126 ++
 src/mt32/SampleRateConverter.h                     |   75 +
 src/mt32/Structures.h                              |   82 +-
 src/mt32/Synth.cpp                                 | 2336 ++++++++++----------
 src/mt32/Synth.h                                   |  689 +++---
 src/mt32/TVA.cpp                                   |  225 +-
 src/mt32/TVA.h                                     |   20 +-
 src/mt32/TVF.cpp                                   |  139 +-
 src/mt32/TVF.h                                     |   21 +-
 src/mt32/TVP.cpp                                   |  270 +--
 src/mt32/TVP.h                                     |   22 +-
 src/mt32/Tables.cpp                                |   33 +-
 src/mt32/Tables.h                                  |   21 +-
 src/mt32/Types.h                                   |   32 +
 src/mt32/c_interface/c_interface.cpp               |  717 ++++++
 src/mt32/c_interface/c_interface.h                 |  434 ++++
 src/mt32/c_interface/c_types.h                     |  336 +++
 src/mt32/c_interface/cpp_interface.h               |  479 ++++
 src/mt32/globals.h                                 |  119 +
 src/mt32/internals.h                               |  118 +
 src/mt32/mmath.h                                   |  733 +-----
 src/mt32/mt32emu.h                                 |  134 +-
 src/mt32/sha1/sha1.cpp                             |  704 ++----
 src/mt32/sha1/sha1.h                               |  120 +-
 src/mt32/srchelper/InternalResampler.cpp           |   74 +
 src/mt32/srchelper/InternalResampler.h             |   42 +
 src/mt32/srchelper/SamplerateAdapter.cpp           |   99 +
 src/mt32/srchelper/SamplerateAdapter.h             |   48 +
 src/mt32/srchelper/SoxrAdapter.cpp                 |  106 +
 src/mt32/srchelper/SoxrAdapter.h                   |   45 +
 src/mt32/srchelper/srctools/include/FIRResampler.h |   67 +
 .../srctools/include/FloatSampleProvider.h         |   34 +
 .../srchelper/srctools/include/IIR2xResampler.h    |  100 +
 .../srchelper/srctools/include/LinearResampler.h   |   42 +
 .../srchelper/srctools/include/ResamplerModel.h    |   63 +
 .../srchelper/srctools/include/ResamplerStage.h    |   38 +
 .../srchelper/srctools/include/SincResampler.h     |   46 +
 src/mt32/srchelper/srctools/src/FIRResampler.cpp   |  107 +
 src/mt32/srchelper/srctools/src/IIR2xResampler.cpp |  229 ++
 .../srchelper/srctools/src/LinearResampler.cpp     |   47 +
 src/mt32/srchelper/srctools/src/ResamplerModel.cpp |  153 ++
 src/mt32/srchelper/srctools/src/SincResampler.cpp  |  136 ++
 71 files changed, 9069 insertions(+), 4510 deletions(-)
 create mode 100644 src/mt32/Analog.cpp
 create mode 100644 src/mt32/Analog.h
 create mode 100644 src/mt32/Enumerations.h
 create mode 100644 src/mt32/LA32FloatWaveGenerator.cpp
 create mode 100644 src/mt32/LA32FloatWaveGenerator.h
 create mode 100644 src/mt32/MemoryRegion.h
 create mode 100644 src/mt32/MidiEventQueue.h
 create mode 100644 src/mt32/MidiStreamParser.cpp
 create mode 100644 src/mt32/MidiStreamParser.h
 create mode 100644 src/mt32/SampleRateConverter.cpp
 create mode 100644 src/mt32/SampleRateConverter.h
 create mode 100644 src/mt32/Types.h
 create mode 100644 src/mt32/c_interface/c_interface.cpp
 create mode 100644 src/mt32/c_interface/c_interface.h
 create mode 100644 src/mt32/c_interface/c_types.h
 create mode 100644 src/mt32/c_interface/cpp_interface.h
 create mode 100644 src/mt32/globals.h
 create mode 100644 src/mt32/internals.h
 create mode 100644 src/mt32/srchelper/InternalResampler.cpp
 create mode 100644 src/mt32/srchelper/InternalResampler.h
 create mode 100644 src/mt32/srchelper/SamplerateAdapter.cpp
 create mode 100644 src/mt32/srchelper/SamplerateAdapter.h
 create mode 100644 src/mt32/srchelper/SoxrAdapter.cpp
 create mode 100644 src/mt32/srchelper/SoxrAdapter.h
 create mode 100644 src/mt32/srchelper/srctools/include/FIRResampler.h
 create mode 100644 src/mt32/srchelper/srctools/include/FloatSampleProvider.h
 create mode 100644 src/mt32/srchelper/srctools/include/IIR2xResampler.h
 create mode 100644 src/mt32/srchelper/srctools/include/LinearResampler.h
 create mode 100644 src/mt32/srchelper/srctools/include/ResamplerModel.h
 create mode 100644 src/mt32/srchelper/srctools/include/ResamplerStage.h
 create mode 100644 src/mt32/srchelper/srctools/include/SincResampler.h
 create mode 100644 src/mt32/srchelper/srctools/src/FIRResampler.cpp
 create mode 100644 src/mt32/srchelper/srctools/src/IIR2xResampler.cpp
 create mode 100644 src/mt32/srchelper/srctools/src/LinearResampler.cpp
 create mode 100644 src/mt32/srchelper/srctools/src/ResamplerModel.cpp
 create mode 100644 src/mt32/srchelper/srctools/src/SincResampler.cpp

diff --git a/src/mt32/Analog.cpp b/src/mt32/Analog.cpp
new file mode 100644
index 00000000..2901198f
--- /dev/null
+++ b/src/mt32/Analog.cpp
@@ -0,0 +1,424 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cstring>
+
+#include "internals.h"
+
+#include "Analog.h"
+#include "Synth.h"
+
+namespace MT32Emu {
+
+/* FIR approximation of the overall impulse response of the cascade composed of the sample & hold circuit and the low pass filter
+ * of the MT-32 first generation.
+ * The coefficients below are found by windowing the inverse DFT of the 1024 pin frequency response converted to the minimum phase.
+ * The frequency response of the LPF is computed directly, the effect of the S&H is approximated by multiplying the LPF frequency
+ * response by the corresponding sinc. Although, the LPF has DC gain of 3.2, we ignore this in the emulation and use normalised model.
+ * The peak gain of the normalised cascade appears about 1.7 near 11.8 kHz. Relative error doesn't exceed 1% for the frequencies
+ * below 12.5 kHz. In the higher frequency range, the relative error is below 8%. Peak error value is at 16 kHz.
+ */
+static const FloatSample COARSE_LPF_FLOAT_TAPS_MT32[] = {
+	1.272473681f, -0.220267785f, -0.158039905f, 0.179603785f, -0.111484097f, 0.054137498f, -0.023518029f, 0.010997169f, -0.006935698f
+};
+
+// Similar approximation for new MT-32 and CM-32L/LAPC-I LPF. As the voltage controlled amplifier was introduced, LPF has unity DC gain.
+// The peak gain value shifted towards higher frequencies and a bit higher about 1.83 near 13 kHz.
+static const FloatSample COARSE_LPF_FLOAT_TAPS_CM32L[] = {
+	1.340615635f, -0.403331694f, 0.036005517f, 0.066156844f, -0.069672532f, 0.049563806f, -0.031113416f, 0.019169774f, -0.012421368f
+};
+
+static const unsigned int COARSE_LPF_INT_FRACTION_BITS = 14;
+
+// Integer versions of the FIRs above multiplied by (1 << 14) and rounded.
+static const IntSampleEx COARSE_LPF_INT_TAPS_MT32[] = {
+	20848, -3609, -2589, 2943, -1827, 887, -385, 180, -114
+};
+
+static const IntSampleEx COARSE_LPF_INT_TAPS_CM32L[] = {
+	21965, -6608, 590, 1084, -1142, 812, -510, 314, -204
+};
+
+/* Combined FIR that both approximates the impulse response of the analogue circuits of sample & hold and the low pass filter
+ * in the audible frequency range (below 20 kHz) and attenuates unwanted mirror spectra above 28 kHz as well. It is a polyphase
+ * filter intended for resampling the signal to 48 kHz yet for applying high frequency boost.
+ * As with the filter above, the analogue LPF frequency response is obtained for 1536 pin grid for range up to 96 kHz and multiplied
+ * by the corresponding sinc. The result is further squared, windowed and passed to generalised Parks-McClellan routine as a desired response.
+ * Finally, the minimum phase factor is found that's essentially the coefficients below.
+ * Relative error in the audible frequency range doesn't exceed 0.0006%, attenuation in the stopband is better than 100 dB.
+ * This level of performance makes it nearly bit-accurate for standard 16-bit sample resolution.
+ */
+
+// FIR version for MT-32 first generation.
+static const FloatSample ACCURATE_LPF_TAPS_MT32[] = {
+	0.003429281f, 0.025929869f, 0.096587777f, 0.228884848f, 0.372413431f, 0.412386503f, 0.263980018f,
+	-0.014504962f, -0.237394528f, -0.257043496f, -0.103436603f, 0.063996095f, 0.124562333f, 0.083703206f,
+	0.013921662f, -0.033475018f, -0.046239712f, -0.029310921f, 0.00126585f, 0.021060961f, 0.017925605f,
+	0.003559874f, -0.005105248f, -0.005647917f, -0.004157918f, -0.002065664f, 0.00158747f, 0.003762585f,
+	0.001867137f, -0.001090028f, -0.001433979f, -0.00022367f, 4.34308E-05f, -0.000247827f, 0.000157087f,
+	0.000605823f, 0.000197317f, -0.000370511f, -0.000261202f, 9.96069E-05f, 9.85073E-05f, -5.28754E-05f,
+	-1.00912E-05f, 7.69943E-05f, 2.03162E-05f, -5.67967E-05f, -3.30637E-05f, 1.61958E-05f, 1.73041E-05f
+};
+
+// FIR version for new MT-32 and CM-32L/LAPC-I.
+static const FloatSample ACCURATE_LPF_TAPS_CM32L[] = {
+	0.003917452f, 0.030693861f, 0.116424199f, 0.275101674f, 0.43217361f, 0.431247894f, 0.183255659f,
+	-0.174955671f, -0.354240244f, -0.212401714f, 0.072259178f, 0.204655344f, 0.108336211f, -0.039099027f,
+	-0.075138174f, -0.026261906f, 0.00582663f, 0.003052193f, 0.00613657f, 0.017017951f, 0.008732535f,
+	-0.011027427f, -0.012933664f, 0.001158097f, 0.006765958f, 0.00046778f, -0.002191106f, 0.001561017f,
+	0.001842871f, -0.001996876f, -0.002315836f, 0.000980965f, 0.001817454f, -0.000243272f, -0.000972848f,
+	0.000149941f, 0.000498886f, -0.000204436f, -0.000347415f, 0.000142386f, 0.000249137f, -4.32946E-05f,
+	-0.000131231f, 3.88575E-07f, 4.48813E-05f, -1.31906E-06f, -1.03499E-05f, 7.71971E-06f, 2.86721E-06f
+};
+
+// According to the CM-64 PCB schematic, there is a difference in the values of the LPF entrance resistors for the reverb and non-reverb channels.
+// This effectively results in non-unity LPF DC gain for the reverb channel of 0.68 while the LPF has unity DC gain for the LA32 output channels.
+// In emulation, the reverb output gain is multiplied by this factor to compensate for the LPF gain difference.
+static const float CM32L_REVERB_TO_LA32_ANALOG_OUTPUT_GAIN_FACTOR = 0.68f;
+
+static const unsigned int OUTPUT_GAIN_FRACTION_BITS = 8;
+static const float OUTPUT_GAIN_MULTIPLIER = float(1 << OUTPUT_GAIN_FRACTION_BITS);
+
+static const unsigned int COARSE_LPF_DELAY_LINE_LENGTH = 8; // Must be a power of 2
+static const unsigned int ACCURATE_LPF_DELAY_LINE_LENGTH = 16; // Must be a power of 2
+static const unsigned int ACCURATE_LPF_NUMBER_OF_PHASES = 3; // Upsampling factor
+static const unsigned int ACCURATE_LPF_PHASE_INCREMENT_REGULAR = 2; // Downsampling factor
+static const unsigned int ACCURATE_LPF_PHASE_INCREMENT_OVERSAMPLED = 1; // No downsampling
+static const Bit32u ACCURATE_LPF_DELTAS_REGULAR[][ACCURATE_LPF_NUMBER_OF_PHASES] = { { 0, 0, 0 }, { 1, 1, 0 }, { 1, 2, 1 } };
+static const Bit32u ACCURATE_LPF_DELTAS_OVERSAMPLED[][ACCURATE_LPF_NUMBER_OF_PHASES] = { { 0, 0, 0 }, { 1, 0, 0 }, { 1, 0, 1 } };
+
+template <class SampleEx>
+class AbstractLowPassFilter {
+public:
+	static AbstractLowPassFilter<SampleEx> &createLowPassFilter(const AnalogOutputMode mode, const bool oldMT32AnalogLPF);
+
+	virtual ~AbstractLowPassFilter() {}
+	virtual SampleEx process(const SampleEx sample) = 0;
+
+	virtual bool hasNextSample() const {
+		return false;
+	}
+
+	virtual unsigned int getOutputSampleRate() const {
+		return SAMPLE_RATE;
+	}
+
+	virtual unsigned int estimateInSampleCount(const unsigned int outSamples) const {
+		return outSamples;
+	}
+
+	virtual void addPositionIncrement(const unsigned int) {}
+};
+
+template <class SampleEx>
+class NullLowPassFilter : public AbstractLowPassFilter<SampleEx> {
+public:
+	SampleEx process(const SampleEx sample) {
+		return sample;
+	}
+};
+
+template <class SampleEx>
+class CoarseLowPassFilter : public AbstractLowPassFilter<SampleEx> {
+private:
+	const SampleEx * const lpfTaps;
+	SampleEx ringBuffer[COARSE_LPF_DELAY_LINE_LENGTH];
+	unsigned int ringBufferPosition;
+
+public:
+	static inline const SampleEx *getLPFTaps(const bool oldMT32AnalogLPF);
+	static inline SampleEx normaliseSample(const SampleEx sample);
+
+	explicit CoarseLowPassFilter(const bool oldMT32AnalogLPF) :
+		lpfTaps(getLPFTaps(oldMT32AnalogLPF)),
+		ringBufferPosition(0)
+	{
+		Synth::muteSampleBuffer(ringBuffer, COARSE_LPF_DELAY_LINE_LENGTH);
+	}
+
+	SampleEx process(const SampleEx inSample) {
+		static const unsigned int DELAY_LINE_MASK = COARSE_LPF_DELAY_LINE_LENGTH - 1;
+
+		SampleEx sample = lpfTaps[COARSE_LPF_DELAY_LINE_LENGTH] * ringBuffer[ringBufferPosition];
+		ringBuffer[ringBufferPosition] = Synth::clipSampleEx(inSample);
+
+		for (unsigned int i = 0; i < COARSE_LPF_DELAY_LINE_LENGTH; i++) {
+			sample += lpfTaps[i] * ringBuffer[(i + ringBufferPosition) & DELAY_LINE_MASK];
+		}
+
+		ringBufferPosition = (ringBufferPosition - 1) & DELAY_LINE_MASK;
+
+		return normaliseSample(sample);
+	}
+};
+
+class AccurateLowPassFilter : public AbstractLowPassFilter<IntSampleEx>, public AbstractLowPassFilter<FloatSample> {
+private:
+	const FloatSample * const LPF_TAPS;
+	const Bit32u (* const deltas)[ACCURATE_LPF_NUMBER_OF_PHASES];
+	const unsigned int phaseIncrement;
+	const unsigned int outputSampleRate;
+
+	FloatSample ringBuffer[ACCURATE_LPF_DELAY_LINE_LENGTH];
+	unsigned int ringBufferPosition;
+	unsigned int phase;
+
+public:
+	AccurateLowPassFilter(const bool oldMT32AnalogLPF, const bool oversample);
+	FloatSample process(const FloatSample sample);
+	IntSampleEx process(const IntSampleEx sample);
+	bool hasNextSample() const;
+	unsigned int getOutputSampleRate() const;
+	unsigned int estimateInSampleCount(const unsigned int outSamples) const;
+	void addPositionIncrement(const unsigned int positionIncrement);
+};
+
+static inline IntSampleEx normaliseSample(const IntSampleEx sample) {
+	return sample >> OUTPUT_GAIN_FRACTION_BITS;
+}
+
+static inline FloatSample normaliseSample(const FloatSample sample) {
+	return sample;
+}
+
+static inline float getActualReverbOutputGain(const float reverbGain, const bool mt32ReverbCompatibilityMode) {
+	return mt32ReverbCompatibilityMode ? reverbGain : reverbGain * CM32L_REVERB_TO_LA32_ANALOG_OUTPUT_GAIN_FACTOR;
+}
+
+static inline IntSampleEx getIntOutputGain(const float outputGain) {
+	return IntSampleEx(((OUTPUT_GAIN_MULTIPLIER < outputGain) ? OUTPUT_GAIN_MULTIPLIER : outputGain) * OUTPUT_GAIN_MULTIPLIER);
+}
+
+template <class SampleEx>
+class AnalogImpl : public Analog {
+public:
+	AbstractLowPassFilter<SampleEx> &leftChannelLPF;
+	AbstractLowPassFilter<SampleEx> &rightChannelLPF;
+	SampleEx synthGain;
+	SampleEx reverbGain;
+
+	AnalogImpl(const AnalogOutputMode mode, const bool oldMT32AnalogLPF) :
+		leftChannelLPF(AbstractLowPassFilter<SampleEx>::createLowPassFilter(mode, oldMT32AnalogLPF)),
+		rightChannelLPF(AbstractLowPassFilter<SampleEx>::createLowPassFilter(mode, oldMT32AnalogLPF)),
+		synthGain(0),
+		reverbGain(0)
+	{}
+
+	~AnalogImpl() {
+		delete &leftChannelLPF;
+		delete &rightChannelLPF;
+	}
+
+	unsigned int getOutputSampleRate() const {
+		return leftChannelLPF.getOutputSampleRate();
+	}
+
+	Bit32u getDACStreamsLength(const Bit32u outputLength) const {
+		return leftChannelLPF.estimateInSampleCount(outputLength);
+	}
+
+	void setSynthOutputGain(const float synthGain);
+	void setReverbOutputGain(const float reverbGain, const bool mt32ReverbCompatibilityMode);
+
+	bool process(IntSample *outStream, const IntSample *nonReverbLeft, const IntSample *nonReverbRight, const IntSample *reverbDryLeft, const IntSample *reverbDryRight, const IntSample *reverbWetLeft, const IntSample *reverbWetRight, Bit32u outLength);
+	bool process(FloatSample *outStream, const FloatSample *nonReverbLeft, const FloatSample *nonReverbRight, const FloatSample *reverbDryLeft, const FloatSample *reverbDryRight, const FloatSample *reverbWetLeft, const FloatSample *reverbWetRight, Bit32u outLength);
+
+	template <class Sample>
+	void produceOutput(Sample *outStream, const Sample *nonReverbLeft, const Sample *nonReverbRight, const Sample *reverbDryLeft, const Sample *reverbDryRight, const Sample *reverbWetLeft, const Sample *reverbWetRight, Bit32u outLength) {
+		if (outStream == NULL) {
+			leftChannelLPF.addPositionIncrement(outLength);
+			rightChannelLPF.addPositionIncrement(outLength);
+			return;
+		}
+
+		while (0 < (outLength--)) {
+			SampleEx outSampleL;
+			SampleEx outSampleR;
+
+			if (leftChannelLPF.hasNextSample()) {
+				outSampleL = leftChannelLPF.process(0);
+				outSampleR = rightChannelLPF.process(0);
+			} else {
+				SampleEx inSampleL = (SampleEx(*(nonReverbLeft++)) + SampleEx(*(reverbDryLeft++))) * synthGain + SampleEx(*(reverbWetLeft++)) * reverbGain;
+				SampleEx inSampleR = (SampleEx(*(nonReverbRight++)) + SampleEx(*(reverbDryRight++))) * synthGain + SampleEx(*(reverbWetRight++)) * reverbGain;
+
+				outSampleL = leftChannelLPF.process(normaliseSample(inSampleL));
+				outSampleR = rightChannelLPF.process(normaliseSample(inSampleR));
+			}
+
+			*(outStream++) = Synth::clipSampleEx(outSampleL);
+			*(outStream++) = Synth::clipSampleEx(outSampleR);
+		}
+	}
+};
+
+Analog *Analog::createAnalog(const AnalogOutputMode mode, const bool oldMT32AnalogLPF, const RendererType rendererType) {
+	switch (rendererType)
+	{
+	case RendererType_BIT16S:
+		return new AnalogImpl<IntSampleEx>(mode, oldMT32AnalogLPF);
+	case RendererType_FLOAT:
+		return new AnalogImpl<FloatSample>(mode, oldMT32AnalogLPF);
+	}
+	return NULL;
+}
+
+template<>
+bool AnalogImpl<IntSampleEx>::process(IntSample *outStream, const IntSample *nonReverbLeft, const IntSample *nonReverbRight, const IntSample *reverbDryLeft, const IntSample *reverbDryRight, const IntSample *reverbWetLeft, const IntSample *reverbWetRight, Bit32u outLength) {
+	produceOutput(outStream, nonReverbLeft, nonReverbRight, reverbDryLeft, reverbDryRight, reverbWetLeft, reverbWetRight, outLength);
+	return true;
+}
+
+template<>
+bool AnalogImpl<FloatSample>::process(IntSample *, const IntSample *, const IntSample *, const IntSample *, const IntSample *, const IntSample *, const IntSample *, Bit32u) {
+	return false;
+}
+
+template<>
+bool AnalogImpl<IntSampleEx>::process(FloatSample *, const FloatSample *, const FloatSample *, const FloatSample *, const FloatSample *, const FloatSample *, const FloatSample *, Bit32u) {
+	return false;
+}
+
+template<>
+bool AnalogImpl<FloatSample>::process(FloatSample *outStream, const FloatSample *nonReverbLeft, const FloatSample *nonReverbRight, const FloatSample *reverbDryLeft, const FloatSample *reverbDryRight, const FloatSample *reverbWetLeft, const FloatSample *reverbWetRight, Bit32u outLength) {
+	produceOutput(outStream, nonReverbLeft, nonReverbRight, reverbDryLeft, reverbDryRight, reverbWetLeft, reverbWetRight, outLength);
+	return true;
+}
+
+template<>
+void AnalogImpl<IntSampleEx>::setSynthOutputGain(const float useSynthGain) {
+	synthGain = getIntOutputGain(useSynthGain);
+}
+
+template<>
+void AnalogImpl<IntSampleEx>::setReverbOutputGain(const float useReverbGain, const bool mt32ReverbCompatibilityMode) {
+	reverbGain = getIntOutputGain(getActualReverbOutputGain(useReverbGain, mt32ReverbCompatibilityMode));
+}
+
+template<>
+void AnalogImpl<FloatSample>::setSynthOutputGain(const float useSynthGain) {
+	synthGain = useSynthGain;
+}
+
+template<>
+void AnalogImpl<FloatSample>::setReverbOutputGain(const float useReverbGain, const bool mt32ReverbCompatibilityMode) {
+	reverbGain = getActualReverbOutputGain(useReverbGain, mt32ReverbCompatibilityMode);
+}
+
+template<>
+AbstractLowPassFilter<IntSampleEx> &AbstractLowPassFilter<IntSampleEx>::createLowPassFilter(AnalogOutputMode mode, bool oldMT32AnalogLPF) {
+	switch (mode) {
+	case AnalogOutputMode_COARSE:
+		return *new CoarseLowPassFilter<IntSampleEx>(oldMT32AnalogLPF);
+	case AnalogOutputMode_ACCURATE:
+		return *new AccurateLowPassFilter(oldMT32AnalogLPF, false);
+	case AnalogOutputMode_OVERSAMPLED:
+		return *new AccurateLowPassFilter(oldMT32AnalogLPF, true);
+	default:
+		return *new NullLowPassFilter<IntSampleEx>;
+	}
+}
+
+template<>
+AbstractLowPassFilter<FloatSample> &AbstractLowPassFilter<FloatSample>::createLowPassFilter(AnalogOutputMode mode, bool oldMT32AnalogLPF) {
+	switch (mode) {
+		case AnalogOutputMode_COARSE:
+			return *new CoarseLowPassFilter<FloatSample>(oldMT32AnalogLPF);
+		case AnalogOutputMode_ACCURATE:
+			return *new AccurateLowPassFilter(oldMT32AnalogLPF, false);
+		case AnalogOutputMode_OVERSAMPLED:
+			return *new AccurateLowPassFilter(oldMT32AnalogLPF, true);
+		default:
+			return *new NullLowPassFilter<FloatSample>;
+	}
+}
+
+template<>
+const IntSampleEx *CoarseLowPassFilter<IntSampleEx>::getLPFTaps(const bool oldMT32AnalogLPF) {
+	return oldMT32AnalogLPF ? COARSE_LPF_INT_TAPS_MT32 : COARSE_LPF_INT_TAPS_CM32L;
+}
+
+template<>
+const FloatSample *CoarseLowPassFilter<FloatSample>::getLPFTaps(const bool oldMT32AnalogLPF) {
+	return oldMT32AnalogLPF ? COARSE_LPF_FLOAT_TAPS_MT32 : COARSE_LPF_FLOAT_TAPS_CM32L;
+}
+
+template<>
+IntSampleEx CoarseLowPassFilter<IntSampleEx>::normaliseSample(const IntSampleEx sample) {
+	return sample >> COARSE_LPF_INT_FRACTION_BITS;
+}
+
+template<>
+FloatSample CoarseLowPassFilter<FloatSample>::normaliseSample(const FloatSample sample) {
+	return sample;
+}
+
+AccurateLowPassFilter::AccurateLowPassFilter(const bool oldMT32AnalogLPF, const bool oversample) :
+	LPF_TAPS(oldMT32AnalogLPF ? ACCURATE_LPF_TAPS_MT32 : ACCURATE_LPF_TAPS_CM32L),
+	deltas(oversample ? ACCURATE_LPF_DELTAS_OVERSAMPLED : ACCURATE_LPF_DELTAS_REGULAR),
+	phaseIncrement(oversample ? ACCURATE_LPF_PHASE_INCREMENT_OVERSAMPLED : ACCURATE_LPF_PHASE_INCREMENT_REGULAR),
+	outputSampleRate(SAMPLE_RATE * ACCURATE_LPF_NUMBER_OF_PHASES / phaseIncrement),
+	ringBufferPosition(0),
+	phase(0)
+{
+	Synth::muteSampleBuffer(ringBuffer, ACCURATE_LPF_DELAY_LINE_LENGTH);
+}
+
+FloatSample AccurateLowPassFilter::process(const FloatSample inSample) {
+	static const unsigned int DELAY_LINE_MASK = ACCURATE_LPF_DELAY_LINE_LENGTH - 1;
+
+	FloatSample sample = (phase == 0) ? LPF_TAPS[ACCURATE_LPF_DELAY_LINE_LENGTH * ACCURATE_LPF_NUMBER_OF_PHASES] * ringBuffer[ringBufferPosition] : 0.0f;
+	if (!hasNextSample()) {
+		ringBuffer[ringBufferPosition] = inSample;
+	}
+
+	for (unsigned int tapIx = phase, delaySampleIx = 0; delaySampleIx < ACCURATE_LPF_DELAY_LINE_LENGTH; delaySampleIx++, tapIx += ACCURATE_LPF_NUMBER_OF_PHASES) {
+		sample += LPF_TAPS[tapIx] * ringBuffer[(delaySampleIx + ringBufferPosition) & DELAY_LINE_MASK];
+	}
+
+	phase += phaseIncrement;
+	if (ACCURATE_LPF_NUMBER_OF_PHASES <= phase) {
+		phase -= ACCURATE_LPF_NUMBER_OF_PHASES;
+		ringBufferPosition = (ringBufferPosition - 1) & DELAY_LINE_MASK;
+	}
+
+	return ACCURATE_LPF_NUMBER_OF_PHASES * sample;
+}
+
+IntSampleEx AccurateLowPassFilter::process(const IntSampleEx sample) {
+	return IntSampleEx(process(FloatSample(sample)));
+}
+
+bool AccurateLowPassFilter::hasNextSample() const {
+	return phaseIncrement <= phase;
+}
+
+unsigned int AccurateLowPassFilter::getOutputSampleRate() const {
+	return outputSampleRate;
+}
+
+unsigned int AccurateLowPassFilter::estimateInSampleCount(const unsigned int outSamples) const {
+	Bit32u cycleCount = outSamples / ACCURATE_LPF_NUMBER_OF_PHASES;
+	Bit32u remainder = outSamples - cycleCount * ACCURATE_LPF_NUMBER_OF_PHASES;
+	return cycleCount * phaseIncrement + deltas[remainder][phase];
+}
+
+void AccurateLowPassFilter::addPositionIncrement(const unsigned int positionIncrement) {
+	phase = (phase + positionIncrement * phaseIncrement) % ACCURATE_LPF_NUMBER_OF_PHASES;
+}
+
+} // namespace MT32Emu
diff --git a/src/mt32/Analog.h b/src/mt32/Analog.h
new file mode 100644
index 00000000..3b6dcabf
--- /dev/null
+++ b/src/mt32/Analog.h
@@ -0,0 +1,53 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_ANALOG_H
+#define MT32EMU_ANALOG_H
+
+#include "globals.h"
+#include "internals.h"
+#include "Enumerations.h"
+#include "Types.h"
+
+namespace MT32Emu {
+
+/* Analog class is dedicated to perform fair emulation of analogue circuitry of hardware units that is responsible
+ * for processing output signal after the DAC. It appears that the analogue circuit labeled "LPF" on the schematic
+ * also applies audible changes to the signal spectra. There is a significant boost of higher frequencies observed
+ * aside from quite poor attenuation of the mirror spectra above 16 kHz which is due to a relatively low filter order.
+ *
+ * As the final mixing of multiplexed output signal is performed after the DAC, this function is migrated here from Synth.
+ * Saying precisely, mixing is performed within the LPF as the entrance resistors are actually components of a LPF
+ * designed using the multiple feedback topology. Nevertheless, the schematic separates them.
+ */
+class Analog {
+public:
+	static Analog *createAnalog(const AnalogOutputMode mode, const bool oldMT32AnalogLPF, const RendererType rendererType);
+
+	virtual ~Analog() {}
+	virtual unsigned int getOutputSampleRate() const = 0;
+	virtual Bit32u getDACStreamsLength(const Bit32u outputLength) const = 0;
+	virtual void setSynthOutputGain(const float synthGain) = 0;
+	virtual void setReverbOutputGain(const float reverbGain, const bool mt32ReverbCompatibilityMode) = 0;
+
+	virtual bool process(IntSample *outStream, const IntSample *nonReverbLeft, const IntSample *nonReverbRight, const IntSample *reverbDryLeft, const IntSample *reverbDryRight, const IntSample *reverbWetLeft, const IntSample *reverbWetRight, Bit32u outLength) = 0;
+	virtual bool process(FloatSample *outStream, const FloatSample *nonReverbLeft, const FloatSample *nonReverbRight, const FloatSample *reverbDryLeft, const FloatSample *reverbDryRight, const FloatSample *reverbWetLeft, const FloatSample *reverbWetRight, Bit32u outLength) = 0;
+};
+
+} // namespace MT32Emu
+
+#endif // #ifndef MT32EMU_ANALOG_H
diff --git a/src/mt32/BReverbModel.cpp b/src/mt32/BReverbModel.cpp
index cc0219b7..af559a92 100644
--- a/src/mt32/BReverbModel.cpp
+++ b/src/mt32/BReverbModel.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,11 +15,12 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "mt32emu.h"
+#include <cstddef>
 
-#if MT32EMU_USE_REVERBMODEL == 2
+#include "internals.h"
 
 #include "BReverbModel.h"
+#include "Synth.h"
 
 // Analysing of state of reverb RAM address lines gives exact sizes of the buffers of filters used. This also indicates that
 // the reverb model implemented in the real devices consists of three series allpass filters preceded by a non-feedback comb (or a delay with a LPF)
@@ -36,358 +37,626 @@ static const Bit32u PROCESS_DELAY = 1;
 static const Bit32u MODE_3_ADDITIONAL_DELAY = 1;
 static const Bit32u MODE_3_FEEDBACK_DELAY = 1;
 
-// Default reverb settings for modes 0-2. These correspond to CM-32L / LAPC-I "new" reverb settings. MT-32 reverb is a bit different.
+// Avoid denormals degrading performance, using biased input
+static const FloatSample BIAS = 1e-20f;
+
+struct BReverbSettings {
+	const Bit32u numberOfAllpasses;
+	const Bit32u * const allpassSizes;
+	const Bit32u numberOfCombs;
+	const Bit32u * const combSizes;
+	const Bit32u * const outLPositions;
+	const Bit32u * const outRPositions;
+	const Bit8u * const filterFactors;
+	const Bit8u * const feedbackFactors;
+	const Bit8u * const dryAmps;
+	const Bit8u * const wetLevels;
+	const Bit8u lpfAmp;
+};
+
+// Default reverb settings for "new" reverb model implemented in CM-32L / LAPC-I.
 // Found by tracing reverb RAM data lines (thanks go to Lord_Nightmare & balrog).
+static const BReverbSettings &getCM32L_LAPCSettings(const ReverbMode mode) {
+	static const Bit32u MODE_0_NUMBER_OF_ALLPASSES = 3;
+	static const Bit32u MODE_0_ALLPASSES[] = {994, 729, 78};
+	static const Bit32u MODE_0_NUMBER_OF_COMBS = 4; // Well, actually there are 3 comb filters, but the entrance LPF + delay can be processed via a hacked comb.
+	static const Bit32u MODE_0_COMBS[] = {705 + PROCESS_DELAY, 2349, 2839, 3632};
+	static const Bit32u MODE_0_OUTL[] = {2349, 141, 1960};
+	static const Bit32u MODE_0_OUTR[] = {1174, 1570, 145};
+	static const Bit8u  MODE_0_COMB_FACTOR[] = {0xA0, 0x60, 0x60, 0x60};
+	static const Bit8u  MODE_0_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98};
+	static const Bit8u  MODE_0_DRY_AMP[] = {0xA0, 0xA0, 0xA0, 0xA0, 0xB0, 0xB0, 0xB0, 0xD0};
+	static const Bit8u  MODE_0_WET_AMP[] = {0x10, 0x30, 0x50, 0x70, 0x90, 0xC0, 0xF0, 0xF0};
+	static const Bit8u  MODE_0_LPF_AMP = 0x60;
+
+	static const Bit32u MODE_1_NUMBER_OF_ALLPASSES = 3;
+	static const Bit32u MODE_1_ALLPASSES[] = {1324, 809, 176};
+	static const Bit32u MODE_1_NUMBER_OF_COMBS = 4; // Same as for mode 0 above
+	static const Bit32u MODE_1_COMBS[] = {961 + PROCESS_DELAY, 2619, 3545, 4519};
+	static const Bit32u MODE_1_OUTL[] = {2618, 1760, 4518};
+	static const Bit32u MODE_1_OUTR[] = {1300, 3532, 2274};
+	static const Bit8u  MODE_1_COMB_FACTOR[] = {0x80, 0x60, 0x60, 0x60};
+	static const Bit8u  MODE_1_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	                                              0x28, 0x48, 0x60, 0x70, 0x78, 0x80, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98};
+	static const Bit8u  MODE_1_DRY_AMP[] = {0xA0, 0xA0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xE0};
+	static const Bit8u  MODE_1_WET_AMP[] = {0x10, 0x30, 0x50, 0x70, 0x90, 0xC0, 0xF0, 0xF0};
+	static const Bit8u  MODE_1_LPF_AMP = 0x60;
+
+	static const Bit32u MODE_2_NUMBER_OF_ALLPASSES = 3;
+	static const Bit32u MODE_2_ALLPASSES[] = {969, 644, 157};
+	static const Bit32u MODE_2_NUMBER_OF_COMBS = 4; // Same as for mode 0 above
+	static const Bit32u MODE_2_COMBS[] = {116 + PROCESS_DELAY, 2259, 2839, 3539};
+	static const Bit32u MODE_2_OUTL[] = {2259, 718, 1769};
+	static const Bit32u MODE_2_OUTR[] = {1136, 2128, 1};
+	static const Bit8u  MODE_2_COMB_FACTOR[] = {0, 0x20, 0x20, 0x20};
+	static const Bit8u  MODE_2_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	                                              0x30, 0x58, 0x78, 0x88, 0xA0, 0xB8, 0xC0, 0xD0,
+	                                              0x30, 0x58, 0x78, 0x88, 0xA0, 0xB8, 0xC0, 0xD0,
+	                                              0x30, 0x58, 0x78, 0x88, 0xA0, 0xB8, 0xC0, 0xD0};
+	static const Bit8u  MODE_2_DRY_AMP[] = {0xA0, 0xA0, 0xB0, 0xB0, 0xB0, 0xB0, 0xC0, 0xE0};
+	static const Bit8u  MODE_2_WET_AMP[] = {0x10, 0x30, 0x50, 0x70, 0x90, 0xC0, 0xF0, 0xF0};
+	static const Bit8u  MODE_2_LPF_AMP = 0x80;
+
+	static const Bit32u MODE_3_NUMBER_OF_ALLPASSES = 0;
+	static const Bit32u MODE_3_NUMBER_OF_COMBS = 1;
+	static const Bit32u MODE_3_DELAY[] = {16000 + MODE_3_FEEDBACK_DELAY + PROCESS_DELAY + MODE_3_ADDITIONAL_DELAY};
+	static const Bit32u MODE_3_OUTL[] = {400, 624, 960, 1488, 2256, 3472, 5280, 8000};
+	static const Bit32u MODE_3_OUTR[] = {800, 1248, 1920, 2976, 4512, 6944, 10560, 16000};
+	static const Bit8u  MODE_3_COMB_FACTOR[] = {0x68};
+	static const Bit8u  MODE_3_COMB_FEEDBACK[] = {0x68, 0x60};
+	static const Bit8u  MODE_3_DRY_AMP[] = {0x20, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50,
+	                                        0x20, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50};
+	static const Bit8u  MODE_3_WET_AMP[] = {0x18, 0x18, 0x28, 0x40, 0x60, 0x80, 0xA8, 0xF8};
+
+	static const BReverbSettings REVERB_MODE_0_SETTINGS = {MODE_0_NUMBER_OF_ALLPASSES, MODE_0_ALLPASSES, MODE_0_NUMBER_OF_COMBS, MODE_0_COMBS, MODE_0_OUTL, MODE_0_OUTR, MODE_0_COMB_FACTOR, MODE_0_COMB_FEEDBACK, MODE_0_DRY_AMP, MODE_0_WET_AMP, MODE_0_LPF_AMP};
+	static const BReverbSettings REVERB_MODE_1_SETTINGS = {MODE_1_NUMBER_OF_ALLPASSES, MODE_1_ALLPASSES, MODE_1_NUMBER_OF_COMBS, MODE_1_COMBS, MODE_1_OUTL, MODE_1_OUTR, MODE_1_COMB_FACTOR, MODE_1_COMB_FEEDBACK, MODE_1_DRY_AMP, MODE_1_WET_AMP, MODE_1_LPF_AMP};
+	static const BReverbSettings REVERB_MODE_2_SETTINGS = {MODE_2_NUMBER_OF_ALLPASSES, MODE_2_ALLPASSES, MODE_2_NUMBER_OF_COMBS, MODE_2_COMBS, MODE_2_OUTL, MODE_2_OUTR, MODE_2_COMB_FACTOR, MODE_2_COMB_FEEDBACK, MODE_2_DRY_AMP, MODE_2_WET_AMP, MODE_2_LPF_AMP};
+	static const BReverbSettings REVERB_MODE_3_SETTINGS = {MODE_3_NUMBER_OF_ALLPASSES, NULL, MODE_3_NUMBER_OF_COMBS, MODE_3_DELAY, MODE_3_OUTL, MODE_3_OUTR, MODE_3_COMB_FACTOR, MODE_3_COMB_FEEDBACK, MODE_3_DRY_AMP, MODE_3_WET_AMP, 0};
+
+	static const BReverbSettings * const REVERB_SETTINGS[] = {&REVERB_MODE_0_SETTINGS, &REVERB_MODE_1_SETTINGS, &REVERB_MODE_2_SETTINGS, &REVERB_MODE_3_SETTINGS};
+
+	return *REVERB_SETTINGS[mode];
+}
+
+// Default reverb settings for "old" reverb model implemented in MT-32.
+// Found by tracing reverb RAM data lines (thanks go to Lord_Nightmare & balrog).
+static const BReverbSettings &getMT32Settings(const ReverbMode mode) {
+	static const Bit32u MODE_0_NUMBER_OF_ALLPASSES = 3;
+	static const Bit32u MODE_0_ALLPASSES[] = {994, 729, 78};
+	static const Bit32u MODE_0_NUMBER_OF_COMBS = 4; // Same as above in the new model implementation
+	static const Bit32u MODE_0_COMBS[] = {575 + PROCESS_DELAY, 2040, 2752, 3629};
+	static const Bit32u MODE_0_OUTL[] = {2040, 687, 1814};
+	static const Bit32u MODE_0_OUTR[] = {1019, 2072, 1};
+	static const Bit8u  MODE_0_COMB_FACTOR[] = {0xB0, 0x60, 0x60, 0x60};
+	static const Bit8u  MODE_0_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	                                              0x28, 0x48, 0x60, 0x70, 0x78, 0x80, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98};
+	static const Bit8u  MODE_0_DRY_AMP[] = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80};
+	static const Bit8u  MODE_0_WET_AMP[] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x70, 0xA0, 0xE0};
+	static const Bit8u  MODE_0_LPF_AMP = 0x80;
+
+	static const Bit32u MODE_1_NUMBER_OF_ALLPASSES = 3;
+	static const Bit32u MODE_1_ALLPASSES[] = {1324, 809, 176};
+	static const Bit32u MODE_1_NUMBER_OF_COMBS = 4; // Same as above in the new model implementation
+	static const Bit32u MODE_1_COMBS[] = {961 + PROCESS_DELAY, 2619, 3545, 4519};
+	static const Bit32u MODE_1_OUTL[] = {2618, 1760, 4518};
+	static const Bit32u MODE_1_OUTR[] = {1300, 3532, 2274};
+	static const Bit8u  MODE_1_COMB_FACTOR[] = {0x90, 0x60, 0x60, 0x60};
+	static const Bit8u  MODE_1_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	                                              0x28, 0x48, 0x60, 0x70, 0x78, 0x80, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98};
+	static const Bit8u  MODE_1_DRY_AMP[] = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80};
+	static const Bit8u  MODE_1_WET_AMP[] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x70, 0xA0, 0xE0};
+	static const Bit8u  MODE_1_LPF_AMP = 0x80;
+
+	static const Bit32u MODE_2_NUMBER_OF_ALLPASSES = 3;
+	static const Bit32u MODE_2_ALLPASSES[] = {969, 644, 157};
+	static const Bit32u MODE_2_NUMBER_OF_COMBS = 4; // Same as above in the new model implementation
+	static const Bit32u MODE_2_COMBS[] = {116 + PROCESS_DELAY, 2259, 2839, 3539};
+	static const Bit32u MODE_2_OUTL[] = {2259, 718, 1769};
+	static const Bit32u MODE_2_OUTR[] = {1136, 2128, 1};
+	static const Bit8u  MODE_2_COMB_FACTOR[] = {0, 0x60, 0x60, 0x60};
+	static const Bit8u  MODE_2_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	                                              0x28, 0x48, 0x60, 0x70, 0x78, 0x80, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
+	                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98};
+	static const Bit8u  MODE_2_DRY_AMP[] = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80};
+	static const Bit8u  MODE_2_WET_AMP[] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x70, 0xA0, 0xE0};
+	static const Bit8u  MODE_2_LPF_AMP = 0x80;
+
+	static const Bit32u MODE_3_NUMBER_OF_ALLPASSES = 0;
+	static const Bit32u MODE_3_NUMBER_OF_COMBS = 1;
+	static const Bit32u MODE_3_DELAY[] = {16000 + MODE_3_FEEDBACK_DELAY + PROCESS_DELAY + MODE_3_ADDITIONAL_DELAY};
+	static const Bit32u MODE_3_OUTL[] = {400, 624, 960, 1488, 2256, 3472, 5280, 8000};
+	static const Bit32u MODE_3_OUTR[] = {800, 1248, 1920, 2976, 4512, 6944, 10560, 16000};
+	static const Bit8u  MODE_3_COMB_FACTOR[] = {0x68};
+	static const Bit8u  MODE_3_COMB_FEEDBACK[] = {0x68, 0x60};
+	static const Bit8u  MODE_3_DRY_AMP[] = {0x10, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	                                        0x10, 0x20, 0x20, 0x10, 0x20, 0x10, 0x20, 0x10};
+	static const Bit8u  MODE_3_WET_AMP[] = {0x08, 0x18, 0x28, 0x40, 0x60, 0x80, 0xA8, 0xF8};
+
+	static const BReverbSettings REVERB_MODE_0_SETTINGS = {MODE_0_NUMBER_OF_ALLPASSES, MODE_0_ALLPASSES, MODE_0_NUMBER_OF_COMBS, MODE_0_COMBS, MODE_0_OUTL, MODE_0_OUTR, MODE_0_COMB_FACTOR, MODE_0_COMB_FEEDBACK, MODE_0_DRY_AMP, MODE_0_WET_AMP, MODE_0_LPF_AMP};
+	static const BReverbSettings REVERB_MODE_1_SETTINGS = {MODE_1_NUMBER_OF_ALLPASSES, MODE_1_ALLPASSES, MODE_1_NUMBER_OF_COMBS, MODE_1_COMBS, MODE_1_OUTL, MODE_1_OUTR, MODE_1_COMB_FACTOR, MODE_1_COMB_FEEDBACK, MODE_1_DRY_AMP, MODE_1_WET_AMP, MODE_1_LPF_AMP};
+	static const BReverbSettings REVERB_MODE_2_SETTINGS = {MODE_2_NUMBER_OF_ALLPASSES, MODE_2_ALLPASSES, MODE_2_NUMBER_OF_COMBS, MODE_2_COMBS, MODE_2_OUTL, MODE_2_OUTR, MODE_2_COMB_FACTOR, MODE_2_COMB_FEEDBACK, MODE_2_DRY_AMP, MODE_2_WET_AMP, MODE_2_LPF_AMP};
+	static const BReverbSettings REVERB_MODE_3_SETTINGS = {MODE_3_NUMBER_OF_ALLPASSES, NULL, MODE_3_NUMBER_OF_COMBS, MODE_3_DELAY, MODE_3_OUTL, MODE_3_OUTR, MODE_3_COMB_FACTOR, MODE_3_COMB_FEEDBACK, MODE_3_DRY_AMP, MODE_3_WET_AMP, 0};
+
+	static const BReverbSettings * const REVERB_SETTINGS[] = {&REVERB_MODE_0_SETTINGS, &REVERB_MODE_1_SETTINGS, &REVERB_MODE_2_SETTINGS, &REVERB_MODE_3_SETTINGS};
+
+	return *REVERB_SETTINGS[mode];
+}
 
-static const Bit32u MODE_0_NUMBER_OF_ALLPASSES = 3;
-static const Bit32u MODE_0_ALLPASSES[] = {994, 729, 78};
-static const Bit32u MODE_0_NUMBER_OF_COMBS = 4; // Well, actually there are 3 comb filters, but the entrance LPF + delay can be processed via a hacked comb.
-static const Bit32u MODE_0_COMBS[] = {705 + PROCESS_DELAY, 2349, 2839, 3632};
-static const Bit32u MODE_0_OUTL[] = {2349, 141, 1960};
-static const Bit32u MODE_0_OUTR[] = {1174, 1570, 145};
-static const Bit32u MODE_0_COMB_FACTOR[] = {0xA0, 0x60, 0x60, 0x60};
-static const Bit32u MODE_0_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
-                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
-                                              0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98};
-static const Bit32u MODE_0_DRY_AMP[] = {0xA0, 0xA0, 0xA0, 0xA0, 0xB0, 0xB0, 0xB0, 0xD0};
-static const Bit32u MODE_0_WET_AMP[] = {0x10, 0x30, 0x50, 0x70, 0x90, 0xC0, 0xF0, 0xF0};
-static const Bit32u MODE_0_LPF_AMP = 0x60;
-
-static const Bit32u MODE_1_NUMBER_OF_ALLPASSES = 3;
-static const Bit32u MODE_1_ALLPASSES[] = {1324, 809, 176};
-static const Bit32u MODE_1_NUMBER_OF_COMBS = 4; // Same as for mode 0 above
-static const Bit32u MODE_1_COMBS[] = {961 + PROCESS_DELAY, 2619, 3545, 4519};
-static const Bit32u MODE_1_OUTL[] = {2618, 1760, 4518};
-static const Bit32u MODE_1_OUTR[] = {1300, 3532, 2274};
-static const Bit32u MODE_1_COMB_FACTOR[] = {0x80, 0x60, 0x60, 0x60};
-static const Bit32u MODE_1_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-											  0x28, 0x48, 0x60, 0x70, 0x78, 0x80, 0x90, 0x98,
-											  0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98,
-											  0x28, 0x48, 0x60, 0x78, 0x80, 0x88, 0x90, 0x98};
-static const Bit32u MODE_1_DRY_AMP[] = {0xA0, 0xA0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xE0};
-static const Bit32u MODE_1_WET_AMP[] = {0x10, 0x30, 0x50, 0x70, 0x90, 0xC0, 0xF0, 0xF0};
-static const Bit32u MODE_1_LPF_AMP = 0x60;
-
-static const Bit32u MODE_2_NUMBER_OF_ALLPASSES = 3;
-static const Bit32u MODE_2_ALLPASSES[] = {969, 644, 157};
-static const Bit32u MODE_2_NUMBER_OF_COMBS = 4; // Same as for mode 0 above
-static const Bit32u MODE_2_COMBS[] = {116 + PROCESS_DELAY, 2259, 2839, 3539};
-static const Bit32u MODE_2_OUTL[] = {2259, 718, 1769};
-static const Bit32u MODE_2_OUTR[] = {1136, 2128, 1};
-static const Bit32u MODE_2_COMB_FACTOR[] = {0, 0x20, 0x20, 0x20};
-static const Bit32u MODE_2_COMB_FEEDBACK[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                                              0x30, 0x58, 0x78, 0x88, 0xA0, 0xB8, 0xC0, 0xD0,
-                                              0x30, 0x58, 0x78, 0x88, 0xA0, 0xB8, 0xC0, 0xD0,
-                                              0x30, 0x58, 0x78, 0x88, 0xA0, 0xB8, 0xC0, 0xD0};
-static const Bit32u MODE_2_DRY_AMP[] = {0xA0, 0xA0, 0xB0, 0xB0, 0xB0, 0xB0, 0xC0, 0xE0};
-static const Bit32u MODE_2_WET_AMP[] = {0x10, 0x30, 0x50, 0x70, 0x90, 0xC0, 0xF0, 0xF0};
-static const Bit32u MODE_2_LPF_AMP = 0x80;
-
-static const Bit32u MODE_3_NUMBER_OF_ALLPASSES = 0;
-static const Bit32u MODE_3_NUMBER_OF_COMBS = 1;
-static const Bit32u MODE_3_DELAY[] = {16000 + MODE_3_FEEDBACK_DELAY + PROCESS_DELAY + MODE_3_ADDITIONAL_DELAY};
-static const Bit32u MODE_3_OUTL[] = {400, 624, 960, 1488, 2256, 3472, 5280, 8000};
-static const Bit32u MODE_3_OUTR[] = {800, 1248, 1920, 2976, 4512, 6944, 10560, 16000};
-static const Bit32u MODE_3_COMB_FACTOR[] = {0x68};
-static const Bit32u MODE_3_COMB_FEEDBACK[] = {0x68, 0x60};
-static const Bit32u MODE_3_DRY_AMP[] = {0x20, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50};
-static const Bit32u MODE_3_WET_AMP[] = {0x18, 0x18, 0x28, 0x40, 0x60, 0x80, 0xA8, 0xF8};
-
-static const BReverbSettings REVERB_MODE_0_SETTINGS = {MODE_0_NUMBER_OF_ALLPASSES, MODE_0_ALLPASSES, MODE_0_NUMBER_OF_COMBS, MODE_0_COMBS, MODE_0_OUTL, MODE_0_OUTR, MODE_0_COMB_FACTOR, MODE_0_COMB_FEEDBACK, MODE_0_DRY_AMP, MODE_0_WET_AMP, MODE_0_LPF_AMP};
-static const BReverbSettings REVERB_MODE_1_SETTINGS = {MODE_1_NUMBER_OF_ALLPASSES, MODE_1_ALLPASSES, MODE_1_NUMBER_OF_COMBS, MODE_1_COMBS, MODE_1_OUTL, MODE_1_OUTR, MODE_1_COMB_FACTOR, MODE_1_COMB_FEEDBACK, MODE_1_DRY_AMP, MODE_1_WET_AMP, MODE_1_LPF_AMP};
-static const BReverbSettings REVERB_MODE_2_SETTINGS = {MODE_2_NUMBER_OF_ALLPASSES, MODE_2_ALLPASSES, MODE_2_NUMBER_OF_COMBS, MODE_2_COMBS, MODE_2_OUTL, MODE_2_OUTR, MODE_2_COMB_FACTOR, MODE_2_COMB_FEEDBACK, MODE_2_DRY_AMP, MODE_2_WET_AMP, MODE_2_LPF_AMP};
-static const BReverbSettings REVERB_MODE_3_SETTINGS = {MODE_3_NUMBER_OF_ALLPASSES, NULL, MODE_3_NUMBER_OF_COMBS, MODE_3_DELAY, MODE_3_OUTL, MODE_3_OUTR, MODE_3_COMB_FACTOR, MODE_3_COMB_FEEDBACK, MODE_3_DRY_AMP, MODE_3_WET_AMP, 0};
-
-static const BReverbSettings * const REVERB_SETTINGS[] = {&REVERB_MODE_0_SETTINGS, &REVERB_MODE_1_SETTINGS, &REVERB_MODE_2_SETTINGS, &REVERB_MODE_3_SETTINGS};
-
-// This algorithm tries to emulate exactly Boss multiplication operation (at least this is what we see on reverb RAM data lines).
-// Also LA32 is suspected to use the similar one to perform PCM interpolation and ring modulation.
-static Bit32s weirdMul(Bit32s a, Bit8u addMask, Bit8u carryMask) {
+static inline IntSample weirdMul(IntSample sample, Bit8u addMask, Bit8u carryMask) {
+#if MT32EMU_BOSS_REVERB_PRECISE_MODE
+	// This algorithm tries to emulate exactly Boss multiplication operation (at least this is what we see on reverb RAM data lines).
 	Bit8u mask = 0x80;
-	Bit32s res = 0;
+	IntSampleEx res = 0;
 	for (int i = 0; i < 8; i++) {
-		Bit32s carry = (a < 0) && (mask & carryMask) > 0 ? a & 1 : 0;
-		a >>= 1;
-		res += (mask & addMask) > 0 ? a + carry : 0;
+		IntSampleEx carry = (sample < 0) && (mask & carryMask) > 0 ? sample & 1 : 0;
+		sample >>= 1;
+		res += (mask & addMask) > 0 ? sample + carry : 0;
 		mask >>= 1;
 	}
-	return res;
+	return IntSample(res);
+#else
+	(void)carryMask;
+	return IntSample((IntSampleEx(sample) * addMask) >> 8);
+#endif
 }
 
-RingBuffer::RingBuffer(Bit32u newsize) : size(newsize), index(0) {
-	buffer = new Bit16s[size];
+static inline FloatSample weirdMul(FloatSample sample, Bit8u addMask, Bit8u carryMask) {
+	(void)carryMask;
+	return sample * addMask / 256.0f;
 }
 
-RingBuffer::~RingBuffer() {
-	delete[] buffer;
-	buffer = NULL;
+static inline IntSample halveSample(IntSample sample) {
+	return sample >> 1;
 }
 
-Bit32s RingBuffer::next() {
-	if (++index >= size) {
-		index = 0;
-	}
-	return buffer[index];
+static inline FloatSample halveSample(FloatSample sample) {
+	return 0.5f * sample;
+}
+
+static inline IntSample quarterSample(IntSample sample) {
+#if MT32EMU_BOSS_REVERB_PRECISE_MODE
+	return (sample >> 1) / 2;
+#else
+	return sample >> 2;
+#endif
 }
 
-bool RingBuffer::isEmpty() const {
-	if (buffer == NULL) return true;
+static inline FloatSample quarterSample(FloatSample sample) {
+	return 0.25f * sample;
+}
 
-	Bit16s *buf = buffer;
-	for (Bit32u i = 0; i < size; i++) {
-		if (*buf < -8 || *buf > 8) return false;
-		buf++;
-	}
-	return true;
+static inline IntSample addDCBias(IntSample sample) {
+	return sample;
+}
+
+static inline FloatSample addDCBias(FloatSample sample) {
+	return sample + BIAS;
 }
 
-void RingBuffer::mute() {
-	Bit16s *buf = buffer;
-	for (Bit32u i = 0; i < size; i++) {
-		*buf++ = 0;
+static inline IntSample addAllpassNoise(IntSample sample) {
+#if MT32EMU_BOSS_REVERB_PRECISE_MODE
+	// This introduces reverb noise which actually makes output from the real Boss chip nondeterministic
+	return sample - 1;
+#else
+	return sample;
+#endif
+}
+
+static inline FloatSample addAllpassNoise(FloatSample sample) {
+	return sample;
+}
+
+/* NOTE:
+ *   Thanks to Mok for discovering, the adder in BOSS reverb chip is found to perform addition with saturation to avoid integer overflow.
+ *   Analysing of the algorithm suggests that the overflow is most probable when the combs output is added below.
+ *   So, despite this isn't actually accurate, we only add the check here for performance reasons.
+ */
+static inline IntSample mixCombs(IntSample out1, IntSample out2, IntSample out3) {
+#if MT32EMU_BOSS_REVERB_PRECISE_MODE
+	return Synth::clipSampleEx(Synth::clipSampleEx(Synth::clipSampleEx(Synth::clipSampleEx(IntSampleEx(out1) + (IntSampleEx(out1) >> 1)) + IntSampleEx(out2)) + (IntSampleEx(out2) >> 1)) + IntSampleEx(out3));
+#else
+	return Synth::clipSampleEx(IntSampleEx(out1) + (IntSampleEx(out1) >> 1) + IntSampleEx(out2) + (IntSampleEx(out2) >> 1) + IntSampleEx(out3));
+#endif
+}
+
+static inline FloatSample mixCombs(FloatSample out1, FloatSample out2, FloatSample out3) {
+	return 1.5f * (out1 + out2) + out3;
+}
+
+template <class Sample>
+class RingBuffer {
+	static inline Sample sampleValueThreshold();
+
+protected:
+	Sample *buffer;
+	const Bit32u size;
+	Bit32u index;
+
+public:
+	RingBuffer(const Bit32u newsize) : size(newsize), index(0) {
+		buffer = new Sample[size];
+	}
+
+	virtual ~RingBuffer() {
+		delete[] buffer;
+		buffer = NULL;
+	}
+
+	Sample next() {
+		if (++index >= size) {
+			index = 0;
+		}
+		return buffer[index];
+	}
+
+	bool isEmpty() const {
+		if (buffer == NULL) return true;
+
+		Sample *buf = buffer;
+		for (Bit32u i = 0; i < size; i++) {
+			if (*buf < -sampleValueThreshold() || *buf > sampleValueThreshold()) return false;
+			buf++;
+		}
+		return true;
+	}
+
+	void mute() {
+		Synth::muteSampleBuffer(buffer, size);
 	}
+};
+
+template<>
+IntSample RingBuffer<IntSample>::sampleValueThreshold() {
+	return 8;
 }
 
-AllpassFilter::AllpassFilter(const Bit32u useSize) : RingBuffer(useSize) {}
+template<>
+FloatSample RingBuffer<FloatSample>::sampleValueThreshold() {
+	return 0.001f;
+}
+
+template <class Sample>
+class AllpassFilter : public RingBuffer<Sample> {
+public:
+	AllpassFilter(const Bit32u useSize) : RingBuffer<Sample>(useSize) {}
 
-Bit32s AllpassFilter::process(const Bit32s in) {
 	// This model corresponds to the allpass filter implementation of the real CM-32L device
 	// found from sample analysis
+	Sample process(const Sample in) {
+		const Sample bufferOut = this->next();
 
-	Bit16s bufferOut = next();
+		// store input - feedback / 2
+		this->buffer[this->index] = in - halveSample(bufferOut);
 
-	// store input - feedback / 2
-	buffer[index] = in - (bufferOut >> 1);
+		// return buffer output + feedforward / 2
+		return bufferOut + halveSample(this->buffer[this->index]);
+	}
+};
 
-	// return buffer output + feedforward / 2
-	return bufferOut + (buffer[index] >> 1);
-}
+template <class Sample>
+class CombFilter : public RingBuffer<Sample> {
+protected:
+	const Bit8u filterFactor;
+	Bit8u feedbackFactor;
 
-CombFilter::CombFilter(const Bit32u useSize, const Bit32u useFilterFactor) : RingBuffer(useSize), filterFactor(useFilterFactor) {}
+public:
+	CombFilter(const Bit32u useSize, const Bit8u useFilterFactor) : RingBuffer<Sample>(useSize), filterFactor(useFilterFactor) {}
 
-void CombFilter::process(const Bit32s in) {
 	// This model corresponds to the comb filter implementation of the real CM-32L device
+	void process(const Sample in) {
 
-	// the previously stored value
-	Bit32s last = buffer[index];
+		// the previously stored value
+		const Sample last = this->buffer[this->index];
 
-	// prepare input + feedback
-	Bit32s filterIn = in + weirdMul(next(), feedbackFactor, 0xF0 /* Maybe 0x80 ? */);
+		// prepare input + feedback
+		const Sample filterIn = in + weirdMul(this->next(), feedbackFactor, 0xF0);
 
-	// store input + feedback processed by a low-pass filter
-	buffer[index] = weirdMul(last, filterFactor, 0x40) - filterIn;
-}
+		// store input + feedback processed by a low-pass filter
+		this->buffer[this->index] = weirdMul(last, filterFactor, 0xC0) - filterIn;
+	}
 
-Bit32s CombFilter::getOutputAt(const Bit32u outIndex) const {
-	return buffer[(size + index - outIndex) % size];
-}
+	Sample getOutputAt(const Bit32u outIndex) const {
+		return this->buffer[(this->size + this->index - outIndex) % this->size];
+	}
 
-void CombFilter::setFeedbackFactor(const Bit32u useFeedbackFactor) {
-	feedbackFactor = useFeedbackFactor;
-}
+	void setFeedbackFactor(const Bit8u useFeedbackFactor) {
+		feedbackFactor = useFeedbackFactor;
+	}
+};
 
-DelayWithLowPassFilter::DelayWithLowPassFilter(const Bit32u useSize, const Bit32u useFilterFactor, const Bit32u useAmp)
-	: CombFilter(useSize, useFilterFactor), amp(useAmp) {}
+template <class Sample>
+class DelayWithLowPassFilter : public CombFilter<Sample> {
+	Bit8u amp;
 
-void DelayWithLowPassFilter::process(const Bit32s in) {
-	// the previously stored value
-	Bit32s last = buffer[index];
+public:
+	DelayWithLowPassFilter(const Bit32u useSize, const Bit8u useFilterFactor, const Bit8u useAmp)
+		: CombFilter<Sample>(useSize, useFilterFactor), amp(useAmp) {}
 
-	// move to the next index
-	next();
+	void process(const Sample in) {
+		// the previously stored value
+		const Sample last = this->buffer[this->index];
 
-	// low-pass filter process
-	Bit32s lpfOut = weirdMul(last, filterFactor, 0xFF) + in;
+		// move to the next index
+		this->next();
 
-	// store lpfOut multiplied by LPF amp factor
-	buffer[index] = weirdMul(lpfOut, amp, 0xFF);
-}
+		// low-pass filter process
+		Sample lpfOut = weirdMul(last, this->filterFactor, 0xFF) + in;
 
-TapDelayCombFilter::TapDelayCombFilter(const Bit32u useSize, const Bit32u useFilterFactor) : CombFilter(useSize, useFilterFactor) {}
+		// store lpfOut multiplied by LPF amp factor
+		this->buffer[this->index] = weirdMul(lpfOut, amp, 0xFF);
+	}
+};
 
-void TapDelayCombFilter::process(const Bit32s in) {
-	// the previously stored value
-	Bit32s last = buffer[index];
+template <class Sample>
+class TapDelayCombFilter : public CombFilter<Sample> {
+	Bit32u outL;
+	Bit32u outR;
 
-	// move to the next index
-	next();
+public:
+	TapDelayCombFilter(const Bit32u useSize, const Bit8u useFilterFactor) : CombFilter<Sample>(useSize, useFilterFactor) {}
 
-	// prepare input + feedback
-	// Actually, the size of the filter varies with the TIME parameter, the feedback sample is taken from the position just below the right output
-	Bit32s filterIn = in + weirdMul(getOutputAt(outR + MODE_3_FEEDBACK_DELAY), feedbackFactor, 0xF0);
+	void process(const Sample in) {
+		// the previously stored value
+		const Sample last = this->buffer[this->index];
 
-	// store input + feedback processed by a low-pass filter
-	buffer[index] = weirdMul(last, filterFactor, 0xF0) - filterIn;
-}
+		// move to the next index
+		this->next();
 
-Bit32s TapDelayCombFilter::getLeftOutput() const {
-	return getOutputAt(outL + PROCESS_DELAY + MODE_3_ADDITIONAL_DELAY);
-}
+		// prepare input + feedback
+		// Actually, the size of the filter varies with the TIME parameter, the feedback sample is taken from the position just below the right output
+		const Sample filterIn = in + weirdMul(this->getOutputAt(outR + MODE_3_FEEDBACK_DELAY), this->feedbackFactor, 0xF0);
 
-Bit32s TapDelayCombFilter::getRightOutput() const {
-	return getOutputAt(outR + PROCESS_DELAY + MODE_3_ADDITIONAL_DELAY);
-}
+		// store input + feedback processed by a low-pass filter
+		this->buffer[this->index] = weirdMul(last, this->filterFactor, 0xF0) - filterIn;
+	}
 
-void TapDelayCombFilter::setOutputPositions(const Bit32u useOutL, const Bit32u useOutR) {
-	outL = useOutL;
-	outR = useOutR;
-}
+	Sample getLeftOutput() const {
+		return this->getOutputAt(outL + PROCESS_DELAY + MODE_3_ADDITIONAL_DELAY);
+	}
 
-BReverbModel::BReverbModel(const ReverbMode mode)
-	: allpasses(NULL), combs(NULL), currentSettings(*REVERB_SETTINGS[mode]), tapDelayMode(mode == REVERB_MODE_TAP_DELAY) {}
+	Sample getRightOutput() const {
+		return this->getOutputAt(outR + PROCESS_DELAY + MODE_3_ADDITIONAL_DELAY);
+	}
 
-BReverbModel::~BReverbModel() {
-	close();
-}
+	void setOutputPositions(const Bit32u useOutL, const Bit32u useOutR) {
+		outL = useOutL;
+		outR = useOutR;
+	}
+};
+
+template <class Sample>
+class BReverbModelImpl : public BReverbModel {
+public:
+	AllpassFilter<Sample> **allpasses;
+	CombFilter<Sample> **combs;
+
+	const BReverbSettings &currentSettings;
+	const bool tapDelayMode;
+	Bit8u dryAmp;
+	Bit8u wetLevel;
+
+	BReverbModelImpl(const ReverbMode mode, const bool mt32CompatibleModel) :
+		allpasses(NULL), combs(NULL),
+		currentSettings(mt32CompatibleModel ? getMT32Settings(mode) : getCM32L_LAPCSettings(mode)),
+		tapDelayMode(mode == REVERB_MODE_TAP_DELAY)
+	{}
+
+	~BReverbModelImpl() {
+		close();
+	}
 
-void BReverbModel::open() {
-	if (currentSettings.numberOfAllpasses > 0) {
-		allpasses = new AllpassFilter*[currentSettings.numberOfAllpasses];
-		for (Bit32u i = 0; i < currentSettings.numberOfAllpasses; i++) {
-			allpasses[i] = new AllpassFilter(currentSettings.allpassSizes[i]);
-		}
+	bool isOpen() const {
+		return combs != NULL;
 	}
-	combs = new CombFilter*[currentSettings.numberOfCombs];
-	if (tapDelayMode) {
-		*combs = new TapDelayCombFilter(*currentSettings.combSizes, *currentSettings.filterFactors);
-	} else {
-		combs[0] = new DelayWithLowPassFilter(currentSettings.combSizes[0], currentSettings.filterFactors[0], currentSettings.lpfAmp);
-		for (Bit32u i = 1; i < currentSettings.numberOfCombs; i++) {
-			combs[i] = new CombFilter(currentSettings.combSizes[i], currentSettings.filterFactors[i]);
+
+	void open() {
+		if (isOpen()) return;
+		if (currentSettings.numberOfAllpasses > 0) {
+			allpasses = new AllpassFilter<Sample>*[currentSettings.numberOfAllpasses];
+			for (Bit32u i = 0; i < currentSettings.numberOfAllpasses; i++) {
+				allpasses[i] = new AllpassFilter<Sample>(currentSettings.allpassSizes[i]);
+			}
 		}
+		combs = new CombFilter<Sample>*[currentSettings.numberOfCombs];
+		if (tapDelayMode) {
+			*combs = new TapDelayCombFilter<Sample>(*currentSettings.combSizes, *currentSettings.filterFactors);
+		} else {
+			combs[0] = new DelayWithLowPassFilter<Sample>(currentSettings.combSizes[0], currentSettings.filterFactors[0], currentSettings.lpfAmp);
+			for (Bit32u i = 1; i < currentSettings.numberOfCombs; i++) {
+				combs[i] = new CombFilter<Sample>(currentSettings.combSizes[i], currentSettings.filterFactors[i]);
+			}
+		}
+		mute();
 	}
-	mute();
-}
 
-void BReverbModel::close() {
-	if (allpasses != NULL) {
-		for (Bit32u i = 0; i < currentSettings.numberOfAllpasses; i++) {
-			if (allpasses[i] != NULL) {
-				delete allpasses[i];
-				allpasses[i] = NULL;
+	void close() {
+		if (allpasses != NULL) {
+			for (Bit32u i = 0; i < currentSettings.numberOfAllpasses; i++) {
+				if (allpasses[i] != NULL) {
+					delete allpasses[i];
+					allpasses[i] = NULL;
+				}
 			}
+			delete[] allpasses;
+			allpasses = NULL;
 		}
-		delete[] allpasses;
-		allpasses = NULL;
-	}
-	if (combs != NULL) {
-		for (Bit32u i = 0; i < currentSettings.numberOfCombs; i++) {
-			if (combs[i] != NULL) {
-				delete combs[i];
-				combs[i] = NULL;
+		if (combs != NULL) {
+			for (Bit32u i = 0; i < currentSettings.numberOfCombs; i++) {
+				if (combs[i] != NULL) {
+					delete combs[i];
+					combs[i] = NULL;
+				}
 			}
+			delete[] combs;
+			combs = NULL;
 		}
-		delete[] combs;
-		combs = NULL;
 	}
-}
 
-void BReverbModel::mute() {
-	if (allpasses != NULL) {
-		for (Bit32u i = 0; i < currentSettings.numberOfAllpasses; i++) {
-			allpasses[i]->mute();
+	void mute() {
+		if (allpasses != NULL) {
+			for (Bit32u i = 0; i < currentSettings.numberOfAllpasses; i++) {
+				allpasses[i]->mute();
+			}
+		}
+		if (combs != NULL) {
+			for (Bit32u i = 0; i < currentSettings.numberOfCombs; i++) {
+				combs[i]->mute();
+			}
 		}
 	}
-	if (combs != NULL) {
-		for (Bit32u i = 0; i < currentSettings.numberOfCombs; i++) {
-			combs[i]->mute();
+
+	void setParameters(Bit8u time, Bit8u level) {
+		if (!isOpen()) return;
+		level &= 7;
+		time &= 7;
+		if (tapDelayMode) {
+			TapDelayCombFilter<Sample> *comb = static_cast<TapDelayCombFilter<Sample> *> (*combs);
+			comb->setOutputPositions(currentSettings.outLPositions[time], currentSettings.outRPositions[time & 7]);
+			comb->setFeedbackFactor(currentSettings.feedbackFactors[((level < 3) || (time < 6)) ? 0 : 1]);
+		} else {
+			for (Bit32u i = 1; i < currentSettings.numberOfCombs; i++) {
+				combs[i]->setFeedbackFactor(currentSettings.feedbackFactors[(i << 3) + time]);
+			}
+		}
+		if (time == 0 && level == 0) {
+			dryAmp = wetLevel = 0;
+		} else {
+			if (tapDelayMode && ((time == 0) || (time == 1 && level == 1))) {
+				// Looks like MT-32 implementation has some minor quirks in this mode:
+				// for odd level values, the output level changes sometimes depending on the time value which doesn't seem right.
+				dryAmp = currentSettings.dryAmps[level + 8];
+			} else {
+				dryAmp = currentSettings.dryAmps[level];
+			}
+			wetLevel = currentSettings.wetLevels[level];
 		}
 	}
-}
 
-void BReverbModel::setParameters(Bit8u time, Bit8u level) {
-	if (combs == NULL) return;
-	level &= 7;
-	time &= 7;
-	if (tapDelayMode) {
-		TapDelayCombFilter *comb = static_cast<TapDelayCombFilter *> (*combs);
-		comb->setOutputPositions(currentSettings.outLPositions[time], currentSettings.outRPositions[time & 7]);
-		comb->setFeedbackFactor(currentSettings.feedbackFactors[((level < 3) || (time < 6)) ? 0 : 1]);
-	} else {
+	bool isActive() const {
+		if (!isOpen()) return false;
+		for (Bit32u i = 0; i < currentSettings.numberOfAllpasses; i++) {
+			if (!allpasses[i]->isEmpty()) return true;
+		}
 		for (Bit32u i = 0; i < currentSettings.numberOfCombs; i++) {
-			combs[i]->setFeedbackFactor(currentSettings.feedbackFactors[(i << 3) + time]);
+			if (!combs[i]->isEmpty()) return true;
 		}
+		return false;
 	}
-	if (time == 0 && level == 0) {
-		dryAmp = wetLevel = 0;
-	} else {
-		dryAmp = currentSettings.dryAmps[level];
-		wetLevel = currentSettings.wetLevels[level];
-	}
-}
 
-bool BReverbModel::isActive() const {
-	for (Bit32u i = 0; i < currentSettings.numberOfAllpasses; i++) {
-		if (!allpasses[i]->isEmpty()) return true;
+	bool isMT32Compatible(const ReverbMode mode) const {
+		return &currentSettings == &getMT32Settings(mode);
 	}
-	for (Bit32u i = 0; i < currentSettings.numberOfCombs; i++) {
-		if (!combs[i]->isEmpty()) return true;
-	}
-	return false;
-}
-
-void BReverbModel::process(const float *inLeft, const float *inRight, float *outLeft, float *outRight, unsigned long numSamples) {
-	Bit32s dry, link, outL1, outR1;
 
-	for (unsigned long i = 0; i < numSamples; i++) {
-		if (tapDelayMode) {
-			dry = Bit32s(*inLeft * 8192.0f) + Bit32s(*inRight * 8192.0f);
-		} else {
-			dry = Bit32s(*inLeft * 8192.0f) / 2 + Bit32s(*inRight * 8192.0f) / 2;
+	template <class SampleEx>
+	void produceOutput(const Sample *inLeft, const Sample *inRight, Sample *outLeft, Sample *outRight, Bit32u numSamples) {
+		if (!isOpen()) {
+			Synth::muteSampleBuffer(outLeft, numSamples);
+			Synth::muteSampleBuffer(outRight, numSamples);
+			return;
 		}
 
-		// Looks like dryAmp doesn't change in MT-32 but it does in CM-32L / LAPC-I
-		dry = weirdMul(dry, dryAmp, 0xFF);
+		while ((numSamples--) > 0) {
+			Sample dry;
 
-		if (tapDelayMode) {
-			TapDelayCombFilter *comb = static_cast<TapDelayCombFilter *> (*combs);
-			comb->process(dry);
-			*outLeft = weirdMul(comb->getLeftOutput(), wetLevel, 0xFF) / 8192.0f;
-			*outRight = weirdMul(comb->getRightOutput(), wetLevel, 0xFF) / 8192.0f;
-		} else {
-			// Get the last stored sample before processing in order not to loose it
-			link = combs[0]->getOutputAt(currentSettings.combSizes[0] - 1);
-
-			// Entrance LPF. Note, comb.process() differs a bit here.
-			combs[0]->process(dry);
-
-			// This introduces reverb noise which actually makes output from the real Boss chip nondeterministic
-			link = link - 1;
-			link = allpasses[0]->process(link);
-			link = allpasses[1]->process(link);
-			link = allpasses[2]->process(link);
-
-			// If the output position is equal to the comb size, get it now in order not to loose it
-			outL1 = combs[1]->getOutputAt(currentSettings.outLPositions[0] - 1);
-			outL1 += outL1 >> 1;
-
-			combs[1]->process(link);
-			combs[2]->process(link);
-			combs[3]->process(link);
-
-			link = combs[2]->getOutputAt(currentSettings.outLPositions[1]);
-			link += link >> 1;
-			link += outL1;
-			link += combs[3]->getOutputAt(currentSettings.outLPositions[2]);
-			*outLeft = weirdMul(link, wetLevel, 0xFF) / 8192.0f;
-
-			outR1 = combs[1]->getOutputAt(currentSettings.outRPositions[0]);
-			outR1 += outR1 >> 1;
-			link = combs[2]->getOutputAt(currentSettings.outRPositions[1]);
-			link += link >> 1;
-			link += outR1;
-			link += combs[3]->getOutputAt(currentSettings.outRPositions[2]);
-			*outRight = weirdMul(link, wetLevel, 0xFF) / 8192.0f;
-		}
+			if (tapDelayMode) {
+				dry = halveSample(*(inLeft++)) + halveSample(*(inRight++));
+			} else {
+				dry = quarterSample(*(inLeft++)) + quarterSample(*(inRight++));
+			}
 
-		inLeft++;
-		inRight++;
-		outLeft++;
-		outRight++;
+			// Looks like dryAmp doesn't change in MT-32 but it does in CM-32L / LAPC-I
+			dry = weirdMul(addDCBias(dry), dryAmp, 0xFF);
+
+			if (tapDelayMode) {
+				TapDelayCombFilter<Sample> *comb = static_cast<TapDelayCombFilter<Sample> *>(*combs);
+				comb->process(dry);
+				if (outLeft != NULL) {
+					*(outLeft++) = weirdMul(comb->getLeftOutput(), wetLevel, 0xFF);
+				}
+				if (outRight != NULL) {
+					*(outRight++) = weirdMul(comb->getRightOutput(), wetLevel, 0xFF);
+				}
+			} else {
+				DelayWithLowPassFilter<Sample> * const entranceDelay = static_cast<DelayWithLowPassFilter<Sample> *>(combs[0]);
+				// If the output position is equal to the comb size, get it now in order not to loose it
+				Sample link = entranceDelay->getOutputAt(currentSettings.combSizes[0] - 1);
+
+				// Entrance LPF. Note, comb.process() differs a bit here.
+				entranceDelay->process(dry);
+
+				link = allpasses[0]->process(addAllpassNoise(link));
+				link = allpasses[1]->process(link);
+				link = allpasses[2]->process(link);
+
+				// If the output position is equal to the comb size, get it now in order not to loose it
+				Sample outL1 = combs[1]->getOutputAt(currentSettings.outLPositions[0] - 1);
+
+				combs[1]->process(link);
+				combs[2]->process(link);
+				combs[3]->process(link);
+
+				if (outLeft != NULL) {
+					Sample outL2 = combs[2]->getOutputAt(currentSettings.outLPositions[1]);
+					Sample outL3 = combs[3]->getOutputAt(currentSettings.outLPositions[2]);
+					Sample outSample = mixCombs(outL1, outL2, outL3);
+					*(outLeft++) = weirdMul(outSample, wetLevel, 0xFF);
+				}
+				if (outRight != NULL) {
+					Sample outR1 = combs[1]->getOutputAt(currentSettings.outRPositions[0]);
+					Sample outR2 = combs[2]->getOutputAt(currentSettings.outRPositions[1]);
+					Sample outR3 = combs[3]->getOutputAt(currentSettings.outRPositions[2]);
+					Sample outSample = mixCombs(outR1, outR2, outR3);
+					*(outRight++) = weirdMul(outSample, wetLevel, 0xFF);
+				}
+			} // if (tapDelayMode)
+		} // while ((numSamples--) > 0)
+	} // produceOutput
+
+	bool process(const IntSample *inLeft, const IntSample *inRight, IntSample *outLeft, IntSample *outRight, Bit32u numSamples);
+	bool process(const FloatSample *inLeft, const FloatSample *inRight, FloatSample *outLeft, FloatSample *outRight, Bit32u numSamples);
+};
+
+BReverbModel *BReverbModel::createBReverbModel(const ReverbMode mode, const bool mt32CompatibleModel, const RendererType rendererType) {
+	switch (rendererType)
+	{
+	case RendererType_BIT16S:
+		return new BReverbModelImpl<IntSample>(mode, mt32CompatibleModel);
+	case RendererType_FLOAT:
+		return new BReverbModelImpl<FloatSample>(mode, mt32CompatibleModel);
 	}
+	return NULL;
 }
 
+template <>
+bool BReverbModelImpl<IntSample>::process(const IntSample *inLeft, const IntSample *inRight, IntSample *outLeft, IntSample *outRight, Bit32u numSamples) {
+	produceOutput<IntSampleEx>(inLeft, inRight, outLeft, outRight, numSamples);
+	return true;
 }
 
-#endif
+template <>
+bool BReverbModelImpl<IntSample>::process(const FloatSample *, const FloatSample *, FloatSample *, FloatSample *, Bit32u) {
+	return false;
+}
+
+template <>
+bool BReverbModelImpl<FloatSample>::process(const IntSample *, const IntSample *, IntSample *, IntSample *, Bit32u) {
+	return false;
+}
+
+template <>
+bool BReverbModelImpl<FloatSample>::process(const FloatSample *inLeft, const FloatSample *inRight, FloatSample *outLeft, FloatSample *outRight, Bit32u numSamples) {
+	produceOutput<FloatSample>(inLeft, inRight, outLeft, outRight, numSamples);
+	return true;
+}
+
+} // namespace MT32Emu
diff --git a/src/mt32/BReverbModel.h b/src/mt32/BReverbModel.h
index d6fcb73c..5b1d4119 100644
--- a/src/mt32/BReverbModel.h
+++ b/src/mt32/BReverbModel.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,95 +18,31 @@
 #ifndef MT32EMU_B_REVERB_MODEL_H
 #define MT32EMU_B_REVERB_MODEL_H
 
-namespace MT32Emu {
-
-struct BReverbSettings {
-	const Bit32u numberOfAllpasses;
-	const Bit32u * const allpassSizes;
-	const Bit32u numberOfCombs;
-	const Bit32u * const combSizes;
-	const Bit32u * const outLPositions;
-	const Bit32u * const outRPositions;
-	const Bit32u * const filterFactors;
-	const Bit32u * const feedbackFactors;
-	const Bit32u * const dryAmps;
-	const Bit32u * const wetLevels;
-	const Bit32u lpfAmp;
-};
-
-class RingBuffer {
-protected:
-	Bit16s *buffer;
-	const Bit32u size;
-	Bit32u index;
-
-public:
-	RingBuffer(const Bit32u size);
-	virtual ~RingBuffer();
-	Bit32s next();
-	bool isEmpty() const;
-	void mute();
-};
-
-class AllpassFilter : public RingBuffer {
-public:
-	AllpassFilter(const Bit32u size);
-	Bit32s process(const Bit32s in);
-};
-
-class CombFilter : public RingBuffer {
-protected:
-	const Bit32u filterFactor;
-	Bit32u feedbackFactor;
-
-public:
-	CombFilter(const Bit32u size, const Bit32u useFilterFactor);
-	virtual void process(const Bit32s in); // Actually, no need to make it virtual, but for sure
-	Bit32s getOutputAt(const Bit32u outIndex) const;
-	void setFeedbackFactor(const Bit32u useFeedbackFactor);
-};
-
-class DelayWithLowPassFilter : public CombFilter {
-	Bit32u amp;
-
-public:
-	DelayWithLowPassFilter(const Bit32u useSize, const Bit32u useFilterFactor, const Bit32u useAmp);
-	void process(const Bit32s in);
-	void setFeedbackFactor(const Bit32u) {}
-};
+#include "globals.h"
+#include "internals.h"
+#include "Enumerations.h"
+#include "Types.h"
 
-class TapDelayCombFilter : public CombFilter {
-	Bit32u outL;
-	Bit32u outR;
-
-public:
-	TapDelayCombFilter(const Bit32u useSize, const Bit32u useFilterFactor);
-	void process(const Bit32s in);
-	Bit32s getLeftOutput() const;
-	Bit32s getRightOutput() const;
-	void setOutputPositions(const Bit32u useOutL, const Bit32u useOutR);
-};
-
-class BReverbModel : public ReverbModel {
-	AllpassFilter **allpasses;
-	CombFilter **combs;
-
-	const BReverbSettings &currentSettings;
-	const bool tapDelayMode;
-	Bit32u dryAmp;
-	Bit32u wetLevel;
-	void mute();
+namespace MT32Emu {
 
+class BReverbModel {
 public:
-	BReverbModel(const ReverbMode mode);
-	~BReverbModel();
-	void open();
-	void close();
-	void setParameters(Bit8u time, Bit8u level);
-	void process(const float *inLeft, const float *inRight, float *outLeft, float *outRight, unsigned long numSamples);
-	bool isActive() const;
+	static BReverbModel *createBReverbModel(const ReverbMode mode, const bool mt32CompatibleModel, const RendererType rendererType);
+
+	virtual ~BReverbModel() {}
+	virtual bool isOpen() const = 0;
+	// After construction or a close(), open() must be called at least once before any other call (with the exception of close()).
+	virtual void open() = 0;
+	// May be called multiple times without an open() in between.
+	virtual void close() = 0;
+	virtual void mute() = 0;
+	virtual void setParameters(Bit8u time, Bit8u level) = 0;
+	virtual bool isActive() const = 0;
+	virtual bool isMT32Compatible(const ReverbMode mode) const = 0;
+	virtual bool process(const IntSample *inLeft, const IntSample *inRight, IntSample *outLeft, IntSample *outRight, Bit32u numSamples) = 0;
+	virtual bool process(const FloatSample *inLeft, const FloatSample *inRight, FloatSample *outLeft, FloatSample *outRight, Bit32u numSamples) = 0;
 };
 
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_B_REVERB_MODEL_H
diff --git a/src/mt32/Enumerations.h b/src/mt32/Enumerations.h
new file mode 100644
index 00000000..bb580ca5
--- /dev/null
+++ b/src/mt32/Enumerations.h
@@ -0,0 +1,187 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Using two guards since this file may be included twice with different MT32EMU_C_ENUMERATIONS define. */
+
+#if (!defined MT32EMU_CPP_ENUMERATIONS_H && !defined MT32EMU_C_ENUMERATIONS) || (!defined MT32EMU_C_ENUMERATIONS_H && defined MT32EMU_C_ENUMERATIONS)
+
+#ifdef MT32EMU_C_ENUMERATIONS
+
+#define MT32EMU_C_ENUMERATIONS_H
+
+#define MT32EMU_DAC_INPUT_MODE_NAME mt32emu_dac_input_mode
+#define MT32EMU_DAC_INPUT_MODE(ident) MT32EMU_DAC_##ident
+
+#define MT32EMU_MIDI_DELAY_MODE_NAME mt32emu_midi_delay_mode
+#define MT32EMU_MIDI_DELAY_MODE(ident) MT32EMU_MDM_##ident
+
+#define MT32EMU_ANALOG_OUTPUT_MODE_NAME mt32emu_analog_output_mode
+#define MT32EMU_ANALOG_OUTPUT_MODE(ident) MT32EMU_AOM_##ident
+
+#define MT32EMU_PARTIAL_STATE_NAME mt32emu_partial_state
+#define MT32EMU_PARTIAL_STATE(ident) MT32EMU_PS_##ident
+
+#define MT32EMU_SAMPLERATE_CONVERSION_QUALITY_NAME mt32emu_samplerate_conversion_quality
+#define MT32EMU_SAMPLERATE_CONVERSION_QUALITY(ident) MT32EMU_SRCQ_##ident
+
+#define MT32EMU_RENDERER_TYPE_NAME mt32emu_renderer_type
+#define MT32EMU_RENDERER_TYPE(ident) MT32EMU_RT_##ident
+
+#else /* #ifdef MT32EMU_C_ENUMERATIONS */
+
+#define MT32EMU_CPP_ENUMERATIONS_H
+
+#define MT32EMU_DAC_INPUT_MODE_NAME DACInputMode
+#define MT32EMU_DAC_INPUT_MODE(ident) DACInputMode_##ident
+
+#define MT32EMU_MIDI_DELAY_MODE_NAME MIDIDelayMode
+#define MT32EMU_MIDI_DELAY_MODE(ident) MIDIDelayMode_##ident
+
+#define MT32EMU_ANALOG_OUTPUT_MODE_NAME AnalogOutputMode
+#define MT32EMU_ANALOG_OUTPUT_MODE(ident) AnalogOutputMode_##ident
+
+#define MT32EMU_PARTIAL_STATE_NAME PartialState
+#define MT32EMU_PARTIAL_STATE(ident) PartialState_##ident
+
+#define MT32EMU_SAMPLERATE_CONVERSION_QUALITY_NAME SamplerateConversionQuality
+#define MT32EMU_SAMPLERATE_CONVERSION_QUALITY(ident) SamplerateConversionQuality_##ident
+
+#define MT32EMU_RENDERER_TYPE_NAME RendererType
+#define MT32EMU_RENDERER_TYPE(ident) RendererType_##ident
+
+namespace MT32Emu {
+
+#endif /* #ifdef MT32EMU_C_ENUMERATIONS */
+
+/**
+ * Methods for emulating the connection between the LA32 and the DAC, which involves
+ * some hacks in the real devices for doubling the volume.
+ * See also http://en.wikipedia.org/wiki/Roland_MT-32#Digital_overflow
+ */
+enum MT32EMU_DAC_INPUT_MODE_NAME {
+	/**
+	 * Produces samples at double the volume, without tricks.
+	 * Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)
+	 * Higher quality than the real devices
+	 */
+	MT32EMU_DAC_INPUT_MODE(NICE),
+
+	/**
+	 * Produces samples that exactly match the bits output from the emulated LA32.
+	 * Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)
+	 * Much less likely to overdrive than any other mode.
+	 * Half the volume of any of the other modes.
+	 * Perfect for developers while debugging :)
+	 */
+	MT32EMU_DAC_INPUT_MODE(PURE),
+
+	/**
+	 * Re-orders the LA32 output bits as in early generation MT-32s (according to Wikipedia).
+	 * Bit order at DAC (where each number represents the original LA32 output bit number, and XX means the bit is always low):
+	 * 15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 XX
+	 */
+	MT32EMU_DAC_INPUT_MODE(GENERATION1),
+
+	/**
+	 * Re-orders the LA32 output bits as in later generations (personally confirmed on my CM-32L - KG).
+	 * Bit order at DAC (where each number represents the original LA32 output bit number):
+	 * 15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 14
+	 */
+	MT32EMU_DAC_INPUT_MODE(GENERATION2)
+};
+
+/** Methods for emulating the effective delay of incoming MIDI messages introduced by a MIDI interface. */
+enum MT32EMU_MIDI_DELAY_MODE_NAME {
+	/** Process incoming MIDI events immediately. */
+	MT32EMU_MIDI_DELAY_MODE(IMMEDIATE),
+
+	/**
+	 * Delay incoming short MIDI messages as if they where transferred via a MIDI cable to a real hardware unit and immediate sysex processing.
+	 * This ensures more accurate timing of simultaneous NoteOn messages.
+	 */
+	MT32EMU_MIDI_DELAY_MODE(DELAY_SHORT_MESSAGES_ONLY),
+
+	/** Delay all incoming MIDI events as if they where transferred via a MIDI cable to a real hardware unit.*/
+	MT32EMU_MIDI_DELAY_MODE(DELAY_ALL)
+};
+
+/** Methods for emulating the effects of analogue circuits of real hardware units on the output signal. */
+enum MT32EMU_ANALOG_OUTPUT_MODE_NAME {
+	/** Only digital path is emulated. The output samples correspond to the digital signal at the DAC entrance. */
+	MT32EMU_ANALOG_OUTPUT_MODE(DIGITAL_ONLY),
+	/** Coarse emulation of LPF circuit. High frequencies are boosted, sample rate remains unchanged. */
+	MT32EMU_ANALOG_OUTPUT_MODE(COARSE),
+	/**
+	 * Finer emulation of LPF circuit. Output signal is upsampled to 48 kHz to allow emulation of audible mirror spectra above 16 kHz,
+	 * which is passed through the LPF circuit without significant attenuation.
+	 */
+	MT32EMU_ANALOG_OUTPUT_MODE(ACCURATE),
+	/**
+	 * Same as AnalogOutputMode_ACCURATE mode but the output signal is 2x oversampled, i.e. the output sample rate is 96 kHz.
+	 * This makes subsequent resampling easier. Besides, due to nonlinear passband of the LPF emulated, it takes fewer number of MACs
+	 * compared to a regular LPF FIR implementations.
+	 */
+	MT32EMU_ANALOG_OUTPUT_MODE(OVERSAMPLED)
+};
+
+enum MT32EMU_PARTIAL_STATE_NAME {
+	MT32EMU_PARTIAL_STATE(INACTIVE),
+	MT32EMU_PARTIAL_STATE(ATTACK),
+	MT32EMU_PARTIAL_STATE(SUSTAIN),
+	MT32EMU_PARTIAL_STATE(RELEASE)
+};
+
+enum MT32EMU_SAMPLERATE_CONVERSION_QUALITY_NAME {
+	/** Use this only when the speed is more important than the audio quality. */
+	MT32EMU_SAMPLERATE_CONVERSION_QUALITY(FASTEST),
+	MT32EMU_SAMPLERATE_CONVERSION_QUALITY(FAST),
+	MT32EMU_SAMPLERATE_CONVERSION_QUALITY(GOOD),
+	MT32EMU_SAMPLERATE_CONVERSION_QUALITY(BEST)
+};
+
+enum MT32EMU_RENDERER_TYPE_NAME {
+	/** Use 16-bit signed samples in the renderer and the accurate wave generator model based on logarithmic fixed-point computations and LUTs. Maximum emulation accuracy and speed. */
+	MT32EMU_RENDERER_TYPE(BIT16S),
+	/** Use float samples in the renderer and simplified wave generator model. Maximum output quality and minimum noise. */
+	MT32EMU_RENDERER_TYPE(FLOAT)
+};
+
+#ifndef MT32EMU_C_ENUMERATIONS
+
+} // namespace MT32Emu
+
+#endif
+
+#undef MT32EMU_DAC_INPUT_MODE_NAME
+#undef MT32EMU_DAC_INPUT_MODE
+
+#undef MT32EMU_MIDI_DELAY_MODE_NAME
+#undef MT32EMU_MIDI_DELAY_MODE
+
+#undef MT32EMU_ANALOG_OUTPUT_MODE_NAME
+#undef MT32EMU_ANALOG_OUTPUT_MODE
+
+#undef MT32EMU_PARTIAL_STATE_NAME
+#undef MT32EMU_PARTIAL_STATE
+
+#undef MT32EMU_SAMPLERATE_CONVERSION_QUALITY_NAME
+#undef MT32EMU_SAMPLERATE_CONVERSION_QUALITY
+
+#undef MT32EMU_RENDERER_TYPE_NAME
+#undef MT32EMU_RENDERER_TYPE
+
+#endif /* #if (!defined MT32EMU_CPP_ENUMERATIONS_H && !defined MT32EMU_C_ENUMERATIONS) || (!defined MT32EMU_C_ENUMERATIONS_H && defined MT32EMU_C_ENUMERATIONS) */
diff --git a/src/mt32/File.cpp b/src/mt32/File.cpp
index c6692592..a5967b4f 100644
--- a/src/mt32/File.cpp
+++ b/src/mt32/File.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,39 +15,63 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <cstdio>
-#include "mt32emu.h"
+#include <cstring>
+
+#include "internals.h"
+
+#include "File.h"
 #include "sha1/sha1.h"
 
 namespace MT32Emu {
 
-static void SHA1DigestToString(char *strDigest, const unsigned int intDigest[]) {
-	sprintf(strDigest, "%08x%08x%08x%08x%08x", intDigest[0], intDigest[1], intDigest[2], intDigest[3], intDigest[4]);
+AbstractFile::AbstractFile() : sha1DigestCalculated(false) {
+	sha1Digest[0] = 0;
+
+	reserved = NULL;
 }
 
-File::File() : sha1DigestCalculated(false), fileSize(0), data(NULL) {
-	sha1DigestCalculated = false;
+AbstractFile::AbstractFile(const SHA1Digest &useSHA1Digest) : sha1DigestCalculated(true) {
+	memcpy(sha1Digest, useSHA1Digest, sizeof(SHA1Digest) - 1);
+	sha1Digest[sizeof(SHA1Digest) - 1] = 0; // Ensure terminator char.
+
+	reserved = NULL;
 }
 
-const char *File::getSHA1() {
+const File::SHA1Digest &AbstractFile::getSHA1() {
 	if (sha1DigestCalculated) {
 		return sha1Digest;
 	}
-	sha1Digest[0] = 0;
 	sha1DigestCalculated = true;
 
-	if (getData() == NULL) {
+	size_t size = getSize();
+	if (size == 0) {
 		return sha1Digest;
 	}
 
-	SHA1 sha1;
-	unsigned int fileDigest[5];
-
-	sha1.Input(data, fileSize);
-	if (sha1.Result(fileDigest)) {
-		SHA1DigestToString(sha1Digest, fileDigest);
+	const Bit8u *data = getData();
+	if (data == NULL) {
+		return sha1Digest;
 	}
+
+	unsigned char fileDigest[20];
+
+	sha1::calc(data, int(size), fileDigest);
+	sha1::toHexString(fileDigest, sha1Digest);
 	return sha1Digest;
 }
 
+ArrayFile::ArrayFile(const Bit8u *useData, size_t useSize) : data(useData), size(useSize)
+{}
+
+ArrayFile::ArrayFile(const Bit8u *useData, size_t useSize, const SHA1Digest &useSHA1Digest) : AbstractFile(useSHA1Digest), data(useData), size(useSize)
+{}
+
+size_t ArrayFile::getSize() {
+	return size;
 }
+
+const Bit8u *ArrayFile::getData() {
+	return data;
+}
+
+} // namespace MT32Emu
diff --git a/src/mt32/File.h b/src/mt32/File.h
index b8dc55f4..91a0a7fe 100644
--- a/src/mt32/File.h
+++ b/src/mt32/File.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -20,25 +20,54 @@
 
 #include <cstddef>
 
+#include "globals.h"
+#include "Types.h"
+
 namespace MT32Emu {
 
-class File {
-private:
-	bool sha1DigestCalculated;
-	char sha1Digest[41];
-protected:
-	size_t fileSize;
-	unsigned char *data;
+class MT32EMU_EXPORT File {
 public:
-	File();
+	// Includes terminator char.
+	typedef char SHA1Digest[41];
+
 	virtual ~File() {}
 	virtual size_t getSize() = 0;
-	virtual const unsigned char *getData() = 0;
-	virtual const char *getSHA1();
+	virtual const Bit8u *getData() = 0;
+	virtual const SHA1Digest &getSHA1() = 0;
 
 	virtual void close() = 0;
 };
 
-}
+class MT32EMU_EXPORT AbstractFile : public File {
+public:
+	const SHA1Digest &getSHA1();
+
+protected:
+	AbstractFile();
+	AbstractFile(const SHA1Digest &sha1Digest);
+
+private:
+	bool sha1DigestCalculated;
+	SHA1Digest sha1Digest;
+
+	// Binary compatibility helper.
+	void *reserved;
+};
+
+class MT32EMU_EXPORT ArrayFile : public AbstractFile {
+public:
+	ArrayFile(const Bit8u *data, size_t size);
+	ArrayFile(const Bit8u *data, size_t size, const SHA1Digest &sha1Digest);
+
+	size_t getSize();
+	const Bit8u *getData();
+	void close() {}
+
+private:
+	const Bit8u *data;
+	size_t size;
+};
+
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_FILE_H
diff --git a/src/mt32/FileStream.cpp b/src/mt32/FileStream.cpp
index 8aa5ab63..081f41a0 100644
--- a/src/mt32/FileStream.cpp
+++ b/src/mt32/FileStream.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,78 +15,84 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "mt32emu.h"
+#ifdef MT32EMU_SHARED
+#include <locale>
+#endif
+
+#include "internals.h"
+
 #include "FileStream.h"
 
 namespace MT32Emu {
 
-using std::ifstream;
-using std::ios_base;
+static inline void configureSystemLocale() {
+#ifdef MT32EMU_SHARED
+	static bool configured = false;
 
-FileStream::FileStream() {
-	ifsp = new ifstream();
+	if (configured) return;
+	configured = true;
+	std::locale::global(std::locale(""));
+#endif
 }
 
+using std::ios_base;
+
+FileStream::FileStream() : ifsp(*new std::ifstream), data(NULL), size(0)
+{}
+
 FileStream::~FileStream() {
-	if (ifsp != NULL) {
-		delete ifsp; // destructor closes the file itself
-	}
-	if (data) {
-		delete[] data;
-	}
+	// destructor closes ifsp
+	delete &ifsp;
+	delete[] data;
 }
 
 size_t FileStream::getSize() {
-	if (fileSize != 0) {
-		return fileSize;
-	}
-	if (ifsp == NULL) {
-		return 0;
+	if (size != 0) {
+		return size;
 	}
-	if (!ifsp->is_open()) {
+	if (!ifsp.is_open()) {
 		return 0;
 	}
-	ifsp->seekg(0, ios_base::end);
-	fileSize = ifsp->tellg();
-	return fileSize;
+	ifsp.seekg(0, ios_base::end);
+	size = size_t(ifsp.tellg());
+	return size;
 }
 
-const unsigned char* FileStream::getData() {
+const Bit8u *FileStream::getData() {
 	if (data != NULL) {
 		return data;
 	}
-	if (ifsp == NULL) {
-		return NULL;
-	}
-	if (!ifsp->is_open()) {
+	if (!ifsp.is_open()) {
 		return NULL;
 	}
 	if (getSize() == 0) {
 		return NULL;
 	}
-	data = new unsigned char[fileSize];
-	if (data == NULL) {
+	Bit8u *fileData = new Bit8u[size];
+	if (fileData == NULL) {
 		return NULL;
 	}
-	ifsp->seekg(0);
-	ifsp->read((char *)data, fileSize);
-	if ((size_t)ifsp->tellg() != fileSize) {
-		delete[] data;
-		data = NULL;
+	ifsp.seekg(0);
+	ifsp.read(reinterpret_cast<char *>(fileData), std::streamsize(size));
+	if (size_t(ifsp.tellg()) != size) {
+		delete[] fileData;
 		return NULL;
 	}
+	data = fileData;
+	close();
 	return data;
 }
 
 bool FileStream::open(const char *filename) {
-	if (ifsp) {
-		ifsp->open(filename, ios_base::in | ios_base::binary);
-	}
-	return (ifsp->good());
+	configureSystemLocale();
+	ifsp.clear();
+	ifsp.open(filename, ios_base::in | ios_base::binary);
+	return !ifsp.fail();
 }
 
 void FileStream::close() {
-	ifsp->close();
+	ifsp.close();
+	ifsp.clear();
 }
 
-}
+} // namespace MT32Emu
diff --git a/src/mt32/FileStream.h b/src/mt32/FileStream.h
index 144928ab..ea5de695 100644
--- a/src/mt32/FileStream.h
+++ b/src/mt32/FileStream.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -19,26 +19,28 @@
 #define MT32EMU_FILE_STREAM_H
 
 #include <fstream>
-#include <iostream>
-#include <cstdio>
 
+#include "globals.h"
+#include "Types.h"
 #include "File.h"
 
 namespace MT32Emu {
 
-class FileStream: public File {
-private:
-	std::ifstream *ifsp;
+class FileStream : public AbstractFile {
 public:
-	FileStream();
-	virtual ~FileStream();
-	virtual size_t getSize();
-	virtual const unsigned char* getData();
+	MT32EMU_EXPORT FileStream();
+	MT32EMU_EXPORT ~FileStream();
+	MT32EMU_EXPORT size_t getSize();
+	MT32EMU_EXPORT const Bit8u *getData();
+	MT32EMU_EXPORT bool open(const char *filename);
+	MT32EMU_EXPORT void close();
 
-	bool open(const char *filename);
-	void close();
+private:
+	std::ifstream &ifsp;
+	const Bit8u *data;
+	size_t size;
 };
 
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_FILE_STREAM_H
diff --git a/src/mt32/LA32FloatWaveGenerator.cpp b/src/mt32/LA32FloatWaveGenerator.cpp
new file mode 100644
index 00000000..6ff4aa37
--- /dev/null
+++ b/src/mt32/LA32FloatWaveGenerator.cpp
@@ -0,0 +1,359 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cstddef>
+
+#include "internals.h"
+
+#include "LA32FloatWaveGenerator.h"
+#include "mmath.h"
+#include "Tables.h"
+
+namespace MT32Emu {
+
+static const float MIDDLE_CUTOFF_VALUE = 128.0f;
+static const float RESONANCE_DECAY_THRESHOLD_CUTOFF_VALUE = 144.0f;
+static const float MAX_CUTOFF_VALUE = 240.0f;
+
+float LA32FloatWaveGenerator::getPCMSample(unsigned int position) {
+	if (position >= pcmWaveLength) {
+		if (!pcmWaveLooped) {
+			return 0;
+		}
+		position = position % pcmWaveLength;
+	}
+	Bit16s pcmSample = pcmWaveAddress[position];
+	float sampleValue = EXP2F(((pcmSample & 32767) - 32787.0f) / 2048.0f);
+	return ((pcmSample & 32768) == 0) ? sampleValue : -sampleValue;
+}
+
+void LA32FloatWaveGenerator::initSynth(const bool useSawtoothWaveform, const Bit8u usePulseWidth, const Bit8u useResonance) {
+	sawtoothWaveform = useSawtoothWaveform;
+	pulseWidth = usePulseWidth;
+	resonance = useResonance;
+
+	wavePos = 0.0f;
+	lastFreq = 0.0f;
+
+	pcmWaveAddress = NULL;
+	active = true;
+}
+
+void LA32FloatWaveGenerator::initPCM(const Bit16s * const usePCMWaveAddress, const Bit32u usePCMWaveLength, const bool usePCMWaveLooped, const bool usePCMWaveInterpolated) {
+	pcmWaveAddress = usePCMWaveAddress;
+	pcmWaveLength = usePCMWaveLength;
+	pcmWaveLooped = usePCMWaveLooped;
+	pcmWaveInterpolated = usePCMWaveInterpolated;
+
+	pcmPosition = 0.0f;
+	active = true;
+}
+
+// ampVal - Logarithmic amp of the wave generator
+// pitch - Logarithmic frequency of the resulting wave
+// cutoffRampVal - Composed of the base cutoff in range [78..178] left-shifted by 18 bits and the TVF modifier
+float LA32FloatWaveGenerator::generateNextSample(const Bit32u ampVal, const Bit16u pitch, const Bit32u cutoffRampVal) {
+	if (!active) {
+		return 0.0f;
+	}
+
+	float sample = 0.0f;
+
+	// SEMI-CONFIRMED: From sample analysis:
+	// (1) Tested with a single partial playing PCM wave 77 with pitchCoarse 36 and no keyfollow, velocity follow, etc.
+	// This gives results within +/- 2 at the output (before any DAC bitshifting)
+	// when sustaining at levels 156 - 255 with no modifiers.
+	// (2) Tested with a special square wave partial (internal capture ID tva5) at TVA envelope levels 155-255.
+	// This gives deltas between -1 and 0 compared to the real output. Note that this special partial only produces
+	// positive amps, so negative still needs to be explored, as well as lower levels.
+	//
+	// Also still partially unconfirmed is the behaviour when ramping between levels, as well as the timing.
+
+	float amp = EXP2F(ampVal / -1024.0f / 4096.0f);
+	float freq = EXP2F(pitch / 4096.0f - 16.0f) * SAMPLE_RATE;
+
+	if (isPCMWave()) {
+		// Render PCM waveform
+		int len = pcmWaveLength;
+		int intPCMPosition = int(pcmPosition);
+		if (intPCMPosition >= len && !pcmWaveLooped) {
+			// We're now past the end of a non-looping PCM waveform so it's time to die.
+			deactivate();
+			return 0.0f;
+		}
+		float positionDelta = freq * 2048.0f / SAMPLE_RATE;
+
+		// Linear interpolation
+		float firstSample = getPCMSample(intPCMPosition);
+		// We observe that for partial structures with ring modulation the interpolation is not applied to the slave PCM partial.
+		// It's assumed that the multiplication circuitry intended to perform the interpolation on the slave PCM partial
+		// is borrowed by the ring modulation circuit (or the LA32 chip has a similar lack of resources assigned to each partial pair).
+		if (pcmWaveInterpolated) {
+			sample = firstSample + (getPCMSample(intPCMPosition + 1) - firstSample) * (pcmPosition - intPCMPosition);
+		} else {
+			sample = firstSample;
+		}
+
+		float newPCMPosition = pcmPosition + positionDelta;
+		if (pcmWaveLooped) {
+			newPCMPosition = fmod(newPCMPosition, float(pcmWaveLength));
+		}
+		pcmPosition = newPCMPosition;
+	} else {
+		// Render synthesised waveform
+		wavePos *= lastFreq / freq;
+		lastFreq = freq;
+
+		float resAmp = EXP2F(1.0f - (32 - resonance) / 4.0f);
+		{
+			//static const float resAmpFactor = EXP2F(-7);
+			//resAmp = EXP2I(resonance << 10) * resAmpFactor;
+		}
+
+		// The cutoffModifier may not be supposed to be directly added to the cutoff -
+		// it may for example need to be multiplied in some way.
+		// The 240 cutoffVal limit was determined via sample analysis (internal Munt capture IDs: glop3, glop4).
+		// More research is needed to be sure that this is correct, however.
+		float cutoffVal = cutoffRampVal / 262144.0f;
+		if (cutoffVal > MAX_CUTOFF_VALUE) {
+			cutoffVal = MAX_CUTOFF_VALUE;
+		}
+
+		// Wave length in samples
+		float waveLen = SAMPLE_RATE / freq;
+
+		// Init cosineLen
+		float cosineLen = 0.5f * waveLen;
+		if (cutoffVal > MIDDLE_CUTOFF_VALUE) {
+			cosineLen *= EXP2F((cutoffVal - MIDDLE_CUTOFF_VALUE) / -16.0f); // found from sample analysis
+		}
+
+		// Start playing in center of first cosine segment
+		// relWavePos is shifted by a half of cosineLen
+		float relWavePos = wavePos + 0.5f * cosineLen;
+		if (relWavePos > waveLen) {
+			relWavePos -= waveLen;
+		}
+
+		// Ratio of positive segment to wave length
+		float pulseLen = 0.5f;
+		if (pulseWidth > 128) {
+			pulseLen = EXP2F((64 - pulseWidth) / 64.0f);
+			//static const float pulseLenFactor = EXP2F(-192 / 64);
+			//pulseLen = EXP2I((256 - pulseWidthVal) << 6) * pulseLenFactor;
+		}
+		pulseLen *= waveLen;
+
+		float hLen = pulseLen - cosineLen;
+
+		// Ignore pulsewidths too high for given freq
+		if (hLen < 0.0f) {
+			hLen = 0.0f;
+		}
+
+		// Correct resAmp for cutoff in range 50..66
+		if ((cutoffVal >= MIDDLE_CUTOFF_VALUE) && (cutoffVal < RESONANCE_DECAY_THRESHOLD_CUTOFF_VALUE)) {
+			resAmp *= sin(FLOAT_PI * (cutoffVal - MIDDLE_CUTOFF_VALUE) / 32.0f);
+		}
+
+		// Produce filtered square wave with 2 cosine waves on slopes
+
+		// 1st cosine segment
+		if (relWavePos < cosineLen) {
+			sample = -cos(FLOAT_PI * relWavePos / cosineLen);
+		} else
+
+		// high linear segment
+		if (relWavePos < (cosineLen + hLen)) {
+			sample = 1.f;
+		} else
+
+		// 2nd cosine segment
+		if (relWavePos < (2 * cosineLen + hLen)) {
+			sample = cos(FLOAT_PI * (relWavePos - (cosineLen + hLen)) / cosineLen);
+		} else {
+
+		// low linear segment
+			sample = -1.f;
+		}
+
+		if (cutoffVal < MIDDLE_CUTOFF_VALUE) {
+
+			// Attenuate samples below cutoff 50
+			// Found by sample analysis
+			sample *= EXP2F(-0.125f * (MIDDLE_CUTOFF_VALUE - cutoffVal));
+		} else {
+
+			// Add resonance sine. Effective for cutoff > 50 only
+			float resSample = 1.0f;
+
+			// Resonance decay speed factor
+			float resAmpDecayFactor = Tables::getInstance().resAmpDecayFactor[resonance >> 2];
+
+			// Now relWavePos counts from the middle of first cosine
+			relWavePos = wavePos;
+
+			// negative segments
+			if (!(relWavePos < (cosineLen + hLen))) {
+				resSample = -resSample;
+				relWavePos -= cosineLen + hLen;
+
+				// From the digital captures, the decaying speed of the resonance sine is found a bit different for the positive and the negative segments
+				resAmpDecayFactor += 0.25f;
+			}
+
+			// Resonance sine WG
+			resSample *= sin(FLOAT_PI * relWavePos / cosineLen);
+
+			// Resonance sine amp
+			float resAmpFadeLog2 = -0.125f * resAmpDecayFactor * (relWavePos / cosineLen); // seems to be exact
+			float resAmpFade = EXP2F(resAmpFadeLog2);
+
+			// Now relWavePos set negative to the left from center of any cosine
+			relWavePos = wavePos;
+
+			// negative segment
+			if (!(wavePos < (waveLen - 0.5f * cosineLen))) {
+				relWavePos -= waveLen;
+			} else
+
+			// positive segment
+			if (!(wavePos < (hLen + 0.5f * cosineLen))) {
+				relWavePos -= cosineLen + hLen;
+			}
+
+			// To ensure the output wave has no breaks, two different windows are appied to the beginning and the ending of the resonance sine segment
+			if (relWavePos < 0.5f * cosineLen) {
+				float syncSine = sin(FLOAT_PI * relWavePos / cosineLen);
+				if (relWavePos < 0.0f) {
+					// The window is synchronous square sine here
+					resAmpFade *= syncSine * syncSine;
+				} else {
+					// The window is synchronous sine here
+					resAmpFade *= syncSine;
+				}
+			}
+
+			sample += resSample * resAmp * resAmpFade;
+		}
+
+		// sawtooth waves
+		if (sawtoothWaveform) {
+			sample *= cos(FLOAT_2PI * wavePos / waveLen);
+		}
+
+		wavePos++;
+
+		// wavePos isn't supposed to be > waveLen
+		if (wavePos > waveLen) {
+			wavePos -= waveLen;
+		}
+	}
+
+	// Multiply sample with current TVA value
+	sample *= amp;
+	return sample;
+}
+
+void LA32FloatWaveGenerator::deactivate() {
+	active = false;
+}
+
+bool LA32FloatWaveGenerator::isActive() const {
+	return active;
+}
+
+bool LA32FloatWaveGenerator::isPCMWave() const {
+	return pcmWaveAddress != NULL;
+}
+
+void LA32FloatPartialPair::init(const bool useRingModulated, const bool useMixed) {
+	ringModulated = useRingModulated;
+	mixed = useMixed;
+	masterOutputSample = 0.0f;
+	slaveOutputSample = 0.0f;
+}
+
+void LA32FloatPartialPair::initSynth(const PairType useMaster, const bool sawtoothWaveform, const Bit8u pulseWidth, const Bit8u resonance) {
+	if (useMaster == MASTER) {
+		master.initSynth(sawtoothWaveform, pulseWidth, resonance);
+	} else {
+		slave.initSynth(sawtoothWaveform, pulseWidth, resonance);
+	}
+}
+
+void LA32FloatPartialPair::initPCM(const PairType useMaster, const Bit16s *pcmWaveAddress, const Bit32u pcmWaveLength, const bool pcmWaveLooped) {
+	if (useMaster == MASTER) {
+		master.initPCM(pcmWaveAddress, pcmWaveLength, pcmWaveLooped, true);
+	} else {
+		slave.initPCM(pcmWaveAddress, pcmWaveLength, pcmWaveLooped, !ringModulated);
+	}
+}
+
+void LA32FloatPartialPair::generateNextSample(const PairType useMaster, const Bit32u amp, const Bit16u pitch, const Bit32u cutoff) {
+	if (useMaster == MASTER) {
+		masterOutputSample = master.generateNextSample(amp, pitch, cutoff);
+	} else {
+		slaveOutputSample = slave.generateNextSample(amp, pitch, cutoff);
+	}
+}
+
+static inline float produceDistortedSample(float sample) {
+	if (sample < -1.0f) {
+		return sample + 2.0f;
+	} else if (1.0f < sample) {
+		return sample - 2.0f;
+	}
+	return sample;
+}
+
+float LA32FloatPartialPair::nextOutSample() {
+	// Note, LA32FloatWaveGenerator produces each sample normalised in terms of a single playing partial,
+	// so the unity sample corresponds to the internal LA32 logarithmic fixed-point unity sample.
+	// However, each logarithmic sample is then unlogged to a 14-bit signed integer value, i.e. the max absolute value is 8192.
+	// Thus, considering that samples are further mapped to a 16-bit signed integer,
+	// we apply a conversion factor 0.25 to produce properly normalised float samples.
+	if (!ringModulated) {
+		return 0.25f * (masterOutputSample + slaveOutputSample);
+	}
+	/*
+	 * SEMI-CONFIRMED: Ring modulation model derived from sample analysis of specially constructed patches which exploit distortion.
+	 * LA32 ring modulator found to produce distorted output in case if the absolute value of maximal amplitude of one of the input partials exceeds 8191.
+	 * This is easy to reproduce using synth partials with resonance values close to the maximum. It looks like an integer overflow happens in this case.
+	 * As the distortion is strictly bound to the amplitude of the complete mixed square + resonance wave in the linear space,
+	 * it is reasonable to assume the ring modulation is performed also in the linear space by sample multiplication.
+	 * Most probably the overflow is caused by limited precision of the multiplication circuit as the very similar distortion occurs with panning.
+	 */
+	float ringModulatedSample = produceDistortedSample(masterOutputSample) * produceDistortedSample(slaveOutputSample);
+	return 0.25f * (mixed ? masterOutputSample + ringModulatedSample : ringModulatedSample);
+}
+
+void LA32FloatPartialPair::deactivate(const PairType useMaster) {
+	if (useMaster == MASTER) {
+		master.deactivate();
+		masterOutputSample = 0.0f;
+	} else {
+		slave.deactivate();
+		slaveOutputSample = 0.0f;
+	}
+}
+
+bool LA32FloatPartialPair::isActive(const PairType useMaster) const {
+	return useMaster == MASTER ? master.isActive() : slave.isActive();
+}
+
+} // namespace MT32Emu
diff --git a/src/mt32/LA32FloatWaveGenerator.h b/src/mt32/LA32FloatWaveGenerator.h
new file mode 100644
index 00000000..7e92d0a6
--- /dev/null
+++ b/src/mt32/LA32FloatWaveGenerator.h
@@ -0,0 +1,132 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_LA32_FLOAT_WAVE_GENERATOR_H
+#define MT32EMU_LA32_FLOAT_WAVE_GENERATOR_H
+
+#include "globals.h"
+#include "internals.h"
+#include "Types.h"
+#include "LA32WaveGenerator.h"
+
+namespace MT32Emu {
+
+/**
+ * LA32WaveGenerator is aimed to represent the exact model of LA32 wave generator.
+ * The output square wave is created by adding high / low linear segments in-between
+ * the rising and falling cosine segments. Basically, it's very similar to the phase distortion synthesis.
+ * Behaviour of a true resonance filter is emulated by adding decaying sine wave.
+ * The beginning and the ending of the resonant sine is multiplied by a cosine window.
+ * To synthesise sawtooth waves, the resulting square wave is multiplied by synchronous cosine wave.
+ */
+class LA32FloatWaveGenerator {
+	//***************************************************************************
+	//  The local copy of partial parameters below
+	//***************************************************************************
+
+	bool active;
+
+	// True means the resulting square wave is to be multiplied by the synchronous cosine
+	bool sawtoothWaveform;
+
+	// Values in range [1..31]
+	// Value 1 correspong to the minimum resonance
+	Bit8u resonance;
+
+	// Processed value in range [0..255]
+	// Values in range [0..128] have no effect and the resulting wave remains symmetrical
+	// Value 255 corresponds to the maximum possible asymmetric of the resulting wave
+	Bit8u pulseWidth;
+
+	// Logarithmic PCM sample start address
+	const Bit16s *pcmWaveAddress;
+
+	// Logarithmic PCM sample length
+	Bit32u pcmWaveLength;
+
+	// true for looped logarithmic PCM samples
+	bool pcmWaveLooped;
+
+	// false for slave PCM partials in the structures with the ring modulation
+	bool pcmWaveInterpolated;
+
+	//***************************************************************************
+	// Internal variables below
+	//***************************************************************************
+
+	float wavePos;
+	float lastFreq;
+	float pcmPosition;
+
+	float getPCMSample(unsigned int position);
+
+public:
+	// Initialise the WG engine for generation of synth partial samples and set up the invariant parameters
+	void initSynth(const bool sawtoothWaveform, const Bit8u pulseWidth, const Bit8u resonance);
+
+	// Initialise the WG engine for generation of PCM partial samples and set up the invariant parameters
+	void initPCM(const Bit16s * const pcmWaveAddress, const Bit32u pcmWaveLength, const bool pcmWaveLooped, const bool pcmWaveInterpolated);
+
+	// Update parameters with respect to TVP, TVA and TVF, and generate next sample
+	float generateNextSample(const Bit32u amp, const Bit16u pitch, const Bit32u cutoff);
+
+	// Deactivate the WG engine
+	void deactivate();
+
+	// Return active state of the WG engine
+	bool isActive() const;
+
+	// Return true if the WG engine generates PCM wave samples
+	bool isPCMWave() const;
+}; // class LA32FloatWaveGenerator
+
+class LA32FloatPartialPair : public LA32PartialPair {
+	LA32FloatWaveGenerator master;
+	LA32FloatWaveGenerator slave;
+	bool ringModulated;
+	bool mixed;
+	float masterOutputSample;
+	float slaveOutputSample;
+
+public:
+	// ringModulated should be set to false for the structures with mixing or stereo output
+	// ringModulated should be set to true for the structures with ring modulation
+	// mixed is used for the structures with ring modulation and indicates whether the master partial output is mixed to the ring modulator output
+	void init(const bool ringModulated, const bool mixed);
+
+	// Initialise the WG engine for generation of synth partial samples and set up the invariant parameters
+	void initSynth(const PairType master, const bool sawtoothWaveform, const Bit8u pulseWidth, const Bit8u resonance);
+
+	// Initialise the WG engine for generation of PCM partial samples and set up the invariant parameters
+	void initPCM(const PairType master, const Bit16s * const pcmWaveAddress, const Bit32u pcmWaveLength, const bool pcmWaveLooped);
+
+	// Update parameters with respect to TVP, TVA and TVF, and generate next sample
+	void generateNextSample(const PairType master, const Bit32u amp, const Bit16u pitch, const Bit32u cutoff);
+
+	// Perform mixing / ring modulation and return the result
+	float nextOutSample();
+
+	// Deactivate the WG engine
+	void deactivate(const PairType master);
+
+	// Return active state of the WG engine
+	bool isActive(const PairType master) const;
+}; // class LA32FloatPartialPair
+
+} // namespace MT32Emu
+
+#endif // #ifndef MT32EMU_LA32_FLOAT_WAVE_GENERATOR_H
diff --git a/src/mt32/LA32Ramp.cpp b/src/mt32/LA32Ramp.cpp
index 2dd36b85..9dcf143f 100644
--- a/src/mt32/LA32Ramp.cpp
+++ b/src/mt32/LA32Ramp.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -47,17 +47,17 @@ We haven't fully explored:
  - Values when ramping between levels (though this is probably correct).
  - Transition timing (may not be 100% accurate, especially for very fast ramps).
 */
-#include <cmath>
 
-#include "mt32emu.h"
+#include "internals.h"
+
 #include "LA32Ramp.h"
-#include "mmath.h"
+#include "Tables.h"
 
 namespace MT32Emu {
 
 // SEMI-CONFIRMED from sample analysis.
-const int TARGET_MULT = 0x40000;
-const unsigned int MAX_CURRENT = 0xFF * TARGET_MULT;
+const unsigned int TARGET_SHIFTS = 18;
+const unsigned int MAX_CURRENT = 0xFF << TARGET_SHIFTS;
 
 // We simulate the delay in handling "target was reached" interrupts by waiting
 // this many samples before setting interruptRaised.
@@ -96,7 +96,7 @@ void LA32Ramp::startRamp(Bit8u target, Bit8u increment) {
 		largeIncrement++;
 	}
 
-	largeTarget = target * TARGET_MULT;
+	largeTarget = target << TARGET_SHIFTS;
 	interruptCountdown = 0;
 	interruptRaised = false;
 }
@@ -152,26 +152,13 @@ void LA32Ramp::reset() {
 	interruptRaised = false;
 }
 
-
-void LA32Ramp::saveState( std::ostream &stream )
-{
-	stream.write(reinterpret_cast<const char*>(&current), sizeof(current) );
-	stream.write(reinterpret_cast<const char*>(&largeTarget), sizeof(largeTarget) );
-	stream.write(reinterpret_cast<const char*>(&largeIncrement), sizeof(largeIncrement) );
-	stream.write(reinterpret_cast<const char*>(&descending), sizeof(descending) );
-	stream.write(reinterpret_cast<const char*>(&interruptCountdown), sizeof(interruptCountdown) );
-	stream.write(reinterpret_cast<const char*>(&interruptRaised), sizeof(interruptRaised) );
-}
-
-
-void LA32Ramp::loadState( std::istream &stream )
-{
-	stream.read(reinterpret_cast<char*>(&current), sizeof(current) );
-	stream.read(reinterpret_cast<char*>(&largeTarget), sizeof(largeTarget) );
-	stream.read(reinterpret_cast<char*>(&largeIncrement), sizeof(largeIncrement) );
-	stream.read(reinterpret_cast<char*>(&descending), sizeof(descending) );
-	stream.read(reinterpret_cast<char*>(&interruptCountdown), sizeof(interruptCountdown) );
-	stream.read(reinterpret_cast<char*>(&interruptRaised), sizeof(interruptRaised) );
+// This is actually beyond the LA32 ramp interface.
+// Instead of polling the current value, MCU receives an interrupt when a ramp completes.
+// However, this is a simple way to work around the specific behaviour of TVA
+// when in sustain phase which one normally wants to avoid.
+// See TVA::recalcSustain() for details.
+bool LA32Ramp::isBelowCurrent(Bit8u target) const {
+	return Bit32u(target << TARGET_SHIFTS) < current;
 }
 
-}
+} // namespace MT32Emu
diff --git a/src/mt32/LA32Ramp.h b/src/mt32/LA32Ramp.h
index 2e733648..959a1ad3 100644
--- a/src/mt32/LA32Ramp.h
+++ b/src/mt32/LA32Ramp.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,6 +18,9 @@
 #ifndef MT32EMU_LA32RAMP_H
 #define MT32EMU_LA32RAMP_H
 
+#include "globals.h"
+#include "Types.h"
+
 namespace MT32Emu {
 
 class LA32Ramp {
@@ -36,11 +39,9 @@ public:
 	Bit32u nextValue();
 	bool checkInterrupt();
 	void reset();
-
-	void saveState( std::ostream &stream );
-	void loadState( std::istream &stream );
+	bool isBelowCurrent(Bit8u target) const;
 };
 
-}
+} // namespace MT32Emu
 
-#endif /* TVA_H_ */
+#endif // #ifndef MT32EMU_LA32RAMP_H
diff --git a/src/mt32/LA32WaveGenerator.cpp b/src/mt32/LA32WaveGenerator.cpp
index f5bcea81..f6f69288 100644
--- a/src/mt32/LA32WaveGenerator.cpp
+++ b/src/mt32/LA32WaveGenerator.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,12 +15,12 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <cmath>
-#include "mt32emu.h"
-#include "mmath.h"
-#include "LA32WaveGenerator.h"
+#include <cstddef>
+
+#include "internals.h"
 
-#if MT32EMU_ACCURATE_WG == 0
+#include "LA32WaveGenerator.h"
+#include "Tables.h"
 
 namespace MT32Emu {
 
@@ -48,7 +48,7 @@ Bit16s LA32Utilites::unlog(const LogSample &logSample) {
 
 void LA32Utilites::addLogSamples(LogSample &logSample1, const LogSample &logSample2) {
 	Bit32u logSampleValue = logSample1.logValue + logSample2.logValue;
-	logSample1.logValue = logSampleValue < 65536 ? (Bit16u)logSampleValue : 65535;
+	logSample1.logValue = logSampleValue < 65536 ? Bit16u(logSampleValue) : 65535;
 	logSample1.sign = logSample1.sign == logSample2.sign ? LogSample::POSITIVE : LogSample::NEGATIVE;
 }
 
@@ -128,8 +128,7 @@ void LA32WaveGenerator::advancePosition() {
 	Bit32u lowLinearLength = (resonanceWaveLengthFactor << 8) - 4 * SINE_SEGMENT_RELATIVE_LENGTH - highLinearLength;
 	computePositions(highLinearLength, lowLinearLength, resonanceWaveLengthFactor);
 
-	// resonancePhase computation hack
-	*(int*)&resonancePhase = ((resonanceSinePosition >> 18) + (phase > POSITIVE_FALLING_SINE_SEGMENT ? 2 : 0)) & 3;
+	resonancePhase = ResonancePhase(((resonanceSinePosition >> 18) + (phase > POSITIVE_FALLING_SINE_SEGMENT ? 2 : 0)) & 3);
 }
 
 void LA32WaveGenerator::generateNextSquareWaveLogSample() {
@@ -155,7 +154,7 @@ void LA32WaveGenerator::generateNextSquareWaveLogSample() {
 		logSampleValue += (MIDDLE_CUTOFF_VALUE - cutoffVal) >> 9;
 	}
 
-	squareLogSample.logValue = logSampleValue < 65536 ? (Bit16u)logSampleValue : 65535;
+	squareLogSample.logValue = logSampleValue < 65536 ? Bit16u(logSampleValue) : 65535;
 	squareLogSample.sign = phase < NEGATIVE_FALLING_SINE_SEGMENT ? LogSample::POSITIVE : LogSample::NEGATIVE;
 }
 
@@ -195,7 +194,7 @@ void LA32WaveGenerator::generateNextResonanceWaveLogSample() {
 	// After all the amp decrements are added, it should be safe now to adjust the amp of the resonance wave to what we see on captures
 	logSampleValue -= 1 << 12;
 
-	resonanceLogSample.logValue = logSampleValue < 65536 ? (Bit16u)logSampleValue : 65535;
+	resonanceLogSample.logValue = logSampleValue < 65536 ? Bit16u(logSampleValue) : 65535;
 	resonanceLogSample.sign = resonancePhase < NEGATIVE_FALLING_RESONANCE_SINE_SEGMENT ? LogSample::POSITIVE : LogSample::NEGATIVE;
 }
 
@@ -213,7 +212,7 @@ void LA32WaveGenerator::generateNextSawtoothCosineLogSample(LogSample &logSample
 void LA32WaveGenerator::pcmSampleToLogSample(LogSample &logSample, const Bit16s pcmSample) const {
 	Bit32u logSampleValue = (32787 - (pcmSample & 32767)) << 1;
 	logSampleValue += amp >> 10;
-	logSample.logValue = logSampleValue < 65536 ? (Bit16u)logSampleValue : 65535;
+	logSample.logValue = logSampleValue < 65536 ? Bit16u(logSampleValue) : 65535;
 	logSample.sign = pcmSample < 0 ? LogSample::NEGATIVE : LogSample::POSITIVE;
 }
 
@@ -338,12 +337,12 @@ Bit32u LA32WaveGenerator::getPCMInterpolationFactor() const {
 	return pcmInterpolationFactor;
 }
 
-void LA32PartialPair::init(const bool useRingModulated, const bool useMixed) {
+void LA32IntPartialPair::init(const bool useRingModulated, const bool useMixed) {
 	ringModulated = useRingModulated;
 	mixed = useMixed;
 }
 
-void LA32PartialPair::initSynth(const PairType useMaster, const bool sawtoothWaveform, const Bit8u pulseWidth, const Bit8u resonance) {
+void LA32IntPartialPair::initSynth(const PairType useMaster, const bool sawtoothWaveform, const Bit8u pulseWidth, const Bit8u resonance) {
 	if (useMaster == MASTER) {
 		master.initSynth(sawtoothWaveform, pulseWidth, resonance);
 	} else {
@@ -351,7 +350,7 @@ void LA32PartialPair::initSynth(const PairType useMaster, const bool sawtoothWav
 	}
 }
 
-void LA32PartialPair::initPCM(const PairType useMaster, const Bit16s *pcmWaveAddress, const Bit32u pcmWaveLength, const bool pcmWaveLooped) {
+void LA32IntPartialPair::initPCM(const PairType useMaster, const Bit16s *pcmWaveAddress, const Bit32u pcmWaveLength, const bool pcmWaveLooped) {
 	if (useMaster == MASTER) {
 		master.initPCM(pcmWaveAddress, pcmWaveLength, pcmWaveLooped, true);
 	} else {
@@ -359,7 +358,7 @@ void LA32PartialPair::initPCM(const PairType useMaster, const Bit16s *pcmWaveAdd
 	}
 }
 
-void LA32PartialPair::generateNextSample(const PairType useMaster, const Bit32u amp, const Bit16u pitch, const Bit32u cutoff) {
+void LA32IntPartialPair::generateNextSample(const PairType useMaster, const Bit32u amp, const Bit16u pitch, const Bit32u cutoff) {
 	if (useMaster == MASTER) {
 		master.generateNextSample(amp, pitch, cutoff);
 	} else {
@@ -367,41 +366,49 @@ void LA32PartialPair::generateNextSample(const PairType useMaster, const Bit32u
 	}
 }
 
-Bit16s LA32PartialPair::unlogAndMixWGOutput(const LA32WaveGenerator &wg, const LogSample * const ringModulatingLogSample) {
-	if (!wg.isActive() || ((ringModulatingLogSample != NULL) && (ringModulatingLogSample->logValue == SILENCE.logValue))) {
+Bit16s LA32IntPartialPair::unlogAndMixWGOutput(const LA32WaveGenerator &wg) {
+	if (!wg.isActive()) {
 		return 0;
 	}
-	LogSample firstLogSample = wg.getOutputLogSample(true);
-	LogSample secondLogSample = wg.getOutputLogSample(false);
-	if (ringModulatingLogSample != NULL) {
-		LA32Utilites::addLogSamples(firstLogSample, *ringModulatingLogSample);
-		LA32Utilites::addLogSamples(secondLogSample, *ringModulatingLogSample);
-	}
-	Bit16s firstSample = LA32Utilites::unlog(firstLogSample);
-	Bit16s secondSample = LA32Utilites::unlog(secondLogSample);
+	Bit16s firstSample = LA32Utilites::unlog(wg.getOutputLogSample(true));
+	Bit16s secondSample = LA32Utilites::unlog(wg.getOutputLogSample(false));
 	if (wg.isPCMWave()) {
-		return Bit16s(firstSample + ((Bit32s(secondSample - firstSample) * wg.getPCMInterpolationFactor()) >> 7));
+		return Bit16s(firstSample + (((Bit32s(secondSample) - Bit32s(firstSample)) * wg.getPCMInterpolationFactor()) >> 7));
 	}
 	return firstSample + secondSample;
 }
 
-Bit16s LA32PartialPair::nextOutSample() {
-	if (ringModulated) {
-		LogSample slaveFirstLogSample = slave.getOutputLogSample(true);
-		LogSample slaveSecondLogSample = slave.getOutputLogSample(false);
-		Bit16s sample = unlogAndMixWGOutput(master, &slaveFirstLogSample);
-		if (!slave.isPCMWave()) {
-			sample += unlogAndMixWGOutput(master, &slaveSecondLogSample);
-		}
-		if (mixed) {
-			sample += unlogAndMixWGOutput(master, NULL);
-		}
-		return sample;
+static inline Bit16s produceDistortedSample(Bit16s sample) {
+	return ((sample & 0x2000) == 0) ? Bit16s(sample & 0x1fff) : Bit16s(sample | ~0x1fff);
+}
+
+Bit16s LA32IntPartialPair::nextOutSample() {
+	if (!ringModulated) {
+		return unlogAndMixWGOutput(master) + unlogAndMixWGOutput(slave);
 	}
-	return unlogAndMixWGOutput(master, NULL) + unlogAndMixWGOutput(slave, NULL);
+
+	Bit16s masterSample = unlogAndMixWGOutput(master); // Store master partial sample for further mixing
+
+	/* SEMI-CONFIRMED from sample analysis:
+	 * We observe that for partial structures with ring modulation the interpolation is not applied to the slave PCM partial.
+	 * It's assumed that the multiplication circuitry intended to perform the interpolation on the slave PCM partial
+	 * is borrowed by the ring modulation circuit (or the LA32 chip has a similar lack of resources assigned to each partial pair).
+	 */
+	Bit16s slaveSample = slave.isPCMWave() ? LA32Utilites::unlog(slave.getOutputLogSample(true)) : unlogAndMixWGOutput(slave);
+
+	/* SEMI-CONFIRMED: Ring modulation model derived from sample analysis of specially constructed patches which exploit distortion.
+	 * LA32 ring modulator found to produce distorted output in case if the absolute value of maximal amplitude of one of the input partials exceeds 8191.
+	 * This is easy to reproduce using synth partials with resonance values close to the maximum. It looks like an integer overflow happens in this case.
+	 * As the distortion is strictly bound to the amplitude of the complete mixed square + resonance wave in the linear space,
+	 * it is reasonable to assume the ring modulation is performed also in the linear space by sample multiplication.
+	 * Most probably the overflow is caused by limited precision of the multiplication circuit as the very similar distortion occurs with panning.
+	 */
+	Bit16s ringModulatedSample = Bit16s((Bit32s(produceDistortedSample(masterSample)) * Bit32s(produceDistortedSample(slaveSample))) >> 13);
+
+	return mixed ? masterSample + ringModulatedSample : ringModulatedSample;
 }
 
-void LA32PartialPair::deactivate(const PairType useMaster) {
+void LA32IntPartialPair::deactivate(const PairType useMaster) {
 	if (useMaster == MASTER) {
 		master.deactivate();
 	} else {
@@ -409,10 +416,8 @@ void LA32PartialPair::deactivate(const PairType useMaster) {
 	}
 }
 
-bool LA32PartialPair::isActive(const PairType useMaster) const {
+bool LA32IntPartialPair::isActive(const PairType useMaster) const {
 	return useMaster == MASTER ? master.isActive() : slave.isActive();
 }
 
-}
-
-#endif // #if MT32EMU_ACCURATE_WG == 0
+} // namespace MT32Emu
diff --git a/src/mt32/LA32WaveGenerator.h b/src/mt32/LA32WaveGenerator.h
index 37a4aead..c206daa6 100644
--- a/src/mt32/LA32WaveGenerator.h
+++ b/src/mt32/LA32WaveGenerator.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,11 +15,13 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#if MT32EMU_ACCURATE_WG == 0
-
 #ifndef MT32EMU_LA32_WAVE_GENERATOR_H
 #define MT32EMU_LA32_WAVE_GENERATOR_H
 
+#include "globals.h"
+#include "internals.h"
+#include "Types.h"
+
 namespace MT32Emu {
 
 /**
@@ -53,7 +55,7 @@ public:
 /**
  * LA32WaveGenerator is aimed to represent the exact model of LA32 wave generator.
  * The output square wave is created by adding high / low linear segments in-between
- * the rising and falling cosine segments. Basically, its very similar to the phase distortion synthesis.
+ * the rising and falling cosine segments. Basically, it's very similar to the phase distortion synthesis.
  * Behaviour of a true resonance filter is emulated by adding decaying sine wave.
  * The beginning and the ending of the resonant sine is multiplied by a cosine window.
  * To synthesise sawtooth waves, the resulting square wave is multiplied by synchronous cosine wave.
@@ -141,7 +143,7 @@ class LA32WaveGenerator {
 	} phase;
 
 	// Current phase of the resonance wave
-	enum {
+	enum ResonancePhase {
 		POSITIVE_RISING_RESONANCE_SINE_SEGMENT,
 		POSITIVE_FALLING_RESONANCE_SINE_SEGMENT,
 		NEGATIVE_FALLING_RESONANCE_SINE_SEGMENT,
@@ -198,23 +200,42 @@ public:
 
 	// Return current PCM interpolation factor
 	Bit32u getPCMInterpolationFactor() const;
-};
+}; // class LA32WaveGenerator
 
 // LA32PartialPair contains a structure of two partials being mixed / ring modulated
 class LA32PartialPair {
+public:
+	enum PairType {
+		MASTER,
+		SLAVE
+	};
+
+	virtual ~LA32PartialPair() {}
+
+	// ringModulated should be set to false for the structures with mixing or stereo output
+	// ringModulated should be set to true for the structures with ring modulation
+	// mixed is used for the structures with ring modulation and indicates whether the master partial output is mixed to the ring modulator output
+	virtual void init(const bool ringModulated, const bool mixed) = 0;
+
+	// Initialise the WG engine for generation of synth partial samples and set up the invariant parameters
+	virtual void initSynth(const PairType master, const bool sawtoothWaveform, const Bit8u pulseWidth, const Bit8u resonance) = 0;
+
+	// Initialise the WG engine for generation of PCM partial samples and set up the invariant parameters
+	virtual void initPCM(const PairType master, const Bit16s * const pcmWaveAddress, const Bit32u pcmWaveLength, const bool pcmWaveLooped) = 0;
+
+	// Deactivate the WG engine
+	virtual void deactivate(const PairType master) = 0;
+}; // class LA32PartialPair
+
+class LA32IntPartialPair : public LA32PartialPair {
 	LA32WaveGenerator master;
 	LA32WaveGenerator slave;
 	bool ringModulated;
 	bool mixed;
 
-	static Bit16s unlogAndMixWGOutput(const LA32WaveGenerator &wg, const LogSample * const ringModulatingLogSample);
+	static Bit16s unlogAndMixWGOutput(const LA32WaveGenerator &wg);
 
 public:
-	enum PairType {
-		MASTER,
-		SLAVE
-	};
-
 	// ringModulated should be set to false for the structures with mixing or stereo output
 	// ringModulated should be set to true for the structures with ring modulation
 	// mixed is used for the structures with ring modulation and indicates whether the master partial output is mixed to the ring modulator output
@@ -229,7 +250,8 @@ public:
 	// Update parameters with respect to TVP, TVA and TVF, and generate next sample
 	void generateNextSample(const PairType master, const Bit32u amp, const Bit16u pitch, const Bit32u cutoff);
 
-	// Perform mixing / ring modulation and return the result
+	// Perform mixing / ring modulation of WG output and return the result
+	// Although, LA32 applies panning itself, we assume it is applied in the mixer, not within a pair
 	Bit16s nextOutSample();
 
 	// Deactivate the WG engine
@@ -237,10 +259,8 @@ public:
 
 	// Return active state of the WG engine
 	bool isActive(const PairType master) const;
-};
+}; // class LA32IntPartialPair
 
 } // namespace MT32Emu
 
 #endif // #ifndef MT32EMU_LA32_WAVE_GENERATOR_H
-
-#endif // #if MT32EMU_ACCURATE_WG == 0
diff --git a/src/mt32/MemoryRegion.h b/src/mt32/MemoryRegion.h
new file mode 100644
index 00000000..807f1478
--- /dev/null
+++ b/src/mt32/MemoryRegion.h
@@ -0,0 +1,132 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_MEMORY_REGION_H
+#define MT32EMU_MEMORY_REGION_H
+
+#include <cstddef>
+
+#include "globals.h"
+#include "Types.h"
+#include "Structures.h"
+
+namespace MT32Emu {
+
+enum MemoryRegionType {
+	MR_PatchTemp, MR_RhythmTemp, MR_TimbreTemp, MR_Patches, MR_Timbres, MR_System, MR_Display, MR_Reset
+};
+
+class Synth;
+
+class MemoryRegion {
+private:
+	Synth *synth;
+	Bit8u *realMemory;
+	Bit8u *maxTable;
+public:
+	MemoryRegionType type;
+	Bit32u startAddr, entrySize, entries;
+
+	MemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable, MemoryRegionType useType, Bit32u useStartAddr, Bit32u useEntrySize, Bit32u useEntries) {
+		synth = useSynth;
+		realMemory = useRealMemory;
+		maxTable = useMaxTable;
+		type = useType;
+		startAddr = useStartAddr;
+		entrySize = useEntrySize;
+		entries = useEntries;
+	}
+	int lastTouched(Bit32u addr, Bit32u len) const {
+		return (offset(addr) + len - 1) / entrySize;
+	}
+	int firstTouchedOffset(Bit32u addr) const {
+		return offset(addr) % entrySize;
+	}
+	int firstTouched(Bit32u addr) const {
+		return offset(addr) / entrySize;
+	}
+	Bit32u regionEnd() const {
+		return startAddr + entrySize * entries;
+	}
+	bool contains(Bit32u addr) const {
+		return addr >= startAddr && addr < regionEnd();
+	}
+	int offset(Bit32u addr) const {
+		return addr - startAddr;
+	}
+	Bit32u getClampedLen(Bit32u addr, Bit32u len) const {
+		if (addr + len > regionEnd())
+			return regionEnd() - addr;
+		return len;
+	}
+	Bit32u next(Bit32u addr, Bit32u len) const {
+		if (addr + len > regionEnd()) {
+			return regionEnd() - addr;
+		}
+		return 0;
+	}
+	Bit8u getMaxValue(int off) const {
+		if (maxTable == NULL)
+			return 0xFF;
+		return maxTable[off % entrySize];
+	}
+	Bit8u *getRealMemory() const {
+		return realMemory;
+	}
+	bool isReadable() const {
+		return getRealMemory() != NULL;
+	}
+	void read(unsigned int entry, unsigned int off, Bit8u *dst, unsigned int len) const;
+	void write(unsigned int entry, unsigned int off, const Bit8u *src, unsigned int len, bool init = false) const;
+}; // class MemoryRegion
+
+class PatchTempMemoryRegion : public MemoryRegion {
+public:
+	PatchTempMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_PatchTemp, MT32EMU_MEMADDR(0x030000), sizeof(MemParams::PatchTemp), 9) {}
+};
+class RhythmTempMemoryRegion : public MemoryRegion {
+public:
+	RhythmTempMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_RhythmTemp, MT32EMU_MEMADDR(0x030110), sizeof(MemParams::RhythmTemp), 85) {}
+};
+class TimbreTempMemoryRegion : public MemoryRegion {
+public:
+	TimbreTempMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_TimbreTemp, MT32EMU_MEMADDR(0x040000), sizeof(TimbreParam), 8) {}
+};
+class PatchesMemoryRegion : public MemoryRegion {
+public:
+	PatchesMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_Patches, MT32EMU_MEMADDR(0x050000), sizeof(PatchParam), 128) {}
+};
+class TimbresMemoryRegion : public MemoryRegion {
+public:
+	TimbresMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_Timbres, MT32EMU_MEMADDR(0x080000), sizeof(MemParams::PaddedTimbre), 64 + 64 + 64 + 64) {}
+};
+class SystemMemoryRegion : public MemoryRegion {
+public:
+	SystemMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_System, MT32EMU_MEMADDR(0x100000), sizeof(MemParams::System), 1) {}
+};
+class DisplayMemoryRegion : public MemoryRegion {
+public:
+	DisplayMemoryRegion(Synth *useSynth) : MemoryRegion(useSynth, NULL, NULL, MR_Display, MT32EMU_MEMADDR(0x200000), SYSEX_BUFFER_SIZE - 1, 1) {}
+};
+class ResetMemoryRegion : public MemoryRegion {
+public:
+	ResetMemoryRegion(Synth *useSynth) : MemoryRegion(useSynth, NULL, NULL, MR_Reset, MT32EMU_MEMADDR(0x7F0000), 0x3FFF, 1) {}
+};
+
+} // namespace MT32Emu
+
+#endif // #ifndef MT32EMU_MEMORY_REGION_H
diff --git a/src/mt32/MidiEventQueue.h b/src/mt32/MidiEventQueue.h
new file mode 100644
index 00000000..c5174d6c
--- /dev/null
+++ b/src/mt32/MidiEventQueue.h
@@ -0,0 +1,71 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_MIDI_EVENT_QUEUE_H
+#define MT32EMU_MIDI_EVENT_QUEUE_H
+
+#include "globals.h"
+#include "Types.h"
+
+namespace MT32Emu {
+
+/**
+ * Used to safely store timestamped MIDI events in a local queue.
+ */
+struct MidiEvent {
+	Bit32u shortMessageData;
+	const Bit8u *sysexData;
+	Bit32u sysexLength;
+	Bit32u timestamp;
+
+	~MidiEvent();
+	void setShortMessage(Bit32u shortMessageData, Bit32u timestamp);
+	void setSysex(const Bit8u *sysexData, Bit32u sysexLength, Bit32u timestamp);
+};
+
+/**
+ * Simple queue implementation using a ring buffer to store incoming MIDI event before the synth actually processes it.
+ * It is intended to:
+ * - get rid of prerenderer while retaining graceful partial abortion
+ * - add fair emulation of the MIDI interface delays
+ * - extend the synth interface with the default implementation of a typical rendering loop.
+ * THREAD SAFETY:
+ * It is safe to use either in a single thread environment or when there are only two threads - one performs only reading
+ * and one performs only writing. More complicated usage requires external synchronisation.
+ */
+class MidiEventQueue {
+private:
+	MidiEvent * const ringBuffer;
+	const Bit32u ringBufferMask;
+	volatile Bit32u startPosition;
+	volatile Bit32u endPosition;
+
+public:
+	MidiEventQueue(Bit32u ringBufferSize = DEFAULT_MIDI_EVENT_QUEUE_SIZE); // Must be a power of 2
+	~MidiEventQueue();
+	void reset();
+	bool pushShortMessage(Bit32u shortMessageData, Bit32u timestamp);
+	bool pushSysex(const Bit8u *sysexData, Bit32u sysexLength, Bit32u timestamp);
+	const MidiEvent *peekMidiEvent();
+	void dropMidiEvent();
+	bool isFull() const;
+	bool inline isEmpty() const;
+};
+
+} // namespace MT32Emu
+
+#endif // #ifndef MT32EMU_MIDI_EVENT_QUEUE_H
diff --git a/src/mt32/MidiStreamParser.cpp b/src/mt32/MidiStreamParser.cpp
new file mode 100644
index 00000000..a426a20c
--- /dev/null
+++ b/src/mt32/MidiStreamParser.cpp
@@ -0,0 +1,289 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cstdio>
+#include <cstring>
+
+#include "internals.h"
+
+#include "MidiStreamParser.h"
+#include "Synth.h"
+
+using namespace MT32Emu;
+
+DefaultMidiStreamParser::DefaultMidiStreamParser(Synth &useSynth, Bit32u initialStreamBufferCapacity) :
+	MidiStreamParser(initialStreamBufferCapacity), synth(useSynth), timestampSet(false) {}
+
+void DefaultMidiStreamParser::setTimestamp(const Bit32u useTimestamp) {
+	timestampSet = true;
+	timestamp = useTimestamp;
+}
+
+void DefaultMidiStreamParser::resetTimestamp() {
+	timestampSet = false;
+}
+
+void DefaultMidiStreamParser::handleShortMessage(const Bit32u message) {
+	do {
+		if (timestampSet) {
+			if (synth.playMsg(message, timestamp)) return;
+		}
+		else {
+			if (synth.playMsg(message)) return;
+		}
+	} while (synth.reportHandler->onMIDIQueueOverflow());
+}
+
+void DefaultMidiStreamParser::handleSysex(const Bit8u *stream, const Bit32u length) {
+	do {
+		if (timestampSet) {
+			if (synth.playSysex(stream, length, timestamp)) return;
+		}
+		else {
+			if (synth.playSysex(stream, length)) return;
+		}
+	} while (synth.reportHandler->onMIDIQueueOverflow());
+}
+
+void DefaultMidiStreamParser::handleSystemRealtimeMessage(const Bit8u realtime) {
+	synth.reportHandler->onMIDISystemRealtime(realtime);
+}
+
+void DefaultMidiStreamParser::printDebug(const char *debugMessage) {
+	synth.printDebug("%s", debugMessage);
+}
+
+MidiStreamParser::MidiStreamParser(Bit32u initialStreamBufferCapacity) :
+	MidiStreamParserImpl(*this, *this, initialStreamBufferCapacity) {}
+
+MidiStreamParserImpl::MidiStreamParserImpl(MidiReceiver &useReceiver, MidiReporter &useReporter, Bit32u initialStreamBufferCapacity) :
+	midiReceiver(useReceiver), midiReporter(useReporter)
+{
+	if (initialStreamBufferCapacity < SYSEX_BUFFER_SIZE) initialStreamBufferCapacity = SYSEX_BUFFER_SIZE;
+	if (MAX_STREAM_BUFFER_SIZE < initialStreamBufferCapacity) initialStreamBufferCapacity = MAX_STREAM_BUFFER_SIZE;
+	streamBufferCapacity = initialStreamBufferCapacity;
+	streamBuffer = new Bit8u[streamBufferCapacity];
+	streamBufferSize = 0;
+	runningStatus = 0;
+
+	reserved = NULL;
+}
+
+MidiStreamParserImpl::~MidiStreamParserImpl() {
+	delete[] streamBuffer;
+}
+
+void MidiStreamParserImpl::parseStream(const Bit8u *stream, Bit32u length) {
+	while (length > 0) {
+		Bit32u parsedMessageLength = 0;
+		if (0xF8 <= *stream) {
+			// Process System Realtime immediately and go on
+			midiReceiver.handleSystemRealtimeMessage(*stream);
+			parsedMessageLength = 1;
+			// No effect on the running status
+		} else if (streamBufferSize > 0) {
+			// Check if there is something in streamBuffer waiting for being processed
+			if (*streamBuffer == 0xF0) {
+				parsedMessageLength = parseSysexFragment(stream, length);
+			} else {
+				parsedMessageLength = parseShortMessageDataBytes(stream, length);
+			}
+		} else {
+			if (*stream == 0xF0) {
+				runningStatus = 0; // SysEx clears the running status
+				parsedMessageLength = parseSysex(stream, length);
+			} else {
+				parsedMessageLength = parseShortMessageStatus(stream);
+			}
+		}
+
+		// Parsed successfully
+		stream += parsedMessageLength;
+		length -= parsedMessageLength;
+	}
+}
+
+void MidiStreamParserImpl::processShortMessage(const Bit32u message) {
+	// Adds running status to the MIDI message if it doesn't contain one
+	Bit8u status = Bit8u(message & 0xFF);
+	if (0xF8 <= status) {
+		midiReceiver.handleSystemRealtimeMessage(status);
+	} else if (processStatusByte(status)) {
+		midiReceiver.handleShortMessage((message << 8) | status);
+	} else if (0x80 <= status) { // If no running status available yet, skip this message
+		midiReceiver.handleShortMessage(message);
+	}
+}
+
+// We deal with SysEx messages below 512 bytes long in most cases. Nevertheless, it seems reasonable to support a possibility
+// to load bulk dumps using a single message. However, this is known to fail with a real device due to limited input buffer size.
+bool MidiStreamParserImpl::checkStreamBufferCapacity(const bool preserveContent) {
+	if (streamBufferSize < streamBufferCapacity) return true;
+	if (streamBufferCapacity < MAX_STREAM_BUFFER_SIZE) {
+		Bit8u *oldStreamBuffer = streamBuffer;
+		streamBufferCapacity = MAX_STREAM_BUFFER_SIZE;
+		streamBuffer = new Bit8u[streamBufferCapacity];
+		if (preserveContent) memcpy(streamBuffer, oldStreamBuffer, streamBufferSize);
+		delete[] oldStreamBuffer;
+		return true;
+	}
+	return false;
+}
+
+// Checks input byte whether it is a status byte. If not, replaces it with running status when available.
+// Returns true if the input byte was changed to running status.
+bool MidiStreamParserImpl::processStatusByte(Bit8u &status) {
+	if (status < 0x80) {
+		// First byte isn't status, try running status
+		if (runningStatus < 0x80) {
+			// No running status available yet
+			midiReporter.printDebug("processStatusByte: No valid running status yet, MIDI message ignored");
+			return false;
+		}
+		status = runningStatus;
+		return true;
+	} else if (status < 0xF0) {
+		// Store current status as running for a Voice message
+		runningStatus = status;
+	} else if (status < 0xF8) {
+		// System Common clears running status
+		runningStatus = 0;
+	} // System Realtime doesn't affect running status
+	return false;
+}
+
+// Returns # of bytes parsed
+Bit32u MidiStreamParserImpl::parseShortMessageStatus(const Bit8u stream[]) {
+	Bit8u status = *stream;
+	Bit32u parsedLength = processStatusByte(status) ? 0 : 1;
+	if (0x80 <= status) { // If no running status available yet, skip one byte
+		*streamBuffer = status;
+		++streamBufferSize;
+	}
+	return parsedLength;
+}
+
+// Returns # of bytes parsed
+Bit32u MidiStreamParserImpl::parseShortMessageDataBytes(const Bit8u stream[], Bit32u length) {
+	const Bit32u shortMessageLength = Synth::getShortMessageLength(*streamBuffer);
+	Bit32u parsedLength = 0;
+
+	// Append incoming bytes to streamBuffer
+	while ((streamBufferSize < shortMessageLength) && (length-- > 0)) {
+		Bit8u dataByte = *(stream++);
+		if (dataByte < 0x80) {
+			// Add data byte to streamBuffer
+			streamBuffer[streamBufferSize++] = dataByte;
+		} else if (dataByte < 0xF8) {
+			// Discard invalid bytes and start over
+			char s[128];
+			sprintf(s, "parseShortMessageDataBytes: Invalid short message: status %02x, expected length %i, actual %i -> ignored", *streamBuffer, shortMessageLength, streamBufferSize);
+			midiReporter.printDebug(s);
+			streamBufferSize = 0; // Clear streamBuffer
+			return parsedLength;
+		} else {
+			// Bypass System Realtime message
+			midiReceiver.handleSystemRealtimeMessage(dataByte);
+		}
+		++parsedLength;
+	}
+	if (streamBufferSize < shortMessageLength) return parsedLength; // Still lacks data bytes
+
+	// Assemble short message
+	Bit32u shortMessage = streamBuffer[0];
+	for (Bit32u i = 1; i < shortMessageLength; ++i) {
+		shortMessage |= streamBuffer[i] << (i << 3);
+	}
+	midiReceiver.handleShortMessage(shortMessage);
+	streamBufferSize = 0; // Clear streamBuffer
+	return parsedLength;
+}
+
+// Returns # of bytes parsed
+Bit32u MidiStreamParserImpl::parseSysex(const Bit8u stream[], const Bit32u length) {
+	// Find SysEx length
+	Bit32u sysexLength = 1;
+	while (sysexLength < length) {
+		Bit8u nextByte = stream[sysexLength++];
+		if (0x80 <= nextByte) {
+			if (nextByte == 0xF7) {
+				// End of SysEx
+				midiReceiver.handleSysex(stream, sysexLength);
+				return sysexLength;
+			}
+			if (0xF8 <= nextByte) {
+				// The System Realtime message must be processed right after return
+				// but the SysEx is actually fragmented and to be reconstructed in streamBuffer
+				--sysexLength;
+				break;
+			}
+			// Illegal status byte in SysEx message, aborting
+			midiReporter.printDebug("parseSysex: SysEx message lacks end-of-sysex (0xf7), ignored");
+			// Continue parsing from that point
+			return sysexLength - 1;
+		}
+	}
+
+	// Store incomplete SysEx message for further processing
+	streamBufferSize = sysexLength;
+	if (checkStreamBufferCapacity(false)) {
+		memcpy(streamBuffer, stream, sysexLength);
+	} else {
+		// Not enough buffer capacity, don't care about the real buffer content, just mark the first byte
+		*streamBuffer = *stream;
+		streamBufferSize = streamBufferCapacity;
+	}
+	return sysexLength;
+}
+
+// Returns # of bytes parsed
+Bit32u MidiStreamParserImpl::parseSysexFragment(const Bit8u stream[], const Bit32u length) {
+	Bit32u parsedLength = 0;
+	while (parsedLength < length) {
+		Bit8u nextByte = stream[parsedLength++];
+		if (nextByte < 0x80) {
+			// Add SysEx data byte to streamBuffer
+			if (checkStreamBufferCapacity(true)) streamBuffer[streamBufferSize++] = nextByte;
+			continue;
+		}
+		if (0xF8 <= nextByte) {
+			// Bypass System Realtime message
+			midiReceiver.handleSystemRealtimeMessage(nextByte);
+			continue;
+		}
+		if (nextByte != 0xF7) {
+			// Illegal status byte in SysEx message, aborting
+			midiReporter.printDebug("parseSysexFragment: SysEx message lacks end-of-sysex (0xf7), ignored");
+			// Clear streamBuffer and continue parsing from that point
+			streamBufferSize = 0;
+			--parsedLength;
+			break;
+		}
+		// End of SysEx
+		if (checkStreamBufferCapacity(true)) {
+			streamBuffer[streamBufferSize++] = nextByte;
+			midiReceiver.handleSysex(streamBuffer, streamBufferSize);
+			streamBufferSize = 0; // Clear streamBuffer
+			break;
+		}
+		// Encountered streamBuffer overrun
+		midiReporter.printDebug("parseSysexFragment: streamBuffer overrun while receiving SysEx message, ignored. Max allowed size of fragmented SysEx is 32768 bytes.");
+		streamBufferSize = 0; // Clear streamBuffer
+		break;
+	}
+	return parsedLength;
+}
diff --git a/src/mt32/MidiStreamParser.h b/src/mt32/MidiStreamParser.h
new file mode 100644
index 00000000..881ec032
--- /dev/null
+++ b/src/mt32/MidiStreamParser.h
@@ -0,0 +1,124 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_MIDI_STREAM_PARSER_H
+#define MT32EMU_MIDI_STREAM_PARSER_H
+
+#include "globals.h"
+#include "Types.h"
+
+namespace MT32Emu {
+
+class Synth;
+
+// Interface for a user-supplied class to receive parsed well-formed MIDI messages.
+class MT32EMU_EXPORT MidiReceiver {
+public:
+	// Invoked when a complete short MIDI message is parsed in the input MIDI stream.
+	virtual void handleShortMessage(const Bit32u message) = 0;
+
+	// Invoked when a complete well-formed System Exclusive MIDI message is parsed in the input MIDI stream.
+	virtual void handleSysex(const Bit8u stream[], const Bit32u length) = 0;
+
+	// Invoked when a System Realtime MIDI message is parsed in the input MIDI stream.
+	virtual void handleSystemRealtimeMessage(const Bit8u realtime) = 0;
+
+protected:
+	~MidiReceiver() {}
+};
+
+// Interface for a user-supplied class to receive notifications of input MIDI stream parse errors.
+class MT32EMU_EXPORT MidiReporter {
+public:
+	// Invoked when an error occurs during processing the input MIDI stream.
+	virtual void printDebug(const char *debugMessage) = 0;
+
+protected:
+	~MidiReporter() {}
+};
+
+// Provides a context for parsing a stream of MIDI events coming from a single source.
+// There can be multiple MIDI sources feeding MIDI events to a single Synth object.
+// NOTE: Calls from multiple threads which feed a single Synth object with data must be explicitly synchronised,
+// although, no synchronisation is required with the rendering thread.
+class MT32EMU_EXPORT MidiStreamParserImpl {
+public:
+	// The first two arguments provide for implementations of essential interfaces needed.
+	// The third argument specifies streamBuffer initial capacity. The buffer capacity should be large enough to fit the longest SysEx expected.
+	// If a longer SysEx occurs, streamBuffer is reallocated to the maximum size of MAX_STREAM_BUFFER_SIZE (32768 bytes).
+	// Default capacity is SYSEX_BUFFER_SIZE (1000 bytes) which is enough to fit SysEx messages in common use.
+	MidiStreamParserImpl(MidiReceiver &, MidiReporter &, Bit32u initialStreamBufferCapacity = SYSEX_BUFFER_SIZE);
+	virtual ~MidiStreamParserImpl();
+
+	// Parses a block of raw MIDI bytes. All the parsed MIDI messages are sent in sequence to the user-supplied methods for further processing.
+	// SysEx messages are allowed to be fragmented across several calls to this method. Running status is also handled for short messages.
+	// NOTE: the total length of a SysEx message being fragmented shall not exceed MAX_STREAM_BUFFER_SIZE (32768 bytes).
+	void parseStream(const Bit8u *stream, Bit32u length);
+
+	// Convenience method which accepts a Bit32u-encoded short MIDI message and sends it to the user-supplied method for further processing.
+	// The short MIDI message may contain no status byte, the running status is used in this case.
+	void processShortMessage(const Bit32u message);
+
+private:
+	Bit8u runningStatus;
+	Bit8u *streamBuffer;
+	Bit32u streamBufferCapacity;
+	Bit32u streamBufferSize;
+	MidiReceiver &midiReceiver;
+	MidiReporter &midiReporter;
+
+	// Binary compatibility helper.
+	void *reserved;
+
+	bool checkStreamBufferCapacity(const bool preserveContent);
+	bool processStatusByte(Bit8u &status);
+	Bit32u parseShortMessageStatus(const Bit8u stream[]);
+	Bit32u parseShortMessageDataBytes(const Bit8u stream[], Bit32u length);
+	Bit32u parseSysex(const Bit8u stream[], const Bit32u length);
+	Bit32u parseSysexFragment(const Bit8u stream[], const Bit32u length);
+}; // class MidiStreamParserImpl
+
+// An abstract class that provides a context for parsing a stream of MIDI events coming from a single source.
+class MT32EMU_EXPORT MidiStreamParser : public MidiStreamParserImpl, protected MidiReceiver, protected MidiReporter {
+public:
+	// The argument specifies streamBuffer initial capacity. The buffer capacity should be large enough to fit the longest SysEx expected.
+	// If a longer SysEx occurs, streamBuffer is reallocated to the maximum size of MAX_STREAM_BUFFER_SIZE (32768 bytes).
+	// Default capacity is SYSEX_BUFFER_SIZE (1000 bytes) which is enough to fit SysEx messages in common use.
+	explicit MidiStreamParser(Bit32u initialStreamBufferCapacity = SYSEX_BUFFER_SIZE);
+};
+
+class MT32EMU_EXPORT DefaultMidiStreamParser : public MidiStreamParser {
+public:
+	explicit DefaultMidiStreamParser(Synth &synth, Bit32u initialStreamBufferCapacity = SYSEX_BUFFER_SIZE);
+	void setTimestamp(const Bit32u useTimestamp);
+	void resetTimestamp();
+
+protected:
+	void handleShortMessage(const Bit32u message);
+	void handleSysex(const Bit8u *stream, const Bit32u length);
+	void handleSystemRealtimeMessage(const Bit8u realtime);
+	void printDebug(const char *debugMessage);
+
+private:
+	Synth &synth;
+	bool timestampSet;
+	Bit32u timestamp;
+};
+
+} // namespace MT32Emu
+
+#endif // MT32EMU_MIDI_STREAM_PARSER_H
diff --git a/src/mt32/Part.cpp b/src/mt32/Part.cpp
index f3a5600b..9c85ce55 100644
--- a/src/mt32/Part.cpp
+++ b/src/mt32/Part.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,8 +18,13 @@
 #include <cstdio>
 #include <cstring>
 
-#include "mt32emu.h"
+#include "internals.h"
+
+#include "Part.h"
+#include "Partial.h"
 #include "PartialManager.h"
+#include "Poly.h"
+#include "Synth.h"
 
 namespace MT32Emu {
 
@@ -33,14 +38,6 @@ static const Bit8u PartialMixStruct[13] = {
 	1, 3, 3, 2, 2, 2, 2
 };
 
-static const float floatKeyfollow[17] = {
-	-1.0f, -1.0f / 2.0f, -1.0f / 4.0f, 0.0f,
-	1.0f / 8.0f, 1.0f / 4.0f, 3.0f / 8.0f, 1.0f / 2.0f, 5.0f / 8.0f, 3.0f / 4.0f, 7.0f / 8.0f, 1.0f,
-	5.0f / 4.0f, 3.0f / 2.0f, 2.0f,
-	1.0009765625f, 1.0048828125f
-};
-
-
 RhythmPart::RhythmPart(Synth *useSynth, unsigned int usePartNum): Part(useSynth, usePartNum) {
 	strcpy(name, "Rhythm");
 	rhythmTemp = &synth->mt32ram.rhythmTemp[0];
@@ -67,18 +64,12 @@ Part::Part(Synth *useSynth, unsigned int usePartNum) {
 	pitchBend = 0;
 	activePartialCount = 0;
 	memset(patchCache, 0, sizeof(patchCache));
-	for (int i = 0; i < MT32EMU_MAX_POLY; i++) {
-		freePolys.prepend(new Poly(synth,this));
-	}
 }
 
 Part::~Part() {
 	while (!activePolys.isEmpty()) {
 		delete activePolys.takeFirst();
 	}
-	while (!freePolys.isEmpty()) {
-		delete freePolys.takeFirst();
-	}
 }
 
 void Part::setDataEntryMSB(unsigned char midiDataEntryMSB) {
@@ -125,7 +116,7 @@ Bit32s Part::getPitchBend() const {
 
 void Part::setBend(unsigned int midiBend) {
 	// CONFIRMED:
-	pitchBend = (((signed)midiBend - 8192) * pitchBenderRange) >> 14; // PORTABILITY NOTE: Assumes arithmetic shift
+	pitchBend = ((signed(midiBend) - 8192) * pitchBenderRange) >> 14; // PORTABILITY NOTE: Assumes arithmetic shift
 }
 
 Bit8u Part::getModulation() const {
@@ -133,7 +124,7 @@ Bit8u Part::getModulation() const {
 }
 
 void Part::setModulation(unsigned int midiModulation) {
-	modulation = (Bit8u)midiModulation;
+	modulation = Bit8u(midiModulation);
 }
 
 void Part::resetAllControllers() {
@@ -175,6 +166,7 @@ void Part::refresh() {
 		patchCache[t].reverb = patchTemp->patch.reverbSwitch > 0;
 	}
 	memcpy(currentInstr, timbreTemp->common.name, 10);
+	synth->newTimbreSet(partNum, patchTemp->patch.timbreGroup, patchTemp->patch.timbreNum, currentInstr);
 	updatePitchBenderRange();
 }
 
@@ -207,7 +199,6 @@ void RhythmPart::setTimbre(TimbreParam * /*timbre*/) {
 
 void Part::setTimbre(TimbreParam *timbre) {
 	*timbreTemp = *timbre;
-	synth->newTimbreSet(partNum, timbre->common.name);
 }
 
 unsigned int RhythmPart::getAbsTimbreNum() const {
@@ -268,26 +259,26 @@ void Part::cacheTimbre(PatchCache cache[4], const TimbreParam *timbre) {
 
 		switch (t) {
 		case 0:
-			cache[t].PCMPartial = (PartialStruct[(int)timbre->common.partialStructure12] & 0x2) ? true : false;
-			cache[t].structureMix = PartialMixStruct[(int)timbre->common.partialStructure12];
+			cache[t].PCMPartial = (PartialStruct[int(timbre->common.partialStructure12)] & 0x2) ? true : false;
+			cache[t].structureMix = PartialMixStruct[int(timbre->common.partialStructure12)];
 			cache[t].structurePosition = 0;
 			cache[t].structurePair = 1;
 			break;
 		case 1:
-			cache[t].PCMPartial = (PartialStruct[(int)timbre->common.partialStructure12] & 0x1) ? true : false;
-			cache[t].structureMix = PartialMixStruct[(int)timbre->common.partialStructure12];
+			cache[t].PCMPartial = (PartialStruct[int(timbre->common.partialStructure12)] & 0x1) ? true : false;
+			cache[t].structureMix = PartialMixStruct[int(timbre->common.partialStructure12)];
 			cache[t].structurePosition = 1;
 			cache[t].structurePair = 0;
 			break;
 		case 2:
-			cache[t].PCMPartial = (PartialStruct[(int)timbre->common.partialStructure34] & 0x2) ? true : false;
-			cache[t].structureMix = PartialMixStruct[(int)timbre->common.partialStructure34];
+			cache[t].PCMPartial = (PartialStruct[int(timbre->common.partialStructure34)] & 0x2) ? true : false;
+			cache[t].structureMix = PartialMixStruct[int(timbre->common.partialStructure34)];
 			cache[t].structurePosition = 0;
 			cache[t].structurePair = 3;
 			break;
 		case 3:
-			cache[t].PCMPartial = (PartialStruct[(int)timbre->common.partialStructure34] & 0x1) ? true : false;
-			cache[t].structureMix = PartialMixStruct[(int)timbre->common.partialStructure34];
+			cache[t].PCMPartial = (PartialStruct[int(timbre->common.partialStructure34)] & 0x1) ? true : false;
+			cache[t].structureMix = PartialMixStruct[int(timbre->common.partialStructure34)];
 			cache[t].structurePosition = 1;
 			cache[t].structurePair = 2;
 			break;
@@ -321,7 +312,7 @@ const char *Part::getName() const {
 
 void Part::setVolume(unsigned int midiVolume) {
 	// CONFIRMED: This calculation matches the table used in the control ROM
-	patchTemp->outputLevel = (Bit8u)(midiVolume * 100 / 127);
+	patchTemp->outputLevel = Bit8u(midiVolume * 100 / 127);
 	//synth->printDebug("%s (%s): Set volume to %d", name, currentInstr, midiVolume);
 }
 
@@ -335,7 +326,7 @@ Bit8u Part::getExpression() const {
 
 void Part::setExpression(unsigned int midiExpression) {
 	// CONFIRMED: This calculation matches the table used in the control ROM
-	expression = (Bit8u)(midiExpression * 100 / 127);
+	expression = Bit8u(midiExpression * 100 / 127);
 }
 
 void RhythmPart::setPan(unsigned int midiPan) {
@@ -349,10 +340,13 @@ void RhythmPart::setPan(unsigned int midiPan) {
 void Part::setPan(unsigned int midiPan) {
 	// NOTE: Panning is inverted compared to GM.
 
-	// CM-32L: Divide by 8.5
-	patchTemp->panpot = (Bit8u)((midiPan << 3) / 68);
-	// FIXME: MT-32: Divide by 9
-	//patchTemp->panpot = (Bit8u)(midiPan / 9);
+	if (synth->controlROMFeatures->quirkPanMult) {
+		// MT-32: Divide by 9
+		patchTemp->panpot = Bit8u(midiPan / 9);
+	} else {
+		// CM-32L: Divide by 8.5
+		patchTemp->panpot = Bit8u((midiPan << 3) / 68);
+	}
 
 	//synth->printDebug("%s (%s): Set pan to %d", name, currentInstr, panpot);
 }
@@ -361,6 +355,10 @@ void Part::setPan(unsigned int midiPan) {
  * Applies key shift to a MIDI key and converts it into an internal key value in the range 12-108.
  */
 unsigned int Part::midiKeyToKey(unsigned int midiKey) {
+	if (synth->controlROMFeatures->quirkKeyShift) {
+		// NOTE: On MT-32 GEN0, key isn't adjusted, and keyShift is applied further in TVP, unlike newer units:
+		return midiKey;
+	}
 	int key = midiKey + patchTemp->patch.keyShift;
 	if (key < 36) {
 		// After keyShift is applied, key < 36, so move up by octaves
@@ -385,7 +383,8 @@ void RhythmPart::noteOn(unsigned int midiKey, unsigned int velocity) {
 	unsigned int key = midiKey;
 	unsigned int drumNum = key - 24;
 	int drumTimbreNum = rhythmTemp[drumNum].timbre;
-	if (drumTimbreNum >= 127) { // 94 on MT-32
+	const int drumTimbreCount = 64 + synth->controlROMMap->timbreRCount; // 94 on MT-32, 128 on LAPC-I/CM32-L
+	if (drumTimbreNum == 127 || drumTimbreNum >= drumTimbreCount) { // timbre #127 is OFF, no sense to play it
 		synth->printDebug("%s: Attempted to play unmapped key %d (velocity %d)", name, midiKey, velocity);
 		return;
 	}
@@ -431,23 +430,10 @@ void Part::noteOn(unsigned int midiKey, unsigned int velocity) {
 	playPoly(patchCache, NULL, midiKey, key, velocity);
 }
 
-void Part::abortPoly(Poly *poly) {
-	if (poly->startAbort()) {
-		while (poly->isActive()) {
-			if (!synth->prerender()) {
-				synth->printDebug("%s (%s): Ran out of prerender space to abort poly gracefully", name, currentInstr);
-				poly->terminate();
-				break;
-			}
-		}
-	}
-}
-
 bool Part::abortFirstPoly(unsigned int key) {
 	for (Poly *poly = activePolys.getFirst(); poly != NULL; poly = poly->getNext()) {
 		if (poly->getKey() == key) {
-			abortPoly(poly);
-			return true;
+			return poly->startAbort();
 		}
 	}
 	return false;
@@ -456,8 +442,7 @@ bool Part::abortFirstPoly(unsigned int key) {
 bool Part::abortFirstPoly(PolyState polyState) {
 	for (Poly *poly = activePolys.getFirst(); poly != NULL; poly = poly->getNext()) {
 		if (poly->getState() == polyState) {
-			abortPoly(poly);
-			return true;
+			return poly->startAbort();
 		}
 	}
 	return false;
@@ -474,8 +459,7 @@ bool Part::abortFirstPoly() {
 	if (activePolys.isEmpty()) {
 		return false;
 	}
-	abortPoly(activePolys.getFirst());
-	return true;
+	return activePolys.getFirst()->startAbort();
 }
 
 void Part::playPoly(const PatchCache cache[4], const MemParams::RhythmTemp *rhythmTemp, unsigned int midiKey, unsigned int key, unsigned int velocity) {
@@ -489,6 +473,7 @@ void Part::playPoly(const PatchCache cache[4], const MemParams::RhythmTemp *rhyt
 	if ((patchTemp->patch.assignMode & 2) == 0) {
 		// Single-assign mode
 		abortFirstPoly(key);
+		if (synth->isAbortingPoly()) return;
 	}
 
 	if (!synth->partialManager->freePartials(needPartials, partNum)) {
@@ -498,12 +483,13 @@ void Part::playPoly(const PatchCache cache[4], const MemParams::RhythmTemp *rhyt
 #endif
 		return;
 	}
+	if (synth->isAbortingPoly()) return;
 
-	if (freePolys.isEmpty()) {
+	Poly *poly = synth->partialManager->assignPolyToPart(this);
+	if (poly == NULL) {
 		synth->printDebug("%s (%s): No free poly to play key %d (velocity %d)", name, currentInstr, midiKey, velocity);
 		return;
 	}
-	Poly *poly = freePolys.takeFirst();
 	if (patchTemp->patch.assignMode & 1) {
 		// Priority to data first received
 		activePolys.prepend(poly);
@@ -533,8 +519,7 @@ void Part::playPoly(const PatchCache cache[4], const MemParams::RhythmTemp *rhyt
 #if MT32EMU_MONITOR_PARTIALS > 1
 	synth->printPartialUsage();
 #endif
-	synth->partStateChanged(partNum, true);
-	synth->polyStateChanged(partNum);
+	synth->reportHandler->onPolyStateChanged(Bit8u(partNum));
 }
 
 void Part::allNotesOff() {
@@ -597,6 +582,10 @@ unsigned int Part::getActivePartialCount() const {
 	return activePartialCount;
 }
 
+const Poly *Part::getFirstActivePoly() const {
+	return activePolys.getFirst();
+}
+
 unsigned int Part::getActiveNonReleasingPartialCount() const {
 	unsigned int activeNonReleasingPartialCount = 0;
 	for (Poly *poly = activePolys.getFirst(); poly != NULL; poly = poly->getNext()) {
@@ -607,24 +596,23 @@ unsigned int Part::getActiveNonReleasingPartialCount() const {
 	return activeNonReleasingPartialCount;
 }
 
+Synth *Part::getSynth() const {
+	return synth;
+}
+
 void Part::partialDeactivated(Poly *poly) {
 	activePartialCount--;
 	if (!poly->isActive()) {
 		activePolys.remove(poly);
-		freePolys.prepend(poly);
-		synth->polyStateChanged(partNum);
-	}
-	if (activePartialCount == 0) {
-		synth->partStateChanged(partNum, false);
+		synth->partialManager->polyFreed(poly);
+		synth->reportHandler->onPolyStateChanged(Bit8u(partNum));
 	}
 }
 
-//#define POLY_LIST_DEBUG
-
 PolyList::PolyList() : firstPoly(NULL), lastPoly(NULL) {}
 
 bool PolyList::isEmpty() const {
-#ifdef POLY_LIST_DEBUG
+#ifdef MT32EMU_POLY_LIST_DEBUG
 	if ((firstPoly == NULL || lastPoly == NULL) && firstPoly != lastPoly) {
 		printf("PolyList: desynchronised firstPoly & lastPoly pointers\n");
 	}
@@ -641,7 +629,7 @@ Poly *PolyList::getLast() const {
 }
 
 void PolyList::prepend(Poly *poly) {
-#ifdef POLY_LIST_DEBUG
+#ifdef MT32EMU_POLY_LIST_DEBUG
 	if (poly->getNext() != NULL) {
 		printf("PolyList: Non-NULL next field in a Poly being prepended is ignored\n");
 	}
@@ -654,14 +642,14 @@ void PolyList::prepend(Poly *poly) {
 }
 
 void PolyList::append(Poly *poly) {
-#ifdef POLY_LIST_DEBUG
+#ifdef MT32EMU_POLY_LIST_DEBUG
 	if (poly->getNext() != NULL) {
 		printf("PolyList: Non-NULL next field in a Poly being appended is ignored\n");
 	}
 #endif
 	poly->setNext(NULL);
 	if (lastPoly != NULL) {
-#ifdef POLY_LIST_DEBUG
+#ifdef MT32EMU_POLY_LIST_DEBUG
 		if (lastPoly->getNext() != NULL) {
 			printf("PolyList: Non-NULL next field in the lastPoly\n");
 		}
@@ -678,7 +666,7 @@ Poly *PolyList::takeFirst() {
 	Poly *oldFirst = firstPoly;
 	firstPoly = oldFirst->getNext();
 	if (firstPoly == NULL) {
-#ifdef POLY_LIST_DEBUG
+#ifdef MT32EMU_POLY_LIST_DEBUG
 		if (lastPoly != oldFirst) {
 			printf("PolyList: firstPoly != lastPoly in a list with a single Poly\n");
 		}
@@ -697,7 +685,7 @@ void PolyList::remove(Poly * const polyToRemove) {
 	for (Poly *poly = firstPoly; poly != NULL; poly = poly->getNext()) {
 		if (poly->getNext() == polyToRemove) {
 			if (polyToRemove == lastPoly) {
-#ifdef POLY_LIST_DEBUG
+#ifdef MT32EMU_POLY_LIST_DEBUG
 				if (lastPoly->getNext() != NULL) {
 					printf("PolyList: Non-NULL next field in the lastPoly\n");
 				}
@@ -711,36 +699,4 @@ void PolyList::remove(Poly * const polyToRemove) {
 	}
 }
 
-// TODO: WE NEED TO REFRESH THIS (FROM)
-const Poly *Part::getActivePoly(int num)
-{
-	if( (size_t)num >= sizeof(activePolys) ) return NULL;
-
-	for( Poly* polyIt = activePolys.getFirst(); polyIt != activePolys.getLast(); polyIt++ ) {
-		if( num == 0 ) return polyIt;
-
-		num--;
-	}
-
-	return NULL;
-}
-
-
-int Part::getActivePolyCount()
-{
-	return sizeof(activePolys);
-}
-// TODO: WE NEED TO REFRESH THIS (TO)
-
-const PatchCache *Part::getPatchCache(int num)
-{
-	return &patchCache[num];
-}
-
-
-const PatchCache *RhythmPart::getDrumCache(int num1, int num2)
-{
-	return &drumCache[num1][num2];
-}
-
-}
+} // namespace MT32Emu
diff --git a/src/mt32/Part.h b/src/mt32/Part.h
index d0212e90..a4de1060 100644
--- a/src/mt32/Part.h
+++ b/src/mt32/Part.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,17 +18,22 @@
 #ifndef MT32EMU_PART_H
 #define MT32EMU_PART_H
 
+#include "globals.h"
+#include "internals.h"
+#include "Types.h"
+#include "Structures.h"
+
 namespace MT32Emu {
 
-class PartialManager;
+class Poly;
 class Synth;
 
 class PolyList {
 private:
-
-public:
 	Poly *firstPoly;
 	Poly *lastPoly;
+
+public:
 	PolyList();
 	bool isEmpty() const;
 	Poly *getFirst() const;
@@ -51,13 +56,11 @@ private:
 
 	unsigned int activePartialCount;
 	PatchCache patchCache[4];
-	PolyList freePolys;
 	PolyList activePolys;
 
 	void setPatch(const PatchParam *patch);
 	unsigned int midiKeyToKey(unsigned int midiKey);
 
-	void abortPoly(Poly *poly);
 	bool abortFirstPoly(unsigned int key);
 
 protected:
@@ -110,8 +113,10 @@ public:
 	virtual void setTimbre(TimbreParam *timbre);
 	virtual unsigned int getAbsTimbreNum() const;
 	const char *getCurrentInstr() const;
+	const Poly *getFirstActivePoly() const;
 	unsigned int getActivePartialCount() const;
 	unsigned int getActiveNonReleasingPartialCount() const;
+	Synth *getSynth() const;
 
 	const MemParams::PatchTemp *getPatchTemp() const;
 
@@ -123,11 +128,7 @@ public:
 	// Abort the first poly in PolyState_HELD, or if none exists, the first active poly in any state.
 	bool abortFirstPolyPreferHeld();
 	bool abortFirstPoly();
-
-	const Poly *getActivePoly(int num);
-	int getActivePolyCount();
-	const PatchCache *getPatchCache(int num);
-};
+}; // class Part
 
 class RhythmPart: public Part {
 	// Pointer to the area of the MT-32's memory dedicated to rhythm
@@ -145,9 +146,8 @@ public:
 	unsigned int getAbsTimbreNum() const;
 	void setPan(unsigned int midiPan);
 	void setProgram(unsigned int patchNum);
-
-	const PatchCache *getDrumCache(int num1, int num2);
 };
 
-}
-#endif
+} // namespace MT32Emu
+
+#endif // #ifndef MT32EMU_PART_H
diff --git a/src/mt32/Partial.cpp b/src/mt32/Partial.cpp
index c035257f..60c06b7b 100644
--- a/src/mt32/Partial.cpp
+++ b/src/mt32/Partial.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,27 +15,45 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <cmath>
-#include <cstdlib>
-#include <cstring>
+#include <cstddef>
 
-#include "mt32emu.h"
-#include "mmath.h"
+#include "internals.h"
+
+#include "Partial.h"
+#include "Part.h"
+#include "PartialManager.h"
+#include "Poly.h"
+#include "Synth.h"
+#include "Tables.h"
+#include "TVA.h"
+#include "TVF.h"
+#include "TVP.h"
 
 namespace MT32Emu {
 
-#ifdef INACCURATE_SMOOTH_PAN
-// Mok wanted an option for smoother panning, and we love Mok.
-static const float PAN_NUMERATOR_NORMAL[] = {0.0f, 0.5f, 1.0f, 1.5f, 2.0f, 2.5f, 3.0f, 3.5f, 4.0f, 4.5f, 5.0f, 5.5f, 6.0f, 6.5f, 7.0f};
-#else
-// CONFIRMED by Mok: These NUMERATOR values (as bytes, not floats, obviously) are sent exactly like this to the LA32.
-static const float PAN_NUMERATOR_NORMAL[] = {0.0f, 0.0f, 1.0f, 1.0f, 2.0f, 2.0f, 3.0f, 3.0f, 4.0f, 4.0f, 5.0f, 5.0f, 6.0f, 6.0f, 7.0f};
-#endif
-static const float PAN_NUMERATOR_MASTER[] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f};
-static const float PAN_NUMERATOR_SLAVE[]  = {0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 7.0f, 7.0f, 7.0f, 7.0f, 7.0f, 7.0f, 7.0f};
+static const Bit8u PAN_NUMERATOR_MASTER[] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7};
+static const Bit8u PAN_NUMERATOR_SLAVE[]  = {0, 1, 2, 3, 4, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7};
+
+// We assume the pan is applied using the same 13-bit multiplier circuit that is also used for ring modulation
+// because of the observed sample overflow, so the panSetting values are likely mapped in a similar way via a LUT.
+// FIXME: Sample analysis suggests that the use of panSetting is linear, but there are some quirks that still need to be resolved.
+static Bit32s getPANFactor(Bit32s panSetting) {
+	static const Bit32u PAN_FACTORS_COUNT = 15;
+	static Bit32s PAN_FACTORS[PAN_FACTORS_COUNT];
+	static bool firstRun = true;
+
+	if (firstRun) {
+		firstRun = false;
+		for (Bit32u i = 1; i < PAN_FACTORS_COUNT; i++) {
+			PAN_FACTORS[i] = Bit32s(0.5 + i * 8192.0 / double(PAN_FACTORS_COUNT - 1));
+		}
+	}
+	return PAN_FACTORS[panSetting];
+}
 
-Partial::Partial(Synth *useSynth, int useDebugPartialNum) :
-	synth(useSynth), debugPartialNum(useDebugPartialNum), sampleNum(0) {
+Partial::Partial(Synth *useSynth, int usePartialIndex) :
+	synth(useSynth), partialIndex(usePartialIndex), sampleNum(0),
+	floatMode(useSynth->getSelectedRendererType() == RendererType_FLOAT) {
 	// Initialisation of tva, tvp and tvf uses 'this' pointer
 	// and thus should not be in the initializer list to avoid a compiler warning
 	tva = new TVA(this, &ampRamp);
@@ -44,15 +62,20 @@ Partial::Partial(Synth *useSynth, int useDebugPartialNum) :
 	ownerPart = -1;
 	poly = NULL;
 	pair = NULL;
-
-
-	// init ptr warnings (load state crashes)
-	pcmWave = NULL;
-	patchCache = NULL;
-	cachebackup.partialParam = NULL;
+	switch (synth->getSelectedRendererType()) {
+	case RendererType_BIT16S:
+		la32Pair = new LA32IntPartialPair;
+		break;
+	case RendererType_FLOAT:
+		la32Pair = new LA32FloatPartialPair;
+		break;
+	default:
+		la32Pair = NULL;
+	}
 }
 
 Partial::~Partial() {
+	delete la32Pair;
 	delete tva;
 	delete tvp;
 	delete tvf;
@@ -60,11 +83,11 @@ Partial::~Partial() {
 
 // Only used for debugging purposes
 int Partial::debugGetPartialNum() const {
-	return debugPartialNum;
+	return partialIndex;
 }
 
 // Only used for debugging purposes
-unsigned long Partial::debugGetSampleNum() const {
+Bit32u Partial::debugGetSampleNum() const {
 	return sampleNum;
 }
 
@@ -90,27 +113,23 @@ void Partial::deactivate() {
 		return;
 	}
 	ownerPart = -1;
+	synth->partialManager->partialDeactivated(partialIndex);
 	if (poly != NULL) {
 		poly->partialDeactivated(this);
 	}
-	synth->partialStateChanged(this, tva->getPhase(), TVA_PHASE_DEAD);
 #if MT32EMU_MONITOR_PARTIALS > 2
 	synth->printDebug("[+%lu] [Partial %d] Deactivated", sampleNum, debugPartialNum);
 	synth->printPartialUsage(sampleNum);
 #endif
 	if (isRingModulatingSlave()) {
-		pair->la32Pair.deactivate(LA32PartialPair::SLAVE);
+		pair->la32Pair->deactivate(LA32PartialPair::SLAVE);
 	} else {
-		la32Pair.deactivate(LA32PartialPair::MASTER);
+		la32Pair->deactivate(LA32PartialPair::MASTER);
 		if (hasRingModulatingSlave()) {
 			pair->deactivate();
 			pair = NULL;
 		}
 	}
-
-	// loadstate ptr warnings (sometimes points to freePolys)
-	poly = NULL;
-
 	if (pair != NULL) {
 		pair->pair = NULL;
 	}
@@ -118,7 +137,7 @@ void Partial::deactivate() {
 
 void Partial::startPartial(const Part *part, Poly *usePoly, const PatchCache *usePatchCache, const MemParams::RhythmTemp *rhythmTemp, Partial *pairPartial) {
 	if (usePoly == NULL || usePatchCache == NULL) {
-		synth->printDebug("[Partial %d] *** Error: Starting partial for owner %d, usePoly=%s, usePatchCache=%s", debugPartialNum, ownerPart, usePoly == NULL ? "*** NULL ***" : "OK", usePatchCache == NULL ? "*** NULL ***" : "OK");
+		synth->printDebug("[Partial %d] *** Error: Starting partial for owner %d, usePoly=%s, usePatchCache=%s", partialIndex, ownerPart, usePoly == NULL ? "*** NULL ***" : "OK", usePatchCache == NULL ? "*** NULL ***" : "OK");
 		return;
 	}
 	patchCache = usePatchCache;
@@ -127,30 +146,37 @@ void Partial::startPartial(const Part *part, Poly *usePoly, const PatchCache *us
 	structurePosition = patchCache->structurePosition;
 
 	Bit8u panSetting = rhythmTemp != NULL ? rhythmTemp->panpot : part->getPatchTemp()->panpot;
-	float panVal;
 	if (mixType == 3) {
 		if (structurePosition == 0) {
-			panVal = PAN_NUMERATOR_MASTER[panSetting];
+			panSetting = PAN_NUMERATOR_MASTER[panSetting] << 1;
 		} else {
-			panVal = PAN_NUMERATOR_SLAVE[panSetting];
+			panSetting = PAN_NUMERATOR_SLAVE[panSetting] << 1;
 		}
 		// Do a normal mix independent of any pair partial.
 		mixType = 0;
 		pairPartial = NULL;
 	} else {
-		panVal = PAN_NUMERATOR_NORMAL[panSetting];
+		// Mok wanted an option for smoother panning, and we love Mok.
+#ifndef INACCURATE_SMOOTH_PAN
+		// CONFIRMED by Mok: exactly bytes like this (right shifted?) are sent to the LA32.
+		panSetting &= 0x0E;
+#endif
 	}
 
-	// FIXME: Sample analysis suggests that the use of panVal is linear, but there are some some quirks that still need to be resolved.
-	stereoVolume.leftVol = panVal / 7.0f;
-	stereoVolume.rightVol = 1.0f - stereoVolume.leftVol;
+	leftPanValue = synth->reversedStereoEnabled ? 14 - panSetting : panSetting;
+	rightPanValue = 14 - leftPanValue;
+
+	if (!floatMode) {
+		leftPanValue = getPANFactor(leftPanValue);
+		rightPanValue = getPANFactor(rightPanValue);
+	}
 
 	// SEMI-CONFIRMED: From sample analysis:
 	// Found that timbres with 3 or 4 partials (i.e. one using two partial pairs) are mixed in two different ways.
 	// Either partial pairs are added or subtracted, it depends on how the partial pairs are allocated.
 	// It seems that partials are grouped into quarters and if the partial pairs are allocated in different quarters the subtraction happens.
 	// Though, this matters little for the majority of timbres, it becomes crucial for timbres which contain several partials that sound very close.
-	// In this case that timbre can sound totally different depending of the way it is mixed up.
+	// In this case that timbre can sound totally different depending on the way it is mixed up.
 	// Most easily this effect can be displayed with the help of a special timbre consisting of several identical square wave partials (3 or 4).
 	// Say, it is 3-partial timbre. Just play any two notes simultaneously and the polys very probably are mixed differently.
 	// Moreover, the partial allocator retains the last partial assignment it did and all the subsequent notes will sound the same as the last released one.
@@ -158,10 +184,9 @@ void Partial::startPartial(const Part *part, Poly *usePoly, const PatchCache *us
 	// whole-quarter assignment or after some partials got aborted, even 4-partial timbres can be found sounding differently.
 	// This behaviour is also confirmed with two more special timbres: one with identical sawtooth partials, and one with PCM wave 02.
 	// For my personal taste, this behaviour rather enriches the sounding and should be emulated.
-	// Also, the current partial allocator model probably needs to be refined.
-	if (debugPartialNum & 8) {
-		stereoVolume.leftVol = -stereoVolume.leftVol;
-		stereoVolume.rightVol = -stereoVolume.rightVol;
+	if (partialIndex & 4) {
+		leftPanValue = -leftPanValue;
+		rightPanValue = -rightPanValue;
 	}
 
 	if (patchCache->PCMPartial) {
@@ -195,11 +220,11 @@ void Partial::startPartial(const Part *part, Poly *usePoly, const PatchCache *us
 	LA32PartialPair *useLA32Pair;
 	if (isRingModulatingSlave()) {
 		pairType = LA32PartialPair::SLAVE;
-		useLA32Pair = &pair->la32Pair;
+		useLA32Pair = pair->la32Pair;
 	} else {
 		pairType = LA32PartialPair::MASTER;
-		la32Pair.init(hasRingModulatingSlave(), mixType == 1);
-		useLA32Pair = &la32Pair;
+		la32Pair->init(hasRingModulatingSlave(), mixType == 1);
+		useLA32Pair = la32Pair;
 	}
 	if (isPCM()) {
 		useLA32Pair->initPCM(pairType, &synth->pcmROMData[pcmWave->addr], pcmWave->len, pcmWave->loop);
@@ -207,11 +232,8 @@ void Partial::startPartial(const Part *part, Poly *usePoly, const PatchCache *us
 		useLA32Pair->initSynth(pairType, (patchCache->waveform & 1) != 0, pulseWidthVal, patchCache->srcPartial.tvf.resonance + 1);
 	}
 	if (!hasRingModulatingSlave()) {
-		la32Pair.deactivate(LA32PartialPair::SLAVE);
+		la32Pair->deactivate(LA32PartialPair::SLAVE);
 	}
-	// Temporary integration hack
-	stereoVolume.leftVol /= 8192.0f;
-	stereoVolume.rightVol /= 8192.0f;
 }
 
 Bit32u Partial::getAmpValue() {
@@ -243,39 +265,6 @@ Bit32u Partial::getCutoffValue() {
 	return (tvf->getBaseCutoff() << 18) + cutoffModifierRampVal;
 }
 
-unsigned long Partial::generateSamples(Bit16s *partialBuf, unsigned long length) {
-	if (!isActive() || alreadyOutputed) {
-		return 0;
-	}
-	if (poly == NULL) {
-		synth->printDebug("[Partial %d] *** ERROR: poly is NULL at Partial::generateSamples()!", debugPartialNum);
-		return 0;
-	}
-	alreadyOutputed = true;
-
-	for (sampleNum = 0; sampleNum < length; sampleNum++) {
-		if (!tva->isPlaying() || !la32Pair.isActive(LA32PartialPair::MASTER)) {
-			deactivate();
-			break;
-		}
-		la32Pair.generateNextSample(LA32PartialPair::MASTER, getAmpValue(), tvp->nextPitch(), getCutoffValue());
-		if (hasRingModulatingSlave()) {
-			la32Pair.generateNextSample(LA32PartialPair::SLAVE, pair->getAmpValue(), pair->tvp->nextPitch(), pair->getCutoffValue());
-			if (!pair->tva->isPlaying() || !la32Pair.isActive(LA32PartialPair::SLAVE)) {
-				pair->deactivate();
-				if (mixType == 2) {
-					deactivate();
-					break;
-				}
-			}
-		}
-		*partialBuf++ = la32Pair.nextOutSample();
-	}
-	unsigned long renderedSamples = sampleNum;
-	sampleNum = 0;
-	return renderedSamples;
-}
-
 bool Partial::hasRingModulatingSlave() const {
 	return pair != NULL && structurePosition == 0 && (mixType == 1 || mixType == 2);
 }
@@ -284,6 +273,10 @@ bool Partial::isRingModulatingSlave() const {
 	return pair != NULL && structurePosition == 1 && (mixType == 1 || mixType == 2);
 }
 
+bool Partial::isRingModulatingNoMix() const {
+	return pair != NULL && ((structurePosition == 1 && mixType == 1) || mixType == 2);
+}
+
 bool Partial::isPCM() const {
 	return pcmWave != NULL;
 }
@@ -299,26 +292,101 @@ Synth *Partial::getSynth() const {
 	return synth;
 }
 
-bool Partial::produceOutput(float *leftBuf, float *rightBuf, unsigned long length) {
+TVA *Partial::getTVA() const {
+	return tva;
+}
+
+void Partial::backupCache(const PatchCache &cache) {
+	if (patchCache == &cache) {
+		cachebackup = cache;
+		patchCache = &cachebackup;
+	}
+}
+
+bool Partial::canProduceOutput() {
 	if (!isActive() || alreadyOutputed || isRingModulatingSlave()) {
 		return false;
 	}
 	if (poly == NULL) {
-		synth->printDebug("[Partial %d] *** ERROR: poly is NULL at Partial::produceOutput()!", debugPartialNum);
+		synth->printDebug("[Partial %d] *** ERROR: poly is NULL at Partial::produceOutput()!", partialIndex);
 		return false;
 	}
-	unsigned long numGenerated = generateSamples(myBuffer, length);
-	for (unsigned int i = 0; i < numGenerated; i++) {
-		*leftBuf++ = myBuffer[i] * stereoVolume.leftVol;
-		*rightBuf++ = myBuffer[i] * stereoVolume.rightVol;
+	return true;
+}
+
+template <class LA32PairImpl>
+bool Partial::generateNextSample(LA32PairImpl *la32PairImpl) {
+	if (!tva->isPlaying() || !la32PairImpl->isActive(LA32PartialPair::MASTER)) {
+		deactivate();
+		return false;
 	}
-	for (; numGenerated < length; numGenerated++) {
-		*leftBuf++ = 0.0f;
-		*rightBuf++ = 0.0f;
+	la32PairImpl->generateNextSample(LA32PartialPair::MASTER, getAmpValue(), tvp->nextPitch(), getCutoffValue());
+	if (hasRingModulatingSlave()) {
+		la32PairImpl->generateNextSample(LA32PartialPair::SLAVE, pair->getAmpValue(), pair->tvp->nextPitch(), pair->getCutoffValue());
+		if (!pair->tva->isPlaying() || !la32PairImpl->isActive(LA32PartialPair::SLAVE)) {
+			pair->deactivate();
+			if (mixType == 2) {
+				deactivate();
+				return false;
+			}
+		}
 	}
 	return true;
 }
 
+void Partial::produceAndMixSample(IntSample *&leftBuf, IntSample *&rightBuf, LA32IntPartialPair *la32IntPair) {
+	IntSampleEx sample = la32IntPair->nextOutSample();
+
+	// FIXME: LA32 may produce distorted sound in case if the absolute value of maximal amplitude of the input exceeds 8191
+	// when the panning value is non-zero. Most probably the distortion occurs in the same way it does with ring modulation,
+	// and it seems to be caused by limited precision of the common multiplication circuit.
+	// From analysis of this overflow, it is obvious that the right channel output is actually found
+	// by subtraction of the left channel output from the input.
+	// Though, it is unknown whether this overflow is exploited somewhere.
+
+	IntSampleEx leftOut = ((sample * leftPanValue) >> 13) + IntSampleEx(*leftBuf);
+	IntSampleEx rightOut = ((sample * rightPanValue) >> 13) + IntSampleEx(*rightBuf);
+	*(leftBuf++) = Synth::clipSampleEx(leftOut);
+	*(rightBuf++) = Synth::clipSampleEx(rightOut);
+}
+
+void Partial::produceAndMixSample(FloatSample *&leftBuf, FloatSample *&rightBuf, LA32FloatPartialPair *la32FloatPair) {
+	FloatSample sample = la32FloatPair->nextOutSample();
+	FloatSample leftOut = (sample * leftPanValue) / 14.0f;
+	FloatSample rightOut = (sample * rightPanValue) / 14.0f;
+	*(leftBuf++) += leftOut;
+	*(rightBuf++) += rightOut;
+}
+
+template <class Sample, class LA32PairImpl>
+bool Partial::doProduceOutput(Sample *leftBuf, Sample *rightBuf, Bit32u length, LA32PairImpl *la32PairImpl) {
+	if (!canProduceOutput()) return false;
+	alreadyOutputed = true;
+
+	for (sampleNum = 0; sampleNum < length; sampleNum++) {
+		if (!generateNextSample(la32PairImpl)) break;
+		produceAndMixSample(leftBuf, rightBuf, la32PairImpl);
+	}
+	sampleNum = 0;
+	return true;
+}
+
+bool Partial::produceOutput(IntSample *leftBuf, IntSample *rightBuf, Bit32u length) {
+	if (floatMode) {
+		synth->printDebug("Partial: Invalid call to produceOutput()! Renderer = %d\n", synth->getSelectedRendererType());
+		return false;
+	}
+	return doProduceOutput(leftBuf, rightBuf, length, static_cast<LA32IntPartialPair *>(la32Pair));
+}
+
+bool Partial::produceOutput(FloatSample *leftBuf, FloatSample *rightBuf, Bit32u length) {
+	if (!floatMode) {
+		synth->printDebug("Partial: Invalid call to produceOutput()! Renderer = %d\n", synth->getSelectedRendererType());
+		return false;
+	}
+	return doProduceOutput(leftBuf, rightBuf, length, static_cast<LA32FloatPartialPair *>(la32Pair));
+}
+
 bool Partial::shouldReverb() {
 	if (!isActive()) {
 		return false;
@@ -337,4 +405,4 @@ void Partial::startDecayAll() {
 	tvf->startDecay();
 }
 
-}
+} // namespace MT32Emu
diff --git a/src/mt32/Partial.h b/src/mt32/Partial.h
index 3e57bcac..e297710f 100644
--- a/src/mt32/Partial.h
+++ b/src/mt32/Partial.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,35 +18,40 @@
 #ifndef MT32EMU_PARTIAL_H
 #define MT32EMU_PARTIAL_H
 
-#include "FileStream.h"
+#include "globals.h"
+#include "internals.h"
+#include "Types.h"
+#include "Structures.h"
+#include "LA32Ramp.h"
+#include "LA32WaveGenerator.h"
+#include "LA32FloatWaveGenerator.h"
 
 namespace MT32Emu {
 
-class Synth;
 class Part;
+class Poly;
+class Synth;
 class TVA;
+class TVF;
+class TVP;
 struct ControlROMPCMStruct;
 
-struct StereoVolume {
-	float leftVol;
-	float rightVol;
-};
-
 // A partial represents one of up to four waveform generators currently playing within a poly.
 class Partial {
 private:
 	Synth *synth;
-	const int debugPartialNum; // Only used for debugging
-	// Number of the sample currently being rendered by generateSamples(), or 0 if no run is in progress
+	const int partialIndex; // Index of this Partial in the global partial table
+	// Number of the sample currently being rendered by produceOutput(), or 0 if no run is in progress
 	// This is only kept available for debugging purposes.
-	unsigned long sampleNum;
+	Bit32u sampleNum;
+
+	// Actually, this is a 4-bit register but we abuse this to emulate inverted mixing.
+	// Also we double the value to enable INACCURATE_SMOOTH_PAN, with respect to MoK.
+	Bit32s leftPanValue, rightPanValue;
 
 	int ownerPart; // -1 if unassigned
 	int mixType;
 	int structurePosition; // 0 or 1 of a structure pair
-	StereoVolume stereoVolume;
-
-	Bit16s myBuffer[MAX_SAMPLES_PER_RUN];
 
 	// Only used for PCM partials
 	int pcmNum;
@@ -58,32 +63,41 @@ private:
 	int pulseWidthVal;
 
 	Poly *poly;
+	Partial *pair;
+
+	TVA *tva;
+	TVP *tvp;
+	TVF *tvf;
 
 	LA32Ramp ampRamp;
 	LA32Ramp cutoffModifierRamp;
 
 	// TODO: This should be owned by PartialPair
-	LA32PartialPair la32Pair;
+	LA32PartialPair *la32Pair;
+	const bool floatMode;
+
+	const PatchCache *patchCache;
+	PatchCache cachebackup;
 
 	Bit32u getAmpValue();
 	Bit32u getCutoffValue();
 
-public:
-	const PatchCache *patchCache;
-	TVA *tva;
-	TVP *tvp;
-	TVF *tvf;
-
-	PatchCache cachebackup;
+	template <class Sample, class LA32PairImpl>
+	bool doProduceOutput(Sample *leftBuf, Sample *rightBuf, Bit32u length, LA32PairImpl *la32PairImpl);
+	bool canProduceOutput();
+	template <class LA32PairImpl>
+	bool generateNextSample(LA32PairImpl *la32PairImpl);
+	void produceAndMixSample(IntSample *&leftBuf, IntSample *&rightBuf, LA32IntPartialPair *la32IntPair);
+	void produceAndMixSample(FloatSample *&leftBuf, FloatSample *&rightBuf, LA32FloatPartialPair *la32FloatPair);
 
-	Partial *pair;
+public:
 	bool alreadyOutputed;
 
 	Partial(Synth *synth, int debugPartialNum);
 	~Partial();
 
 	int debugGetPartialNum() const;
-	unsigned long debugGetSampleNum() const;
+	Bit32u debugGetSampleNum() const;
 
 	int getOwnerPart() const;
 	const Poly *getPoly() const;
@@ -94,21 +108,23 @@ public:
 	void startAbort();
 	void startDecayAll();
 	bool shouldReverb();
+	bool isRingModulatingNoMix() const;
 	bool hasRingModulatingSlave() const;
 	bool isRingModulatingSlave() const;
 	bool isPCM() const;
 	const ControlROMPCMStruct *getControlROMPCMStruct() const;
 	Synth *getSynth() const;
+	TVA *getTVA() const;
+
+	void backupCache(const PatchCache &cache);
 
 	// Returns true only if data written to buffer
-	// This function (unlike the one below it) returns processed stereo samples
+	// These functions produce processed stereo samples
 	// made from combining this single partial with its pair, if it has one.
-	bool produceOutput(float *leftBuf, float *rightBuf, unsigned long length);
-
-	// This function writes mono sample output to the provided buffer, and returns the number of samples written
-	unsigned long generateSamples(Bit16s *partialBuf, unsigned long length);
-};
+	bool produceOutput(IntSample *leftBuf, IntSample *rightBuf, Bit32u length);
+	bool produceOutput(FloatSample *leftBuf, FloatSample *rightBuf, Bit32u length);
+}; // class Partial
 
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_PARTIAL_H
diff --git a/src/mt32/PartialManager.cpp b/src/mt32/PartialManager.cpp
index 3642773d..aeba5ce8 100644
--- a/src/mt32/PartialManager.cpp
+++ b/src/mt32/PartialManager.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,30 +15,46 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <cstddef>
 #include <cstring>
 
-#include "mt32emu.h"
+#include "internals.h"
+
 #include "PartialManager.h"
-#include "FileStream.h"
+#include "Part.h"
+#include "Partial.h"
+#include "Poly.h"
+#include "Synth.h"
 
 namespace MT32Emu {
 
 PartialManager::PartialManager(Synth *useSynth, Part **useParts) {
 	synth = useSynth;
 	parts = useParts;
-	for (unsigned int i = 0; i < synth->getPartialLimit(); i++) {
+	inactivePartialCount = synth->getPartialCount();
+	partialTable = new Partial *[inactivePartialCount];
+	inactivePartials = new int[inactivePartialCount];
+	freePolys = new Poly *[synth->getPartialCount()];
+	firstFreePolyIndex = 0;
+	for (unsigned int i = 0; i < synth->getPartialCount(); i++) {
 		partialTable[i] = new Partial(synth, i);
+		inactivePartials[i] = inactivePartialCount - i - 1;
+		freePolys[i] = new Poly();
 	}
 }
 
 PartialManager::~PartialManager(void) {
-	for (unsigned int i = 0; i < synth->getPartialLimit(); i++) {
+	for (unsigned int i = 0; i < synth->getPartialCount(); i++) {
 		delete partialTable[i];
+		if (freePolys[i] != NULL) delete freePolys[i];
 	}
+	delete[] partialTable;
+	delete[] inactivePartials;
+	delete[] freePolys;
 }
 
 void PartialManager::clearAlreadyOutputed() {
-	for (unsigned int i = 0; i < synth->getPartialLimit(); i++) {
+	for (unsigned int i = 0; i < synth->getPartialCount(); i++) {
 		partialTable[i]->alreadyOutputed = false;
 	}
 }
@@ -47,19 +63,23 @@ bool PartialManager::shouldReverb(int i) {
 	return partialTable[i]->shouldReverb();
 }
 
-bool PartialManager::produceOutput(int i, float *leftBuf, float *rightBuf, Bit32u bufferLength) {
+bool PartialManager::produceOutput(int i, IntSample *leftBuf, IntSample *rightBuf, Bit32u bufferLength) {
+	return partialTable[i]->produceOutput(leftBuf, rightBuf, bufferLength);
+}
+
+bool PartialManager::produceOutput(int i, FloatSample *leftBuf, FloatSample *rightBuf, Bit32u bufferLength) {
 	return partialTable[i]->produceOutput(leftBuf, rightBuf, bufferLength);
 }
 
 void PartialManager::deactivateAll() {
-	for (unsigned int i = 0; i < synth->getPartialLimit(); i++) {
+	for (unsigned int i = 0; i < synth->getPartialCount(); i++) {
 		partialTable[i]->deactivate();
 	}
 }
 
 unsigned int PartialManager::setReserve(Bit8u *rset) {
 	unsigned int pr = 0;
-	for (unsigned int x = 0; x <= 8; x++) {
+	for (int x = 0; x <= 8; x++) {
 		numReservedPartialsForPart[x] = rset[x];
 		pr += rset[x];
 	}
@@ -67,35 +87,27 @@ unsigned int PartialManager::setReserve(Bit8u *rset) {
 }
 
 Partial *PartialManager::allocPartial(int partNum) {
-	Partial *outPartial = NULL;
-
-	// Get the first inactive partial
-	for (unsigned int partialNum = 0; partialNum < synth->getPartialLimit(); partialNum++) {
-		if (!partialTable[partialNum]->isActive()) {
-			outPartial = partialTable[partialNum];
-			break;
-		}
+	if (inactivePartialCount > 0) {
+		Partial *partial = partialTable[inactivePartials[--inactivePartialCount]];
+		partial->activate(partNum);
+		return partial;
 	}
-	if (outPartial != NULL) {
-		outPartial->activate(partNum);
+	synth->printDebug("PartialManager Error: No inactive partials to allocate for part %d, current partial state:\n", partNum);
+	for (Bit32u i = 0; i < synth->getPartialCount(); i++) {
+		const Partial *partial = partialTable[i];
+		synth->printDebug("[Partial %d]: activation=%d, owner part=%d\n", i, partial->isActive(), partial->getOwnerPart());
 	}
-	return outPartial;
+	return NULL;
 }
 
-unsigned int PartialManager::getFreePartialCount(void) {
-	unsigned int count = 0;
-	for (unsigned int i = 0; i < synth->getPartialLimit(); i++) {
-		if (!partialTable[i]->isActive()) {
-			count++;
-		}
-	}
-	return count;
+unsigned int PartialManager::getFreePartialCount() {
+	return inactivePartialCount;
 }
 
 // This function is solely used to gather data for debug output at the moment.
 void PartialManager::getPerPartPartialUsage(unsigned int perPartPartialUsage[9]) {
 	memset(perPartPartialUsage, 0, 9 * sizeof(unsigned int));
-	for (unsigned int i = 0; i < synth->getPartialLimit(); i++) {
+	for (unsigned int i = 0; i < synth->getPartialCount(); i++) {
 		if (partialTable[i]->isActive()) {
 			perPartPartialUsage[partialTable[i]->getOwnerPart()]++;
 		}
@@ -190,7 +202,7 @@ bool PartialManager::freePartials(unsigned int needed, int partNum) {
 			break;
 		}
 #endif
-		if (getFreePartialCount() >= needed) {
+		if (synth->isAbortingPoly() || getFreePartialCount() >= needed) {
 			return true;
 		}
 	}
@@ -207,7 +219,7 @@ bool PartialManager::freePartials(unsigned int needed, int partNum) {
 			if (!abortFirstPolyPreferHeldWhereReserveExceeded(partNum)) {
 				break;
 			}
-			if (getFreePartialCount() >= needed) {
+			if (synth->isAbortingPoly() || getFreePartialCount() >= needed) {
 				return true;
 			}
 		}
@@ -223,7 +235,7 @@ bool PartialManager::freePartials(unsigned int needed, int partNum) {
 			if (!abortFirstPolyPreferHeldWhereReserveExceeded(-1)) {
 				break;
 			}
-			if (getFreePartialCount() >= needed) {
+			if (synth->isAbortingPoly() || getFreePartialCount() >= needed) {
 				return true;
 			}
 		}
@@ -234,7 +246,7 @@ bool PartialManager::freePartials(unsigned int needed, int partNum) {
 		if (!parts[partNum]->abortFirstPolyPreferHeld()) {
 			break;
 		}
-		if (getFreePartialCount() >= needed) {
+		if (synth->isAbortingPoly() || getFreePartialCount() >= needed) {
 			return true;
 		}
 	}
@@ -244,10 +256,52 @@ bool PartialManager::freePartials(unsigned int needed, int partNum) {
 }
 
 const Partial *PartialManager::getPartial(unsigned int partialNum) const {
-	if (partialNum > synth->getPartialLimit() - 1) {
+	if (partialNum > synth->getPartialCount() - 1) {
 		return NULL;
 	}
 	return partialTable[partialNum];
 }
 
+Poly *PartialManager::assignPolyToPart(Part *part) {
+	if (firstFreePolyIndex < synth->getPartialCount()) {
+		Poly *poly = freePolys[firstFreePolyIndex];
+		freePolys[firstFreePolyIndex] = NULL;
+		firstFreePolyIndex++;
+		poly->setPart(part);
+		return poly;
+	}
+	return NULL;
 }
+
+void PartialManager::polyFreed(Poly *poly) {
+	if (0 == firstFreePolyIndex) {
+		synth->printDebug("PartialManager Error: Cannot return freed poly, currently active polys:\n");
+		for (Bit32u partNum = 0; partNum < 9; partNum++) {
+			const Poly *activePoly = synth->getPart(partNum)->getFirstActivePoly();
+			Bit32u polyCount = 0;
+			while (activePoly != NULL) {
+				activePoly = activePoly->getNext();
+				polyCount++;
+			}
+			synth->printDebug("Part: %i, active poly count: %i\n", partNum, polyCount);
+		}
+	} else {
+		firstFreePolyIndex--;
+		freePolys[firstFreePolyIndex] = poly;
+	}
+	poly->setPart(NULL);
+}
+
+void PartialManager::partialDeactivated(int partialIndex) {
+	if (inactivePartialCount < synth->getPartialCount()) {
+		inactivePartials[inactivePartialCount++] = partialIndex;
+		return;
+	}
+	synth->printDebug("PartialManager Error: Cannot return deactivated partial %d, current partial state:\n", partialIndex);
+	for (Bit32u i = 0; i < synth->getPartialCount(); i++) {
+		const Partial *partial = partialTable[i];
+		synth->printDebug("[Partial %d]: activation=%d, owner part=%d\n", i, partial->isActive(), partial->getOwnerPart());
+	}
+}
+
+} // namespace MT32Emu
diff --git a/src/mt32/PartialManager.h b/src/mt32/PartialManager.h
index a1c9266e..deded8f1 100644
--- a/src/mt32/PartialManager.h
+++ b/src/mt32/PartialManager.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,37 +18,50 @@
 #ifndef MT32EMU_PARTIALMANAGER_H
 #define MT32EMU_PARTIALMANAGER_H
 
+#include "globals.h"
+#include "internals.h"
+#include "Types.h"
+
 namespace MT32Emu {
 
+class Part;
+class Partial;
+class Poly;
 class Synth;
 
 class PartialManager {
 private:
-	Synth *synth; // Only used for sending debug output
+	Synth *synth;
 	Part **parts;
-
-	Partial *partialTable[MT32EMU_MAX_PARTIALS];
+	Poly **freePolys;
+	Partial **partialTable;
 	Bit8u numReservedPartialsForPart[9];
+	Bit32u firstFreePolyIndex;
+	int *inactivePartials; // Holds indices of inactive Partials in the Partial table
+	Bit32u inactivePartialCount;
 
 	bool abortFirstReleasingPolyWhereReserveExceeded(int minPart);
 	bool abortFirstPolyPreferHeldWhereReserveExceeded(int minPart);
 
 public:
-
 	PartialManager(Synth *synth, Part **parts);
 	~PartialManager();
 	Partial *allocPartial(int partNum);
-	unsigned int getFreePartialCount(void);
+	unsigned int getFreePartialCount();
 	void getPerPartPartialUsage(unsigned int perPartPartialUsage[9]);
 	bool freePartials(unsigned int needed, int partNum);
 	unsigned int setReserve(Bit8u *rset);
 	void deactivateAll();
-	bool produceOutput(int i, float *leftBuf, float *rightBuf, Bit32u bufferLength);
+	bool produceOutput(int i, IntSample *leftBuf, IntSample *rightBuf, Bit32u bufferLength);
+	bool produceOutput(int i, FloatSample *leftBuf, FloatSample *rightBuf, Bit32u bufferLength);
 	bool shouldReverb(int i);
 	void clearAlreadyOutputed();
 	const Partial *getPartial(unsigned int partialNum) const;
-};
+	Poly *assignPolyToPart(Part *part);
+	void polyFreed(Poly *poly);
+	void partialDeactivated(int partialIndex);
+}; // class PartialManager
 
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_PARTIALMANAGER_H
diff --git a/src/mt32/Poly.cpp b/src/mt32/Poly.cpp
index cbe755da..44b8d244 100644
--- a/src/mt32/Poly.cpp
+++ b/src/mt32/Poly.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,14 +15,19 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "mt32emu.h"
-#include "PartialManager.h"
+#include <cstddef>
+
+#include "internals.h"
+
+#include "Poly.h"
+#include "Part.h"
+#include "Partial.h"
+#include "Synth.h"
 
 namespace MT32Emu {
 
-Poly::Poly(Synth *useSynth, Part *usePart) {
-	synth = useSynth;
-	part = usePart;
+Poly::Poly() {
+	part = NULL;
 	key = 255;
 	velocity = 255;
 	sustain = false;
@@ -34,10 +39,21 @@ Poly::Poly(Synth *useSynth, Part *usePart) {
 	next = NULL;
 }
 
+void Poly::setPart(Part *usePart) {
+	part = usePart;
+}
+
 void Poly::reset(unsigned int newKey, unsigned int newVelocity, bool newSustain, Partial **newPartials) {
 	if (isActive()) {
-		// FIXME: Throw out some big ugly debug output with a lot of exclamation marks - we should never get here
-		terminate();
+		// This should never happen
+		part->getSynth()->printDebug("Resetting active poly. Active partial count: %i\n", activePartialCount);
+		for (int i = 0; i < 4; i++) {
+			if (partials[i] != NULL && partials[i]->isActive()) {
+				partials[i]->deactivate();
+				activePartialCount--;
+			}
+		}
+		state = POLY_Inactive;
 	}
 
 	key = newKey;
@@ -94,41 +110,24 @@ bool Poly::startDecay() {
 }
 
 bool Poly::startAbort() {
-	if (state == POLY_Inactive) {
+	if (state == POLY_Inactive || part->getSynth()->isAbortingPoly()) {
 		return false;
 	}
 	for (int t = 0; t < 4; t++) {
 		Partial *partial = partials[t];
 		if (partial != NULL) {
 			partial->startAbort();
+			part->getSynth()->abortingPoly = this;
 		}
 	}
 	return true;
 }
 
-void Poly::terminate() {
-	if (state == POLY_Inactive) {
-		return;
-	}
-	for (int t = 0; t < 4; t++) {
-		Partial *partial = partials[t];
-		if (partial != NULL) {
-			partial->deactivate();
-		}
-	}
-	if (state != POLY_Inactive) {
-		// FIXME: Throw out lots of debug output - this should never happen
-		// (Deactivating the partials above should've made them each call partialDeactivated(), ultimately changing the state to POLY_Inactive)
-		state = POLY_Inactive;
-	}
-}
-
 void Poly::backupCacheToPartials(PatchCache cache[4]) {
 	for (int partialNum = 0; partialNum < 4; partialNum++) {
 		Partial *partial = partials[partialNum];
-		if (partial != NULL && partial->patchCache == &cache[partialNum]) {
-			partial->cachebackup = cache[partialNum];
-			partial->patchCache = &partial->cachebackup;
+		if (partial != NULL) {
+			partial->backupCache(cache[partialNum]);
 		}
 	}
 }
@@ -173,11 +172,14 @@ void Poly::partialDeactivated(Partial *partial) {
 	}
 	if (activePartialCount == 0) {
 		state = POLY_Inactive;
+		if (part->getSynth()->abortingPoly == this) {
+			part->getSynth()->abortingPoly = NULL;
+		}
 	}
 	part->partialDeactivated(this);
 }
 
-Poly *Poly::getNext() {
+Poly *Poly::getNext() const {
 	return next;
 }
 
@@ -185,104 +187,4 @@ void Poly::setNext(Poly *poly) {
 	next = poly;
 }
 
-
-#ifdef WIN32_DEBUG
-void Poly::rawVerifyState( char *name, Synth *useSynth )
-{
-	Poly *ptr1, *ptr2;
-	Poly poly_temp(synth, part);
-
-
-#ifndef WIN32_DUMP
-	return;
-#endif
-
-	ptr1 = this;
-	ptr2 = &poly_temp;
-	useSynth->rawLoadState( name, ptr2, sizeof(*this) );
-
-
-	if( ptr1->synth != ptr2->synth ) __asm int 3
-	if( ptr1->part != ptr2->part ) __asm int 3
-	if( ptr1->key != ptr2->key ) __asm int 3
-	if( ptr1->velocity != ptr2->velocity ) __asm int 3
-	if( ptr1->activePartialCount != ptr2->activePartialCount ) __asm int 3
-	if( ptr1->sustain != ptr2->sustain ) __asm int 3
-	if( ptr1->state != ptr2->state ) __asm int 3
-
-	for( int lcv=0; lcv<4; lcv++ ) {
-		if( ptr1->partials[lcv] != ptr2->partials[lcv] ) __asm int 3
-	}
-
-
-
-	// avoid destructor problems
-	memset( ptr2, 0, sizeof(*ptr2) );
-}
-#endif
-
-
-void Poly::saveState( std::ostream &stream )
-{
-	// - static fastptr
-	//Synth *synth;
-	//Part *part;
-
-	stream.write(reinterpret_cast<const char*>(&key), sizeof(key) );
-	stream.write(reinterpret_cast<const char*>(&velocity), sizeof(velocity) );
-	stream.write(reinterpret_cast<const char*>(&activePartialCount), sizeof(activePartialCount) );
-	stream.write(reinterpret_cast<const char*>(&sustain), sizeof(sustain) );
-	stream.write(reinterpret_cast<const char*>(&state), sizeof(state) );
-
-
-	// - reloc ptr (!!!)
-	//Partial *partials[4];
-	for( int lcv=0; lcv<4; lcv++ ) {
-		Bit8u partials_idx;
-
-		synth->findPartial( partials[lcv], &partials_idx );
-		
-		stream.write(reinterpret_cast<const char*>(&partials_idx), sizeof(partials_idx) );
-	}
-
-
-#ifdef WIN32_DEBUG
-	// DEBUG
-	synth->rawDumpState( "temp-save", this, sizeof(*this) );
-	synth->rawDumpNo++;
-#endif
-}
-
-
-void Poly::loadState( std::istream &stream )
-{
-	// - static fastptr
-	//Synth *synth;
-	//Part *part;
-
-	stream.read(reinterpret_cast<char*>(&key), sizeof(key) );
-	stream.read(reinterpret_cast<char*>(&velocity), sizeof(velocity) );
-	stream.read(reinterpret_cast<char*>(&activePartialCount), sizeof(activePartialCount) );
-	stream.read(reinterpret_cast<char*>(&sustain), sizeof(sustain) );
-	stream.read(reinterpret_cast<char*>(&state), sizeof(state) );
-
-	
-	// - reloc ptr (!!!)
-	//Partial *partials[4];
-	for( int lcv=0; lcv<4; lcv++ ) {
-		Bit8u partials_idx;
-
-		stream.read(reinterpret_cast<char*>(&partials_idx), sizeof(partials_idx) );
-		partials[lcv] = (Partial *) synth->indexPartial(partials_idx);
-	}
-
-
-#ifdef WIN32_DEBUG
-	// DEBUG
-	synth->rawDumpState( "temp-load", this, sizeof(*this) );
-	this->rawVerifyState( "temp-save", synth );
-	synth->rawDumpNo++;
-#endif
-}
-
-}
+} // namespace MT32Emu
diff --git a/src/mt32/Poly.h b/src/mt32/Poly.h
index 2fc06751..b2d4ecea 100644
--- a/src/mt32/Poly.h
+++ b/src/mt32/Poly.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,23 +18,17 @@
 #ifndef MT32EMU_POLY_H
 #define MT32EMU_POLY_H
 
-#include "FileStream.h"
+#include "globals.h"
+#include "internals.h"
 
 namespace MT32Emu {
 
-class Synth;
 class Part;
-
-enum PolyState {
-	POLY_Playing,
-	POLY_Held, // This marks keys that have been released on the keyboard, but are being held by the pedal
-	POLY_Releasing,
-	POLY_Inactive
-};
+class Partial;
+struct PatchCache;
 
 class Poly {
 private:
-	Synth *synth;
 	Part *part;
 	unsigned int key;
 	unsigned int velocity;
@@ -48,13 +42,13 @@ private:
 	Poly *next;
 
 public:
-	Poly(Synth *useSynth, Part *usePart);
+	Poly();
+	void setPart(Part *usePart);
 	void reset(unsigned int key, unsigned int velocity, bool sustain, Partial **partials);
 	bool noteOff(bool pedalHeld);
 	bool stopPedalHold();
 	bool startDecay();
 	bool startAbort();
-	void terminate();
 
 	void backupCacheToPartials(PatchCache cache[4]);
 
@@ -67,16 +61,10 @@ public:
 
 	void partialDeactivated(Partial *partial);
 
-	Poly *getNext();
+	Poly *getNext() const;
 	void setNext(Poly *poly);
+}; // class Poly
 
-	void saveState( std::ostream &stream );
-	void loadState( std::istream &stream );
-
-	// savestate debugging
-	void rawVerifyState( char *name, Synth *synth );
-};
-
-}
+} // namespace MT32Emu
 
-#endif /* POLY_H_ */
+#endif // #ifndef MT32EMU_POLY_H
diff --git a/src/mt32/ROMInfo.cpp b/src/mt32/ROMInfo.cpp
index 866b2449..8c813a4e 100644
--- a/src/mt32/ROMInfo.cpp
+++ b/src/mt32/ROMInfo.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -16,41 +16,49 @@
  */
 
 #include <cstring>
+
+#include "internals.h"
+
 #include "ROMInfo.h"
 
 namespace MT32Emu {
 
-// Known ROMs
-static const ROMInfo CTRL_MT32_V1_04 = {65536, "5a5cb5a77d7d55ee69657c2f870416daed52dea7", ROMInfo::Control, "ctrl_mt32_1_04", "MT-32 Control v1.04", ROMInfo::Full, NULL, NULL};
-static const ROMInfo CTRL_MT32_V1_05 = {65536, "e17a3a6d265bf1fa150312061134293d2b58288c", ROMInfo::Control, "ctrl_mt32_1_05", "MT-32 Control v1.05", ROMInfo::Full, NULL, NULL};
-static const ROMInfo CTRL_MT32_V1_06 = {65536, "a553481f4e2794c10cfe597fef154eef0d8257de", ROMInfo::Control, "ctrl_mt32_1_06", "MT-32 Control v1.06", ROMInfo::Full, NULL, NULL};
-static const ROMInfo CTRL_MT32_V1_07 = {65536, "b083518fffb7f66b03c23b7eb4f868e62dc5a987", ROMInfo::Control, "ctrl_mt32_1_07", "MT-32 Control v1.07", ROMInfo::Full, NULL, NULL};
-static const ROMInfo CTRL_MT32_BLUER = {65536, "7b8c2a5ddb42fd0732e2f22b3340dcf5360edf92", ROMInfo::Control, "ctrl_mt32_bluer", "MT-32 Control BlueRidge", ROMInfo::Full, NULL, NULL};
+static const ROMInfo *getKnownROMInfoFromList(Bit32u index) {
+	// Known ROMs
+	static const ROMInfo CTRL_MT32_V1_04 = {65536, "5a5cb5a77d7d55ee69657c2f870416daed52dea7", ROMInfo::Control, "ctrl_mt32_1_04", "MT-32 Control v1.04", ROMInfo::Full, NULL};
+	static const ROMInfo CTRL_MT32_V1_05 = {65536, "e17a3a6d265bf1fa150312061134293d2b58288c", ROMInfo::Control, "ctrl_mt32_1_05", "MT-32 Control v1.05", ROMInfo::Full, NULL};
+	static const ROMInfo CTRL_MT32_V1_06 = {65536, "a553481f4e2794c10cfe597fef154eef0d8257de", ROMInfo::Control, "ctrl_mt32_1_06", "MT-32 Control v1.06", ROMInfo::Full, NULL};
+	static const ROMInfo CTRL_MT32_V1_07 = {65536, "b083518fffb7f66b03c23b7eb4f868e62dc5a987", ROMInfo::Control, "ctrl_mt32_1_07", "MT-32 Control v1.07", ROMInfo::Full, NULL};
+	static const ROMInfo CTRL_MT32_BLUER = {65536, "7b8c2a5ddb42fd0732e2f22b3340dcf5360edf92", ROMInfo::Control, "ctrl_mt32_bluer", "MT-32 Control BlueRidge", ROMInfo::Full, NULL};
 
-static const ROMInfo CTRL_CM32L_V1_00 = {65536, "73683d585cd6948cc19547942ca0e14a0319456d", ROMInfo::Control, "ctrl_cm32l_1_00", "CM-32L/LAPC-I Control v1.00", ROMInfo::Full, NULL, NULL};
-static const ROMInfo CTRL_CM32L_V1_02 = {65536, "a439fbb390da38cada95a7cbb1d6ca199cd66ef8", ROMInfo::Control, "ctrl_cm32l_1_02", "CM-32L/LAPC-I Control v1.02", ROMInfo::Full, NULL, NULL};
+	static const ROMInfo CTRL_MT32_V2_04 = {131072, "2c16432b6c73dd2a3947cba950a0f4c19d6180eb", ROMInfo::Control, "ctrl_mt32_2_04", "MT-32 Control v2.04", ROMInfo::Full, NULL};
+	static const ROMInfo CTRL_CM32L_V1_00 = {65536, "73683d585cd6948cc19547942ca0e14a0319456d", ROMInfo::Control, "ctrl_cm32l_1_00", "CM-32L/LAPC-I Control v1.00", ROMInfo::Full, NULL};
+	static const ROMInfo CTRL_CM32L_V1_02 = {65536, "a439fbb390da38cada95a7cbb1d6ca199cd66ef8", ROMInfo::Control, "ctrl_cm32l_1_02", "CM-32L/LAPC-I Control v1.02", ROMInfo::Full, NULL};
 
-static const ROMInfo PCM_MT32 = {524288, "f6b1eebc4b2d200ec6d3d21d51325d5b48c60252", ROMInfo::PCM, "pcm_mt32", "MT-32 PCM ROM", ROMInfo::Full, NULL, NULL};
-static const ROMInfo PCM_CM32L = {1048576, "289cc298ad532b702461bfc738009d9ebe8025ea", ROMInfo::PCM, "pcm_cm32l", "CM-32L/CM-64/LAPC-I PCM ROM", ROMInfo::Full, NULL, NULL};
+	static const ROMInfo PCM_MT32 = {524288, "f6b1eebc4b2d200ec6d3d21d51325d5b48c60252", ROMInfo::PCM, "pcm_mt32", "MT-32 PCM ROM", ROMInfo::Full, NULL};
+	static const ROMInfo PCM_CM32L = {1048576, "289cc298ad532b702461bfc738009d9ebe8025ea", ROMInfo::PCM, "pcm_cm32l", "CM-32L/CM-64/LAPC-I PCM ROM", ROMInfo::Full, NULL};
 
-static const ROMInfo * const ROM_INFOS[] = {
+	static const ROMInfo * const ROM_INFOS[] = {
 		&CTRL_MT32_V1_04,
 		&CTRL_MT32_V1_05,
 		&CTRL_MT32_V1_06,
 		&CTRL_MT32_V1_07,
 		&CTRL_MT32_BLUER,
+		&CTRL_MT32_V2_04,
 		&CTRL_CM32L_V1_00,
 		&CTRL_CM32L_V1_02,
 		&PCM_MT32,
 		&PCM_CM32L,
 		NULL};
 
+	return ROM_INFOS[index];
+}
+
 const ROMInfo* ROMInfo::getROMInfo(File *file) {
 	size_t fileSize = file->getSize();
-	const char *fileDigest = file->getSHA1();
-	for (int i = 0; ROM_INFOS[i] != NULL; i++) {
-		const ROMInfo *romInfo = ROM_INFOS[i];
-		if (fileSize == romInfo->fileSize && !strcmp(fileDigest, romInfo->sha1Digest)) {
+	for (Bit32u i = 0; getKnownROMInfoFromList(i) != NULL; i++) {
+		const ROMInfo *romInfo = getKnownROMInfoFromList(i);
+		if (fileSize == romInfo->fileSize && !strcmp(file->getSHA1(), romInfo->sha1Digest)) {
 			return romInfo;
 		}
 	}
@@ -61,18 +69,18 @@ void ROMInfo::freeROMInfo(const ROMInfo *romInfo) {
 	(void) romInfo;
 }
 
-static int getROMCount() {
-	int count;
-	for(count = 0; ROM_INFOS[count] != NULL; count++) {
+static Bit32u getROMCount() {
+	Bit32u count;
+	for(count = 0; getKnownROMInfoFromList(count) != NULL; count++) {
 	}
 	return count;
 }
 
-const ROMInfo** ROMInfo::getROMInfoList(unsigned int types, unsigned int pairTypes) {
+const ROMInfo** ROMInfo::getROMInfoList(Bit32u types, Bit32u pairTypes) {
 	const ROMInfo **romInfoList = new const ROMInfo*[getROMCount() + 1];
 	const ROMInfo **currentROMInList = romInfoList;
-	for(int i = 0; ROM_INFOS[i] != NULL; i++) {
-		const ROMInfo *romInfo = ROM_INFOS[i];
+	for (Bit32u i = 0; getKnownROMInfoFromList(i) != NULL; i++) {
+		const ROMInfo *romInfo = getKnownROMInfoFromList(i);
 		if ((types & (1 << romInfo->type)) && (pairTypes & (1 << romInfo->pairType))) {
 			*currentROMInList++ = romInfo;
 		}
@@ -85,19 +93,21 @@ void ROMInfo::freeROMInfoList(const ROMInfo **romInfoList) {
 	delete[] romInfoList;
 }
 
+ROMImage::ROMImage(File *useFile) : file(useFile), romInfo(ROMInfo::getROMInfo(file))
+{}
+
+ROMImage::~ROMImage() {
+	ROMInfo::freeROMInfo(romInfo);
+}
+
 const ROMImage* ROMImage::makeROMImage(File *file) {
-	ROMImage *romImage = new ROMImage;
-	romImage->file = file;
-	romImage->romInfo = ROMInfo::getROMInfo(romImage->file);
-	return romImage;
+	return new ROMImage(file);
 }
 
 void ROMImage::freeROMImage(const ROMImage *romImage) {
-	ROMInfo::freeROMInfo(romImage->romInfo);
 	delete romImage;
 }
 
-
 File* ROMImage::getFile() const {
 	return file;
 }
@@ -106,4 +116,4 @@ const ROMInfo* ROMImage::getROMInfo() const {
 	return romInfo;
 }
 
-}
+} // namespace MT32Emu
diff --git a/src/mt32/ROMInfo.h b/src/mt32/ROMInfo.h
index 53ae5aff..cd4a1c5a 100644
--- a/src/mt32/ROMInfo.h
+++ b/src/mt32/ROMInfo.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -19,6 +19,8 @@
 #define MT32EMU_ROMINFO_H
 
 #include <cstddef>
+
+#include "globals.h"
 #include "File.h"
 
 namespace MT32Emu {
@@ -28,50 +30,51 @@ namespace MT32Emu {
 struct ROMInfo {
 public:
 	size_t fileSize;
-	const char *sha1Digest;
+	const File::SHA1Digest &sha1Digest;
 	enum Type {PCM, Control, Reverb} type;
 	const char *shortName;
 	const char *description;
 	enum PairType {Full, FirstHalf, SecondHalf, Mux0, Mux1} pairType;
 	ROMInfo *pairROMInfo;
-	void *controlROMInfo;
 
 	// Returns a ROMInfo struct by inspecting the size and the SHA1 hash
-	static const ROMInfo* getROMInfo(File *file);
+	MT32EMU_EXPORT static const ROMInfo* getROMInfo(File *file);
 
 	// Currently no-op
-	static void freeROMInfo(const ROMInfo *romInfo);
+	MT32EMU_EXPORT static void freeROMInfo(const ROMInfo *romInfo);
 
 	// Allows retrieving a NULL-terminated list of ROMInfos for a range of types and pairTypes
 	// (specified by bitmasks)
 	// Useful for GUI/console app to output information on what ROMs it supports
-	static const ROMInfo** getROMInfoList(unsigned int types, unsigned int pairTypes);
+	MT32EMU_EXPORT static const ROMInfo** getROMInfoList(Bit32u types, Bit32u pairTypes);
 
 	// Frees the list of ROMInfos given
-	static void freeROMInfoList(const ROMInfo **romInfos);
+	MT32EMU_EXPORT static void freeROMInfoList(const ROMInfo **romInfos);
 };
 
 // Synth::open() is to require a full control ROMImage and a full PCM ROMImage to work
 
 class ROMImage {
 private:
-	File *file;
-	const ROMInfo *romInfo;
+	File * const file;
+	const ROMInfo * const romInfo;
 
-public:
+	ROMImage(File *file);
+	~ROMImage();
 
+public:
 	// Creates a ROMImage object given a ROMInfo and a File. Keeps a reference
 	// to the File and ROMInfo given, which must be freed separately by the user
 	// after the ROMImage is freed
-	static const ROMImage* makeROMImage(File *file);
+	MT32EMU_EXPORT static const ROMImage* makeROMImage(File *file);
 
 	// Must only be done after all Synths using the ROMImage are deleted
-	static void freeROMImage(const ROMImage *romImage);
+	MT32EMU_EXPORT static void freeROMImage(const ROMImage *romImage);
 
-	File *getFile() const;
-	const ROMInfo *getROMInfo() const;
+	MT32EMU_EXPORT File *getFile() const;
+	MT32EMU_EXPORT const ROMInfo *getROMInfo() const;
 };
 
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_ROMINFO_H
diff --git a/src/mt32/SampleRateConverter.cpp b/src/mt32/SampleRateConverter.cpp
new file mode 100644
index 00000000..73f7963e
--- /dev/null
+++ b/src/mt32/SampleRateConverter.cpp
@@ -0,0 +1,126 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cstddef>
+
+#include "SampleRateConverter.h"
+
+#if MT32EMU_WITH_LIBSOXR_RESAMPLER
+#include "srchelper/SoxrAdapter.h"
+#elif MT32EMU_WITH_LIBSAMPLERATE_RESAMPLER
+#include "srchelper/SamplerateAdapter.h"
+#elif MT32EMU_WITH_INTERNAL_RESAMPLER
+#include "srchelper/InternalResampler.h"
+#endif
+
+#include "Synth.h"
+
+using namespace MT32Emu;
+
+static inline void *createDelegate(Synth &synth, double targetSampleRate, SamplerateConversionQuality quality) {
+#if MT32EMU_WITH_LIBSOXR_RESAMPLER
+	return new SoxrAdapter(synth, targetSampleRate, quality);
+#elif MT32EMU_WITH_LIBSAMPLERATE_RESAMPLER
+	return new SamplerateAdapter(synth, targetSampleRate, quality);
+#elif MT32EMU_WITH_INTERNAL_RESAMPLER
+	return new InternalResampler(synth, targetSampleRate, quality);
+#else
+	(void)synth, (void)targetSampleRate, (void)quality;
+	return NULL;
+#endif
+}
+
+AnalogOutputMode SampleRateConverter::getBestAnalogOutputMode(double targetSampleRate) {
+	if (Synth::getStereoOutputSampleRate(AnalogOutputMode_ACCURATE) < targetSampleRate) {
+		return AnalogOutputMode_OVERSAMPLED;
+	} else if (Synth::getStereoOutputSampleRate(AnalogOutputMode_COARSE) < targetSampleRate) {
+		return AnalogOutputMode_ACCURATE;
+	}
+	return AnalogOutputMode_COARSE;
+}
+
+double SampleRateConverter::getSupportedOutputSampleRate(double desiredSampleRate) {
+#if MT32EMU_WITH_LIBSOXR_RESAMPLER || MT32EMU_WITH_LIBSAMPLERATE_RESAMPLER || MT32EMU_WITH_INTERNAL_RESAMPLER
+	return desiredSampleRate > 0 ? desiredSampleRate : 0;
+#else
+	(void)desiredSampleRate;
+	return 0;
+#endif
+}
+
+SampleRateConverter::SampleRateConverter(Synth &useSynth, double targetSampleRate, SamplerateConversionQuality useQuality) :
+	synthInternalToTargetSampleRateRatio(SAMPLE_RATE / targetSampleRate),
+	useSynthDelegate(useSynth.getStereoOutputSampleRate() == targetSampleRate),
+	srcDelegate(useSynthDelegate ? &useSynth : createDelegate(useSynth, targetSampleRate, useQuality))
+{}
+
+SampleRateConverter::~SampleRateConverter() {
+	if (!useSynthDelegate) {
+#if MT32EMU_WITH_LIBSOXR_RESAMPLER
+		delete static_cast<SoxrAdapter *>(srcDelegate);
+#elif MT32EMU_WITH_LIBSAMPLERATE_RESAMPLER
+		delete static_cast<SamplerateAdapter *>(srcDelegate);
+#elif MT32EMU_WITH_INTERNAL_RESAMPLER
+		delete static_cast<InternalResampler *>(srcDelegate);
+#endif
+	}
+}
+
+void SampleRateConverter::getOutputSamples(float *buffer, unsigned int length) {
+	if (useSynthDelegate) {
+		static_cast<Synth *>(srcDelegate)->render(buffer, length);
+		return;
+	}
+
+#if MT32EMU_WITH_LIBSOXR_RESAMPLER
+	static_cast<SoxrAdapter *>(srcDelegate)->getOutputSamples(buffer, length);
+#elif MT32EMU_WITH_LIBSAMPLERATE_RESAMPLER
+	static_cast<SamplerateAdapter *>(srcDelegate)->getOutputSamples(buffer, length);
+#elif MT32EMU_WITH_INTERNAL_RESAMPLER
+	static_cast<InternalResampler *>(srcDelegate)->getOutputSamples(buffer, length);
+#else
+	Synth::muteSampleBuffer(buffer, length);
+#endif
+}
+
+void SampleRateConverter::getOutputSamples(Bit16s *outBuffer, unsigned int length) {
+	static const unsigned int CHANNEL_COUNT = 2;
+
+	if (useSynthDelegate) {
+		static_cast<Synth *>(srcDelegate)->render(outBuffer, length);
+		return;
+	}
+
+	float floatBuffer[CHANNEL_COUNT * MAX_SAMPLES_PER_RUN];
+	while (length > 0) {
+		const unsigned int size = MAX_SAMPLES_PER_RUN < length ? MAX_SAMPLES_PER_RUN : length;
+		getOutputSamples(floatBuffer, size);
+		float *outs = floatBuffer;
+		float *ends = floatBuffer + CHANNEL_COUNT * size;
+		while (outs < ends) {
+			*(outBuffer++) = Synth::convertSample(*(outs++));
+		}
+		length -= size;
+	}
+}
+
+double SampleRateConverter::convertOutputToSynthTimestamp(double outputTimestamp) const {
+	return outputTimestamp * synthInternalToTargetSampleRateRatio;
+}
+
+double SampleRateConverter::convertSynthToOutputTimestamp(double synthTimestamp) const {
+	return synthTimestamp / synthInternalToTargetSampleRateRatio;
+}
diff --git a/src/mt32/SampleRateConverter.h b/src/mt32/SampleRateConverter.h
new file mode 100644
index 00000000..e8950111
--- /dev/null
+++ b/src/mt32/SampleRateConverter.h
@@ -0,0 +1,75 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_SAMPLE_RATE_CONVERTER_H
+#define MT32EMU_SAMPLE_RATE_CONVERTER_H
+
+#include "globals.h"
+#include "Types.h"
+#include "Enumerations.h"
+
+namespace MT32Emu {
+
+class Synth;
+
+/* SampleRateConverter class allows to convert the synthesiser output to any desired sample rate.
+ * It processes the completely mixed stereo output signal as it passes the analogue circuit emulation,
+ * so emulating the synthesiser output signal passing further through an ADC.
+ * Several conversion quality options are provided which allow to trade-off the conversion speed vs. the passband width.
+ * All the options except FASTEST guarantee full suppression of the aliasing noise in terms of the 16-bit integer samples.
+ */
+class MT32EMU_EXPORT SampleRateConverter {
+public:
+	// Returns the value of AnalogOutputMode for which the output signal may retain its full frequency spectrum
+	// at the sample rate specified by the targetSampleRate argument.
+	static AnalogOutputMode getBestAnalogOutputMode(double targetSampleRate);
+
+	// Returns the sample rate supported by the sample rate conversion implementation currently in effect
+	// that is closest to the one specified by the desiredSampleRate argument.
+	static double getSupportedOutputSampleRate(double desiredSampleRate);
+
+	// Creates a SampleRateConverter instance that converts output signal from the synth to the given sample rate
+	// with the specified conversion quality.
+	SampleRateConverter(Synth &synth, double targetSampleRate, SamplerateConversionQuality quality);
+	~SampleRateConverter();
+
+	// Fills the provided output buffer with the results of the sample rate conversion.
+	// The input samples are automatically retrieved from the synth as necessary.
+	void getOutputSamples(MT32Emu::Bit16s *buffer, unsigned int length);
+
+	// Fills the provided output buffer with the results of the sample rate conversion.
+	// The input samples are automatically retrieved from the synth as necessary.
+	void getOutputSamples(float *buffer, unsigned int length);
+
+	// Returns the number of samples produced at the internal synth sample rate (32000 Hz)
+	// that correspond to the number of samples at the target sample rate.
+	// Intended to facilitate audio time synchronisation.
+	double convertOutputToSynthTimestamp(double outputTimestamp) const;
+
+	// Returns the number of samples produced at the target sample rate
+	// that correspond to the number of samples at the internal synth sample rate (32000 Hz).
+	// Intended to facilitate audio time synchronisation.
+	double convertSynthToOutputTimestamp(double synthTimestamp) const;
+
+private:
+	const double synthInternalToTargetSampleRateRatio;
+	const bool useSynthDelegate;
+	void * const srcDelegate;
+}; // class SampleRateConverter
+
+} // namespace MT32Emu
+
+#endif // MT32EMU_SAMPLE_RATE_CONVERTER_H
diff --git a/src/mt32/Structures.h b/src/mt32/Structures.h
index 43d2d1f2..d116aaeb 100644
--- a/src/mt32/Structures.h
+++ b/src/mt32/Structures.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,6 +18,9 @@
 #ifndef MT32EMU_STRUCTURES_H
 #define MT32EMU_STRUCTURES_H
 
+#include "globals.h"
+#include "Types.h"
+
 namespace MT32Emu {
 
 // MT32EMU_MEMADDR() converts from sysex-padded, MT32EMU_SYSEXMEMADDR converts to it
@@ -31,13 +34,6 @@ namespace MT32Emu {
 #define MT32EMU_ALIGN_PACKED __attribute__((packed))
 #endif
 
-typedef unsigned int       Bit32u;
-typedef   signed int       Bit32s;
-typedef unsigned short int Bit16u;
-typedef   signed short int Bit16s;
-typedef unsigned char      Bit8u;
-typedef   signed char      Bit8s;
-
 // The following structures represent the MT-32's memory
 // Since sysex allows this memory to be written to in blocks of bytes,
 // we keep this packed so that we can copy data into the various
@@ -109,8 +105,8 @@ struct TimbreParam {
 			Bit8u envTime[5]; // 0-100
 			Bit8u envLevel[4]; // 0-100 // [3]: SUSTAIN LEVEL
 		} MT32EMU_ALIGN_PACKED tva;
-	} MT32EMU_ALIGN_PACKED partial[4];
-} MT32EMU_ALIGN_PACKED;
+	} MT32EMU_ALIGN_PACKED partial[4]; // struct PartialParam
+} MT32EMU_ALIGN_PACKED; // struct TimbreParam
 
 struct PatchParam {
 	Bit8u timbreGroup; // TIMBRE GROUP  0-3 (group A, group B, Memory, Rhythm)
@@ -170,7 +166,16 @@ struct MemParams {
 		Bit8u chanAssign[9]; // MIDI CHANNEL (PART1) 0-16 (1-16,OFF)
 		Bit8u masterVol; // MASTER VOLUME 0-100
 	} MT32EMU_ALIGN_PACKED system;
-};
+}; // struct MemParams
+
+struct SoundGroup {
+	Bit8u timbreNumberTableAddrLow;
+	Bit8u timbreNumberTableAddrHigh;
+	Bit8u displayPosition;
+	Bit8u name[9];
+	Bit8u timbreCount;
+	Bit8u pad;
+} MT32EMU_ALIGN_PACKED;
 
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #pragma pack(pop)
@@ -178,7 +183,52 @@ struct MemParams {
 #pragma pack()
 #endif
 
-struct ControlROMPCMStruct;
+struct ControlROMFeatureSet {
+	unsigned int quirkBasePitchOverflow : 1;
+	unsigned int quirkPitchEnvelopeOverflow : 1;
+	unsigned int quirkRingModulationNoMix : 1;
+	unsigned int quirkTVAZeroEnvLevels : 1;
+	unsigned int quirkPanMult : 1;
+	unsigned int quirkKeyShift : 1;
+	unsigned int quirkTVFBaseCutoffLimit : 1;
+
+	// Features below don't actually depend on control ROM version, which is used to identify hardware model
+	unsigned int defaultReverbMT32Compatible : 1;
+	unsigned int oldMT32AnalogLPF : 1;
+};
+
+struct ControlROMMap {
+	const char *shortName;
+	const ControlROMFeatureSet &featureSet;
+	Bit16u pcmTable; // 4 * pcmCount bytes
+	Bit16u pcmCount;
+	Bit16u timbreAMap; // 128 bytes
+	Bit16u timbreAOffset;
+	bool timbreACompressed;
+	Bit16u timbreBMap; // 128 bytes
+	Bit16u timbreBOffset;
+	bool timbreBCompressed;
+	Bit16u timbreRMap; // 2 * timbreRCount bytes
+	Bit16u timbreRCount;
+	Bit16u rhythmSettings; // 4 * rhythmSettingsCount bytes
+	Bit16u rhythmSettingsCount;
+	Bit16u reserveSettings; // 9 bytes
+	Bit16u panSettings; // 8 bytes
+	Bit16u programSettings; // 8 bytes
+	Bit16u rhythmMaxTable; // 4 bytes
+	Bit16u patchMaxTable; // 16 bytes
+	Bit16u systemMaxTable; // 23 bytes
+	Bit16u timbreMaxTable; // 72 bytes
+	Bit16u soundGroupsTable; // 14 bytes each entry
+	Bit16u soundGroupsCount;
+};
+
+struct ControlROMPCMStruct {
+	Bit8u pos;
+	Bit8u len;
+	Bit8u pitchLSB;
+	Bit8u pitchMSB;
+};
 
 struct PCMWaveEntry {
 	Bit32u addr;
@@ -192,7 +242,7 @@ struct PatchCache {
 	bool playPartial;
 	bool PCMPartial;
 	int pcm;
-	char waveform;
+	Bit8u waveform;
 
 	Bit32u structureMix;
 	int structurePosition;
@@ -210,8 +260,6 @@ struct PatchCache {
 	const TimbreParam::PartialParam *partialParam;
 };
 
-class Partial; // Forward reference for class defined in partial.h
-
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_STRUCTURES_H
diff --git a/src/mt32/Synth.cpp b/src/mt32/Synth.cpp
index 72f63835..62810ba3 100644
--- a/src/mt32/Synth.cpp
+++ b/src/mt32/Synth.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,136 +15,227 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <cerrno>
-#include <cmath>
-#include <cstdlib>
-#include <cstring>
-#include <stdexcept>
-#include <exception>
+#include <cstdio>
 
-#include "mt32emu.h"
-#include "mmath.h"
-#include "PartialManager.h"
+#include "internals.h"
 
-#if MT32EMU_USE_REVERBMODEL == 1
-#include "AReverbModel.h"
-#elif MT32EMU_USE_REVERBMODEL == 2
+#include "Synth.h"
+#include "Analog.h"
 #include "BReverbModel.h"
-#else
-#include "FreeverbModel.h"
+#include "File.h"
+#include "MemoryRegion.h"
+#include "MidiEventQueue.h"
+#include "Part.h"
+#include "Partial.h"
+#include "PartialManager.h"
+#include "Poly.h"
+#include "ROMInfo.h"
+#include "TVA.h"
+
+#if MT32EMU_MONITOR_SYSEX > 0
+#include "mmath.h"
 #endif
-#include "DelayReverb.h"
 
 namespace MT32Emu {
 
-static const ControlROMMap ControlROMMaps[7] = {
-	// ID    IDc IDbytes                     PCMmap  PCMc  tmbrA   tmbrAO, tmbrAC tmbrB   tmbrBO, tmbrBC tmbrR   trC  rhythm  rhyC  rsrv    panpot  prog    rhyMax  patMax  sysMax  timMax
-	{0x4014, 22, "\000 ver1.04 14 July 87 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x73A6,  85,  0x57C7, 0x57E2, 0x57D0, 0x5252, 0x525E, 0x526E, 0x520A},
-	{0x4014, 22, "\000 ver1.05 06 Aug, 87 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x7414,  85,  0x57C7, 0x57E2, 0x57D0, 0x5252, 0x525E, 0x526E, 0x520A},
-	{0x4014, 22, "\000 ver1.06 31 Aug, 87 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x7414,  85,  0x57D9, 0x57F4, 0x57E2, 0x5264, 0x5270, 0x5280, 0x521C},
-	{0x4010, 22, "\000 ver1.07 10 Oct, 87 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x73fe,  85,  0x57B1, 0x57CC, 0x57BA, 0x523C, 0x5248, 0x5258, 0x51F4}, // MT-32 revision 1
-	{0x4010, 22, "\000verX.XX  30 Sep, 88 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x741C,  85,  0x57E5, 0x5800, 0x57EE, 0x5270, 0x527C, 0x528C, 0x5228}, // MT-32 Blue Ridge mod
-	{0x2205, 22, "\000CM32/LAPC1.00 890404", 0x8100,  256, 0x8000, 0x8000, false, 0x8080, 0x8000, false, 0x8500,  64, 0x8580,  85,  0x4F65, 0x4F80, 0x4F6E, 0x48A1, 0x48A5, 0x48BE, 0x48D5},
-	{0x2205, 22, "\000CM32/LAPC1.02 891205", 0x8100,  256, 0x8000, 0x8000, true,  0x8080, 0x8000, true,  0x8500,  64, 0x8580,  85,  0x4F93, 0x4FAE, 0x4F9C, 0x48CB, 0x48CF, 0x48E8, 0x48FF}  // CM-32L
-	// (Note that all but CM-32L ROM actually have 86 entries for rhythmTemp)
+// MIDI interface data transfer rate in samples. Used to simulate the transfer delay.
+static const double MIDI_DATA_TRANSFER_RATE = double(SAMPLE_RATE) / 31250.0 * 8.0;
+
+// FIXME: there should be more specific feature sets for various MT-32 control ROM versions
+static const ControlROMFeatureSet OLD_MT32_COMPATIBLE = {
+	true, // quirkBasePitchOverflow
+	true, // quirkPitchEnvelopeOverflow
+	true, // quirkRingModulationNoMix
+	true, // quirkTVAZeroEnvLevels
+	true, // quirkPanMult
+	true, // quirkKeyShift
+	true, // quirkTVFBaseCutoffLimit
+	true, // defaultReverbMT32Compatible
+	true // oldMT32AnalogLPF
+};
+static const ControlROMFeatureSet CM32L_COMPATIBLE = {
+	false, // quirkBasePitchOverflow
+	false, // quirkPitchEnvelopeOverflow
+	false, // quirkRingModulationNoMix
+	false, // quirkTVAZeroEnvLevels
+	false, // quirkPanMult
+	false, // quirkKeyShift
+	false, // quirkTVFBaseCutoffLimit
+	false, // defaultReverbMT32Compatible
+	false // oldMT32AnalogLPF
+};
+
+static const ControlROMMap ControlROMMaps[8] = {
+	//     ID                Features        PCMmap  PCMc  tmbrA  tmbrAO, tmbrAC tmbrB   tmbrBO  tmbrBC tmbrR   trC rhythm rhyC  rsrv   panpot   prog   rhyMax  patMax  sysMax  timMax  sndGrp sGC
+	{ "ctrl_mt32_1_04", OLD_MT32_COMPATIBLE, 0x3000, 128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200, 30, 0x73A6, 85, 0x57C7, 0x57E2, 0x57D0, 0x5252, 0x525E, 0x526E, 0x520A, 0x7064, 19 },
+	{ "ctrl_mt32_1_05", OLD_MT32_COMPATIBLE, 0x3000, 128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200, 30, 0x7414, 85, 0x57C7, 0x57E2, 0x57D0, 0x5252, 0x525E, 0x526E, 0x520A, 0x70CA, 19 },
+	{ "ctrl_mt32_1_06", OLD_MT32_COMPATIBLE, 0x3000, 128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200, 30, 0x7414, 85, 0x57D9, 0x57F4, 0x57E2, 0x5264, 0x5270, 0x5280, 0x521C, 0x70CA, 19 },
+	{ "ctrl_mt32_1_07", OLD_MT32_COMPATIBLE, 0x3000, 128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200, 30, 0x73fe, 85, 0x57B1, 0x57CC, 0x57BA, 0x523C, 0x5248, 0x5258, 0x51F4, 0x70B0, 19 }, // MT-32 revision 1
+	{"ctrl_mt32_bluer", OLD_MT32_COMPATIBLE, 0x3000, 128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200, 30, 0x741C, 85, 0x57E5, 0x5800, 0x57EE, 0x5270, 0x527C, 0x528C, 0x5228, 0x70CE, 19 }, // MT-32 Blue Ridge mod
+	{"ctrl_mt32_2_04",   CM32L_COMPATIBLE,   0x8100, 128, 0x8000, 0x8000, true,  0x8080, 0x8000, true,  0x8500, 30, 0x8580, 85, 0x4F5D, 0x4F78, 0x4F66, 0x4899, 0x489D, 0x48B6, 0x48CD, 0x5A58, 19 },
+	{"ctrl_cm32l_1_00",  CM32L_COMPATIBLE,   0x8100, 256, 0x8000, 0x8000, true,  0x8080, 0x8000, true,  0x8500, 64, 0x8580, 85, 0x4F65, 0x4F80, 0x4F6E, 0x48A1, 0x48A5, 0x48BE, 0x48D5, 0x5A6C, 19 },
+	{"ctrl_cm32l_1_02",  CM32L_COMPATIBLE,   0x8100, 256, 0x8000, 0x8000, true,  0x8080, 0x8000, true,  0x8500, 64, 0x8580, 85, 0x4F93, 0x4FAE, 0x4F9C, 0x48CB, 0x48CF, 0x48E8, 0x48FF, 0x5A96, 19 }  // CM-32L
+	// (Note that old MT-32 ROMs actually have 86 entries for rhythmTemp)
+};
+
+static const PartialState PARTIAL_PHASE_TO_STATE[8] = {
+	PartialState_ATTACK, PartialState_ATTACK, PartialState_ATTACK, PartialState_ATTACK,
+	PartialState_SUSTAIN, PartialState_SUSTAIN, PartialState_RELEASE, PartialState_INACTIVE
 };
 
-static inline Bit16s *streamOffset(Bit16s *stream, Bit32u pos) {
-	return stream == NULL ? NULL : stream + pos;
+static inline PartialState getPartialState(PartialManager *partialManager, unsigned int partialNum) {
+	const Partial *partial = partialManager->getPartial(partialNum);
+	return partial->isActive() ? PARTIAL_PHASE_TO_STATE[partial->getTVA()->getPhase()] : PartialState_INACTIVE;
 }
 
-static inline void clearIfNonNull(Bit16s *stream, Bit32u len) {
-	if (stream != NULL) {
-		memset(stream, 0, len * sizeof(Bit16s));
+template <class I, class O>
+static inline void convertSampleFormat(const I *inBuffer, O *outBuffer, const Bit32u len) {
+	if (inBuffer == NULL || outBuffer == NULL) return;
+
+	const I *inBufferEnd = inBuffer + len;
+	while (inBuffer < inBufferEnd) {
+		*(outBuffer++) = Synth::convertSample(*(inBuffer++));
 	}
 }
 
-static inline void mix(float *target, const float *stream, Bit32u len) {
-	while (len--) {
-		*target += *stream;
-		stream++;
-		target++;
+class Renderer {
+protected:
+	Synth &synth;
+
+	void printDebug(const char *msg) const {
+		synth.printDebug("%s", msg);
 	}
-}
 
-static inline void clearFloats(float *leftBuf, float *rightBuf, Bit32u len) {
-	// FIXME: Use memset() where compatibility is guaranteed (if this turns out to be a win)
-	while (len--) {
-		*leftBuf++ = 0.0f;
-		*rightBuf++ = 0.0f;
+	bool isActivated() const {
+		return synth.activated;
 	}
-}
 
-static inline Bit16s clipBit16s(Bit32s a) {
-	// Clamp values above 32767 to 32767, and values below -32768 to -32768
-	if ((a + 32768) & ~65535) {
-		return (a >> 31) ^ 32767;
+	bool isAbortingPoly() const {
+		return synth.isAbortingPoly();
 	}
-	return a;
-}
 
-static void floatToBit16s_nice(Bit16s *target, const float *source, Bit32u len, float outputGain) {
-	float gain = outputGain * 16384.0f;
-	while (len--) {
-		// Since we're not shooting for accuracy here, don't worry about the rounding mode.
-		*target = clipBit16s((Bit32s)(*source * gain));
-		source++;
-		target++;
+	Analog &getAnalog() const {
+		return *synth.analog;
 	}
-}
 
-static void floatToBit16s_pure(Bit16s *target, const float *source, Bit32u len, float /*outputGain*/) {
-	while (len--) {
-		*target = clipBit16s((Bit32s)floor(*source * 8192.0f));
-		source++;
-		target++;
+	MidiEventQueue &getMidiQueue() {
+		return *synth.midiQueue;
 	}
-}
 
-static void floatToBit16s_reverb(Bit16s *target, const float *source, Bit32u len, float outputGain) {
-	float gain = outputGain * 8192.0f;
-	while (len--) {
-		*target = clipBit16s((Bit32s)floor(*source * gain));
-		source++;
-		target++;
+	PartialManager &getPartialManager() {
+		return *synth.partialManager;
 	}
-}
 
-static void floatToBit16s_generation1(Bit16s *target, const float *source, Bit32u len, float outputGain) {
-	float gain = outputGain * 8192.0f;
-	while (len--) {
-		*target = clipBit16s((Bit32s)floor(*source * gain));
-		*target = (*target & 0x8000) | ((*target << 1) & 0x7FFE);
-		source++;
-		target++;
+	BReverbModel &getReverbModel() {
+		return *synth.reverbModel;
+	}
+
+	Bit32u getRenderedSampleCount() {
+		return synth.renderedSampleCount;
 	}
-}
 
-static void floatToBit16s_generation2(Bit16s *target, const float *source, Bit32u len, float outputGain) {
-	float gain = outputGain * 8192.0f;
-	while (len--) {
-		*target = clipBit16s((Bit32s)floor(*source * gain));
-		*target = (*target & 0x8000) | ((*target << 1) & 0x7FFE) | ((*target >> 14) & 0x0001);
-		source++;
-		target++;
+	void incRenderedSampleCount(const Bit32u count) {
+		synth.renderedSampleCount += count;
 	}
+
+public:
+	Renderer(Synth &useSynth) : synth(useSynth) {}
+
+	virtual ~Renderer() {}
+
+	virtual void render(IntSample *stereoStream, Bit32u len) = 0;
+	virtual void render(FloatSample *stereoStream, Bit32u len) = 0;
+	virtual void renderStreams(const DACOutputStreams<IntSample> &streams, Bit32u len) = 0;
+	virtual void renderStreams(const DACOutputStreams<FloatSample> &streams, Bit32u len) = 0;
+};
+
+template <class Sample>
+class RendererImpl : public Renderer {
+	// These buffers are used for building the output streams as they are found at the DAC entrance.
+	// The output is mixed down to stereo interleaved further in the analog circuitry emulation.
+	Sample tmpNonReverbLeft[MAX_SAMPLES_PER_RUN], tmpNonReverbRight[MAX_SAMPLES_PER_RUN];
+	Sample tmpReverbDryLeft[MAX_SAMPLES_PER_RUN], tmpReverbDryRight[MAX_SAMPLES_PER_RUN];
+	Sample tmpReverbWetLeft[MAX_SAMPLES_PER_RUN], tmpReverbWetRight[MAX_SAMPLES_PER_RUN];
+
+	const DACOutputStreams<Sample> tmpBuffers;
+	DACOutputStreams<Sample> createTmpBuffers() {
+		DACOutputStreams<Sample> buffers = {
+			tmpNonReverbLeft, tmpNonReverbRight,
+			tmpReverbDryLeft, tmpReverbDryRight,
+			tmpReverbWetLeft, tmpReverbWetRight
+		};
+		return buffers;
+	}
+
+public:
+	RendererImpl(Synth &useSynth) :
+		Renderer(useSynth),
+		tmpBuffers(createTmpBuffers())
+	{}
+
+	void render(IntSample *stereoStream, Bit32u len);
+	void render(FloatSample *stereoStream, Bit32u len);
+	void renderStreams(const DACOutputStreams<IntSample> &streams, Bit32u len);
+	void renderStreams(const DACOutputStreams<FloatSample> &streams, Bit32u len);
+
+	template <class O>
+	void doRenderAndConvert(O *stereoStream, Bit32u len);
+	void doRender(Sample *stereoStream, Bit32u len);
+
+	template <class O>
+	void doRenderAndConvertStreams(const DACOutputStreams<O> &streams, Bit32u len);
+	void doRenderStreams(const DACOutputStreams<Sample> &streams, Bit32u len);
+	void produceLA32Output(Sample *buffer, Bit32u len);
+	void convertSamplesToOutput(Sample *buffer, Bit32u len);
+	void produceStreams(const DACOutputStreams<Sample> &streams, Bit32u len);
+};
+
+class Extensions {
+public:
+	RendererType selectedRendererType;
+	Bit32s masterTunePitchDelta;
+	bool niceAmpRamp;
+
+	// Here we keep the reverse mapping of assigned parts per MIDI channel.
+	// NOTE: value above 8 means that the channel is not assigned
+	Bit8u chantable[16][9];
+
+	// This stores the index of Part in chantable that failed to play and required partial abortion.
+	Bit32u abortingPartIx;
+};
+
+Bit32u Synth::getLibraryVersionInt() {
+	return (MT32EMU_VERSION_MAJOR << 16) | (MT32EMU_VERSION_MINOR << 8) | (MT32EMU_VERSION_PATCH);
+}
+
+const char *Synth::getLibraryVersionString() {
+	return MT32EMU_VERSION;
 }
 
-Bit8u Synth::calcSysexChecksum(const Bit8u *data, Bit32u len, Bit8u checksum) {
+Bit8u Synth::calcSysexChecksum(const Bit8u *data, const Bit32u len, const Bit8u initChecksum) {
+	unsigned int checksum = -initChecksum;
 	for (unsigned int i = 0; i < len; i++) {
-		checksum = checksum + data[i];
-	}
-	checksum = checksum & 0x7f;
-	if (checksum) {
-		checksum = 0x80 - checksum;
+		checksum -= data[i];
 	}
-	return checksum;
+	return Bit8u(checksum & 0x7f);
+}
+
+Bit32u Synth::getStereoOutputSampleRate(AnalogOutputMode analogOutputMode) {
+	static const unsigned int SAMPLE_RATES[] = {SAMPLE_RATE, SAMPLE_RATE, SAMPLE_RATE * 3 / 2, SAMPLE_RATE * 3};
+
+	return SAMPLE_RATES[analogOutputMode];
 }
 
-Synth::Synth(ReportHandler *useReportHandler) {
-	isOpen = false;
-	reverbEnabled = true;
+Synth::Synth(ReportHandler *useReportHandler) :
+	mt32ram(*new MemParams),
+	mt32default(*new MemParams),
+	extensions(*new Extensions)
+{
+	opened = false;
 	reverbOverridden = false;
+	partialCount = DEFAULT_MAX_PARTIALS;
+	controlROMMap = NULL;
+	controlROMFeatures = NULL;
 
 	if (useReportHandler == NULL) {
 		reportHandler = new ReportHandler;
@@ -154,91 +245,109 @@ Synth::Synth(ReportHandler *useReportHandler) {
 		isDefaultReportHandler = false;
 	}
 
-#if MT32EMU_USE_REVERBMODEL == 1
-	reverbModels[REVERB_MODE_ROOM] = new AReverbModel(REVERB_MODE_ROOM);
-	reverbModels[REVERB_MODE_HALL] = new AReverbModel(REVERB_MODE_HALL);
-	reverbModels[REVERB_MODE_PLATE] = new AReverbModel(REVERB_MODE_PLATE);
-	reverbModels[REVERB_MODE_TAP_DELAY] = new DelayReverb();
-#elif MT32EMU_USE_REVERBMODEL == 2
-	reverbModels[REVERB_MODE_ROOM] = new BReverbModel(REVERB_MODE_ROOM);
-	reverbModels[REVERB_MODE_HALL] = new BReverbModel(REVERB_MODE_HALL);
-	reverbModels[REVERB_MODE_PLATE] = new BReverbModel(REVERB_MODE_PLATE);
-	reverbModels[REVERB_MODE_TAP_DELAY] = new BReverbModel(REVERB_MODE_TAP_DELAY);
-#else
-	reverbModels[REVERB_MODE_ROOM] = new FreeverbModel(0.76f, 0.687770909f, 0.63f, 0, 0.5f);
-	reverbModels[REVERB_MODE_HALL] = new FreeverbModel(2.0f, 0.712025098f, 0.86f, 1, 0.5f);
-	reverbModels[REVERB_MODE_PLATE] = new FreeverbModel(0.4f, 0.939522749f, 0.38f, 2, 0.05f);
-	reverbModels[REVERB_MODE_TAP_DELAY] = new DelayReverb();
-#endif
-
+	for (int i = 0; i < 4; i++) {
+		reverbModels[i] = NULL;
+	}
 	reverbModel = NULL;
+	analog = NULL;
+	renderer = NULL;
 	setDACInputMode(DACInputMode_NICE);
+	setMIDIDelayMode(MIDIDelayMode_DELAY_SHORT_MESSAGES_ONLY);
 	setOutputGain(1.0f);
-	setReverbOutputGain(0.68f);
+	setReverbOutputGain(1.0f);
+	setReversedStereoEnabled(false);
+	setNiceAmpRampEnabled(true);
+	selectRendererType(RendererType_BIT16S);
+
+	patchTempMemoryRegion = NULL;
+	rhythmTempMemoryRegion = NULL;
+	timbreTempMemoryRegion = NULL;
+	patchesMemoryRegion = NULL;
+	timbresMemoryRegion = NULL;
+	systemMemoryRegion = NULL;
+	displayMemoryRegion = NULL;
+	resetMemoryRegion = NULL;
+	paddedTimbreMaxTable = NULL;
+
 	partialManager = NULL;
+	pcmWaves = NULL;
+	pcmROMData = NULL;
+	soundGroupNames = NULL;
+	midiQueue = NULL;
+	lastReceivedMIDIEventTimestamp = 0;
 	memset(parts, 0, sizeof(parts));
 	renderedSampleCount = 0;
-
-	partialLimit = MT32EMU_MAX_PARTIALS;
 }
 
 Synth::~Synth() {
 	close(); // Make sure we're closed and everything is freed
-	for (int i = 0; i < 4; i++) {
-		delete reverbModels[i];
-	}
 	if (isDefaultReportHandler) {
 		delete reportHandler;
 	}
+	delete &mt32ram;
+	delete &mt32default;
+	delete &extensions;
 }
 
 void ReportHandler::showLCDMessage(const char *data) {
-	printf("WRITE-LCD: %s", data);
-	printf("\n");
+	printf("WRITE-LCD: %s\n", data);
 }
 
 void ReportHandler::printDebug(const char *fmt, va_list list) {
-		vprintf(fmt, list);
-		printf("\n");
-}
-
-void Synth::partStateChanged(int partNum, bool isPartActive) {
-	reportHandler->onPartStateChanged(partNum, isPartActive);
-}
-
-void Synth::polyStateChanged(int partNum) {
-	reportHandler->onPolyStateChanged(partNum);
+	vprintf(fmt, list);
+	printf("\n");
 }
 
-void Synth::partialStateChanged(const Partial * const partial, int oldPartialPhase, int newPartialPhase) {
-	for (unsigned int i = 0; i < getPartialLimit(); i++) {
-		if (getPartial(i) == partial) {
-			reportHandler->onPartialStateChanged(i, oldPartialPhase, newPartialPhase);
-			break;
-		}
+void Synth::newTimbreSet(Bit8u partNum, Bit8u timbreGroup, Bit8u timbreNumber, const char patchName[]) {
+	const char *soundGroupName;
+	switch (timbreGroup) {
+	case 1:
+		timbreNumber += 64;
+		// Fall-through
+	case 0:
+		soundGroupName = soundGroupNames[soundGroupIx[timbreNumber]];
+		break;
+	case 2:
+		soundGroupName = soundGroupNames[controlROMMap->soundGroupsCount - 2];
+		break;
+	case 3:
+		soundGroupName = soundGroupNames[controlROMMap->soundGroupsCount - 1];
+		break;
+	default:
+		soundGroupName = NULL;
+		break;
 	}
-}
-
-void Synth::newTimbreSet(int partNum, char patchName[]) {
-	reportHandler->onProgramChanged(partNum, patchName);
+	reportHandler->onProgramChanged(partNum, soundGroupName, patchName);
 }
 
 void Synth::printDebug(const char *fmt, ...) {
 	va_list ap;
 	va_start(ap, fmt);
 #if MT32EMU_DEBUG_SAMPLESTAMPS > 0
-	reportHandler->printDebug("[%u] ", renderedSampleCount);
+	reportHandler->printDebug("[%u]", (va_list)&renderedSampleCount);
 #endif
 	reportHandler->printDebug(fmt, ap);
 	va_end(ap);
 }
 
 void Synth::setReverbEnabled(bool newReverbEnabled) {
-	reverbEnabled = newReverbEnabled;
+	if (!opened) return;
+	if (isReverbEnabled() == newReverbEnabled) return;
+	if (newReverbEnabled) {
+		bool oldReverbOverridden = reverbOverridden;
+		reverbOverridden = false;
+		refreshSystemReverbParameters();
+		reverbOverridden = oldReverbOverridden;
+	} else {
+#if MT32EMU_REDUCE_REVERB_MEMORY
+		reverbModel->close();
+#endif
+		reverbModel = NULL;
+	}
 }
 
 bool Synth::isReverbEnabled() const {
-	return reverbEnabled;
+	return reverbModel != NULL;
 }
 
 void Synth::setReverbOverridden(bool newReverbOverridden) {
@@ -249,45 +358,90 @@ bool Synth::isReverbOverridden() const {
 	return reverbOverridden;
 }
 
-void Synth::setDACInputMode(DACInputMode mode) {
-	switch(mode) {
-	case DACInputMode_GENERATION1:
-		la32FloatToBit16sFunc = floatToBit16s_generation1;
-		reverbFloatToBit16sFunc = floatToBit16s_reverb;
-		break;
-	case DACInputMode_GENERATION2:
-		la32FloatToBit16sFunc = floatToBit16s_generation2;
-		reverbFloatToBit16sFunc = floatToBit16s_reverb;
-		break;
-	case DACInputMode_PURE:
-		la32FloatToBit16sFunc = floatToBit16s_pure;
-		reverbFloatToBit16sFunc = floatToBit16s_pure;
-		break;
-	case DACInputMode_NICE:
-	default:
-		la32FloatToBit16sFunc = floatToBit16s_nice;
-		reverbFloatToBit16sFunc = floatToBit16s_reverb;
-		break;
+void Synth::setReverbCompatibilityMode(bool mt32CompatibleMode) {
+	if (!opened || (isMT32ReverbCompatibilityMode() == mt32CompatibleMode)) return;
+	bool oldReverbEnabled = isReverbEnabled();
+	setReverbEnabled(false);
+	for (int i = 0; i < 4; i++) {
+		delete reverbModels[i];
 	}
+	initReverbModels(mt32CompatibleMode);
+	setReverbEnabled(oldReverbEnabled);
+	setReverbOutputGain(reverbOutputGain);
+}
+
+bool Synth::isMT32ReverbCompatibilityMode() const {
+	return opened && (reverbModels[REVERB_MODE_ROOM]->isMT32Compatible(REVERB_MODE_ROOM));
+}
+
+bool Synth::isDefaultReverbMT32Compatible() const {
+	return opened && controlROMFeatures->defaultReverbMT32Compatible;
+}
+
+void Synth::setDACInputMode(DACInputMode mode) {
+	dacInputMode = mode;
+}
+
+DACInputMode Synth::getDACInputMode() const {
+	return dacInputMode;
+}
+
+void Synth::setMIDIDelayMode(MIDIDelayMode mode) {
+	midiDelayMode = mode;
+}
+
+MIDIDelayMode Synth::getMIDIDelayMode() const {
+	return midiDelayMode;
 }
 
 void Synth::setOutputGain(float newOutputGain) {
+	if (newOutputGain < 0.0f) newOutputGain = -newOutputGain;
 	outputGain = newOutputGain;
+	if (analog != NULL) analog->setSynthOutputGain(newOutputGain);
+}
+
+float Synth::getOutputGain() const {
+	return outputGain;
 }
 
 void Synth::setReverbOutputGain(float newReverbOutputGain) {
+	if (newReverbOutputGain < 0.0f) newReverbOutputGain = -newReverbOutputGain;
 	reverbOutputGain = newReverbOutputGain;
+	if (analog != NULL) analog->setReverbOutputGain(newReverbOutputGain, isMT32ReverbCompatibilityMode());
+}
+
+float Synth::getReverbOutputGain() const {
+	return reverbOutputGain;
+}
+
+void Synth::setReversedStereoEnabled(bool enabled) {
+	reversedStereoEnabled = enabled;
+}
+
+bool Synth::isReversedStereoEnabled() const {
+	return reversedStereoEnabled;
+}
+
+void Synth::setNiceAmpRampEnabled(bool enabled) {
+	extensions.niceAmpRamp = enabled;
+}
+
+bool Synth::isNiceAmpRampEnabled() const {
+	return extensions.niceAmpRamp;
 }
 
 bool Synth::loadControlROM(const ROMImage &controlROMImage) {
-	if (&controlROMImage == NULL) return false;
 	File *file = controlROMImage.getFile();
 	const ROMInfo *controlROMInfo = controlROMImage.getROMInfo();
 	if ((controlROMInfo == NULL)
 			|| (controlROMInfo->type != ROMInfo::Control)
 			|| (controlROMInfo->pairType != ROMInfo::Full)) {
+#if MT32EMU_MONITOR_INIT
+		printDebug("Invalid Control ROM Info provided");
+#endif
 		return false;
 	}
+
 #if MT32EMU_MONITOR_INIT
 	printDebug("Found Control ROM: %s, %s", controlROMInfo->shortName, controlROMInfo->description);
 #endif
@@ -296,9 +450,11 @@ bool Synth::loadControlROM(const ROMImage &controlROMImage) {
 
 	// Control ROM successfully loaded, now check whether it's a known type
 	controlROMMap = NULL;
+	controlROMFeatures = NULL;
 	for (unsigned int i = 0; i < sizeof(ControlROMMaps) / sizeof(ControlROMMaps[0]); i++) {
-		if (memcmp(&controlROMData[ControlROMMaps[i].idPos], ControlROMMaps[i].idBytes, ControlROMMaps[i].idLen) == 0) {
+		if (strcmp(controlROMInfo->shortName, ControlROMMaps[i].shortName) == 0) {
 			controlROMMap = &ControlROMMaps[i];
+			controlROMFeatures = &controlROMMap->featureSet;
 			return true;
 		}
 	}
@@ -309,7 +465,6 @@ bool Synth::loadControlROM(const ROMImage &controlROMImage) {
 }
 
 bool Synth::loadPCMROM(const ROMImage &pcmROMImage) {
-	if (&pcmROMImage == NULL) return false;
 	File *file = pcmROMImage.getFile();
 	const ROMInfo *pcmROMInfo = pcmROMImage.getROMInfo();
 	if ((pcmROMInfo == NULL)
@@ -334,7 +489,7 @@ bool Synth::loadPCMROM(const ROMImage &pcmROMImage) {
 
 		int order[16] = {0, 9, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 8};
 
-		signed short log = 0;
+		Bit16s log = 0;
 		for (int u = 0; u < 15; u++) {
 			int bit;
 			if (order[u] < 8) {
@@ -342,7 +497,7 @@ bool Synth::loadPCMROM(const ROMImage &pcmROMImage) {
 			} else {
 				bit = (c >> (7 - (order[u] - 8))) & 0x1;
 			}
-			log = log | (short)(bit << (15 - u));
+			log = log | Bit16s(bit << (15 - u));
 		}
 		pcmROMData[i] = log;
 	}
@@ -350,11 +505,11 @@ bool Synth::loadPCMROM(const ROMImage &pcmROMImage) {
 }
 
 bool Synth::initPCMList(Bit16u mapAddress, Bit16u count) {
-	ControlROMPCMStruct *tps = (ControlROMPCMStruct *)&controlROMData[mapAddress];
+	ControlROMPCMStruct *tps = reinterpret_cast<ControlROMPCMStruct *>(&controlROMData[mapAddress]);
 	for (int i = 0; i < count; i++) {
-		size_t rAddr = tps[i].pos * 0x800;
-		size_t rLenExp = (tps[i].len & 0x70) >> 4;
-		size_t rLen = 0x800 << rLenExp;
+		Bit32u rAddr = tps[i].pos * 0x800;
+		Bit32u rLenExp = (tps[i].len & 0x70) >> 4;
+		Bit32u rLen = 0x800 << rLenExp;
 		if (rAddr + rLen > pcmROMSize) {
 			printDebug("Control ROM error: Wave map entry %d points to invalid PCM address 0x%04X, length 0x%04X", i, rAddr, rLen);
 			return false;
@@ -370,7 +525,7 @@ bool Synth::initPCMList(Bit16u mapAddress, Bit16u count) {
 	return false;
 }
 
-bool Synth::initCompressedTimbre(int timbreNum, const Bit8u *src, unsigned int srcLen) {
+bool Synth::initCompressedTimbre(Bit16u timbreNum, const Bit8u *src, Bit32u srcLen) {
 	// "Compressed" here means that muted partials aren't present in ROM (except in the case of partial 0 being muted).
 	// Instead the data from the previous unmuted partial is used.
 	if (srcLen < sizeof(TimbreParam::CommonParam)) {
@@ -394,7 +549,7 @@ bool Synth::initCompressedTimbre(int timbreNum, const Bit8u *src, unsigned int s
 	return true;
 }
 
-bool Synth::initTimbres(Bit16u mapAddress, Bit16u offset, int count, int startTimbre, bool compressed) {
+bool Synth::initTimbres(Bit16u mapAddress, Bit16u offset, Bit16u count, Bit16u startTimbre, bool compressed) {
 	const Bit8u *timbreMap = &controlROMData[mapAddress];
 	for (Bit16u i = 0; i < count * 2; i += 2) {
 		Bit16u address = (timbreMap[i + 1] << 8) | timbreMap[i];
@@ -416,19 +571,37 @@ bool Synth::initTimbres(Bit16u mapAddress, Bit16u offset, int count, int startTi
 	return true;
 }
 
-bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage) {
-	if (isOpen) {
-		return false;
-	}
-	prerenderReadIx = prerenderWriteIx = 0;
-#if MT32EMU_MONITOR_INIT
-	printDebug("Initialising Constant Tables");
-#endif
+void Synth::initReverbModels(bool mt32CompatibleMode) {
+	reverbModels[REVERB_MODE_ROOM] = BReverbModel::createBReverbModel(REVERB_MODE_ROOM, mt32CompatibleMode, getSelectedRendererType());
+	reverbModels[REVERB_MODE_HALL] = BReverbModel::createBReverbModel(REVERB_MODE_HALL, mt32CompatibleMode, getSelectedRendererType());
+	reverbModels[REVERB_MODE_PLATE] = BReverbModel::createBReverbModel(REVERB_MODE_PLATE, mt32CompatibleMode, getSelectedRendererType());
+	reverbModels[REVERB_MODE_TAP_DELAY] = BReverbModel::createBReverbModel(REVERB_MODE_TAP_DELAY, mt32CompatibleMode, getSelectedRendererType());
 #if !MT32EMU_REDUCE_REVERB_MEMORY
-	for (int i = 0; i < 4; i++) {
-		reverbModels[i]->open(useProp.sampleRate);
+	for (int i = REVERB_MODE_ROOM; i <= REVERB_MODE_TAP_DELAY; i++) {
+		reverbModels[i]->open();
 	}
 #endif
+}
+
+void Synth::initSoundGroups(char newSoundGroupNames[][9]) {
+	memcpy(soundGroupIx, &controlROMData[controlROMMap->soundGroupsTable - sizeof(soundGroupIx)], sizeof(soundGroupIx));
+	const SoundGroup *table = reinterpret_cast<SoundGroup *>(&controlROMData[controlROMMap->soundGroupsTable]);
+	for (unsigned int i = 0; i < controlROMMap->soundGroupsCount; i++) {
+		memcpy(&newSoundGroupNames[i][0], table[i].name, sizeof(table[i].name));
+	}
+}
+
+bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage, AnalogOutputMode analogOutputMode) {
+	return open(controlROMImage, pcmROMImage, DEFAULT_MAX_PARTIALS, analogOutputMode);
+}
+
+bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage, Bit32u usePartialCount, AnalogOutputMode analogOutputMode) {
+	if (opened) {
+		return false;
+	}
+	partialCount = usePartialCount;
+	abortingPoly = NULL;
+	extensions.abortingPartIx = 0;
 
 	// This is to help detect bugs
 	memset(&mt32ram, '?', sizeof(mt32ram));
@@ -439,6 +612,7 @@ bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage) {
 	if (!loadControlROM(controlROMImage)) {
 		printDebug("Init Error - Missing or invalid Control ROM image");
 		reportHandler->onErrorControlROM();
+		dispose();
 		return false;
 	}
 
@@ -456,13 +630,24 @@ bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage) {
 	if (!loadPCMROM(pcmROMImage)) {
 		printDebug("Init Error - Missing PCM ROM image");
 		reportHandler->onErrorPCMROM();
+		dispose();
 		return false;
 	}
 
+#if MT32EMU_MONITOR_INIT
+	printDebug("Initialising Reverb Models");
+#endif
+	bool mt32CompatibleReverb = controlROMFeatures->defaultReverbMT32Compatible;
+#if MT32EMU_MONITOR_INIT
+	printDebug("Using %s Compatible Reverb Models", mt32CompatibleReverb ? "MT-32" : "CM-32L");
+#endif
+	initReverbModels(mt32CompatibleReverb);
+
 #if MT32EMU_MONITOR_INIT
 	printDebug("Initialising Timbre Bank A");
 #endif
 	if (!initTimbres(controlROMMap->timbreAMap, controlROMMap->timbreAOffset, 0x40, 0, controlROMMap->timbreACompressed)) {
+		dispose();
 		return false;
 	}
 
@@ -470,6 +655,7 @@ bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage) {
 	printDebug("Initialising Timbre Bank B");
 #endif
 	if (!initTimbres(controlROMMap->timbreBMap, controlROMMap->timbreBOffset, 0x40, 64, controlROMMap->timbreBCompressed)) {
+		dispose();
 		return false;
 	}
 
@@ -477,6 +663,7 @@ bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage) {
 	printDebug("Initialising Timbre Bank R");
 #endif
 	if (!initTimbres(controlROMMap->timbreRMap, 0, controlROMMap->timbreRCount, 192, true)) {
+		dispose();
 		return false;
 	}
 
@@ -532,7 +719,16 @@ bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage) {
 		mt32ram.system.chanAssign[i] = i + 1;
 	}
 	mt32ram.system.masterVol = 100; // Confirmed
+
+	bool oldReverbOverridden = reverbOverridden;
+	reverbOverridden = false;
 	refreshSystem();
+	resetMasterTunePitchDelta();
+	reverbOverridden = oldReverbOverridden;
+
+	char(*writableSoundGroupNames)[9] = new char[controlROMMap->soundGroupsCount][9];
+	soundGroupNames = writableSoundGroupNames;
+	initSoundGroups(writableSoundGroupNames);
 
 	for (int i = 0; i < 9; i++) {
 		MemParams::PatchTemp *patchTemp = &mt32ram.patchTemp[i];
@@ -563,8 +759,37 @@ bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage) {
 	// For resetting mt32 mid-execution
 	mt32default = mt32ram;
 
-	isOpen = true;
-	isEnabled = false;
+	midiQueue = new MidiEventQueue();
+
+	analog = Analog::createAnalog(analogOutputMode, controlROMFeatures->oldMT32AnalogLPF, getSelectedRendererType());
+#if MT32EMU_MONITOR_INIT
+	static const char *ANALOG_OUTPUT_MODES[] = { "Digital only", "Coarse", "Accurate", "Oversampled2x" };
+	printDebug("Using Analog output mode %s", ANALOG_OUTPUT_MODES[analogOutputMode]);
+#endif
+	setOutputGain(outputGain);
+	setReverbOutputGain(reverbOutputGain);
+
+	switch (getSelectedRendererType()) {
+		case RendererType_BIT16S:
+			renderer = new RendererImpl<IntSample>(*this);
+#if MT32EMU_MONITOR_INIT
+			printDebug("Using integer 16-bit samples in renderer and wave generator");
+#endif
+			break;
+		case RendererType_FLOAT:
+			renderer = new RendererImpl<FloatSample>(*this);
+#if MT32EMU_MONITOR_INIT
+			printDebug("Using float 32-bit samples in renderer and wave generator");
+#endif
+			break;
+		default:
+			printDebug("Synth: Unknown renderer type %i\n", getSelectedRendererType());
+			dispose();
+			return false;
+	}
+
+	opened = true;
+	activated = false;
 
 #if MT32EMU_MONITOR_INIT
 	printDebug("*** Initialisation complete ***");
@@ -572,10 +797,17 @@ bool Synth::open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage) {
 	return true;
 }
 
-void Synth::close() {
-	if (!isOpen) {
-		return;
-	}
+void Synth::dispose() {
+	opened = false;
+
+	delete midiQueue;
+	midiQueue = NULL;
+
+	delete renderer;
+	renderer = NULL;
+
+	delete analog;
+	analog = NULL;
 
 	delete partialManager;
 	partialManager = NULL;
@@ -585,46 +817,178 @@ void Synth::close() {
 		parts[i] = NULL;
 	}
 
+	delete[] soundGroupNames;
+	soundGroupNames = NULL;
+
 	delete[] pcmWaves;
+	pcmWaves = NULL;
+
 	delete[] pcmROMData;
+	pcmROMData = NULL;
 
 	deleteMemoryRegions();
 
 	for (int i = 0; i < 4; i++) {
-		reverbModels[i]->close();
+		delete reverbModels[i];
+		reverbModels[i] = NULL;
 	}
 	reverbModel = NULL;
-	isOpen = false;
+	controlROMFeatures = NULL;
+	controlROMMap = NULL;
+}
+
+void Synth::close() {
+	if (opened) {
+		dispose();
+	}
+}
+
+bool Synth::isOpen() const {
+	return opened;
+}
+
+void Synth::flushMIDIQueue() {
+	if (midiQueue != NULL) {
+		for (;;) {
+			const MidiEvent *midiEvent = midiQueue->peekMidiEvent();
+			if (midiEvent == NULL) break;
+			if (midiEvent->sysexData == NULL) {
+				playMsgNow(midiEvent->shortMessageData);
+			} else {
+				playSysexNow(midiEvent->sysexData, midiEvent->sysexLength);
+			}
+			midiQueue->dropMidiEvent();
+		}
+		lastReceivedMIDIEventTimestamp = renderedSampleCount;
+	}
+}
+
+Bit32u Synth::setMIDIEventQueueSize(Bit32u useSize) {
+	static const Bit32u MAX_QUEUE_SIZE = (1 << 24); // This results in about 256 Mb - much greater than any reasonable value
+
+	if (midiQueue == NULL) return 0;
+	flushMIDIQueue();
+
+	// Find a power of 2 that is >= useSize
+	Bit32u binarySize = 1;
+	if (useSize < MAX_QUEUE_SIZE) {
+		// Using simple linear search as this isn't time critical
+		while (binarySize < useSize) binarySize <<= 1;
+	} else {
+		binarySize = MAX_QUEUE_SIZE;
+	}
+	delete midiQueue;
+	midiQueue = new MidiEventQueue(binarySize);
+	return binarySize;
+}
+
+Bit32u Synth::getShortMessageLength(Bit32u msg) {
+	if ((msg & 0xF0) == 0xF0) {
+		switch (msg & 0xFF) {
+			case 0xF1:
+			case 0xF3:
+				return 2;
+			case 0xF2:
+				return 3;
+			default:
+				return 1;
+		}
+	}
+	// NOTE: This calculation isn't quite correct
+	// as it doesn't consider the running status byte
+	return ((msg & 0xE0) == 0xC0) ? 2 : 3;
+}
+
+Bit32u Synth::addMIDIInterfaceDelay(Bit32u len, Bit32u timestamp) {
+	Bit32u transferTime =  Bit32u(double(len) * MIDI_DATA_TRANSFER_RATE);
+	// Dealing with wrapping
+	if (Bit32s(timestamp - lastReceivedMIDIEventTimestamp) < 0) {
+		timestamp = lastReceivedMIDIEventTimestamp;
+	}
+	timestamp += transferTime;
+	lastReceivedMIDIEventTimestamp = timestamp;
+	return timestamp;
+}
+
+Bit32u Synth::getInternalRenderedSampleCount() const {
+	return renderedSampleCount;
+}
+
+bool Synth::playMsg(Bit32u msg) {
+	return playMsg(msg, renderedSampleCount);
+}
+
+bool Synth::playMsg(Bit32u msg, Bit32u timestamp) {
+	if ((msg & 0xF8) == 0xF8) {
+		reportHandler->onMIDISystemRealtime(Bit8u(msg & 0xFF));
+		return true;
+	}
+	if (midiQueue == NULL) return false;
+	if (midiDelayMode != MIDIDelayMode_IMMEDIATE) {
+		timestamp = addMIDIInterfaceDelay(getShortMessageLength(msg), timestamp);
+	}
+	if (!activated) activated = true;
+	do {
+		if (midiQueue->pushShortMessage(msg, timestamp)) return true;
+	} while (reportHandler->onMIDIQueueOverflow());
+	return false;
+}
+
+bool Synth::playSysex(const Bit8u *sysex, Bit32u len) {
+	return playSysex(sysex, len, renderedSampleCount);
+}
+
+bool Synth::playSysex(const Bit8u *sysex, Bit32u len, Bit32u timestamp) {
+	if (midiQueue == NULL) return false;
+	if (midiDelayMode == MIDIDelayMode_DELAY_ALL) {
+		timestamp = addMIDIInterfaceDelay(len, timestamp);
+	}
+	if (!activated) activated = true;
+	do {
+		if (midiQueue->pushSysex(sysex, len, timestamp)) return true;
+	} while (reportHandler->onMIDIQueueOverflow());
+	return false;
 }
 
-void Synth::playMsg(Bit32u msg) {
-	// FIXME: Implement active sensing
-	unsigned char code     = (unsigned char)((msg & 0x0000F0) >> 4);
-	unsigned char chan     = (unsigned char)(msg & 0x00000F);
-	unsigned char note     = (unsigned char)((msg & 0x00FF00) >> 8);
-	unsigned char velocity = (unsigned char)((msg & 0xFF0000) >> 16);
-	isEnabled = true;
+void Synth::playMsgNow(Bit32u msg) {
+	if (!opened) return;
+
+	// NOTE: Active sense IS implemented in real hardware. However, realtime processing is clearly out of the library scope.
+	//       It is assumed that realtime consumers of the library respond to these MIDI events as appropriate.
+
+	Bit8u code = Bit8u((msg & 0x0000F0) >> 4);
+	Bit8u chan = Bit8u(msg & 0x00000F);
+	Bit8u note = Bit8u((msg & 0x007F00) >> 8);
+	Bit8u velocity = Bit8u((msg & 0x7F0000) >> 16);
 
 	//printDebug("Playing chan %d, code 0x%01x note: 0x%02x", chan, code, note);
 
-	char part = chantable[chan];
-	if (part < 0 || part > 8) {
+	Bit8u *chanParts = extensions.chantable[chan];
+	if (*chanParts > 8) {
 #if MT32EMU_MONITOR_MIDI > 0
 		printDebug("Play msg on unreg chan %d (%d): code=0x%01x, vel=%d", chan, part, code, velocity);
 #endif
 		return;
 	}
-	playMsgOnPart(part, code, note, velocity);
-
-	// This ensures minimum 1-sample delay between sequential MIDI events
-	// Without this, a sequence of NoteOn and immediately succeeding NoteOff messages is always silent
-	// Technically, it's also impossible to send events through the MIDI interface faster than about each millisecond
-	prerender();
+	for (Bit32u i = extensions.abortingPartIx; i <= 8; i++) {
+		const Bit32u partNum = chanParts[i];
+		if (partNum > 8) break;
+		playMsgOnPart(partNum, code, note, velocity);
+		if (isAbortingPoly()) {
+			extensions.abortingPartIx = i;
+			break;
+		} else if (extensions.abortingPartIx) {
+			extensions.abortingPartIx = 0;
+		}
+	}
 }
 
-void Synth::playMsgOnPart(unsigned char part, unsigned char code, unsigned char note, unsigned char velocity) {
+void Synth::playMsgOnPart(Bit8u part, Bit8u code, Bit8u note, Bit8u velocity) {
+	if (!opened) return;
+
 	Bit32u bend;
 
+	if (!activated) activated = true;
 	//printDebug("Synth::playMsgOnPart(%02x, %02x, %02x, %02x)", part, code, note, velocity);
 	switch (code) {
 	case 0x8:
@@ -701,7 +1065,7 @@ void Synth::playMsgOnPart(unsigned char part, unsigned char code, unsigned char
 #if MT32EMU_MONITOR_MIDI > 0
 			printDebug("Unknown MIDI Control code: 0x%02x - vel 0x%02x", note, velocity);
 #endif
-			break;
+			return;
 		}
 
 		break;
@@ -718,13 +1082,12 @@ void Synth::playMsgOnPart(unsigned char part, unsigned char code, unsigned char
 #if MT32EMU_MONITOR_MIDI > 0
 		printDebug("Unknown Midi code: 0x%01x - %02x - %02x", code, note, velocity);
 #endif
-		break;
+		return;
 	}
-
-	//midiOutShortMsg(m_out, msg);
+	reportHandler->onMIDIMessagePlayed();
 }
 
-void Synth::playSysex(const Bit8u *sysex, Bit32u len) {
+void Synth::playSysexNow(const Bit8u *sysex, Bit32u len) {
 	if (len < 2) {
 		printDebug("playSysex: Message is too short for sysex (%d bytes)", len);
 	}
@@ -752,23 +1115,23 @@ void Synth::playSysexWithoutFraming(const Bit8u *sysex, Bit32u len) {
 		return;
 	}
 	if (sysex[0] != SYSEX_MANUFACTURER_ROLAND) {
-		printDebug("playSysexWithoutFraming: Header not intended for this device manufacturer: %02x %02x %02x %02x", (int)sysex[0], (int)sysex[1], (int)sysex[2], (int)sysex[3]);
+		printDebug("playSysexWithoutFraming: Header not intended for this device manufacturer: %02x %02x %02x %02x", int(sysex[0]), int(sysex[1]), int(sysex[2]), int(sysex[3]));
 		return;
 	}
 	if (sysex[2] == SYSEX_MDL_D50) {
-		printDebug("playSysexWithoutFraming: Header is intended for model D-50 (not yet supported): %02x %02x %02x %02x", (int)sysex[0], (int)sysex[1], (int)sysex[2], (int)sysex[3]);
+		printDebug("playSysexWithoutFraming: Header is intended for model D-50 (not yet supported): %02x %02x %02x %02x", int(sysex[0]), int(sysex[1]), int(sysex[2]), int(sysex[3]));
 		return;
 	} else if (sysex[2] != SYSEX_MDL_MT32) {
-		printDebug("playSysexWithoutFraming: Header not intended for model MT-32: %02x %02x %02x %02x", (int)sysex[0], (int)sysex[1], (int)sysex[2], (int)sysex[3]);
+		printDebug("playSysexWithoutFraming: Header not intended for model MT-32: %02x %02x %02x %02x", int(sysex[0]), int(sysex[1]), int(sysex[2]), int(sysex[3]));
 		return;
 	}
 	playSysexWithoutHeader(sysex[1], sysex[3], sysex + 4, len - 4);
 }
 
-void Synth::playSysexWithoutHeader(unsigned char device, unsigned char command, const Bit8u *sysex, Bit32u len) {
+void Synth::playSysexWithoutHeader(Bit8u device, Bit8u command, const Bit8u *sysex, Bit32u len) {
 	if (device > 0x10) {
 		// We have device ID 0x10 (default, but changeable, on real MT-32), < 0x10 is for channels
-		printDebug("playSysexWithoutHeader: Message is not intended for this device ID (provided: %02x, expected: 0x10 or channel)", (int)device);
+		printDebug("playSysexWithoutHeader: Message is not intended for this device ID (provided: %02x, expected: 0x10 or channel)", int(device));
 		return;
 	}
 	// This is checked early in the real devices (before any sysex length checks or further processing)
@@ -777,24 +1140,38 @@ void Synth::playSysexWithoutHeader(unsigned char device, unsigned char command,
 		reset();
 		return;
 	}
+
+	if (command == SYSEX_CMD_EOD) {
+#if MT32EMU_MONITOR_SYSEX > 0
+		printDebug("playSysexWithoutHeader: Ignored unsupported command %02x", command);
+#endif
+		return;
+	}
 	if (len < 4) {
 		printDebug("playSysexWithoutHeader: Message is too short (%d bytes)!", len);
 		return;
 	}
-	unsigned char checksum = calcSysexChecksum(sysex, len - 1, 0);
+	Bit8u checksum = calcSysexChecksum(sysex, len - 1);
 	if (checksum != sysex[len - 1]) {
 		printDebug("playSysexWithoutHeader: Message checksum is incorrect (provided: %02x, expected: %02x)!", sysex[len - 1], checksum);
 		return;
 	}
 	len -= 1; // Exclude checksum
 	switch (command) {
+	case SYSEX_CMD_WSD:
+#if MT32EMU_MONITOR_SYSEX > 0
+		printDebug("playSysexWithoutHeader: Ignored unsupported command %02x", command);
+#endif
+		break;
 	case SYSEX_CMD_DAT:
+		/* Outcommented until we (ever) actually implement handshake communication
 		if (hasActivePartials()) {
 			printDebug("playSysexWithoutHeader: Got SYSEX_CMD_DAT but partials are active - ignoring");
 			// FIXME: We should send SYSEX_CMD_RJC in this case
 			break;
 		}
-		// Deliberate fall-through
+		*/
+		// Fall-through
 	case SYSEX_CMD_DT1:
 		writeSysex(device, sysex, len);
 		break;
@@ -804,7 +1181,7 @@ void Synth::playSysexWithoutHeader(unsigned char device, unsigned char command,
 			// FIXME: We should send SYSEX_CMD_RJC in this case
 			break;
 		}
-		// Deliberate fall-through
+		// Fall-through
 	case SYSEX_CMD_RQ1:
 		readSysex(device, sysex, len);
 		break;
@@ -814,11 +1191,13 @@ void Synth::playSysexWithoutHeader(unsigned char device, unsigned char command,
 	}
 }
 
-void Synth::readSysex(unsigned char /*device*/, const Bit8u * /*sysex*/, Bit32u /*len*/) const {
+void Synth::readSysex(Bit8u /*device*/, const Bit8u * /*sysex*/, Bit32u /*len*/) const {
 	// NYI
 }
 
-void Synth::writeSysex(unsigned char device, const Bit8u *sysex, Bit32u len) {
+void Synth::writeSysex(Bit8u device, const Bit8u *sysex, Bit32u len) {
+	if (!opened) return;
+	reportHandler->onMIDIMessagePlayed();
 	Bit32u addr = (sysex[0] << 16) | (sysex[1] << 8) | (sysex[2]);
 	addr = MT32EMU_MEMADDR(addr);
 	sysex += 3;
@@ -832,45 +1211,59 @@ void Synth::writeSysex(unsigned char device, const Bit8u *sysex, Bit32u len) {
 		printDebug("WRITE-CHANNEL: Channel %d temp area 0x%06x", device, MT32EMU_SYSEXMEMADDR(addr));
 #endif
 		if (/*addr >= MT32EMU_MEMADDR(0x000000) && */addr < MT32EMU_MEMADDR(0x010000)) {
-			int offset;
-			if (chantable[device] == -1) {
+			addr += MT32EMU_MEMADDR(0x030000);
+			Bit8u *chanParts = extensions.chantable[device];
+			if (*chanParts > 8) {
 #if MT32EMU_MONITOR_SYSEX > 0
 				printDebug(" (Channel not mapped to a part... 0 offset)");
 #endif
-				offset = 0;
-			} else if (chantable[device] == 8) {
+			} else {
+				for (Bit32u partIx = 0; partIx <= 8; partIx++) {
+					if (chanParts[partIx] > 8) break;
+					int offset;
+					if (chanParts[partIx] == 8) {
 #if MT32EMU_MONITOR_SYSEX > 0
-				printDebug(" (Channel mapped to rhythm... 0 offset)");
+						printDebug(" (Channel mapped to rhythm... 0 offset)");
 #endif
-				offset = 0;
-			} else {
-				offset = chantable[device] * sizeof(MemParams::PatchTemp);
+						offset = 0;
+					} else {
+						offset = chanParts[partIx] * sizeof(MemParams::PatchTemp);
 #if MT32EMU_MONITOR_SYSEX > 0
-				printDebug(" (Setting extra offset to %d)", offset);
+						printDebug(" (Setting extra offset to %d)", offset);
 #endif
+					}
+					writeSysexGlobal(addr + offset, sysex, len);
+				}
+				return;
 			}
-			addr += MT32EMU_MEMADDR(0x030000) + offset;
 		} else if (/*addr >= MT32EMU_MEMADDR(0x010000) && */ addr < MT32EMU_MEMADDR(0x020000)) {
 			addr += MT32EMU_MEMADDR(0x030110) - MT32EMU_MEMADDR(0x010000);
 		} else if (/*addr >= MT32EMU_MEMADDR(0x020000) && */ addr < MT32EMU_MEMADDR(0x030000)) {
-			int offset;
-			if (chantable[device] == -1) {
+			addr += MT32EMU_MEMADDR(0x040000) - MT32EMU_MEMADDR(0x020000);
+			Bit8u *chanParts = extensions.chantable[device];
+			if (*chanParts > 8) {
 #if MT32EMU_MONITOR_SYSEX > 0
 				printDebug(" (Channel not mapped to a part... 0 offset)");
 #endif
-				offset = 0;
-			} else if (chantable[device] == 8) {
+			} else {
+				for (Bit32u partIx = 0; partIx <= 8; partIx++) {
+					if (chanParts[partIx] > 8) break;
+					int offset;
+					if (chanParts[partIx] == 8) {
 #if MT32EMU_MONITOR_SYSEX > 0
-				printDebug(" (Channel mapped to rhythm... 0 offset)");
+						printDebug(" (Channel mapped to rhythm... 0 offset)");
 #endif
-				offset = 0;
-			} else {
-				offset = chantable[device] * sizeof(TimbreParam);
+						offset = 0;
+					} else {
+						offset = chanParts[partIx] * sizeof(TimbreParam);
 #if MT32EMU_MONITOR_SYSEX > 0
-				printDebug(" (Setting extra offset to %d)", offset);
+						printDebug(" (Setting extra offset to %d)", offset);
 #endif
+					}
+					writeSysexGlobal(addr + offset, sysex, len);
+				}
+				return;
 			}
-			addr += MT32EMU_MEMADDR(0x040000) - MT32EMU_MEMADDR(0x020000) + offset;
 		} else {
 #if MT32EMU_MONITOR_SYSEX > 0
 			printDebug(" Invalid channel");
@@ -878,8 +1271,11 @@ void Synth::writeSysex(unsigned char device, const Bit8u *sysex, Bit32u len) {
 			return;
 		}
 	}
+	writeSysexGlobal(addr, sysex, len);
+}
 
-	// Process device-global sysex (possibly converted from channel-specific sysex above)
+// Process device-global sysex (possibly converted from channel-specific sysex above)
+void Synth::writeSysexGlobal(Bit32u addr, const Bit8u *sysex, Bit32u len) {
 	for (;;) {
 		// Find the appropriate memory region
 		const MemoryRegion *region = findMemoryRegion(addr);
@@ -901,6 +1297,7 @@ void Synth::writeSysex(unsigned char device, const Bit8u *sysex, Bit32u len) {
 }
 
 void Synth::readMemory(Bit32u addr, Bit32u len, Bit8u *data) {
+	if (!opened) return;
 	const MemoryRegion *region = findMemoryRegion(addr);
 	if (region != NULL) {
 		readMemoryRegion(region, addr, len, data);
@@ -919,12 +1316,12 @@ void Synth::initMemoryRegions() {
 		pos += sizeof(TimbreParam::PartialParam);
 	}
 	memset(&paddedTimbreMaxTable[pos], 0, 10); // Padding
-	patchTempMemoryRegion = new PatchTempMemoryRegion(this, (Bit8u *)&mt32ram.patchTemp[0], &controlROMData[controlROMMap->patchMaxTable]);
-	rhythmTempMemoryRegion = new RhythmTempMemoryRegion(this, (Bit8u *)&mt32ram.rhythmTemp[0], &controlROMData[controlROMMap->rhythmMaxTable]);
-	timbreTempMemoryRegion = new TimbreTempMemoryRegion(this, (Bit8u *)&mt32ram.timbreTemp[0], paddedTimbreMaxTable);
-	patchesMemoryRegion = new PatchesMemoryRegion(this, (Bit8u *)&mt32ram.patches[0], &controlROMData[controlROMMap->patchMaxTable]);
-	timbresMemoryRegion = new TimbresMemoryRegion(this, (Bit8u *)&mt32ram.timbres[0], paddedTimbreMaxTable);
-	systemMemoryRegion = new SystemMemoryRegion(this, (Bit8u *)&mt32ram.system, &controlROMData[controlROMMap->systemMaxTable]);
+	patchTempMemoryRegion = new PatchTempMemoryRegion(this, reinterpret_cast<Bit8u *>(&mt32ram.patchTemp[0]), &controlROMData[controlROMMap->patchMaxTable]);
+	rhythmTempMemoryRegion = new RhythmTempMemoryRegion(this, reinterpret_cast<Bit8u *>(&mt32ram.rhythmTemp[0]), &controlROMData[controlROMMap->rhythmMaxTable]);
+	timbreTempMemoryRegion = new TimbreTempMemoryRegion(this, reinterpret_cast<Bit8u *>(&mt32ram.timbreTemp[0]), paddedTimbreMaxTable);
+	patchesMemoryRegion = new PatchesMemoryRegion(this, reinterpret_cast<Bit8u *>(&mt32ram.patches[0]), &controlROMData[controlROMMap->patchMaxTable]);
+	timbresMemoryRegion = new TimbresMemoryRegion(this, reinterpret_cast<Bit8u *>(&mt32ram.timbres[0]), paddedTimbreMaxTable);
+	systemMemoryRegion = new SystemMemoryRegion(this, reinterpret_cast<Bit8u *>(&mt32ram.system), &controlROMData[controlROMMap->systemMaxTable]);
 	displayMemoryRegion = new DisplayMemoryRegion(this);
 	resetMemoryRegion = new ResetMemoryRegion(this);
 }
@@ -986,7 +1383,7 @@ void Synth::readMemoryRegion(const MemoryRegion *region, Bit32u addr, Bit32u len
 		for (m = 0; m < len; m += 2) {
 			data[m] = 0xff;
 			if (m + 1 < len) {
-				data[m+1] = (Bit8u)region->type;
+				data[m+1] = Bit8u(region->type);
 			}
 		}
 	}
@@ -1194,16 +1591,16 @@ void Synth::writeMemoryRegion(const MemoryRegion *region, Bit32u addr, Bit32u le
 			if(firstPart < 0)
 				firstPart = 0;
 			int lastPart = off + len - SYSTEM_CHAN_ASSIGN_START_OFF;
-			if(lastPart > 9)
-				lastPart = 9;
-			refreshSystemChanAssign(firstPart, lastPart);
+			if(lastPart > 8)
+				lastPart = 8;
+			refreshSystemChanAssign(Bit8u(firstPart), Bit8u(lastPart));
 		}
 		if (off <= SYSTEM_MASTER_VOL_OFF && off + len > SYSTEM_MASTER_VOL_OFF) {
 			refreshSystemMasterVol();
 		}
 		break;
 	case MR_Display:
-		char buf[MAX_SYSEX_SIZE];
+		char buf[SYSEX_BUFFER_SIZE];
 		memcpy(&buf, &data[0], len);
 		buf[len] = 0;
 #if MT32EMU_MONITOR_SYSEX > 0
@@ -1218,6 +1615,8 @@ void Synth::writeMemoryRegion(const MemoryRegion *region, Bit32u addr, Bit32u le
 }
 
 void Synth::refreshSystemMasterTune() {
+	// 171 is ~half a semitone.
+	extensions.masterTunePitchDelta = ((mt32ram.system.masterTune - 64) * 171) >> 6; // PORTABILITY NOTE: Assumes arithmetic shift.
 #if MT32EMU_MONITOR_SYSEX > 0
 	//FIXME:KG: This is just an educated guess.
 	// The LAPC-I documentation claims a range of 427.5Hz-452.6Hz (similar to what we have here)
@@ -1231,7 +1630,7 @@ void Synth::refreshSystemReverbParameters() {
 #if MT32EMU_MONITOR_SYSEX > 0
 	printDebug(" Reverb: mode=%d, time=%d, level=%d", mt32ram.system.reverbMode, mt32ram.system.reverbTime, mt32ram.system.reverbLevel);
 #endif
-	if (reverbOverridden && reverbModel != NULL) {
+	if (reverbOverridden) {
 #if MT32EMU_MONITOR_SYSEX > 0
 		printDebug(" (Reverb overridden - ignoring)");
 #endif
@@ -1241,17 +1640,31 @@ void Synth::refreshSystemReverbParameters() {
 	reportHandler->onNewReverbTime(mt32ram.system.reverbTime);
 	reportHandler->onNewReverbLevel(mt32ram.system.reverbLevel);
 
-	ReverbModel *newReverbModel = reverbModels[mt32ram.system.reverbMode];
+	BReverbModel *oldReverbModel = reverbModel;
+	if (mt32ram.system.reverbTime == 0 && mt32ram.system.reverbLevel == 0) {
+		// Setting both time and level to 0 effectively disables wet reverb output on real devices.
+		// Take a shortcut in this case to reduce CPU load.
+		reverbModel = NULL;
+	} else {
+		reverbModel = reverbModels[mt32ram.system.reverbMode];
+	}
+	if (reverbModel != oldReverbModel) {
 #if MT32EMU_REDUCE_REVERB_MEMORY
-	if (reverbModel != newReverbModel) {
-		if (reverbModel != NULL) {
-			reverbModel->close();
+		if (oldReverbModel != NULL) {
+			oldReverbModel->close();
+		}
+		if (isReverbEnabled()) {
+			reverbModel->open();
+		}
+#else
+		if (isReverbEnabled()) {
+			reverbModel->mute();
 		}
-		newReverbModel->open();
-	}
 #endif
-	reverbModel = newReverbModel;
-	reverbModel->setParameters(mt32ram.system.reverbTime, mt32ram.system.reverbLevel);
+	}
+	if (isReverbEnabled()) {
+		reverbModel->setParameters(mt32ram.system.reverbTime, mt32ram.system.reverbLevel);
+	}
 }
 
 void Synth::refreshSystemReserveSettings() {
@@ -1262,19 +1675,25 @@ void Synth::refreshSystemReserveSettings() {
 	partialManager->setReserve(rset);
 }
 
-void Synth::refreshSystemChanAssign(unsigned int firstPart, unsigned int lastPart) {
-	memset(chantable, -1, sizeof(chantable));
+void Synth::refreshSystemChanAssign(Bit8u firstPart, Bit8u lastPart) {
+	memset(extensions.chantable, 0xFF, sizeof(extensions.chantable));
 
-	// CONFIRMED: In the case of assigning a channel to multiple parts, the lower part wins.
-	for (unsigned int i = 0; i <= 8; i++) {
+	// CONFIRMED: In the case of assigning a MIDI channel to multiple parts,
+	//            the messages received on that MIDI channel are handled by all the parts.
+	for (Bit32u i = 0; i <= 8; i++) {
 		if (parts[i] != NULL && i >= firstPart && i <= lastPart) {
 			// CONFIRMED: Decay is started for all polys, and all controllers are reset, for every part whose assignment was touched by the sysex write.
 			parts[i]->allSoundOff();
 			parts[i]->resetAllControllers();
 		}
-		int chan = mt32ram.system.chanAssign[i];
-		if (chan != 16 && chantable[chan] == -1) {
-			chantable[chan] = i;
+		Bit8u chan = mt32ram.system.chanAssign[i];
+		if (chan > 15) continue;
+		Bit8u *chanParts = extensions.chantable[chan];
+		for (Bit32u j = 0; j <= 8; j++) {
+			if (chanParts[j] > 8) {
+				chanParts[j] = Bit8u(i);
+				break;
+			}
 		}
 	}
 
@@ -1299,6 +1718,7 @@ void Synth::refreshSystem() {
 }
 
 void Synth::reset() {
+	if (!opened) return;
 #if MT32EMU_MONITOR_SYSEX > 0
 	printDebug("RESET");
 #endif
@@ -1314,1005 +1734,667 @@ void Synth::reset() {
 		}
 	}
 	refreshSystem();
-	isEnabled = false;
+	resetMasterTunePitchDelta();
+	isActive();
 }
 
-void Synth::render(Bit16s *stream, Bit32u len) {
-	if (!isEnabled) {
-		memset(stream, 0, len * sizeof(Bit16s) * 2);
-		return;
-	}
-	while (len > 0) {
-		Bit32u thisLen = len > MAX_SAMPLES_PER_RUN ? MAX_SAMPLES_PER_RUN : len;
-		renderStreams(tmpNonReverbLeft, tmpNonReverbRight, tmpReverbDryLeft, tmpReverbDryRight, tmpReverbWetLeft, tmpReverbWetRight, thisLen);
-		for (Bit32u i = 0; i < thisLen; i++) {
-			stream[0] = clipBit16s((Bit32s)tmpNonReverbLeft[i] + (Bit32s)tmpReverbDryLeft[i] + (Bit32s)tmpReverbWetLeft[i]);
-			stream[1] = clipBit16s((Bit32s)tmpNonReverbRight[i] + (Bit32s)tmpReverbDryRight[i] + (Bit32s)tmpReverbWetRight[i]);
-			stream += 2;
-		}
-		len -= thisLen;
+void Synth::resetMasterTunePitchDelta() {
+	// This effectively resets master tune to 440.0Hz.
+	// Despite that the manual claims 442.0Hz is the default setting for master tune,
+	// it doesn't actually take effect upon a reset due to a bug in the reset routine.
+	// CONFIRMED: This bug is present in all supported Control ROMs.
+	extensions.masterTunePitchDelta = 0;
+#if MT32EMU_MONITOR_SYSEX > 0
+	printDebug(" Actual Master Tune reset to 440.0");
+#endif
+}
+
+Bit32s Synth::getMasterTunePitchDelta() const {
+	return extensions.masterTunePitchDelta;
+}
+
+MidiEvent::~MidiEvent() {
+	if (sysexData != NULL) {
+		delete[] sysexData;
 	}
 }
 
-bool Synth::prerender() {
-	int newPrerenderWriteIx = (prerenderWriteIx + 1) % MAX_PRERENDER_SAMPLES;
-	if (newPrerenderWriteIx == prerenderReadIx) {
-		// The prerender buffer is full
-		return false;
+void MidiEvent::setShortMessage(Bit32u useShortMessageData, Bit32u useTimestamp) {
+	if (sysexData != NULL) {
+		delete[] sysexData;
 	}
-	doRenderStreams(
-		prerenderNonReverbLeft + prerenderWriteIx,
-		prerenderNonReverbRight + prerenderWriteIx,
-		prerenderReverbDryLeft + prerenderWriteIx,
-		prerenderReverbDryRight + prerenderWriteIx,
-		prerenderReverbWetLeft + prerenderWriteIx,
-		prerenderReverbWetRight + prerenderWriteIx,
-		1);
-	prerenderWriteIx = newPrerenderWriteIx;
-	return true;
+	shortMessageData = useShortMessageData;
+	timestamp = useTimestamp;
+	sysexData = NULL;
+	sysexLength = 0;
 }
 
-static inline void maybeCopy(Bit16s *out, Bit32u outPos, Bit16s *in, Bit32u inPos, Bit32u len) {
-	if (out == NULL) {
-		return;
+void MidiEvent::setSysex(const Bit8u *useSysexData, Bit32u useSysexLength, Bit32u useTimestamp) {
+	if (sysexData != NULL) {
+		delete[] sysexData;
 	}
-	memcpy(out + outPos, in + inPos, len * sizeof(Bit16s));
+	shortMessageData = 0;
+	timestamp = useTimestamp;
+	sysexLength = useSysexLength;
+	Bit8u *dstSysexData = new Bit8u[sysexLength];
+	sysexData = dstSysexData;
+	memcpy(dstSysexData, useSysexData, sysexLength);
 }
 
-void Synth::copyPrerender(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u pos, Bit32u len) {
-	maybeCopy(nonReverbLeft, pos, prerenderNonReverbLeft, prerenderReadIx, len);
-	maybeCopy(nonReverbRight, pos, prerenderNonReverbRight, prerenderReadIx, len);
-	maybeCopy(reverbDryLeft, pos, prerenderReverbDryLeft, prerenderReadIx, len);
-	maybeCopy(reverbDryRight, pos, prerenderReverbDryRight, prerenderReadIx, len);
-	maybeCopy(reverbWetLeft, pos, prerenderReverbWetLeft, prerenderReadIx, len);
-	maybeCopy(reverbWetRight, pos, prerenderReverbWetRight, prerenderReadIx, len);
+MidiEventQueue::MidiEventQueue(Bit32u useRingBufferSize) : ringBuffer(new MidiEvent[useRingBufferSize]), ringBufferMask(useRingBufferSize - 1) {
+	memset(ringBuffer, 0, useRingBufferSize * sizeof(MidiEvent));
+	reset();
 }
 
-void Synth::checkPrerender(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u &pos, Bit32u &len) {
-	if (prerenderReadIx > prerenderWriteIx) {
-		// There's data in the prerender buffer, and the write index has wrapped.
-		Bit32u prerenderCopyLen = MAX_PRERENDER_SAMPLES - prerenderReadIx;
-		if (prerenderCopyLen > len) {
-			prerenderCopyLen = len;
-		}
-		copyPrerender(nonReverbLeft, nonReverbRight, reverbDryLeft, reverbDryRight, reverbWetLeft, reverbWetRight, pos, prerenderCopyLen);
-		len -= prerenderCopyLen;
-		pos += prerenderCopyLen;
-		prerenderReadIx = (prerenderReadIx + prerenderCopyLen) % MAX_PRERENDER_SAMPLES;
-	}
-	if (prerenderReadIx < prerenderWriteIx) {
-		// There's data in the prerender buffer, and the write index is ahead of the read index.
-		Bit32u prerenderCopyLen = prerenderWriteIx - prerenderReadIx;
-		if (prerenderCopyLen > len) {
-			prerenderCopyLen = len;
-		}
-		copyPrerender(nonReverbLeft, nonReverbRight, reverbDryLeft, reverbDryRight, reverbWetLeft, reverbWetRight, pos, prerenderCopyLen);
-		len -= prerenderCopyLen;
-		pos += prerenderCopyLen;
-		prerenderReadIx += prerenderCopyLen;
-	}
-	if (prerenderReadIx == prerenderWriteIx) {
-		// If the ring buffer's empty, reset it to start at 0 to minimise wrapping,
-		// which requires two writes instead of one.
-		prerenderReadIx = prerenderWriteIx = 0;
-	}
-}
-
-void Synth::renderStreams(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u len) {
-	if (!isEnabled) {
-		clearIfNonNull(nonReverbLeft, len);
-		clearIfNonNull(nonReverbRight, len);
-		clearIfNonNull(reverbDryLeft, len);
-		clearIfNonNull(reverbDryRight, len);
-		clearIfNonNull(reverbWetLeft, len);
-		clearIfNonNull(reverbWetRight, len);
-		return;
-	}
-	Bit32u pos = 0;
-
-	// First, check for data in the prerender buffer and spit that out before generating anything new.
-	// Note that the prerender buffer is rarely used - see comments elsewhere for details.
-	checkPrerender(nonReverbLeft, nonReverbRight, reverbDryLeft, reverbDryRight, reverbWetLeft, reverbWetRight, pos, len);
+MidiEventQueue::~MidiEventQueue() {
+	delete[] ringBuffer;
+}
 
-	while (len > 0) {
-		Bit32u thisLen = len > MAX_SAMPLES_PER_RUN ? MAX_SAMPLES_PER_RUN : len;
-		doRenderStreams(
-			streamOffset(nonReverbLeft, pos),
-			streamOffset(nonReverbRight, pos),
-			streamOffset(reverbDryLeft, pos),
-			streamOffset(reverbDryRight, pos),
-			streamOffset(reverbWetLeft, pos),
-			streamOffset(reverbWetRight, pos),
-			thisLen);
-		len -= thisLen;
-		pos += thisLen;
-	}
+void MidiEventQueue::reset() {
+	startPosition = 0;
+	endPosition = 0;
 }
 
-// FIXME: Using more temporary buffers than we need to
-void Synth::doRenderStreams(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u len) {
-	clearFloats(&tmpBufMixLeft[0], &tmpBufMixRight[0], len);
-	if (!reverbEnabled) {
-		for (unsigned int i = 0; i < getPartialLimit(); i++) {
-			if (partialManager->produceOutput(i, &tmpBufPartialLeft[0], &tmpBufPartialRight[0], len)) {
-				mix(&tmpBufMixLeft[0], &tmpBufPartialLeft[0], len);
-				mix(&tmpBufMixRight[0], &tmpBufPartialRight[0], len);
-			}
-		}
-		if (nonReverbLeft != NULL) {
-			la32FloatToBit16sFunc(nonReverbLeft, &tmpBufMixLeft[0], len, outputGain);
-		}
-		if (nonReverbRight != NULL) {
-			la32FloatToBit16sFunc(nonReverbRight, &tmpBufMixRight[0], len, outputGain);
-		}
-		clearIfNonNull(reverbDryLeft, len);
-		clearIfNonNull(reverbDryRight, len);
-		clearIfNonNull(reverbWetLeft, len);
-		clearIfNonNull(reverbWetRight, len);
-	} else {
-		for (unsigned int i = 0; i < getPartialLimit(); i++) {
-			if (!partialManager->shouldReverb(i)) {
-				if (partialManager->produceOutput(i, &tmpBufPartialLeft[0], &tmpBufPartialRight[0], len)) {
-					mix(&tmpBufMixLeft[0], &tmpBufPartialLeft[0], len);
-					mix(&tmpBufMixRight[0], &tmpBufPartialRight[0], len);
-				}
-			}
-		}
-		if (nonReverbLeft != NULL) {
-			la32FloatToBit16sFunc(nonReverbLeft, &tmpBufMixLeft[0], len, outputGain);
-		}
-		if (nonReverbRight != NULL) {
-			la32FloatToBit16sFunc(nonReverbRight, &tmpBufMixRight[0], len, outputGain);
-		}
+bool MidiEventQueue::pushShortMessage(Bit32u shortMessageData, Bit32u timestamp) {
+	Bit32u newEndPosition = (endPosition + 1) & ringBufferMask;
+	// Is ring buffer full?
+	if (startPosition == newEndPosition) return false;
+	ringBuffer[endPosition].setShortMessage(shortMessageData, timestamp);
+	endPosition = newEndPosition;
+	return true;
+}
 
-		clearFloats(&tmpBufMixLeft[0], &tmpBufMixRight[0], len);
-		for (unsigned int i = 0; i < getPartialLimit(); i++) {
-			if (partialManager->shouldReverb(i)) {
-				if (partialManager->produceOutput(i, &tmpBufPartialLeft[0], &tmpBufPartialRight[0], len)) {
-					mix(&tmpBufMixLeft[0], &tmpBufPartialLeft[0], len);
-					mix(&tmpBufMixRight[0], &tmpBufPartialRight[0], len);
-				}
-			}
-		}
-		if (reverbDryLeft != NULL) {
-			la32FloatToBit16sFunc(reverbDryLeft, &tmpBufMixLeft[0], len, outputGain);
-		}
-		if (reverbDryRight != NULL) {
-			la32FloatToBit16sFunc(reverbDryRight, &tmpBufMixRight[0], len, outputGain);
-		}
+bool MidiEventQueue::pushSysex(const Bit8u *sysexData, Bit32u sysexLength, Bit32u timestamp) {
+	Bit32u newEndPosition = (endPosition + 1) & ringBufferMask;
+	// Is ring buffer full?
+	if (startPosition == newEndPosition) return false;
+	ringBuffer[endPosition].setSysex(sysexData, sysexLength, timestamp);
+	endPosition = newEndPosition;
+	return true;
+}
 
-		// FIXME: Note that on the real devices, reverb input and output are signed linear 16-bit (well, kinda, there's some fudging) PCM, not float.
-		reverbModel->process(&tmpBufMixLeft[0], &tmpBufMixRight[0], &tmpBufReverbOutLeft[0], &tmpBufReverbOutRight[0], len);
-		if (reverbWetLeft != NULL) {
-			reverbFloatToBit16sFunc(reverbWetLeft, &tmpBufReverbOutLeft[0], len, reverbOutputGain);
-		}
-		if (reverbWetRight != NULL) {
-			reverbFloatToBit16sFunc(reverbWetRight, &tmpBufReverbOutRight[0], len, reverbOutputGain);
-		}
-	}
-	partialManager->clearAlreadyOutputed();
-	renderedSampleCount += len;
+const MidiEvent *MidiEventQueue::peekMidiEvent() {
+	return isEmpty() ? NULL : &ringBuffer[startPosition];
 }
 
-void Synth::printPartialUsage(unsigned long sampleOffset) {
-	unsigned int partialUsage[9];
-	partialManager->getPerPartPartialUsage(partialUsage);
-	if (sampleOffset > 0) {
-		printDebug("[+%lu] Partial Usage: 1:%02d 2:%02d 3:%02d 4:%02d 5:%02d 6:%02d 7:%02d 8:%02d R: %02d  TOTAL: %02d", sampleOffset, partialUsage[0], partialUsage[1], partialUsage[2], partialUsage[3], partialUsage[4], partialUsage[5], partialUsage[6], partialUsage[7], partialUsage[8], getPartialLimit() - partialManager->getFreePartialCount());
-	} else {
-		printDebug("Partial Usage: 1:%02d 2:%02d 3:%02d 4:%02d 5:%02d 6:%02d 7:%02d 8:%02d R: %02d  TOTAL: %02d", partialUsage[0], partialUsage[1], partialUsage[2], partialUsage[3], partialUsage[4], partialUsage[5], partialUsage[6], partialUsage[7], partialUsage[8], getPartialLimit() - partialManager->getFreePartialCount());
+void MidiEventQueue::dropMidiEvent() {
+	// Is ring buffer empty?
+	if (startPosition != endPosition) {
+		startPosition = (startPosition + 1) & ringBufferMask;
 	}
 }
 
-bool Synth::hasActivePartials() const {
-	if (prerenderReadIx != prerenderWriteIx) {
-		// Data in the prerender buffer means that the current isActive() states are "in the future".
-		// It also means that partials are definitely active at this render point.
-		return true;
-	}
-	for (unsigned int partialNum = 0; partialNum < getPartialLimit(); partialNum++) {
-		if (partialManager->getPartial(partialNum)->isActive()) {
-			return true;
-		}
-	}
-	return false;
+bool MidiEventQueue::isFull() const {
+	return startPosition == ((endPosition + 1) & ringBufferMask);
 }
 
-bool Synth::isActive() const {
-	if (hasActivePartials()) {
-		return true;
-	}
-	if (reverbEnabled) {
-		return reverbModel->isActive();
-	}
-	return false;
+bool MidiEventQueue::isEmpty() const {
+	return startPosition == endPosition;
 }
 
-const Partial *Synth::getPartial(unsigned int partialNum) const {
-	return partialManager->getPartial(partialNum);
+void Synth::selectRendererType(RendererType newRendererType) {
+	extensions.selectedRendererType = newRendererType;
 }
 
-const Part *Synth::getPart(unsigned int partNum) const {
-	if (partNum > 8) {
-		return NULL;
-	}
-	return parts[partNum];
+RendererType Synth::getSelectedRendererType() const {
+	return extensions.selectedRendererType;
 }
 
-void MemoryRegion::read(unsigned int entry, unsigned int off, Bit8u *dst, unsigned int len) const {
-	off += entry * entrySize;
-	// This method should never be called with out-of-bounds parameters,
-	// or on an unsupported region - seeing any of this debug output indicates a bug in the emulator
-	if (off > entrySize * entries - 1) {
-#if MT32EMU_MONITOR_SYSEX > 0
-		synth->printDebug("read[%d]: parameters start out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
-#endif
-		return;
-	}
-	if (off + len > entrySize * entries) {
-#if MT32EMU_MONITOR_SYSEX > 0
-		synth->printDebug("read[%d]: parameters end out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
-#endif
-		len = entrySize * entries - off;
-	}
-	Bit8u *src = getRealMemory();
-	if (src == NULL) {
-#if MT32EMU_MONITOR_SYSEX > 0
-		synth->printDebug("read[%d]: unreadable region: entry=%d, off=%d, len=%d", type, entry, off, len);
-#endif
-		return;
-	}
-	memcpy(dst, src + off, len);
+Bit32u Synth::getStereoOutputSampleRate() const {
+	return (analog == NULL) ? SAMPLE_RATE : analog->getOutputSampleRate();
 }
 
-void MemoryRegion::write(unsigned int entry, unsigned int off, const Bit8u *src, unsigned int len, bool init) const {
-	unsigned int memOff = entry * entrySize + off;
-	// This method should never be called with out-of-bounds parameters,
-	// or on an unsupported region - seeing any of this debug output indicates a bug in the emulator
-	if (off > entrySize * entries - 1) {
-#if MT32EMU_MONITOR_SYSEX > 0
-		synth->printDebug("write[%d]: parameters start out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
-#endif
+template <class Sample>
+void RendererImpl<Sample>::doRender(Sample *stereoStream, Bit32u len) {
+	if (!isActivated()) {
+		incRenderedSampleCount(getAnalog().getDACStreamsLength(len));
+		if (!getAnalog().process(NULL, NULL, NULL, NULL, NULL, NULL, stereoStream, len)) {
+			printDebug("RendererImpl: Invalid call to Analog::process()!\n");
+		}
+		Synth::muteSampleBuffer(stereoStream, len << 1);
 		return;
 	}
-	if (off + len > entrySize * entries) {
-#if MT32EMU_MONITOR_SYSEX > 0
-		synth->printDebug("write[%d]: parameters end out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
-#endif
-		len = entrySize * entries - off;
-	}
-	Bit8u *dest = getRealMemory();
-	if (dest == NULL) {
-#if MT32EMU_MONITOR_SYSEX > 0
-		synth->printDebug("write[%d]: unwritable region: entry=%d, off=%d, len=%d", type, entry, off, len);
-#endif
-	}
 
-	for (unsigned int i = 0; i < len; i++) {
-		Bit8u desiredValue = src[i];
-		Bit8u maxValue = getMaxValue(memOff);
-		// maxValue == 0 means write-protected unless called from initialisation code, in which case it really means the maximum value is 0.
-		if (maxValue != 0 || init) {
-			if (desiredValue > maxValue) {
-#if MT32EMU_MONITOR_SYSEX > 0
-				synth->printDebug("write[%d]: Wanted 0x%02x at %d, but max 0x%02x", type, desiredValue, memOff, maxValue);
-#endif
-				desiredValue = maxValue;
-			}
-			dest[memOff] = desiredValue;
-		} else if (desiredValue != 0) {
-#if MT32EMU_MONITOR_SYSEX > 0
-			// Only output debug info if they wanted to write non-zero, since a lot of things cause this to spit out a lot of debug info otherwise.
-			synth->printDebug("write[%d]: Wanted 0x%02x at %d, but write-protected", type, desiredValue, memOff);
-#endif
+	while (len > 0) {
+		// As in AnalogOutputMode_ACCURATE mode output is upsampled, MAX_SAMPLES_PER_RUN is more than enough for the temp buffers.
+		Bit32u thisPassLen = len > MAX_SAMPLES_PER_RUN ? MAX_SAMPLES_PER_RUN : len;
+		doRenderStreams(tmpBuffers, getAnalog().getDACStreamsLength(thisPassLen));
+		if (!getAnalog().process(stereoStream, tmpNonReverbLeft, tmpNonReverbRight, tmpReverbDryLeft, tmpReverbDryRight, tmpReverbWetLeft, tmpReverbWetRight, thisPassLen)) {
+			printDebug("RendererImpl: Invalid call to Analog::process()!\n");
+			Synth::muteSampleBuffer(stereoStream, len << 1);
+			return;
 		}
-		memOff++;
+		stereoStream += thisPassLen << 1;
+		len -= thisPassLen;
 	}
 }
 
-
-void Synth::setPartialLimit( unsigned int _partialLimit )
-{
-	/* NTS: A memory leak can occur if we open the synth with the initial (max)
-		number of partials, then allow DOSBox-X to call setPartialLimit()
-		with an (often lower) partial count, because the PartialManager()
-		will later free only that lower count of partials. To prevent this,
-		we throw a C++ exception if an attempt is made while the synth is
-		open to call this function. */
-	if (isOpen) throw std::runtime_error("MT32 attempt to change partial limit while synth is open");
-	partialLimit = _partialLimit;
+template <class Sample>
+template <class O>
+void RendererImpl<Sample>::doRenderAndConvert(O *stereoStream, Bit32u len) {
+	Sample renderingBuffer[MAX_SAMPLES_PER_RUN << 1];
+	while (len > 0) {
+		Bit32u thisPassLen = len > MAX_SAMPLES_PER_RUN ? MAX_SAMPLES_PER_RUN : len;
+		doRender(renderingBuffer, thisPassLen);
+		convertSampleFormat(renderingBuffer, stereoStream, thisPassLen << 1);
+		stereoStream += thisPassLen << 1;
+		len -= thisPassLen;
+	}
 }
 
-
-const unsigned int Synth::getPartialLimit() const
-{
-	return partialLimit;
+template<>
+void RendererImpl<IntSample>::render(IntSample *stereoStream, Bit32u len) {
+	doRender(stereoStream, len);
 }
 
+template<>
+void RendererImpl<IntSample>::render(FloatSample *stereoStream, Bit32u len) {
+	doRenderAndConvert(stereoStream, len);
+}
 
-void Synth::findPart( const Part *src, Bit8u *index_out )
-{
-	Bit8u part_idx;
-
-
-	part_idx = 0xff;
-	if( src != NULL ) {
-#ifdef WIN32_DEBUG
-		bool stop = false;
-#endif
-	
-		part_idx = 0;
-		for( unsigned int lcv=0; lcv<9; lcv++ ) {
-			if( src == getPart(lcv) ) {
-#ifdef WIN32_DEBUG
-				stop = true;
-#endif
-				break;
-			}
+template<>
+void RendererImpl<FloatSample>::render(IntSample *stereoStream, Bit32u len) {
+	doRenderAndConvert(stereoStream, len);
+}
 
-			part_idx++;
-		}
+template<>
+void RendererImpl<FloatSample>::render(FloatSample *stereoStream, Bit32u len) {
+	doRender(stereoStream, len);
+}
 
-#ifdef WIN32_DEBUG
-		// DEBUG
-		if( stop == false ) __asm int 3
-#endif
+template <class S>
+static inline void renderStereo(bool opened, Renderer *renderer, S *stream, Bit32u len) {
+	if (opened) {
+		renderer->render(stream, len);
+	} else {
+		Synth::muteSampleBuffer(stream, len << 1);
 	}
-
-
-	*index_out = part_idx;
 }
 
+void Synth::render(Bit16s *stream, Bit32u len) {
+	renderStereo(opened, renderer, stream, len);
+}
 
-void Synth::findPartial( const Partial *src, Bit8u *index_out )
-{
-	Bit8u partials_idx;
-
-
-	partials_idx = 0xff;
-	if( src != NULL ) {
-#ifdef WIN32_DEBUG
-		bool stop = false;
-#endif
-
-		partials_idx = 0;
-		for( unsigned int lcv=0; lcv<getPartialLimit(); lcv++ ) {
-			if( src == getPartial(lcv) ) {
-#ifdef WIN32_DEBUG
-				stop = true;
-#endif
-				break;
-			}
-
-			partials_idx++;
-		}
+void Synth::render(float *stream, Bit32u len) {
+	renderStereo(opened, renderer, stream, len);
+}
 
-#ifdef WIN32_DEBUG
-		// DEBUG
-		if( stop == false ) __asm int 3
-#endif
+template <class Sample>
+static inline void advanceStream(Sample *&stream, Bit32u len) {
+	if (stream != NULL) {
+		stream += len;
 	}
+}
 
+template <class Sample>
+static inline void advanceStreams(DACOutputStreams<Sample> &streams, Bit32u len) {
+	advanceStream(streams.nonReverbLeft, len);
+	advanceStream(streams.nonReverbRight, len);
+	advanceStream(streams.reverbDryLeft, len);
+	advanceStream(streams.reverbDryRight, len);
+	advanceStream(streams.reverbWetLeft, len);
+	advanceStream(streams.reverbWetRight, len);
+}
 
-	*index_out = partials_idx;
+template <class Sample>
+static inline void muteStreams(const DACOutputStreams<Sample> &streams, Bit32u len) {
+	Synth::muteSampleBuffer(streams.nonReverbLeft, len);
+	Synth::muteSampleBuffer(streams.nonReverbRight, len);
+	Synth::muteSampleBuffer(streams.reverbDryLeft, len);
+	Synth::muteSampleBuffer(streams.reverbDryRight, len);
+	Synth::muteSampleBuffer(streams.reverbWetLeft, len);
+	Synth::muteSampleBuffer(streams.reverbWetRight, len);
 }
 
+template <class I, class O>
+static inline void convertStreamsFormat(const DACOutputStreams<I> &inStreams, const DACOutputStreams<O> &outStreams, Bit32u len) {
+	convertSampleFormat(inStreams.nonReverbLeft, outStreams.nonReverbLeft, len);
+	convertSampleFormat(inStreams.nonReverbRight, outStreams.nonReverbRight, len);
+	convertSampleFormat(inStreams.reverbDryLeft, outStreams.reverbDryLeft, len);
+	convertSampleFormat(inStreams.reverbDryRight, outStreams.reverbDryRight, len);
+	convertSampleFormat(inStreams.reverbWetLeft, outStreams.reverbWetLeft, len);
+	convertSampleFormat(inStreams.reverbWetRight, outStreams.reverbWetRight, len);
+}
 
-void Synth::findPartialParam( const TimbreParam::PartialParam *src, Bit16u *index_out1, Bit16u *index_out2 )
+template <class Sample>
+void RendererImpl<Sample>::doRenderStreams(const DACOutputStreams<Sample> &streams, Bit32u len)
 {
-	Bit16u partialParam_idx1, partialParam_idx2;
-	bool stop;
-
-
-	stop = false;
-
-	partialParam_idx1 = 0xffff;
-	partialParam_idx2 = 0xffff;
-
-
-	if( src != NULL ) {
-		partialParam_idx1 = 0;
-
-		// #1 = mt32ram.timbres[] - partial
-		for( int lcv1=0; lcv1<256; lcv1++ ) {
-			partialParam_idx2 = 0;
-
-			for( int lcv2=0; lcv2<4; lcv2++ ) {
-				if( src == &mt32ram.timbres[lcv1].timbre.partial[lcv2] ) { stop = true; break; }
-
-				partialParam_idx2++;
-			}
-			if( stop == true ) break;
-
-			partialParam_idx1++;
-		}
-
-
-		if( stop == false ) {
-			partialParam_idx1 = 0x1000;
-
-			// #2 = mt32ram.timbreTemp - partial[]
-			for( int lcv1=0; lcv1<8; lcv1++ ) {
-				partialParam_idx2 = 0;
-
-				for( int lcv2=0; lcv2<4; lcv2++ ) {
-					if( src == &mt32ram.timbreTemp[lcv1].partial[lcv2] ) { stop = true; break; }
-
-					partialParam_idx2++;
-				}
-				if( stop == true ) break;
-
-				partialParam_idx1++;
-			}
-		}
-
-
-		if( stop == false ) {
-			partialParam_idx1 = 0x2000;
-
-			// #3 = parts[0-7] - patchCache[0-3].srcPartial
-			for( int lcv1=0; lcv1<8; lcv1++ ) {
-				partialParam_idx2 = 0;
-
-				for( int lcv2=0; lcv2<4; lcv2++ ) {
-					Part *part;
-
-					part = (Part *) getPart(lcv1);
-					if( src == &part->getPatchCache(lcv2)->srcPartial ) { stop = true; break; }
-
-					partialParam_idx2++;
+	DACOutputStreams<Sample> tmpStreams = streams;
+	while (len > 0) {
+		// We need to ensure zero-duration notes will play so add minimum 1-sample delay.
+		Bit32u thisLen = 1;
+		if (!isAbortingPoly()) {
+			const MidiEvent *nextEvent = getMidiQueue().peekMidiEvent();
+			Bit32s samplesToNextEvent = (nextEvent != NULL) ? Bit32s(nextEvent->timestamp - getRenderedSampleCount()) : MAX_SAMPLES_PER_RUN;
+			if (samplesToNextEvent > 0) {
+				thisLen = len > MAX_SAMPLES_PER_RUN ? MAX_SAMPLES_PER_RUN : len;
+				if (thisLen > Bit32u(samplesToNextEvent)) {
+					thisLen = samplesToNextEvent;
 				}
-				if( stop == true ) break;
-
-				partialParam_idx1++;
-			}
-		}
-
-
-		if( stop == false ) {
-			partialParam_idx1 = 0x3000;
-
-			// #4 = parts[8] - patchCache[0-3].srcPartial (Rhythm)
-			for( int lcv1=0; lcv1<1; lcv1++ ) {
-				partialParam_idx2 = 0;
-
-				for( int lcv2=0; lcv2<4; lcv2++ ) {
-					RhythmPart *part;
-
-					part = (RhythmPart *) getPart(8);
-					if( src == &part->getPatchCache(lcv2)->srcPartial ) { stop = true; break; }
-
-					partialParam_idx2++;
+			} else {
+				if (nextEvent->sysexData == NULL) {
+					synth.playMsgNow(nextEvent->shortMessageData);
+					// If a poly is aborting we don't drop the event from the queue.
+					// Instead, we'll return to it again when the abortion is done.
+					if (!isAbortingPoly()) {
+						getMidiQueue().dropMidiEvent();
+					}
+				} else {
+					synth.playSysexNow(nextEvent->sysexData, nextEvent->sysexLength);
+					getMidiQueue().dropMidiEvent();
 				}
-				if( stop == true ) break;
-
-				partialParam_idx1++;
 			}
 		}
+		produceStreams(tmpStreams, thisLen);
+		advanceStreams(tmpStreams, thisLen);
+		len -= thisLen;
+	}
+}
 
+template <class Sample>
+template <class O>
+void RendererImpl<Sample>::doRenderAndConvertStreams(const DACOutputStreams<O> &streams, Bit32u len) {
+	Sample cnvNonReverbLeft[MAX_SAMPLES_PER_RUN], cnvNonReverbRight[MAX_SAMPLES_PER_RUN];
+	Sample cnvReverbDryLeft[MAX_SAMPLES_PER_RUN], cnvReverbDryRight[MAX_SAMPLES_PER_RUN];
+	Sample cnvReverbWetLeft[MAX_SAMPLES_PER_RUN], cnvReverbWetRight[MAX_SAMPLES_PER_RUN];
 
-		if( stop == false ) {
-			partialParam_idx1 = 0x4000;
-
-			// #5 = parts[8] - drumCache[][].srcPartial (Rhythm)
-			for( int lcv1=0; lcv1<85; lcv1++ ) {
-				partialParam_idx2 = 0;
-
-				for( int lcv2=0; lcv2<4; lcv2++ ) {
-					RhythmPart *part;
-
-					part = (RhythmPart *) getPart(8);
-					if( src == &part->getDrumCache(lcv1,lcv2)->srcPartial ) { stop = true; break; }
-
-					partialParam_idx2++;
-				}
-				if( stop == true ) break;
-
-				partialParam_idx1++;
-			}
-		}
-
+	const DACOutputStreams<Sample> cnvStreams = {
+		cnvNonReverbLeft, cnvNonReverbRight,
+		cnvReverbDryLeft, cnvReverbDryRight,
+		cnvReverbWetLeft, cnvReverbWetRight
+	};
 
-		if( stop == false ) {
-			partialParam_idx1 = 0x5000;
+	DACOutputStreams<O> tmpStreams = streams;
 
-			// #6 = partials[] - cacheBackup
-			for( unsigned int lcv1=0; lcv1<getPartialLimit(); lcv1++ ) {
-				partialParam_idx2 = 0;
+	while (len > 0) {
+		Bit32u thisPassLen = len > MAX_SAMPLES_PER_RUN ? MAX_SAMPLES_PER_RUN : len;
+		doRenderStreams(cnvStreams, thisPassLen);
+		convertStreamsFormat(cnvStreams, tmpStreams, thisPassLen);
+		advanceStreams(tmpStreams, thisPassLen);
+		len -= thisPassLen;
+	}
+}
 
-				for( int lcv2=0; lcv2<1; lcv2++ ) {
-					if( src == &getPartial(lcv1)->cachebackup.srcPartial ) { stop = true; break; }
+template<>
+void RendererImpl<IntSample>::renderStreams(const DACOutputStreams<IntSample> &streams, Bit32u len) {
+	doRenderStreams(streams, len);
+}
 
-					partialParam_idx2++;
-				}
-				if( stop == true ) break;
+template<>
+void RendererImpl<IntSample>::renderStreams(const DACOutputStreams<FloatSample> &streams, Bit32u len) {
+	doRenderAndConvertStreams(streams, len);
+}
 
-				partialParam_idx1++;
-			}
+template<>
+void RendererImpl<FloatSample>::renderStreams(const DACOutputStreams<IntSample> &streams, Bit32u len) {
+	doRenderAndConvertStreams(streams, len);
+}
 
+template<>
+void RendererImpl<FloatSample>::renderStreams(const DACOutputStreams<FloatSample> &streams, Bit32u len) {
+	doRenderStreams(streams, len);
+}
 
-#ifdef WIN32_DEBUG
-			// DEBUG
-			if( stop == false ) __asm int 3
-#endif
-		}
+template <class S>
+static inline void renderStreams(bool opened, Renderer *renderer, const DACOutputStreams<S> &streams, Bit32u len) {
+	if (opened) {
+		renderer->renderStreams(streams, len);
+	} else {
+		muteStreams(streams, len);
 	}
+}
 
-
-	*index_out1 = partialParam_idx1;
-	*index_out2 = partialParam_idx2;
+void Synth::renderStreams(const DACOutputStreams<Bit16s> &streams, Bit32u len) {
+	MT32Emu::renderStreams(opened, renderer, streams, len);
 }
 
+void Synth::renderStreams(const DACOutputStreams<float> &streams, Bit32u len) {
+	MT32Emu::renderStreams(opened, renderer, streams, len);
+}
 
-void Synth::findPatchCache( const PatchCache *src, Bit16u *index_out1, Bit16u *index_out2 )
+void Synth::renderStreams(
+	Bit16s *nonReverbLeft, Bit16s *nonReverbRight,
+	Bit16s *reverbDryLeft, Bit16s *reverbDryRight,
+	Bit16s *reverbWetLeft, Bit16s *reverbWetRight,
+	Bit32u len)
 {
-	Bit16u patchCache_idx1, patchCache_idx2;
-	bool stop;
-
-
-	stop = false;
-
-	patchCache_idx1 = 0xffff;
-	patchCache_idx2 = 0xffff;
-
-
-	if( src != NULL ) {
-		patchCache_idx1 = 0;
-
-		// #1 = parts[0-7] - patchCache
-		for( int lcv1=0; lcv1<8; lcv1++ ) {
-			patchCache_idx2 = 0;
-
-			for( int lcv2=0; lcv2<4; lcv2++ ) {
-				Part *part;
-
-				part = (Part *) getPart(lcv1);
-				if( src == part->getPatchCache(lcv2) ) { stop = true; break; }
-
-				patchCache_idx2++;
-			}
-			if( stop == true ) break;
-
-			patchCache_idx1++;
-		}
-
-
-		if( stop == false ) {
-			patchCache_idx1 = 0x1000;
-
-			// #2 parts[8] - patchCache (Rhythm)
-			for( int lcv1=0; lcv1<1; lcv1++ ) {
-				patchCache_idx2 = 0;
-
-				for( int lcv2=0; lcv2<4; lcv2++ ) {
-					RhythmPart *part;
-
-					part = (RhythmPart *) getPart(8);
-					if( src == part->getPatchCache(lcv2) ) { stop = true; break; }
-
-					patchCache_idx2++;
-				}
-				if( stop == true ) break;
-
-				patchCache_idx1++;
-			}
-		}
-
-
-		if( stop == false ) {
-			patchCache_idx1 = 0x2000;
-
-			// #3 parts[8] - drumcache[][] (Rhythm)
-			for( int lcv1=0; lcv1<85; lcv1++ ) {
-				patchCache_idx2 = 0;
-
-				for( int lcv2=0; lcv2<4; lcv2++ ) {
-					RhythmPart *part;
-
-					part = (RhythmPart *) getPart(8);
-					if( src == part->getDrumCache(lcv1,lcv2) ) { stop = true; break; }
-
-					patchCache_idx2++;
-				}
-				if( stop == true ) break;
+	DACOutputStreams<IntSample> streams = {
+		nonReverbLeft, nonReverbRight,
+		reverbDryLeft, reverbDryRight,
+		reverbWetLeft, reverbWetRight
+	};
+	renderStreams(streams, len);
+}
 
-				patchCache_idx1++;
+void Synth::renderStreams(
+	float *nonReverbLeft, float *nonReverbRight,
+	float *reverbDryLeft, float *reverbDryRight,
+	float *reverbWetLeft, float *reverbWetRight,
+	Bit32u len)
+{
+	DACOutputStreams<FloatSample> streams = {
+		nonReverbLeft, nonReverbRight,
+		reverbDryLeft, reverbDryRight,
+		reverbWetLeft, reverbWetRight
+	};
+	renderStreams(streams, len);
+}
+
+// In GENERATION2 units, the output from LA32 goes to the Boss chip already bit-shifted.
+// In NICE mode, it's also better to increase volume before the reverb processing to preserve accuracy.
+template <>
+void RendererImpl<IntSample>::produceLA32Output(IntSample *buffer, Bit32u len) {
+	switch (synth.getDACInputMode()) {
+		case DACInputMode_GENERATION2:
+			while (len--) {
+				*buffer = (*buffer & 0x8000) | ((*buffer << 1) & 0x7FFE) | ((*buffer >> 14) & 0x0001);
+				++buffer;
 			}
-		}
-
-
-		if( stop == false ) {
-			patchCache_idx1 = 0x3000;
-
-			// #4 partials[] - cacheBackup
-			for( unsigned int lcv1=0; lcv1<getPartialLimit(); lcv1++ ) {
-				patchCache_idx2 = 0;
-
-				for( int lcv2=0; lcv2<1; lcv2++ ) {
-					if( src == &getPartial(lcv1)->cachebackup ) { stop = true; break; }
-
-					patchCache_idx2++;
-				}
-				if( stop == true ) break;
-
-				patchCache_idx1++;
+			break;
+		case DACInputMode_NICE:
+			while (len--) {
+				*buffer = Synth::clipSampleEx(IntSampleEx(*buffer) << 1);
+				++buffer;
 			}
-
-
-#ifdef WIN32_DEBUG
-			// DEBUG
-			if( stop == false ) __asm int 3
-#endif
-		}
+			break;
+		default:
+			break;
 	}
-
-
-	*index_out1 = patchCache_idx1;
-	*index_out2 = patchCache_idx2;
 }
 
-
-void Synth::findPatchTemp( const MemParams::PatchTemp *src, Bit8u *index_out )
-{
-	Bit8u patchTemp_idx;
-
-
-	patchTemp_idx = 0xff;
-	if( src != NULL ) {
-#ifdef WIN32_DEBUG
-		bool stop = false;
-#endif
-
-		patchTemp_idx = 0;
-		for( int lcv=0; lcv<9; lcv++ ) {
-			if( src == &mt32ram.patchTemp[lcv] ) {
-#ifdef WIN32_DEBUG
-				stop = true;
-#endif
-				break;
-			}
-
-			patchTemp_idx++;
+template <>
+void RendererImpl<IntSample>::convertSamplesToOutput(IntSample *buffer, Bit32u len) {
+	if (synth.getDACInputMode() == DACInputMode_GENERATION1) {
+		while (len--) {
+			*buffer = IntSample((*buffer & 0x8000) | ((*buffer << 1) & 0x7FFE));
+			++buffer;
 		}
-
-
-#ifdef WIN32_DEBUG
-		// DEBUG
-		if( stop == false ) __asm int 3
-#endif
 	}
-
-
-	*index_out = patchTemp_idx;
 }
 
-
-void Synth::findPCMWaveEntry( const PCMWaveEntry *src, Bit16u *index_out )
-{
-	Bit16u PCMWaveEntry_idx;
-
-	PCMWaveEntry_idx = 0xffff;
-	if( src != NULL ) {
-#ifdef WIN32_DEBUG
-		bool stop = false;
-#endif
-
-		PCMWaveEntry_idx = 0;
-		for( int lcv=0; lcv<controlROMMap->pcmCount; lcv++ ) {
-			if( src == &pcmWaves[lcv] ) {
-#ifdef WIN32_DEBUG
-				stop = true;
-#endif
-				break;
-			}
-
-			PCMWaveEntry_idx++;
-		}
-
-
-#ifdef WIN32_DEBUG
-		// DEBUG
-		if( stop == false ) __asm int 3
-#endif
+static inline float produceDistortedSample(float sample) {
+	// Here we roughly simulate the distortion caused by the DAC bit shift.
+	if (sample < -1.0f) {
+		return sample + 2.0f;
+	} else if (1.0f < sample) {
+		return sample - 2.0f;
 	}
-
-
-	*index_out = PCMWaveEntry_idx;
+	return sample;
 }
 
-// WE NEED TO REFRESH THIS
-void Synth::findPoly( const Poly *src, Bit16u *index_out1, Bit16u *index_out2 )
-{
-	Bit16u poly_idx1, poly_idx2;
-
-
-	poly_idx1 = 0xffff;
-	poly_idx2 = 0xffff;
-
-	if( src != NULL ) {
-		bool stop;
-
-		poly_idx1 = 0;
-		stop = false;
-
-		for( int lcv1=0; lcv1<9; lcv1++ ) {
-			Part *part;
-			part = (Part *) getPart(lcv1);
-
-			poly_idx2 = 0;
-
-			for( int lcv2=0; lcv2<part->getActivePolyCount(); lcv2++ ) {
-				if( src == part->getActivePoly(lcv2) ) { stop = true; break; }
-
-				poly_idx2++;
-			}
-			if( stop ) break;
-
-			poly_idx1++;
+template <>
+void RendererImpl<FloatSample>::produceLA32Output(FloatSample *buffer, Bit32u len) {
+	switch (synth.getDACInputMode()) {
+	case DACInputMode_NICE:
+		// Note, we do not do any clamping for floats here to avoid introducing distortions.
+		// This means that the output signal may actually overshoot the unity when the volume is set too high.
+		// We leave it up to the consumer whether the output is to be clamped or properly normalised further on.
+		while (len--) {
+			*buffer *= 2.0f;
+			buffer++;
 		}
-
-
-#ifdef WIN32_DEBUG
-		// DEBUG
-		if( stop == false ) __asm int 3
-#endif
+		break;
+	case DACInputMode_GENERATION2:
+		while (len--) {
+			*buffer = produceDistortedSample(2.0f * *buffer);
+			buffer++;
+		}
+		break;
+	default:
+		break;
 	}
-
-	*index_out1 = poly_idx1;
-	*index_out2 = poly_idx2;
 }
 
-
-
-void Synth::findRhythmTemp( const MemParams::RhythmTemp *src, Bit8u *index_out )
-{
-	Bit8u rhythmTemp_idx;
-
-	rhythmTemp_idx = 0xff;
-	if( src != NULL ) {
-#ifdef WIN32_DEBUG
-		bool stop = false;
-#endif
-
-		rhythmTemp_idx = 0;
-		for( int lcv=0; lcv<85; lcv++ ) {
-			if( src == &mt32ram.rhythmTemp[lcv] ) {
-#ifdef WIN32_DEBUG
-				stop = true;
-#endif
-				break;
-			}
-
-			rhythmTemp_idx++;
+template <>
+void RendererImpl<FloatSample>::convertSamplesToOutput(FloatSample *buffer, Bit32u len) {
+	if (synth.getDACInputMode() == DACInputMode_GENERATION1) {
+		while (len--) {
+			*buffer = produceDistortedSample(2.0f * *buffer);
+			buffer++;
 		}
-
-#ifdef WIN32_DEBUG
-		// DEBUG
-		if( stop == false ) __asm int 3
-#endif
 	}
-
-
-	*index_out = rhythmTemp_idx;
 }
 
+template <class Sample>
+void RendererImpl<Sample>::produceStreams(const DACOutputStreams<Sample> &streams, Bit32u len) {
+	if (isActivated()) {
+		// Even if LA32 output isn't desired, we proceed anyway with temp buffers
+		Sample *nonReverbLeft = streams.nonReverbLeft == NULL ? tmpNonReverbLeft : streams.nonReverbLeft;
+		Sample *nonReverbRight = streams.nonReverbRight == NULL ? tmpNonReverbRight : streams.nonReverbRight;
+		Sample *reverbDryLeft = streams.reverbDryLeft == NULL ? tmpReverbDryLeft : streams.reverbDryLeft;
+		Sample *reverbDryRight = streams.reverbDryRight == NULL ? tmpReverbDryRight : streams.reverbDryRight;
 
-void Synth::findTimbreParam( const TimbreParam *src, Bit8u *index_out )
-{
-	Bit8u timbreParam_idx;
+		Synth::muteSampleBuffer(nonReverbLeft, len);
+		Synth::muteSampleBuffer(nonReverbRight, len);
+		Synth::muteSampleBuffer(reverbDryLeft, len);
+		Synth::muteSampleBuffer(reverbDryRight, len);
 
+		for (unsigned int i = 0; i < synth.getPartialCount(); i++) {
+			if (getPartialManager().shouldReverb(i)) {
+				getPartialManager().produceOutput(i, reverbDryLeft, reverbDryRight, len);
+			} else {
+				getPartialManager().produceOutput(i, nonReverbLeft, nonReverbRight, len);
+			}
+		}
 
-	timbreParam_idx = 0xff;
-	if( src != NULL ) {
-#ifdef WIN32_DEBUG
-		bool stop = false;
-#endif
+		produceLA32Output(reverbDryLeft, len);
+		produceLA32Output(reverbDryRight, len);
 
-		timbreParam_idx = 0;
-		for( int lcv=0; lcv<8; lcv++ ) {
-			if( src == &mt32ram.timbreTemp[lcv] ) {
-#ifdef WIN32_DEBUG
-				stop = true;
-#endif
-				break;
+		if (synth.isReverbEnabled()) {
+			if (!getReverbModel().process(reverbDryLeft, reverbDryRight, streams.reverbWetLeft, streams.reverbWetRight, len)) {
+				printDebug("RendererImpl: Invalid call to BReverbModel::process()!\n");
 			}
-
-			timbreParam_idx++;
+			if (streams.reverbWetLeft != NULL) convertSamplesToOutput(streams.reverbWetLeft, len);
+			if (streams.reverbWetRight != NULL) convertSamplesToOutput(streams.reverbWetRight, len);
+		} else {
+			Synth::muteSampleBuffer(streams.reverbWetLeft, len);
+			Synth::muteSampleBuffer(streams.reverbWetRight, len);
 		}
 
-#ifdef WIN32_DEBUG
-		// DEBUG
-		if( stop == false ) __asm int 3
-#endif
+		// Don't bother with conversion if the output is going to be unused
+		if (streams.nonReverbLeft != NULL) {
+			produceLA32Output(nonReverbLeft, len);
+			convertSamplesToOutput(nonReverbLeft, len);
+		}
+		if (streams.nonReverbRight != NULL) {
+			produceLA32Output(nonReverbRight, len);
+			convertSamplesToOutput(nonReverbRight, len);
+		}
+		if (streams.reverbDryLeft != NULL) convertSamplesToOutput(reverbDryLeft, len);
+		if (streams.reverbDryRight != NULL) convertSamplesToOutput(reverbDryRight, len);
+	} else {
+		muteStreams(streams, len);
 	}
 
-
-	*index_out = timbreParam_idx;
+	getPartialManager().clearAlreadyOutputed();
+	incRenderedSampleCount(len);
 }
 
-
-Part *Synth::indexPart( Bit8u index )
-{
-	Part *ptr;
-
-	ptr = NULL;
-	if( index != 0xff )
-		ptr = (Part *) getPart(index);
-
-	return ptr;
+void Synth::printPartialUsage(Bit32u sampleOffset) {
+	unsigned int partialUsage[9];
+	partialManager->getPerPartPartialUsage(partialUsage);
+	if (sampleOffset > 0) {
+		printDebug("[+%u] Partial Usage: 1:%02d 2:%02d 3:%02d 4:%02d 5:%02d 6:%02d 7:%02d 8:%02d R: %02d  TOTAL: %02d", sampleOffset, partialUsage[0], partialUsage[1], partialUsage[2], partialUsage[3], partialUsage[4], partialUsage[5], partialUsage[6], partialUsage[7], partialUsage[8], getPartialCount() - partialManager->getFreePartialCount());
+	} else {
+		printDebug("Partial Usage: 1:%02d 2:%02d 3:%02d 4:%02d 5:%02d 6:%02d 7:%02d 8:%02d R: %02d  TOTAL: %02d", partialUsage[0], partialUsage[1], partialUsage[2], partialUsage[3], partialUsage[4], partialUsage[5], partialUsage[6], partialUsage[7], partialUsage[8], getPartialCount() - partialManager->getFreePartialCount());
+	}
 }
 
-
-Partial *Synth::indexPartial( Bit8u index )
-{
-	Partial *ptr;
-
-	ptr = NULL;
-	if( index != 0xff )
-		ptr = (Partial *) getPartial(index);
-
-	return ptr;
+bool Synth::hasActivePartials() const {
+	if (!opened) {
+		return false;
+	}
+	for (unsigned int partialNum = 0; partialNum < getPartialCount(); partialNum++) {
+		if (partialManager->getPartial(partialNum)->isActive()) {
+			return true;
+		}
+	}
+	return false;
 }
 
-
-TimbreParam::PartialParam *Synth::indexPartialParam( Bit16u index1, Bit16u index2 )
-{
-	TimbreParam::PartialParam *ptr;
-
-
-	ptr = NULL;
-	if( index1 < 0x1000 ) {
-		index1 -= 0x0000;
-
-		ptr = &mt32ram.timbres[index1].timbre.partial[index2];
+bool Synth::isActive() {
+	if (!opened) {
+		return false;
 	}
-	else if( index1 < 0x2000 ) {
-		index1 -= 0x1000;
-
-		ptr = &mt32ram.timbreTemp[index1].partial[index2];
+	if (!midiQueue->isEmpty() || hasActivePartials()) {
+		return true;
 	}
-	else if( index1 < 0x3000 ) {
-		Part *part;
-
-		index1 -= 0x2000;
-
-		part = (Part *) getPart(index1);
-		ptr = (TimbreParam::PartialParam *) &part->getPatchCache(index2)->srcPartial;
+	if (isReverbEnabled() && reverbModel->isActive()) {
+		return true;
 	}
-	else if( index1 < 0x4000 ) {
-		RhythmPart *part;
+	activated = false;
+	return false;
+}
 
-		index1 -= 0x3000;
+Bit32u Synth::getPartialCount() const {
+	return partialCount;
+}
 
-		part = (RhythmPart *) getPart(8);
-		ptr = (TimbreParam::PartialParam *) &part->getPatchCache(index2)->srcPartial;
+void Synth::getPartStates(bool *partStates) const {
+	if (!opened) {
+		memset(partStates, 0, 9 * sizeof(bool));
+		return;
 	}
-	else if( index1 < 0x5000 ) {
-		RhythmPart *part;
-
-		index1 -= 0x4000;
-
-		part = (RhythmPart *) getPart(8);
-		ptr = (TimbreParam::PartialParam *) &part->getDrumCache(index1,index2)->srcPartial;
+	for (int partNumber = 0; partNumber < 9; partNumber++) {
+		const Part *part = parts[partNumber];
+		partStates[partNumber] = part->getActiveNonReleasingPartialCount() > 0;
 	}
-	else if( index1 < 0x6000 ) {
-		index1 -= 0x5000;
+}
 
-		ptr = (TimbreParam::PartialParam *) &getPartial(index1)->cachebackup.srcPartial;
+Bit32u Synth::getPartStates() const {
+	if (!opened) return 0;
+	bool partStates[9];
+	getPartStates(partStates);
+	Bit32u bitSet = 0;
+	for (int partNumber = 8; partNumber >= 0; partNumber--) {
+		bitSet = (bitSet << 1) | (partStates[partNumber] ? 1 : 0);
 	}
-
-
-	return ptr;
+	return bitSet;
 }
 
-
-PatchCache *Synth::indexPatchCache( Bit16u index1, Bit16u index2 )
-{
-	PatchCache *ptr;
-
-
-	ptr = NULL;
-	if( index1 < 0x1000 ) {
-		Part *part;
-
-		index1 -= 0x0000;
-
-		part = (Part *) getPart(index1);
-		ptr = (PatchCache *) part->getPatchCache(index2);
+void Synth::getPartialStates(PartialState *partialStates) const {
+	if (!opened) {
+		memset(partialStates, 0, partialCount * sizeof(PartialState));
+		return;
 	}
-	else if( index1 < 0x2000 ) {
-		RhythmPart *part;
-
-		index1 -= 0x1000;
-
-		part = (RhythmPart *) getPart(8);
-		ptr = (PatchCache *) part->getPatchCache(index2);
+	for (unsigned int partialNum = 0; partialNum < partialCount; partialNum++) {
+		partialStates[partialNum] = getPartialState(partialManager, partialNum);
 	}
-	else if( index1 < 0x3000 ) {
-		RhythmPart *part;
-
-		index1 -= 0x2000;
+}
 
-		part = (RhythmPart *) getPart(8);
-		ptr = (PatchCache *) part->getDrumCache(index1, index2);
+void Synth::getPartialStates(Bit8u *partialStates) const {
+	if (!opened) {
+		memset(partialStates, 0, ((partialCount + 3) >> 2));
+		return;
 	}
-	else if( index1 < 0x4000 ) {
-		index1 -= 0x3000;
-
-		ptr = (PatchCache *) &getPartial(index1)->cachebackup;
+	for (unsigned int quartNum = 0; (4 * quartNum) < partialCount; quartNum++) {
+		Bit8u packedStates = 0;
+		for (unsigned int i = 0; i < 4; i++) {
+			unsigned int partialNum = (4 * quartNum) + i;
+			if (partialCount <= partialNum) break;
+			PartialState partialState = getPartialState(partialManager, partialNum);
+			packedStates |= (partialState & 3) << (2 * i);
+		}
+		partialStates[quartNum] = packedStates;
 	}
-
-
-	return ptr;
-}
-
-
-MemParams::PatchTemp *Synth::indexPatchTemp( Bit8u index )
-{
-	MemParams::PatchTemp *ptr;
-
-	ptr = NULL;
-	if( index != 0xff )
-		ptr = &mt32ram.patchTemp[index];
-
-	return ptr;
 }
 
-
-PCMWaveEntry *Synth::indexPCMWaveEntry( Bit16u index )
-{
-	PCMWaveEntry *ptr;
-
-	ptr = NULL;
-	if( index != 0xffff ) {
-		ptr = &pcmWaves[index];
+Bit32u Synth::getPlayingNotes(Bit8u partNumber, Bit8u *keys, Bit8u *velocities) const {
+	Bit32u playingNotes = 0;
+	if (opened && (partNumber < 9)) {
+		const Part *part = parts[partNumber];
+		const Poly *poly = part->getFirstActivePoly();
+		while (poly != NULL) {
+			keys[playingNotes] = Bit8u(poly->getKey());
+			velocities[playingNotes] = Bit8u(poly->getVelocity());
+			playingNotes++;
+			poly = poly->getNext();
+		}
 	}
-
-	return ptr;
+	return playingNotes;
 }
 
-// WE NEED TO REFRESH THIS
-Poly *Synth::indexPoly( Bit16u index1, Bit16u index2 )
-{
-	Poly *ptr;
-
-
-	ptr = NULL;
-	if( index1 != 0xffff ) {
-		Part *part;
-		part = (Part *) getPart(index1);
+const char *Synth::getPatchName(Bit8u partNumber) const {
+	return (!opened || partNumber > 8) ? NULL : parts[partNumber]->getCurrentInstr();
+}
 
-		ptr = (Poly *) part->getActivePoly(index2);
+const Part *Synth::getPart(Bit8u partNum) const {
+	if (partNum > 8) {
+		return NULL;
 	}
-
-
-	return ptr;
+	return parts[partNum];
 }
 
-
-MemParams::RhythmTemp *Synth::indexRhythmTemp( Bit8u index )
-{
-	MemParams::RhythmTemp *ptr;
-
-	ptr = NULL;
-	if( index != 0xff ) {
-		ptr = &mt32ram.rhythmTemp[index];
+void MemoryRegion::read(unsigned int entry, unsigned int off, Bit8u *dst, unsigned int len) const {
+	off += entry * entrySize;
+	// This method should never be called with out-of-bounds parameters,
+	// or on an unsupported region - seeing any of this debug output indicates a bug in the emulator
+	if (off > entrySize * entries - 1) {
+#if MT32EMU_MONITOR_SYSEX > 0
+		synth->printDebug("read[%d]: parameters start out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
+#endif
+		return;
 	}
-
-	return ptr;
+	if (off + len > entrySize * entries) {
+#if MT32EMU_MONITOR_SYSEX > 0
+		synth->printDebug("read[%d]: parameters end out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
+#endif
+		len = entrySize * entries - off;
+	}
+	Bit8u *src = getRealMemory();
+	if (src == NULL) {
+#if MT32EMU_MONITOR_SYSEX > 0
+		synth->printDebug("read[%d]: unreadable region: entry=%d, off=%d, len=%d", type, entry, off, len);
+#endif
+		return;
+	}
+	memcpy(dst, src + off, len);
 }
 
+void MemoryRegion::write(unsigned int entry, unsigned int off, const Bit8u *src, unsigned int len, bool init) const {
+	unsigned int memOff = entry * entrySize + off;
+	// This method should never be called with out-of-bounds parameters,
+	// or on an unsupported region - seeing any of this debug output indicates a bug in the emulator
+	if (off > entrySize * entries - 1) {
+#if MT32EMU_MONITOR_SYSEX > 0
+		synth->printDebug("write[%d]: parameters start out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
+#endif
+		return;
+	}
+	if (off + len > entrySize * entries) {
+#if MT32EMU_MONITOR_SYSEX > 0
+		synth->printDebug("write[%d]: parameters end out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
+#endif
+		len = entrySize * entries - off;
+	}
+	Bit8u *dest = getRealMemory();
+	if (dest == NULL) {
+#if MT32EMU_MONITOR_SYSEX > 0
+		synth->printDebug("write[%d]: unwritable region: entry=%d, off=%d, len=%d", type, entry, off, len);
+#endif
+		return;
+	}
 
-TimbreParam *Synth::indexTimbreParam( Bit8u index )
-{
-	TimbreParam *ptr;
-
-	ptr = NULL;
-	if( index != 0xff )
-		ptr = &mt32ram.timbreTemp[index];
-
-	return ptr;
-}
-
+	for (unsigned int i = 0; i < len; i++) {
+		Bit8u desiredValue = src[i];
+		Bit8u maxValue = getMaxValue(memOff);
+		// maxValue == 0 means write-protected unless called from initialisation code, in which case it really means the maximum value is 0.
+		if (maxValue != 0 || init) {
+			if (desiredValue > maxValue) {
+#if MT32EMU_MONITOR_SYSEX > 0
+				synth->printDebug("write[%d]: Wanted 0x%02x at %d, but max 0x%02x", type, desiredValue, memOff, maxValue);
+#endif
+				desiredValue = maxValue;
+			}
+			dest[memOff] = desiredValue;
+		} else if (desiredValue != 0) {
+#if MT32EMU_MONITOR_SYSEX > 0
+			// Only output debug info if they wanted to write non-zero, since a lot of things cause this to spit out a lot of debug info otherwise.
+			synth->printDebug("write[%d]: Wanted 0x%02x at %d, but write-protected", type, desiredValue, memOff);
+#endif
+		}
+		memOff++;
+	}
 }
 
+} // namespace MT32Emu
diff --git a/src/mt32/Synth.h b/src/mt32/Synth.h
index 2f7d57f2..54417d5b 100644
--- a/src/mt32/Synth.h
+++ b/src/mt32/Synth.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -19,47 +19,40 @@
 #define MT32EMU_SYNTH_H
 
 #include <cstdarg>
+#include <cstddef>
+#include <cstring>
+
+#include "globals.h"
+#include "Types.h"
+#include "Enumerations.h"
 
 namespace MT32Emu {
 
-class File;
-class TableInitialiser;
+class Analog;
+class BReverbModel;
+class Extensions;
+class MemoryRegion;
+class MidiEventQueue;
+class Part;
+class Poly;
 class Partial;
 class PartialManager;
-class Part;
+class Renderer;
 class ROMImage;
 
-/**
- * Methods for emulating the connection between the LA32 and the DAC, which involves
- * some hacks in the real devices for doubling the volume.
- * See also http://en.wikipedia.org/wiki/Roland_MT-32#Digital_overflow
- */
-enum DACInputMode {
-	// Produces samples at double the volume, without tricks.
-	// * Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)
-	// * Higher quality than the real devices
-	DACInputMode_NICE,
-
-	// Produces samples that exactly match the bits output from the emulated LA32.
-	// * Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)
-	// * Much less likely to overdrive than any other mode.
-	// * Half the volume of any of the other modes, meaning its volume relative to the reverb
-	//   output when mixed together directly will sound wrong.
-	// * Perfect for developers while debugging :)
-	DACInputMode_PURE,
-
-	// Re-orders the LA32 output bits as in early generation MT-32s (according to Wikipedia).
-	// Bit order at DAC (where each number represents the original LA32 output bit number, and XX means the bit is always low):
-	// 15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 XX
-	DACInputMode_GENERATION1,
-
-	// Re-orders the LA32 output bits as in later generations (personally confirmed on my CM-32L - KG).
-	// Bit order at DAC (where each number represents the original LA32 output bit number):
-	// 15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 14
-	DACInputMode_GENERATION2
-};
+class PatchTempMemoryRegion;
+class RhythmTempMemoryRegion;
+class TimbreTempMemoryRegion;
+class PatchesMemoryRegion;
+class TimbresMemoryRegion;
+class SystemMemoryRegion;
+class DisplayMemoryRegion;
+class ResetMemoryRegion;
 
-typedef void (*FloatToBit16sFunc)(Bit16s *target, const float *source, Bit32u len, float outputGain);
+struct ControlROMFeatureSet;
+struct ControlROMMap;
+struct PCMWaveEntry;
+struct MemParams;
 
 const Bit8u SYSEX_MANUFACTURER_ROLAND = 0x41;
 
@@ -76,200 +69,67 @@ const Bit8u SYSEX_CMD_EOD = 0x45; // End of data
 const Bit8u SYSEX_CMD_ERR = 0x4E; // Communications error
 const Bit8u SYSEX_CMD_RJC = 0x4F; // Rejection
 
-const int MAX_SYSEX_SIZE = 512;
-
-const unsigned int CONTROL_ROM_SIZE = 64 * 1024;
-
-struct ControlROMPCMStruct {
-	Bit8u pos;
-	Bit8u len;
-	Bit8u pitchLSB;
-	Bit8u pitchMSB;
-};
-
-struct ControlROMMap {
-	Bit16u idPos;
-	Bit16u idLen;
-	const char *idBytes;
-	Bit16u pcmTable; // 4 * pcmCount bytes
-	Bit16u pcmCount;
-	Bit16u timbreAMap; // 128 bytes
-	Bit16u timbreAOffset;
-	bool timbreACompressed;
-	Bit16u timbreBMap; // 128 bytes
-	Bit16u timbreBOffset;
-	bool timbreBCompressed;
-	Bit16u timbreRMap; // 2 * timbreRCount bytes
-	Bit16u timbreRCount;
-	Bit16u rhythmSettings; // 4 * rhythmSettingsCount bytes
-	Bit16u rhythmSettingsCount;
-	Bit16u reserveSettings; // 9 bytes
-	Bit16u panSettings; // 8 bytes
-	Bit16u programSettings; // 8 bytes
-	Bit16u rhythmMaxTable; // 4 bytes
-	Bit16u patchMaxTable; // 16 bytes
-	Bit16u systemMaxTable; // 23 bytes
-	Bit16u timbreMaxTable; // 72 bytes
-};
-
-enum MemoryRegionType {
-	MR_PatchTemp, MR_RhythmTemp, MR_TimbreTemp, MR_Patches, MR_Timbres, MR_System, MR_Display, MR_Reset
-};
-
-enum ReverbMode {
-	REVERB_MODE_ROOM,
-	REVERB_MODE_HALL,
-	REVERB_MODE_PLATE,
-	REVERB_MODE_TAP_DELAY
-};
-
-class MemoryRegion {
-private:
-	Synth *synth;
-	Bit8u *realMemory;
-	Bit8u *maxTable;
-public:
-	MemoryRegionType type;
-	Bit32u startAddr, entrySize, entries;
-
-	MemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable, MemoryRegionType useType, Bit32u useStartAddr, Bit32u useEntrySize, Bit32u useEntries) {
-		synth = useSynth;
-		realMemory = useRealMemory;
-		maxTable = useMaxTable;
-		type = useType;
-		startAddr = useStartAddr;
-		entrySize = useEntrySize;
-		entries = useEntries;
-	}
-	int lastTouched(Bit32u addr, Bit32u len) const {
-		return (offset(addr) + len - 1) / entrySize;
-	}
-	int firstTouchedOffset(Bit32u addr) const {
-		return offset(addr) % entrySize;
-	}
-	int firstTouched(Bit32u addr) const {
-		return offset(addr) / entrySize;
-	}
-	Bit32u regionEnd() const {
-		return startAddr + entrySize * entries;
-	}
-	bool contains(Bit32u addr) const {
-		return addr >= startAddr && addr < regionEnd();
-	}
-	int offset(Bit32u addr) const {
-		return addr - startAddr;
-	}
-	Bit32u getClampedLen(Bit32u addr, Bit32u len) const {
-		if (addr + len > regionEnd())
-			return regionEnd() - addr;
-		return len;
-	}
-	Bit32u next(Bit32u addr, Bit32u len) const {
-		if (addr + len > regionEnd()) {
-			return regionEnd() - addr;
-		}
-		return 0;
-	}
-	Bit8u getMaxValue(int off) const {
-		if (maxTable == NULL)
-			return 0xFF;
-		return maxTable[off % entrySize];
-	}
-	Bit8u *getRealMemory() const {
-		return realMemory;
-	}
-	bool isReadable() const {
-		return getRealMemory() != NULL;
-	}
-	void read(unsigned int entry, unsigned int off, Bit8u *dst, unsigned int len) const;
-	void write(unsigned int entry, unsigned int off, const Bit8u *src, unsigned int len, bool init = false) const;
-};
-
-class PatchTempMemoryRegion : public MemoryRegion {
-public:
-	PatchTempMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_PatchTemp, MT32EMU_MEMADDR(0x030000), sizeof(MemParams::PatchTemp), 9) {}
-};
-class RhythmTempMemoryRegion : public MemoryRegion {
-public:
-	RhythmTempMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_RhythmTemp, MT32EMU_MEMADDR(0x030110), sizeof(MemParams::RhythmTemp), 85) {}
-};
-class TimbreTempMemoryRegion : public MemoryRegion {
-public:
-	TimbreTempMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_TimbreTemp, MT32EMU_MEMADDR(0x040000), sizeof(TimbreParam), 8) {}
-};
-class PatchesMemoryRegion : public MemoryRegion {
-public:
-	PatchesMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_Patches, MT32EMU_MEMADDR(0x050000), sizeof(PatchParam), 128) {}
-};
-class TimbresMemoryRegion : public MemoryRegion {
-public:
-	TimbresMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_Timbres, MT32EMU_MEMADDR(0x080000), sizeof(MemParams::PaddedTimbre), 64 + 64 + 64 + 64) {}
-};
-class SystemMemoryRegion : public MemoryRegion {
-public:
-	SystemMemoryRegion(Synth *useSynth, Bit8u *useRealMemory, Bit8u *useMaxTable) : MemoryRegion(useSynth, useRealMemory, useMaxTable, MR_System, MT32EMU_MEMADDR(0x100000), sizeof(MemParams::System), 1) {}
-};
-class DisplayMemoryRegion : public MemoryRegion {
-public:
-	DisplayMemoryRegion(Synth *useSynth) : MemoryRegion(useSynth, NULL, NULL, MR_Display, MT32EMU_MEMADDR(0x200000), MAX_SYSEX_SIZE - 1, 1) {}
-};
-class ResetMemoryRegion : public MemoryRegion {
-public:
-	ResetMemoryRegion(Synth *useSynth) : MemoryRegion(useSynth, NULL, NULL, MR_Reset, MT32EMU_MEMADDR(0x7F0000), 0x3FFF, 1) {}
+const Bit32u CONTROL_ROM_SIZE = 64 * 1024;
+
+// Set of multiplexed output streams appeared at the DAC entrance.
+template <class T>
+struct DACOutputStreams {
+	T *nonReverbLeft;
+	T *nonReverbRight;
+	T *reverbDryLeft;
+	T *reverbDryRight;
+	T *reverbWetLeft;
+	T *reverbWetRight;
 };
 
-class ReverbModel {
-public:
-	virtual ~ReverbModel() {}
-	// After construction or a close(), open() will be called at least once before any other call (with the exception of close()).
-	virtual void open() = 0;
-	// May be called multiple times without an open() in between.
-	virtual void close() = 0;
-	virtual void setParameters(Bit8u time, Bit8u level) = 0;
-	virtual void process(const float *inLeft, const float *inRight, float *outLeft, float *outRight, unsigned long numSamples) = 0;
-	virtual bool isActive() const = 0;
-	
-	virtual void saveState( std::ostream &stream ) {}
-	virtual void loadState( std::istream &stream ) {}
-};
-
-class ReportHandler {
-friend class Synth;
-
+// Class for the client to supply callbacks for reporting various errors and information
+class MT32EMU_EXPORT ReportHandler {
 public:
 	virtual ~ReportHandler() {}
 
-protected:
-
 	// Callback for debug messages, in vprintf() format
 	virtual void printDebug(const char *fmt, va_list list);
-
-	// Callbacks for reporting various errors and information
+	// Callbacks for reporting errors
 	virtual void onErrorControlROM() {}
 	virtual void onErrorPCMROM() {}
+	// Callback for reporting about displaying a new custom message on LCD
 	virtual void showLCDMessage(const char *message);
+	// Callback for reporting actual processing of a MIDI message
+	virtual void onMIDIMessagePlayed() {}
+	// Callback for reporting an overflow of the input MIDI queue.
+	// Returns true if a recovery action was taken and yet another attempt to enqueue the MIDI event is desired.
+	virtual bool onMIDIQueueOverflow() { return false; }
+	// Callback invoked when a System Realtime MIDI message is detected at the input.
+	virtual void onMIDISystemRealtime(Bit8u /* systemRealtime */) {}
+	// Callbacks for reporting system events
 	virtual void onDeviceReset() {}
 	virtual void onDeviceReconfig() {}
+	// Callbacks for reporting changes of reverb settings
 	virtual void onNewReverbMode(Bit8u /* mode */) {}
 	virtual void onNewReverbTime(Bit8u /* time */) {}
 	virtual void onNewReverbLevel(Bit8u /* level */) {}
-	virtual void onPartStateChanged(int /* partNum */, bool /* isActive */) {}
-	virtual void onPolyStateChanged(int /* partNum */) {}
-	virtual void onPartialStateChanged(int /* partialNum */, int /* oldPartialPhase */, int /* newPartialPhase */) {}
-	virtual void onProgramChanged(int /* partNum */, char * /* patchName */) {}
+	// Callbacks for reporting various information
+	virtual void onPolyStateChanged(Bit8u /* partNum */) {}
+	virtual void onProgramChanged(Bit8u /* partNum */, const char * /* soundGroupName */, const char * /* patchName */) {}
 };
 
 class Synth {
+friend class DefaultMidiStreamParser;
 friend class Part;
-friend class RhythmPart;
-friend class Poly;
 friend class Partial;
-friend class Tables;
-friend class MemoryRegion;
+friend class PartialManager;
+friend class Poly;
+friend class Renderer;
+friend class RhythmPart;
+friend class SamplerateAdapter;
+friend class SoxrAdapter;
 friend class TVA;
 friend class TVF;
 friend class TVP;
+
 private:
+	// **************************** Implementation fields **************************
+
 	PatchTempMemoryRegion *patchTempMemoryRegion;
 	RhythmTempMemoryRegion *rhythmTempMemoryRegion;
 	TimbreTempMemoryRegion *timbreTempMemoryRegion;
@@ -281,33 +141,40 @@ private:
 
 	Bit8u *paddedTimbreMaxTable;
 
-	bool isEnabled;
-
 	PCMWaveEntry *pcmWaves; // Array
 
+	const ControlROMFeatureSet *controlROMFeatures;
 	const ControlROMMap *controlROMMap;
 	Bit8u controlROMData[CONTROL_ROM_SIZE];
 	Bit16s *pcmROMData;
 	size_t pcmROMSize; // This is in 16-bit samples, therefore half the number of bytes in the ROM
 
-	Bit8s chantable[32];
+	Bit8u soundGroupIx[128]; // For each standard timbre
+	const char (*soundGroupNames)[9]; // Array
 
-	Bit32u renderedSampleCount;
+	Bit32u partialCount;
+	Bit8u nukeme[16]; // FIXME: Nuke it. For binary compatibility only.
 
+	MidiEventQueue *midiQueue;
+	volatile Bit32u lastReceivedMIDIEventTimestamp;
+	volatile Bit32u renderedSampleCount;
 
-	MemParams mt32ram, mt32default;
+	MemParams &mt32ram, &mt32default;
 
-	ReverbModel *reverbModels[4];
-	ReverbModel *reverbModel;
-	bool reverbEnabled;
+	BReverbModel *reverbModels[4];
+	BReverbModel *reverbModel;
 	bool reverbOverridden;
 
-	FloatToBit16sFunc la32FloatToBit16sFunc;
-	FloatToBit16sFunc reverbFloatToBit16sFunc;
+	MIDIDelayMode midiDelayMode;
+	DACInputMode dacInputMode;
+
 	float outputGain;
 	float reverbOutputGain;
 
-	bool isOpen;
+	bool reversedStereoEnabled;
+
+	bool opened;
+	bool activated;
 
 	bool isDefaultReportHandler;
 	ReportHandler *reportHandler;
@@ -315,44 +182,24 @@ private:
 	PartialManager *partialManager;
 	Part *parts[9];
 
-	// FIXME: We can reorganise things so that we don't need all these separate tmpBuf, tmp and prerender buffers.
-	// This should be rationalised when things have stabilised a bit (if prerender buffers don't die in the mean time).
-
-	float tmpBufPartialLeft[MAX_SAMPLES_PER_RUN];
-	float tmpBufPartialRight[MAX_SAMPLES_PER_RUN];
-	float tmpBufMixLeft[MAX_SAMPLES_PER_RUN];
-	float tmpBufMixRight[MAX_SAMPLES_PER_RUN];
-	float tmpBufReverbOutLeft[MAX_SAMPLES_PER_RUN];
-	float tmpBufReverbOutRight[MAX_SAMPLES_PER_RUN];
-
-	Bit16s tmpNonReverbLeft[MAX_SAMPLES_PER_RUN];
-	Bit16s tmpNonReverbRight[MAX_SAMPLES_PER_RUN];
-	Bit16s tmpReverbDryLeft[MAX_SAMPLES_PER_RUN];
-	Bit16s tmpReverbDryRight[MAX_SAMPLES_PER_RUN];
-	Bit16s tmpReverbWetLeft[MAX_SAMPLES_PER_RUN];
-	Bit16s tmpReverbWetRight[MAX_SAMPLES_PER_RUN];
-
-	// These ring buffers are only used to simulate delays present on the real device.
-	// In particular, when a partial needs to be aborted to free it up for use by a new Poly,
+	// When a partial needs to be aborted to free it up for use by a new Poly,
 	// the controller will busy-loop waiting for the sound to finish.
-	Bit16s prerenderNonReverbLeft[MAX_PRERENDER_SAMPLES];
-	Bit16s prerenderNonReverbRight[MAX_PRERENDER_SAMPLES];
-	Bit16s prerenderReverbDryLeft[MAX_PRERENDER_SAMPLES];
-	Bit16s prerenderReverbDryRight[MAX_PRERENDER_SAMPLES];
-	Bit16s prerenderReverbWetLeft[MAX_PRERENDER_SAMPLES];
-	Bit16s prerenderReverbWetRight[MAX_PRERENDER_SAMPLES];
-	int prerenderReadIx;
-	int prerenderWriteIx;
-
-	unsigned int partialLimit;
-
-	bool prerender();
-	void copyPrerender(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u pos, Bit32u len);
-	void checkPrerender(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u &pos, Bit32u &len);
-	void doRenderStreams(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u len);
-
-	void playAddressedSysex(unsigned char channel, const Bit8u *sysex, Bit32u len);
-	void readSysex(unsigned char channel, const Bit8u *sysex, Bit32u len) const;
+	// We emulate this by delaying new MIDI events processing until abortion finishes.
+	Poly *abortingPoly;
+
+	Analog *analog;
+	Renderer *renderer;
+
+	// Binary compatibility helper.
+	Extensions &extensions;
+
+	// **************************** Implementation methods **************************
+
+	Bit32u addMIDIInterfaceDelay(Bit32u len, Bit32u timestamp);
+	bool isAbortingPoly() const { return abortingPoly != NULL; }
+
+	void writeSysexGlobal(Bit32u addr, const Bit8u *sysex, Bit32u len);
+	void readSysex(Bit8u channel, const Bit8u *sysex, Bit32u len) const;
 	void initMemoryRegions();
 	void deleteMemoryRegions();
 	MemoryRegion *findMemoryRegion(Bit32u addr);
@@ -363,116 +210,292 @@ private:
 	bool loadPCMROM(const ROMImage &pcmROMImage);
 
 	bool initPCMList(Bit16u mapAddress, Bit16u count);
-	bool initTimbres(Bit16u mapAddress, Bit16u offset, int timbreCount, int startTimbre, bool compressed);
-	bool initCompressedTimbre(int drumNum, const Bit8u *mem, unsigned int memLen);
+	bool initTimbres(Bit16u mapAddress, Bit16u offset, Bit16u timbreCount, Bit16u startTimbre, bool compressed);
+	bool initCompressedTimbre(Bit16u drumNum, const Bit8u *mem, Bit32u memLen);
+	void initReverbModels(bool mt32CompatibleMode);
+	void initSoundGroups(char newSoundGroupNames[][9]);
 
 	void refreshSystemMasterTune();
 	void refreshSystemReverbParameters();
 	void refreshSystemReserveSettings();
-	void refreshSystemChanAssign(unsigned int firstPart, unsigned int lastPart);
+	void refreshSystemChanAssign(Bit8u firstPart, Bit8u lastPart);
 	void refreshSystemMasterVol();
 	void refreshSystem();
 	void reset();
+	void dispose();
 
-	void printPartialUsage(unsigned long sampleOffset = 0);
+	void printPartialUsage(Bit32u sampleOffset = 0);
 
-	void partStateChanged(int partNum, bool isPartActive);
-	void polyStateChanged(int partNum);
-	void partialStateChanged(const Partial * const partial, int oldPartialPhase, int newPartialPhase);
-	void newTimbreSet(int partNum, char patchName[]);
+	void newTimbreSet(Bit8u partNum, Bit8u timbreGroup, Bit8u timbreNumber, const char patchName[]);
 	void printDebug(const char *fmt, ...);
 
+	// partNum should be 0..7 for Part 1..8, or 8 for Rhythm
+	const Part *getPart(Bit8u partNum) const;
+
+	void resetMasterTunePitchDelta();
+	Bit32s getMasterTunePitchDelta() const;
+
 public:
-	static Bit8u calcSysexChecksum(const Bit8u *data, Bit32u len, Bit8u checksum);
+	static inline Bit16s clipSampleEx(Bit32s sampleEx) {
+		// Clamp values above 32767 to 32767, and values below -32768 to -32768
+		// FIXME: Do we really need this stuff? I think these branches are very well predicted. Instead, this introduces a chain.
+		// The version below is actually a bit faster on my system...
+		//return ((sampleEx + 0x8000) & ~0xFFFF) ? Bit16s((sampleEx >> 31) ^ 0x7FFF) : (Bit16s)sampleEx;
+		return ((-0x8000 <= sampleEx) && (sampleEx <= 0x7FFF)) ? Bit16s(sampleEx) : Bit16s((sampleEx >> 31) ^ 0x7FFF);
+	}
+
+	static inline float clipSampleEx(float sampleEx) {
+		return sampleEx;
+	}
+
+	template <class S>
+	static inline void muteSampleBuffer(S *buffer, Bit32u len) {
+		if (buffer == NULL) return;
+		memset(buffer, 0, len * sizeof(S));
+	}
+
+	static inline void muteSampleBuffer(float *buffer, Bit32u len) {
+		if (buffer == NULL) return;
+		// FIXME: Use memset() where compatibility is guaranteed (if this turns out to be a win)
+		while (len--) {
+			*(buffer++) = 0.0f;
+		}
+	}
+
+	static inline Bit16s convertSample(float sample) {
+		return Synth::clipSampleEx(Bit32s(sample * 32768.0f)); // This multiplier corresponds to normalised floats
+	}
+
+	static inline float convertSample(Bit16s sample) {
+		return float(sample) / 32768.0f; // This multiplier corresponds to normalised floats
+	}
+
+	// Returns library version as an integer in format: 0x00MMmmpp, where:
+	// MM - major version number
+	// mm - minor version number
+	// pp - patch number
+	MT32EMU_EXPORT static Bit32u getLibraryVersionInt();
+	// Returns library version as a C-string in format: "MAJOR.MINOR.PATCH"
+	MT32EMU_EXPORT static const char *getLibraryVersionString();
+
+	MT32EMU_EXPORT static Bit32u getShortMessageLength(Bit32u msg);
+	MT32EMU_EXPORT static Bit8u calcSysexChecksum(const Bit8u *data, const Bit32u len, const Bit8u initChecksum = 0);
+
+	// Returns output sample rate used in emulation of stereo analog circuitry of hardware units.
+	// See comment for AnalogOutputMode.
+	MT32EMU_EXPORT static Bit32u getStereoOutputSampleRate(AnalogOutputMode analogOutputMode);
 
 	// Optionally sets callbacks for reporting various errors, information and debug messages
-	Synth(ReportHandler *useReportHandler = NULL);
-	~Synth();
+	MT32EMU_EXPORT explicit Synth(ReportHandler *useReportHandler = NULL);
+	MT32EMU_EXPORT ~Synth();
 
 	// Used to initialise the MT-32. Must be called before any other function.
 	// Returns true if initialization was sucessful, otherwise returns false.
 	// controlROMImage and pcmROMImage represent Control and PCM ROM images for use by synth.
-	bool open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage);
-
-	// Closes the MT-32 and deallocates any memory used by the synthesizer
-	void close(void);
-
-	// Sends a 4-byte MIDI message to the MT-32 for immediate playback
-	void playMsg(Bit32u msg);
-	void playMsgOnPart(unsigned char part, unsigned char code, unsigned char note, unsigned char velocity);
+	// usePartialCount sets the maximum number of partials playing simultaneously for this session (optional).
+	// analogOutputMode sets the mode for emulation of analogue circuitry of the hardware units (optional).
+	MT32EMU_EXPORT bool open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage, Bit32u usePartialCount = DEFAULT_MAX_PARTIALS, AnalogOutputMode analogOutputMode = AnalogOutputMode_COARSE);
 
-	// Sends a string of Sysex commands to the MT-32 for immediate interpretation
-	// The length is in bytes
-	void playSysex(const Bit8u *sysex, Bit32u len);
-	void playSysexWithoutFraming(const Bit8u *sysex, Bit32u len);
-	void playSysexWithoutHeader(unsigned char device, unsigned char command, const Bit8u *sysex, Bit32u len);
-	void writeSysex(unsigned char channel, const Bit8u *sysex, Bit32u len);
+	// Overloaded method which opens the synth with default partial count.
+	MT32EMU_EXPORT bool open(const ROMImage &controlROMImage, const ROMImage &pcmROMImage, AnalogOutputMode analogOutputMode);
 
-	void setReverbEnabled(bool reverbEnabled);
-	bool isReverbEnabled() const;
-	void setReverbOverridden(bool reverbOverridden);
-	bool isReverbOverridden() const;
-	void setDACInputMode(DACInputMode mode);
+	// Closes the MT-32 and deallocates any memory used by the synthesizer
+	MT32EMU_EXPORT void close();
+
+	// Returns true if the synth is in completely initialized state, otherwise returns false.
+	MT32EMU_EXPORT bool isOpen() const;
+
+	// All the enqueued events are processed by the synth immediately.
+	MT32EMU_EXPORT void flushMIDIQueue();
+
+	// Sets size of the internal MIDI event queue. The queue size is set to the minimum power of 2 that is greater or equal to the size specified.
+	// The queue is flushed before reallocation.
+	// Returns the actual queue size being used.
+	MT32EMU_EXPORT Bit32u setMIDIEventQueueSize(Bit32u);
+
+	// Returns current value of the global counter of samples rendered since the synth was created (at the native sample rate 32000 Hz).
+	// This method helps to compute accurate timestamp of a MIDI message to use with the methods below.
+	MT32EMU_EXPORT Bit32u getInternalRenderedSampleCount() const;
+
+	// Enqueues a MIDI event for subsequent playback.
+	// The MIDI event will be processed not before the specified timestamp.
+	// The timestamp is measured as the global rendered sample count since the synth was created (at the native sample rate 32000 Hz).
+	// The minimum delay involves emulation of the delay introduced while the event is transferred via MIDI interface
+	// and emulation of the MCU busy-loop while it frees partials for use by a new Poly.
+	// Calls from multiple threads must be synchronised, although, no synchronisation is required with the rendering thread.
+	// The methods return false if the MIDI event queue is full and the message cannot be enqueued.
+
+	// Enqueues a single short MIDI message to play at specified time. The message must contain a status byte.
+	MT32EMU_EXPORT bool playMsg(Bit32u msg, Bit32u timestamp);
+	// Enqueues a single well formed System Exclusive MIDI message to play at specified time.
+	MT32EMU_EXPORT bool playSysex(const Bit8u *sysex, Bit32u len, Bit32u timestamp);
+
+	// Enqueues a single short MIDI message to be processed ASAP. The message must contain a status byte.
+	MT32EMU_EXPORT bool playMsg(Bit32u msg);
+	// Enqueues a single well formed System Exclusive MIDI message to be processed ASAP.
+	MT32EMU_EXPORT bool playSysex(const Bit8u *sysex, Bit32u len);
+
+	// WARNING:
+	// The methods below don't ensure minimum 1-sample delay between sequential MIDI events,
+	// and a sequence of NoteOn and immediately succeeding NoteOff messages is always silent.
+	// A thread that invokes these methods must be explicitly synchronised with the thread performing sample rendering.
+
+	// Sends a short MIDI message to the synth for immediate playback. The message must contain a status byte.
+	// See the WARNING above.
+	MT32EMU_EXPORT void playMsgNow(Bit32u msg);
+	// Sends unpacked short MIDI message to the synth for immediate playback. The message must contain a status byte.
+	// See the WARNING above.
+	MT32EMU_EXPORT void playMsgOnPart(Bit8u part, Bit8u code, Bit8u note, Bit8u velocity);
+
+	// Sends a single well formed System Exclusive MIDI message for immediate processing. The length is in bytes.
+	// See the WARNING above.
+	MT32EMU_EXPORT void playSysexNow(const Bit8u *sysex, Bit32u len);
+	// Sends inner body of a System Exclusive MIDI message for direct processing. The length is in bytes.
+	// See the WARNING above.
+	MT32EMU_EXPORT void playSysexWithoutFraming(const Bit8u *sysex, Bit32u len);
+	// Sends inner body of a System Exclusive MIDI message for direct processing. The length is in bytes.
+	// See the WARNING above.
+	MT32EMU_EXPORT void playSysexWithoutHeader(Bit8u device, Bit8u command, const Bit8u *sysex, Bit32u len);
+	// Sends inner body of a System Exclusive MIDI message for direct processing. The length is in bytes.
+	// See the WARNING above.
+	MT32EMU_EXPORT void writeSysex(Bit8u channel, const Bit8u *sysex, Bit32u len);
+
+	// Allows to disable wet reverb output altogether.
+	MT32EMU_EXPORT void setReverbEnabled(bool reverbEnabled);
+	// Returns whether wet reverb output is enabled.
+	MT32EMU_EXPORT bool isReverbEnabled() const;
+	// Sets override reverb mode. In this mode, emulation ignores sysexes (or the related part of them) which control the reverb parameters.
+	// This mode is in effect until it is turned off. When the synth is re-opened, the override mode is unchanged but the state
+	// of the reverb model is reset to default.
+	MT32EMU_EXPORT void setReverbOverridden(bool reverbOverridden);
+	// Returns whether reverb settings are overridden.
+	MT32EMU_EXPORT bool isReverbOverridden() const;
+	// Forces reverb model compatibility mode. By default, the compatibility mode corresponds to the used control ROM version.
+	// Invoking this method with the argument set to true forces emulation of old MT-32 reverb circuit.
+	// When the argument is false, emulation of the reverb circuit used in new generation of MT-32 compatible modules is enforced
+	// (these include CM-32L and LAPC-I).
+	MT32EMU_EXPORT void setReverbCompatibilityMode(bool mt32CompatibleMode);
+	// Returns whether reverb is in old MT-32 compatibility mode.
+	MT32EMU_EXPORT bool isMT32ReverbCompatibilityMode() const;
+	// Returns whether default reverb compatibility mode is the old MT-32 compatibility mode.
+	MT32EMU_EXPORT bool isDefaultReverbMT32Compatible() const;
+	// Sets new DAC input mode. See DACInputMode for details.
+	MT32EMU_EXPORT void setDACInputMode(DACInputMode mode);
+	// Returns current DAC input mode. See DACInputMode for details.
+	MT32EMU_EXPORT DACInputMode getDACInputMode() const;
+	// Sets new MIDI delay mode. See MIDIDelayMode for details.
+	MT32EMU_EXPORT void setMIDIDelayMode(MIDIDelayMode mode);
+	// Returns current MIDI delay mode. See MIDIDelayMode for details.
+	MT32EMU_EXPORT MIDIDelayMode getMIDIDelayMode() const;
+
+	// Sets output gain factor for synth output channels. Applied to all output samples and unrelated with the synth's Master volume,
+	// it rather corresponds to the gain of the output analog circuitry of the hardware units. However, together with setReverbOutputGain()
+	// it offers to the user a capability to control the gain of reverb and non-reverb output channels independently.
+	MT32EMU_EXPORT void setOutputGain(float gain);
+	// Returns current output gain factor for synth output channels.
+	MT32EMU_EXPORT float getOutputGain() const;
+
+	// Sets output gain factor for the reverb wet output channels. It rather corresponds to the gain of the output
+	// analog circuitry of the hardware units. However, together with setOutputGain() it offers to the user a capability
+	// to control the gain of reverb and non-reverb output channels independently.
+	//
+	// Note: We're currently emulate CM-32L/CM-64 reverb quite accurately and the reverb output level closely
+	// corresponds to the level of digital capture. Although, according to the CM-64 PCB schematic,
+	// there is a difference in the reverb analogue circuit, and the resulting output gain is 0.68
+	// of that for LA32 analogue output. This factor is applied to the reverb output gain.
+	MT32EMU_EXPORT void setReverbOutputGain(float gain);
+	// Returns current output gain factor for reverb wet output channels.
+	MT32EMU_EXPORT float getReverbOutputGain() const;
+
+	// Swaps left and right output channels.
+	MT32EMU_EXPORT void setReversedStereoEnabled(bool enabled);
+	// Returns whether left and right output channels are swapped.
+	MT32EMU_EXPORT bool isReversedStereoEnabled() const;
+
+	// Allows to toggle the NiceAmpRamp mode.
+	// In this mode, we want to ensure that amp ramp never jumps to the target
+	// value and always gradually increases or decreases. It seems that real units
+	// do not bother to always check if a newly started ramp leads to a jump.
+	// We also prefer the quality improvement over the emulation accuracy,
+	// so this mode is enabled by default.
+	MT32EMU_EXPORT void setNiceAmpRampEnabled(bool enabled);
+	// Returns whether NiceAmpRamp mode is enabled.
+	MT32EMU_EXPORT bool isNiceAmpRampEnabled() const;
+
+	// Selects new type of the wave generator and renderer to be used during subsequent calls to open().
+	// By default, RendererType_BIT16S is selected.
+	// See RendererType for details.
+	MT32EMU_EXPORT void selectRendererType(RendererType);
+	// Returns previously selected type of the wave generator and renderer.
+	// See RendererType for details.
+	MT32EMU_EXPORT RendererType getSelectedRendererType() const;
+
+	// Returns actual sample rate used in emulation of stereo analog circuitry of hardware units.
+	// See comment for render() below.
+	MT32EMU_EXPORT Bit32u getStereoOutputSampleRate() const;
+
+	// Renders samples to the specified output stream as if they were sampled at the analog stereo output.
+	// When AnalogOutputMode is set to ACCURATE (OVERSAMPLED), the output signal is upsampled to 48 (96) kHz in order
+	// to retain emulation accuracy in whole audible frequency spectra. Otherwise, native digital signal sample rate is retained.
+	// getStereoOutputSampleRate() can be used to query actual sample rate of the output signal.
+	// The length is in frames, not bytes (in 16-bit stereo, one frame is 4 bytes). Uses NATIVE byte ordering.
+	MT32EMU_EXPORT void render(Bit16s *stream, Bit32u len);
+	// Same as above but outputs to a float stereo stream.
+	MT32EMU_EXPORT void render(float *stream, Bit32u len);
+
+	// Renders samples to the specified output streams as if they appeared at the DAC entrance.
+	// No further processing performed in analog circuitry emulation is applied to the signal.
+	// NULL may be specified in place of any or all of the stream buffers to skip it.
+	// The length is in samples, not bytes. Uses NATIVE byte ordering.
+	MT32EMU_EXPORT void renderStreams(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u len);
+	MT32EMU_EXPORT void renderStreams(const DACOutputStreams<Bit16s> &streams, Bit32u len);
+	// Same as above but outputs to float streams.
+	MT32EMU_EXPORT void renderStreams(float *nonReverbLeft, float *nonReverbRight, float *reverbDryLeft, float *reverbDryRight, float *reverbWetLeft, float *reverbWetRight, Bit32u len);
+	MT32EMU_EXPORT void renderStreams(const DACOutputStreams<float> &streams, Bit32u len);
 
-	// Sets output gain factor. Applied to all output samples and unrelated with the synth's Master volume.
-	void setOutputGain(float);
+	// Returns true when there is at least one active partial, otherwise false.
+	MT32EMU_EXPORT bool hasActivePartials() const;
 
-	// Sets output gain factor for the reverb wet output. setOutputGain() doesn't change reverb output gain.
-	void setReverbOutputGain(float);
+	// Returns true if the synth is active and subsequent calls to render() may result in non-trivial output (i.e. silence).
+	// The synth is considered active when either there are pending MIDI events in the queue, there is at least one active partial,
+	// or the reverb is (somewhat unreliably) detected as being active.
+	MT32EMU_EXPORT bool isActive();
 
-	// Renders samples to the specified output stream.
-	// The length is in frames, not bytes (in 16-bit stereo,
-	// one frame is 4 bytes).
-	void render(Bit16s *stream, Bit32u len);
+	// Returns the maximum number of partials playing simultaneously.
+	MT32EMU_EXPORT Bit32u getPartialCount() const;
 
-	// Renders samples to the specified output streams (any or all of which may be NULL).
-	void renderStreams(Bit16s *nonReverbLeft, Bit16s *nonReverbRight, Bit16s *reverbDryLeft, Bit16s *reverbDryRight, Bit16s *reverbWetLeft, Bit16s *reverbWetRight, Bit32u len);
+	// Fills in current states of all the parts into the array provided. The array must have at least 9 entries to fit values for all the parts.
+	// If the value returned for a part is true, there is at least one active non-releasing partial playing on this part.
+	// This info is useful in emulating behaviour of LCD display of the hardware units.
+	MT32EMU_EXPORT void getPartStates(bool *partStates) const;
 
-	// Returns true when there is at least one active partial, otherwise false.
-	bool hasActivePartials() const;
+	// Returns current states of all the parts as a bit set. The least significant bit corresponds to the state of part 1,
+	// total of 9 bits hold the states of all the parts. If the returned bit for a part is set, there is at least one active
+	// non-releasing partial playing on this part. This info is useful in emulating behaviour of LCD display of the hardware units.
+	MT32EMU_EXPORT Bit32u getPartStates() const;
 
-	// Returns true if hasActivePartials() returns true, or reverb is (somewhat unreliably) detected as being active.
-	bool isActive() const;
+	// Fills in current states of all the partials into the array provided. The array must be large enough to accommodate states of all the partials.
+	MT32EMU_EXPORT void getPartialStates(PartialState *partialStates) const;
 
-	const Partial *getPartial(unsigned int partialNum) const;
+	// Fills in current states of all the partials into the array provided. Each byte in the array holds states of 4 partials
+	// starting from the least significant bits. The state of each partial is packed in a pair of bits.
+	// The array must be large enough to accommodate states of all the partials (see getPartialCount()).
+	MT32EMU_EXPORT void getPartialStates(Bit8u *partialStates) const;
 
-	void setPartialLimit( unsigned int partialLimit );
-	const unsigned int getPartialLimit() const;
-	
-	void readMemory(Bit32u addr, Bit32u len, Bit8u *data);
+	// Fills in information about currently playing notes on the specified part into the arrays provided. The arrays must be large enough
+	// to accommodate data for all the playing notes. The maximum number of simultaneously playing notes cannot exceed the number of partials.
+	// Argument partNumber should be 0..7 for Part 1..8, or 8 for Rhythm.
+	// Returns the number of currently playing notes on the specified part.
+	MT32EMU_EXPORT Bit32u getPlayingNotes(Bit8u partNumber, Bit8u *keys, Bit8u *velocities) const;
 
-	// partNum should be 0..7 for Part 1..8, or 8 for Rhythm
-	const Part *getPart(unsigned int partNum) const;
-
-	// svn-daum
-	void *dumpRam();
-	void loadRam( void *buf );
-
-	void findPart( const Part *src, Bit8u *index_out );
-	void findPartial( const Partial *src, Bit8u *index_out );
-	void findPartialParam( const TimbreParam::PartialParam *src, Bit16u *index_out1, Bit16u *index_out2 );
-	void findPatchCache( const PatchCache *src, Bit16u *index_out1, Bit16u *index_out2 );
-	void findPatchTemp( const MemParams::PatchTemp *src, Bit8u *index_out );
-	void findPCMWaveEntry( const PCMWaveEntry *src, Bit16u *index_out );
-	void findPoly( const Poly *src, Bit16u *index_out1, Bit16u *index_out2 );
-	void findRhythmTemp( const MemParams::RhythmTemp *src, Bit8u *index_out );
-	void findTimbreParam( const TimbreParam *src, Bit8u *index_out );
-
-	Part *indexPart( Bit8u index );
-	Partial *indexPartial( Bit8u index );
-	TimbreParam::PartialParam *indexPartialParam( Bit16u index1, Bit16u index2 );
-	PatchCache *indexPatchCache( Bit16u index1, Bit16u index2 );
-	MemParams::PatchTemp *indexPatchTemp( Bit8u index );
-	PCMWaveEntry *indexPCMWaveEntry( Bit16u index );
-	Poly *indexPoly( Bit16u index1, Bit16u index2 );
-	MemParams::RhythmTemp *indexRhythmTemp( Bit8u index );
-	TimbreParam *indexTimbreParam( Bit8u index );
-};
+	// Returns name of the patch set on the specified part.
+	// Argument partNumber should be 0..7 for Part 1..8, or 8 for Rhythm.
+	MT32EMU_EXPORT const char *getPatchName(Bit8u partNumber) const;
 
+	// Stores internal state of emulated synth into an array provided (as it would be acquired from hardware).
+	MT32EMU_EXPORT void readMemory(Bit32u addr, Bit32u len, Bit8u *data);
+}; // class Synth
 
-// debugger only
-//#define WIN32_DEBUG
-//#define WIN32_DUMP
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_SYNTH_H
diff --git a/src/mt32/TVA.cpp b/src/mt32/TVA.cpp
index 11140491..3f7064f9 100644
--- a/src/mt32/TVA.cpp
+++ b/src/mt32/TVA.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -19,11 +19,15 @@
  * This class emulates the calculations performed by the 8095 microcontroller in order to configure the LA-32's amplitude ramp for a single partial at each stage of its TVA envelope.
  * Unless we introduced bugs, it should be pretty much 100% accurate according to Mok's specifications.
 */
-#include <cmath>
 
-#include "mt32emu.h"
-#include "mmath.h"
-#include "PartialManager.h"
+#include "internals.h"
+
+#include "TVA.h"
+#include "Part.h"
+#include "Partial.h"
+#include "Poly.h"
+#include "Synth.h"
+#include "Tables.h"
 
 namespace MT32Emu {
 
@@ -32,31 +36,18 @@ static Bit8u biasLevelToAmpSubtractionCoeff[13] = {255, 187, 137, 100, 74, 54, 4
 
 TVA::TVA(const Partial *usePartial, LA32Ramp *useAmpRamp) :
 	partial(usePartial), ampRamp(useAmpRamp), system(&usePartial->getSynth()->mt32ram.system), phase(TVA_PHASE_DEAD) {
-
-
-	// init ptr warnings (load state crashes)
-	part = NULL;
-	partialParam = NULL;
-	patchTemp = NULL;
-	rhythmTemp = NULL;
 }
 
 void TVA::startRamp(Bit8u newTarget, Bit8u newIncrement, int newPhase) {
-	if (newPhase != phase) {
-		partial->getSynth()->partialStateChanged(partial, phase, newPhase);
-	}
 	target = newTarget;
 	phase = newPhase;
 	ampRamp->startRamp(newTarget, newIncrement);
 #if MT32EMU_MONITOR_TVA >= 1
-	partial->getSynth()->printDebug("[+%lu] [Partial %d] TVA,ramp,%d,%d,%d,%d", partial->debugGetSampleNum(), partial->debugGetPartialNum(), (newIncrement & 0x80) ? -1 : 1, (newIncrement & 0x7F), newPhase);
+	partial->getSynth()->printDebug("[+%lu] [Partial %d] TVA,ramp,%x,%s%x,%d", partial->debugGetSampleNum(), partial->debugGetPartialNum(), newTarget, (newIncrement & 0x80) ? "-" : "+", (newIncrement & 0x7F), newPhase);
 #endif
 }
 
 void TVA::end(int newPhase) {
-	if (newPhase != phase) {
-		partial->getSynth()->partialStateChanged(partial, phase, newPhase);
-	}
 	phase = newPhase;
 	playing = false;
 #if MT32EMU_MONITOR_TVA >= 1
@@ -104,14 +95,14 @@ static int calcVeloAmpSubtraction(Bit8u veloSensitivity, unsigned int velocity)
 	// FIXME:KG: Better variable names
 	int velocityMult = veloSensitivity - 50;
 	int absVelocityMult = velocityMult < 0 ? -velocityMult : velocityMult;
-	velocityMult = (signed)((unsigned)(velocityMult * ((signed)velocity - 64)) << 2);
+	velocityMult = signed(unsigned(velocityMult * (signed(velocity) - 64)) << 2);
 	return absVelocityMult - (velocityMult >> 8); // PORTABILITY NOTE: Assumes arithmetic shift
 }
 
-static int calcBasicAmp(const Tables *tables, const Partial *partial, const MemParams::System *system, const TimbreParam::PartialParam *partialParam, const MemParams::PatchTemp *patchTemp, const MemParams::RhythmTemp *rhythmTemp, int biasAmpSubtraction, int veloAmpSubtraction, Bit8u expression) {
+static int calcBasicAmp(const Tables *tables, const Partial *partial, const MemParams::System *system, const TimbreParam::PartialParam *partialParam, const MemParams::PatchTemp *patchTemp, const MemParams::RhythmTemp *rhythmTemp, int biasAmpSubtraction, int veloAmpSubtraction, Bit8u expression, bool hasRingModQuirk) {
 	int amp = 155;
 
-	if (!partial->isRingModulatingSlave()) {
+	if (!(hasRingModQuirk ? partial->isRingModulatingNoMix() : partial->isRingModulatingSlave())) {
 		amp -= tables->masterVolToAmpSubtraction[system->masterVol];
 		if (amp < 0) {
 			return 0;
@@ -153,7 +144,7 @@ static int calcBasicAmp(const Tables *tables, const Partial *partial, const MemP
 	return amp;
 }
 
-int calcKeyTimeSubtraction(Bit8u envTimeKeyfollow, int key) {
+static int calcKeyTimeSubtraction(Bit8u envTimeKeyfollow, int key) {
 	if (envTimeKeyfollow == 0) {
 		return 0;
 	}
@@ -178,7 +169,7 @@ void TVA::reset(const Part *newPart, const TimbreParam::PartialParam *newPartial
 	biasAmpSubtraction = calcBiasAmpSubtractions(partialParam, key);
 	veloAmpSubtraction = calcVeloAmpSubtraction(partialParam->tva.veloSensitivity, velocity);
 
-	int newTarget = calcBasicAmp(tables, partial, system, partialParam, patchTemp, newRhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression());
+	int newTarget = calcBasicAmp(tables, partial, system, partialParam, patchTemp, newRhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression(), partial->getSynth()->controlROMFeatures->quirkRingModulationNoMix);
 	int newPhase;
 	if (partialParam->tva.envTime[0] == 0) {
 		// Initially go to the TVA_PHASE_ATTACK target amp, and spend the next phase going from there to the TVA_PHASE_2 target amp
@@ -195,7 +186,7 @@ void TVA::reset(const Part *newPart, const TimbreParam::PartialParam *newPartial
 	// "Go downward as quickly as possible".
 	// Since the current value is 0, the LA32Ramp will notice that we're already at or below the target and trying to go downward,
 	// and therefore jump to the target immediately and raise an interrupt.
-	startRamp((Bit8u)newTarget, 0x80 | 127, newPhase);
+	startRamp(Bit8u(newTarget), 0x80 | 127, newPhase);
 }
 
 void TVA::startAbort() {
@@ -230,18 +221,29 @@ void TVA::recalcSustain() {
 	}
 	// We're sustaining. Recalculate all the values
 	const Tables *tables = &Tables::getInstance();
-	int newTarget = calcBasicAmp(tables, partial, system, partialParam, patchTemp, rhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression());
+	int newTarget = calcBasicAmp(tables, partial, system, partialParam, patchTemp, rhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression(), partial->getSynth()->controlROMFeatures->quirkRingModulationNoMix);
 	newTarget += partialParam->tva.envLevel[3];
-	// Since we're in TVA_PHASE_SUSTAIN at this point, we know that target has been reached and an interrupt fired, so we can rely on it being the current amp.
+
+	// Although we're in TVA_PHASE_SUSTAIN at this point, we cannot be sure that there is no active ramp at the moment.
+	// In case the channel volume or the expression changes frequently, the previously started ramp may still be in progress.
+	// Real hardware units ignore this possibility and rely on the assumption that the target is the current amp.
+	// This is OK in most situations but when the ramp that is currently in progress needs to change direction
+	// due to a volume/expression update, this leads to a jump in the amp that is audible as an unpleasant click.
+	// To avoid that, we compare the newTarget with the the actual current ramp value and correct the direction if necessary.
 	int targetDelta = newTarget - target;
 
 	// Calculate an increment to get to the new amp value in a short, more or less consistent amount of time
 	Bit8u newIncrement;
-	if (targetDelta >= 0) {
-		newIncrement = tables->envLogarithmicTime[(Bit8u)targetDelta] - 2;
+	bool descending = targetDelta < 0;
+	if (!descending) {
+		newIncrement = tables->envLogarithmicTime[Bit8u(targetDelta)] - 2;
 	} else {
-		newIncrement = (tables->envLogarithmicTime[(Bit8u)-targetDelta] - 2) | 0x80;
+		newIncrement = (tables->envLogarithmicTime[Bit8u(-targetDelta)] - 2) | 0x80;
 	}
+	if (part->getSynth()->isNiceAmpRampEnabled() && (descending != ampRamp->isBelowCurrent(newTarget))) {
+		newIncrement ^= 0x80;
+	}
+
 	// Configure so that once the transition's complete and nextPhase() is called, we'll just re-enter sustain phase (or decay phase, depending on parameters at the time).
 	startRamp(newTarget, newIncrement, TVA_PHASE_SUSTAIN - 1);
 }
@@ -269,7 +271,7 @@ void TVA::nextPhase() {
 	}
 
 	bool allLevelsZeroFromNowOn = false;
-	if (partialParam->tva.envLevel[3] == 0) {
+	if (!partial->getSynth()->controlROMFeatures->quirkTVAZeroEnvLevels && partialParam->tva.envLevel[3] == 0) {
 		if (newPhase == TVA_PHASE_4) {
 			allLevelsZeroFromNowOn = true;
 		} else if (partialParam->tva.envLevel[2] == 0) {
@@ -292,7 +294,7 @@ void TVA::nextPhase() {
 	int envPointIndex = phase;
 
 	if (!allLevelsZeroFromNowOn) {
-		newTarget = calcBasicAmp(tables, partial, system, partialParam, patchTemp, rhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression());
+		newTarget = calcBasicAmp(tables, partial, system, partialParam, patchTemp, rhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression(), partial->getSynth()->controlROMFeatures->quirkRingModulationNoMix);
 
 		if (newPhase == TVA_PHASE_SUSTAIN || newPhase == TVA_PHASE_RELEASE) {
 			if (partialParam->tva.envLevel[3] == 0) {
@@ -324,7 +326,7 @@ void TVA::nextPhase() {
 		int envTimeSetting = partialParam->tva.envTime[envPointIndex];
 
 		if (newPhase == TVA_PHASE_ATTACK) {
-			envTimeSetting -= ((signed)partial->getPoly()->getVelocity() - 64) >> (6 - partialParam->tva.envTimeVeloSensitivity); // PORTABILITY NOTE: Assumes arithmetic shift
+			envTimeSetting -= (signed(partial->getPoly()->getVelocity()) - 64) >> (6 - partialParam->tva.envTimeVeloSensitivity); // PORTABILITY NOTE: Assumes arithmetic shift
 
 			if (envTimeSetting <= 0 && partialParam->tva.envTime[envPointIndex] != 0) {
 				envTimeSetting = 1;
@@ -351,14 +353,14 @@ void TVA::nextPhase() {
 					}
 				}
 				targetDelta = -targetDelta;
-				newIncrement = tables->envLogarithmicTime[(Bit8u)targetDelta] - envTimeSetting;
+				newIncrement = tables->envLogarithmicTime[Bit8u(targetDelta)] - envTimeSetting;
 				if (newIncrement <= 0) {
 					newIncrement = 1;
 				}
 				newIncrement = newIncrement | 0x80;
 			} else {
 				// FIXME: The last 22 or so entries in this table are 128 - surely that fucks things up, since that ends up being -128 signed?
-				newIncrement = tables->envLogarithmicTime[(Bit8u)targetDelta] - envTimeSetting;
+				newIncrement = tables->envLogarithmicTime[Bit8u(targetDelta)] - envTimeSetting;
 				if (newIncrement <= 0) {
 					newIncrement = 1;
 				}
@@ -373,156 +375,7 @@ void TVA::nextPhase() {
 		}
 	}
 
-	startRamp((Bit8u)newTarget, (Bit8u)newIncrement, newPhase);
-}
-
-
-#ifdef WIN32_DEBUG
-void TVA::rawVerifyState( char *name, Synth *useSynth )
-{
-	TVA *ptr1, *ptr2;
-	TVA tva_temp(partial,ampRamp);
-
-
-#ifndef WIN32_DUMP
-	return;
-#endif
-
-	ptr1 = this;
-	ptr2 = &tva_temp;
-	useSynth->rawLoadState( name, ptr2, sizeof(*this) );
-
-
-	if( ptr1->partial != ptr2->partial ) __asm int 3
-	if( ptr1->ampRamp != ptr2->ampRamp ) __asm int 3
-	if( ptr1->system != ptr2->system ) __asm int 3
-	if( ptr1->part != ptr2->part ) __asm int 3
-	if( ptr1->partialParam != ptr2->partialParam ) __asm int 3
-	if( ptr1->patchTemp != ptr2->patchTemp ) __asm int 3
-	if( ptr1->rhythmTemp != ptr2->rhythmTemp ) __asm int 3
-	if( ptr1->playing != ptr2->playing ) __asm int 3
-	if( ptr1->biasAmpSubtraction != ptr2->biasAmpSubtraction ) __asm int 3
-	if( ptr1->veloAmpSubtraction != ptr2->veloAmpSubtraction ) __asm int 3
-	if( ptr1->keyTimeSubtraction != ptr2->keyTimeSubtraction ) __asm int 3
-	if( ptr1->target != ptr2->target ) __asm int 3
-	if( ptr1->phase != ptr2->phase ) __asm int 3
-
-
-
-	// avoid destructor problems
-	memset( ptr2, 0, sizeof(*ptr2) );
-}
-#endif
-
-
-void TVA::saveState( std::ostream &stream )
-{
-	Bit16u partialParam_idx1, partialParam_idx2;
-	Bit8u part_idx;
-	Bit8u patchTemp_idx;
-	Bit8u rhythmTemp_idx;
-
-
-	// - static fastptr
-	//const Partial * const partial;
-	//LA32Ramp *ampRamp;
-	//const MemParams::System * const system;
-
-
-	// - reloc fastptr (!!)
-	//const Part *part;
-	partial->getSynth()->findPart( part, &part_idx );
-	stream.write(reinterpret_cast<const char*>(&part_idx), sizeof(part_idx) );
-
-
-	// - reloc fastptr (!!)
-	//const TimbreParam::PartialParam *partialParam;
-	partial->getSynth()->findPartialParam( partialParam, &partialParam_idx1, &partialParam_idx2 );
-	stream.write(reinterpret_cast<const char*>(&partialParam_idx1), sizeof(partialParam_idx1) );
-	stream.write(reinterpret_cast<const char*>(&partialParam_idx2), sizeof(partialParam_idx2) );
-
-
-	// - reloc fastptr (!!)
-	//const MemParams::PatchTemp *patchTemp;
-	partial->getSynth()->findPatchTemp( patchTemp, &patchTemp_idx );
-	stream.write(reinterpret_cast<const char*>(&patchTemp_idx), sizeof(patchTemp_idx) );
-
-
-	// - reloc fastptr (!!)
-	//const MemParams::RhythmTemp *rhythmTemp;
-	partial->getSynth()->findRhythmTemp( rhythmTemp, &rhythmTemp_idx );
-	stream.write(reinterpret_cast<const char*>(&rhythmTemp_idx), sizeof(rhythmTemp_idx) );
-
-
-	stream.write(reinterpret_cast<const char*>(&playing), sizeof(playing) );
-	stream.write(reinterpret_cast<const char*>(&biasAmpSubtraction), sizeof(biasAmpSubtraction) );
-	stream.write(reinterpret_cast<const char*>(&veloAmpSubtraction), sizeof(veloAmpSubtraction) );
-	stream.write(reinterpret_cast<const char*>(&keyTimeSubtraction), sizeof(keyTimeSubtraction) );
-	stream.write(reinterpret_cast<const char*>(&target), sizeof(target) );
-	stream.write(reinterpret_cast<const char*>(&phase), sizeof(phase) );
-
-
-#ifdef WIN32_DEBUG
-	// DEBUG
-	partial->getSynth()->rawDumpState( "temp-save", this, sizeof(*this) );
-	partial->getSynth()->rawDumpNo++;
-#endif
+	startRamp(Bit8u(newTarget), Bit8u(newIncrement), newPhase);
 }
 
-
-void TVA::loadState( std::istream &stream )
-{
-	Bit16u partialParam_idx1, partialParam_idx2;
-	Bit8u part_idx;
-	Bit8u patchTemp_idx;
-	Bit8u rhythmTemp_idx;
-
-
-	// - static fastptr
-	//const Partial * const partial;
-	//LA32Ramp *ampRamp;
-	//const MemParams::System * const system;
-
-
-	// - reloc fastptr (!!)
-	//const Part *part;
-	stream.read(reinterpret_cast<char*>(&part_idx), sizeof(part_idx) );
-	part = partial->getSynth()->indexPart(part_idx);
-
-
-	// - reloc fastptr (!!)
-	//const TimbreParam::PartialParam *partialParam;
-	stream.read(reinterpret_cast<char*>(&partialParam_idx1), sizeof(partialParam_idx1) );
-	stream.read(reinterpret_cast<char*>(&partialParam_idx2), sizeof(partialParam_idx2) );
-	partialParam = partial->getSynth()->indexPartialParam(partialParam_idx1, partialParam_idx2);
-
-
-	// - reloc fastptr (!!)
-	//const MemParams::PatchTemp *patchTemp;
-	stream.read(reinterpret_cast<char*>(&patchTemp_idx), sizeof(patchTemp_idx) );
-	patchTemp = partial->getSynth()->indexPatchTemp(patchTemp_idx);
-
-
-	// - reloc fastptr (!!)
-	//const MemParams::RhythmTemp *rhythmTemp;
-	stream.read(reinterpret_cast<char*>(&rhythmTemp_idx), sizeof(rhythmTemp_idx) );
-	rhythmTemp = partial->getSynth()->indexRhythmTemp(rhythmTemp_idx);
-
-
-	stream.read(reinterpret_cast<char*>(&playing), sizeof(playing) );
-	stream.read(reinterpret_cast<char*>(&biasAmpSubtraction), sizeof(biasAmpSubtraction) );
-	stream.read(reinterpret_cast<char*>(&veloAmpSubtraction), sizeof(veloAmpSubtraction) );
-	stream.read(reinterpret_cast<char*>(&keyTimeSubtraction), sizeof(keyTimeSubtraction) );
-	stream.read(reinterpret_cast<char*>(&target), sizeof(target) );
-	stream.read(reinterpret_cast<char*>(&phase), sizeof(phase) );
-
-
-#ifdef WIN32_DEBUG
-	// DEBUG
-	partial->getSynth()->rawDumpState( "temp-load", this, sizeof(*this) );
-	this->rawVerifyState( "temp-save", partial->getSynth() );
-	partial->getSynth()->rawDumpNo++;
-#endif
-}
-
-}
+} // namespace MT32Emu
diff --git a/src/mt32/TVA.h b/src/mt32/TVA.h
index 0241b54d..cf9296d4 100644
--- a/src/mt32/TVA.h
+++ b/src/mt32/TVA.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,9 +18,15 @@
 #ifndef MT32EMU_TVA_H
 #define MT32EMU_TVA_H
 
+#include "globals.h"
+#include "Types.h"
+#include "Structures.h"
+
 namespace MT32Emu {
 
+class LA32Ramp;
 class Part;
+class Partial;
 
 // Note that when entering nextPhase(), newPhase is set to phase + 1, and the descriptions/names below refer to
 // newPhase's value.
@@ -87,14 +93,8 @@ public:
 
 	bool isPlaying() const;
 	int getPhase() const;
+}; // class TVA
 
-	void saveState( std::ostream &stream );
-	void loadState( std::istream &stream );
-
-	// savestate debugging
-	void rawVerifyState( char *name, Synth *synth );
-};
-
-}
+} // namespace MT32Emu
 
-#endif /* TVA_H_ */
+#endif // #ifndef MT32EMU_TVA_H
diff --git a/src/mt32/TVF.cpp b/src/mt32/TVF.cpp
index fcfbc08f..7ba9c7f2 100644
--- a/src/mt32/TVF.cpp
+++ b/src/mt32/TVF.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,10 +15,14 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <cmath>
+#include "internals.h"
 
-#include "mt32emu.h"
-#include "mmath.h"
+#include "TVF.h"
+#include "LA32Ramp.h"
+#include "Partial.h"
+#include "Poly.h"
+#include "Synth.h"
+#include "Tables.h"
 
 namespace MT32Emu {
 
@@ -49,7 +53,7 @@ enum {
 	PHASE_DONE = 7
 };
 
-static int calcBaseCutoff(const TimbreParam::PartialParam *partialParam, Bit32u basePitch, unsigned int key) {
+static int calcBaseCutoff(const TimbreParam::PartialParam *partialParam, Bit32u basePitch, unsigned int key, bool quirkTVFBaseCutoffLimit) {
 	// This table matches the values used by a real LAPC-I.
 	static const Bit8s biasLevelToBiasMult[] = {85, 42, 21, 16, 10, 5, 2, 0, -2, -5, -10, -16, -21, -74, -85};
 	// These values represent unique options with no consistent pattern, so we have to use something like a table in any case.
@@ -59,7 +63,7 @@ static int calcBaseCutoff(const TimbreParam::PartialParam *partialParam, Bit32u
 	static const Bit8s keyfollowMult21[] = {-21, -10, -5, 0, 2, 5, 8, 10, 13, 16, 18, 21, 26, 32, 42, 21, 21};
 	int baseCutoff = keyfollowMult21[partialParam->tvf.keyfollow] - keyfollowMult21[partialParam->wg.pitchKeyfollow];
 	// baseCutoff range now: -63 to 63
-	baseCutoff *= (int)key - 60;
+	baseCutoff *= int(key) - 60;
 	// baseCutoff range now: -3024 to 3024
 	int biasPoint = partialParam->tvf.biasPoint;
 	if ((biasPoint & 0x40) == 0) {
@@ -87,23 +91,25 @@ static int calcBaseCutoff(const TimbreParam::PartialParam *partialParam, Bit32u
 		if (pitchDeltaThing > 0) {
 			baseCutoff -= pitchDeltaThing;
 		}
-	} else if (baseCutoff < -2048) {
-		baseCutoff = -2048;
+	} else if (quirkTVFBaseCutoffLimit) {
+		if (baseCutoff <= -0x400) {
+			baseCutoff = -400;
+		}
+	} else {
+		if (baseCutoff < -2048) {
+			baseCutoff = -2048;
+		}
 	}
 	baseCutoff += 2056;
 	baseCutoff >>= 4; // PORTABILITY NOTE: Hmm... Depends whether it could've been below -2056, but maybe arithmetic shift assumed?
 	if (baseCutoff > 255) {
 		baseCutoff = 255;
 	}
-	return (Bit8u)baseCutoff;
+	return Bit8u(baseCutoff);
 }
 
 TVF::TVF(const Partial *usePartial, LA32Ramp *useCutoffModifierRamp) :
 	partial(usePartial), cutoffModifierRamp(useCutoffModifierRamp) {
-
-
-	// init ptr warnings (load state crashes)
-	partialParam = NULL;
 }
 
 void TVF::startRamp(Bit8u newTarget, Bit8u newIncrement, int newPhase) {
@@ -111,7 +117,7 @@ void TVF::startRamp(Bit8u newTarget, Bit8u newIncrement, int newPhase) {
 	phase = newPhase;
 	cutoffModifierRamp->startRamp(newTarget, newIncrement);
 #if MT32EMU_MONITOR_TVF >= 1
-	partial->getSynth()->printDebug("[+%lu] [Partial %d] TVF,ramp,%d,%d,%d,%d", partial->debugGetSampleNum(), partial->debugGetPartialNum(), newTarget, (newIncrement & 0x80) ? -1 : 1, (newIncrement & 0x7F), newPhase);
+	partial->getSynth()->printDebug("[+%lu] [Partial %d] TVF,ramp,%x,%s%x,%d", partial->debugGetSampleNum(), partial->debugGetPartialNum(), newTarget, (newIncrement & 0x80) ? "-" : "+", (newIncrement & 0x7F), newPhase);
 #endif
 }
 
@@ -123,7 +129,7 @@ void TVF::reset(const TimbreParam::PartialParam *newPartialParam, unsigned int b
 
 	const Tables *tables = &Tables::getInstance();
 
-	baseCutoff = calcBaseCutoff(newPartialParam, basePitch, key);
+	baseCutoff = calcBaseCutoff(newPartialParam, basePitch, key, partial->getSynth()->controlROMFeatures->quirkTVFBaseCutoffLimit);
 #if MT32EMU_MONITOR_TVF >= 1
 	partial->getSynth()->printDebug("[+%lu] [Partial %d] TVF,base,%d", partial->debugGetSampleNum(), partial->debugGetPartialNum(), baseCutoff);
 #endif
@@ -131,7 +137,7 @@ void TVF::reset(const TimbreParam::PartialParam *newPartialParam, unsigned int b
 	int newLevelMult = velocity * newPartialParam->tvf.envVeloSensitivity;
 	newLevelMult >>= 6;
 	newLevelMult += 109 - newPartialParam->tvf.envVeloSensitivity;
-	newLevelMult += ((signed)key - 60) >> (4 - newPartialParam->tvf.envDepthKeyfollow);
+	newLevelMult += (signed(key) - 60) >> (4 - newPartialParam->tvf.envDepthKeyfollow);
 	if (newLevelMult < 0) {
 		newLevelMult = 0;
 	}
@@ -143,7 +149,7 @@ void TVF::reset(const TimbreParam::PartialParam *newPartialParam, unsigned int b
 	levelMult = newLevelMult;
 
 	if (newPartialParam->tvf.envTimeKeyfollow != 0) {
-		keyTimeSubtraction = ((signed)key - 60) >> (5 - newPartialParam->tvf.envTimeKeyfollow);
+		keyTimeSubtraction = (signed(key) - 60) >> (5 - newPartialParam->tvf.envTimeKeyfollow);
 	} else {
 		keyTimeSubtraction = 0;
 	}
@@ -231,101 +237,4 @@ void TVF::nextPhase() {
 	startRamp(newTarget, newIncrement, newPhase);
 }
 
-
-#ifdef WIN32_DEBUG
-void TVF::rawVerifyState( char *name, Synth *useSynth )
-{
-	TVF *ptr1, *ptr2;
-	TVF tvf_temp(partial,cutoffModifierRamp);
-
-
-#ifndef WIN32_DUMP
-	return;
-#endif
-
-	ptr1 = this;
-	ptr2 = &tvf_temp;
-	useSynth->rawLoadState( name, ptr2, sizeof(*this) );
-
-
-	if( ptr1->partial != ptr2->partial ) __asm int 3
-	if( ptr1->cutoffModifierRamp != ptr2->cutoffModifierRamp ) __asm int 3
-	if( ptr1->partialParam != ptr2->partialParam ) __asm int 3
-	if( ptr1->baseCutoff != ptr2->baseCutoff ) __asm int 3
-	if( ptr1->keyTimeSubtraction != ptr2->keyTimeSubtraction ) __asm int 3
-	if( ptr1->levelMult != ptr2->levelMult ) __asm int 3
-	if( ptr1->target != ptr2->target ) __asm int 3
-	if( ptr1->phase != ptr2->phase ) __asm int 3
-
-
-
-	// avoid destructor problems
-	memset( ptr2, 0, sizeof(*ptr2) );
-}
-#endif
-
-
-void TVF::saveState( std::ostream &stream )
-{
-	Bit16u partialParam_idx1, partialParam_idx2;
-
-	// - static fastptr
-	//const Partial * const partial;
-	//LA32Ramp *cutoffModifierRamp;
-
-
-	// - reloc fastptr (!!)
-	//const TimbreParam::PartialParam *partialParam;
-	partial->getSynth()->findPartialParam( partialParam, &partialParam_idx1, &partialParam_idx2 );
-
-	stream.write(reinterpret_cast<const char*>(&partialParam_idx1), sizeof(partialParam_idx1) );
-	stream.write(reinterpret_cast<const char*>(&partialParam_idx2), sizeof(partialParam_idx2) );
-
-
-	stream.write(reinterpret_cast<const char*>(&baseCutoff), sizeof(baseCutoff) );
-	stream.write(reinterpret_cast<const char*>(&keyTimeSubtraction), sizeof(keyTimeSubtraction) );
-	stream.write(reinterpret_cast<const char*>(&levelMult), sizeof(levelMult) );
-	stream.write(reinterpret_cast<const char*>(&target), sizeof(target) );
-	stream.write(reinterpret_cast<const char*>(&phase), sizeof(phase) );
-
-
-#ifdef WIN32_DEBUG
-	// DEBUG
-	partial->getSynth()->rawDumpState( "temp-save", this, sizeof(*this) );
-	partial->getSynth()->rawDumpNo++;
-#endif
-}
-
-
-void TVF::loadState( std::istream &stream )
-{
-	Bit16u partialParam_idx1, partialParam_idx2;
-
-	// - static fastptr
-	//const Partial * const partial;
-	//LA32Ramp *cutoffModifierRamp;
-
-
-	// - reloc fastptr (!!)
-	//const TimbreParam::PartialParam *partialParam;
-	stream.read(reinterpret_cast<char*>(&partialParam_idx1), sizeof(partialParam_idx1) );
-	stream.read(reinterpret_cast<char*>(&partialParam_idx2), sizeof(partialParam_idx2) );
-	partialParam = partial->getSynth()->indexPartialParam(partialParam_idx1, partialParam_idx2);
-
-
-	stream.read(reinterpret_cast<char*>(&baseCutoff), sizeof(baseCutoff) );
-	stream.read(reinterpret_cast<char*>(&keyTimeSubtraction), sizeof(keyTimeSubtraction) );
-	stream.read(reinterpret_cast<char*>(&levelMult), sizeof(levelMult) );
-	stream.read(reinterpret_cast<char*>(&target), sizeof(target) );
-	stream.read(reinterpret_cast<char*>(&phase), sizeof(phase) );
-
-
-#ifdef WIN32_DEBUG
-	// DEBUG
-	partial->getSynth()->rawDumpState( "temp-load", this, sizeof(*this) );
-	this->rawVerifyState( "temp-save", partial->getSynth() );
-	partial->getSynth()->rawDumpNo++;
-#endif
-}
-
-}
+} // namespace MT32Emu
diff --git a/src/mt32/TVF.h b/src/mt32/TVF.h
index f1e7d92f..e637aa5b 100644
--- a/src/mt32/TVF.h
+++ b/src/mt32/TVF.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,8 +18,15 @@
 #ifndef MT32EMU_TVF_H
 #define MT32EMU_TVF_H
 
+#include "globals.h"
+#include "Types.h"
+#include "Structures.h"
+
 namespace MT32Emu {
 
+class LA32Ramp;
+class Partial;
+
 class TVF {
 private:
 	const Partial * const partial;
@@ -47,14 +54,8 @@ public:
 	Bit8u getBaseCutoff() const;
 	void handleInterrupt();
 	void startDecay();
+}; // class TVF
 
-	void saveState( std::ostream &stream );
-	void loadState( std::istream &stream );
-
-	// savestate debugging
-	void rawVerifyState( char *name, Synth *synth );
-};
-
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_TVF_H
diff --git a/src/mt32/TVP.cpp b/src/mt32/TVP.cpp
index 831da3c4..a3b36404 100644
--- a/src/mt32/TVP.cpp
+++ b/src/mt32/TVP.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,10 +15,16 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <cmath>
 #include <cstdlib>
 
-#include "mt32emu.h"
+#include "internals.h"
+
+#include "TVP.h"
+#include "Part.h"
+#include "Partial.h"
+#include "Poly.h"
+#include "Synth.h"
+#include "TVA.h"
 
 namespace MT32Emu {
 
@@ -45,25 +51,21 @@ static Bit16u keyToPitchTable[] = {
 	21845, 22187, 22528, 22869
 };
 
-TVP::TVP(const Partial *usePartial) :
-	partial(usePartial), system(&usePartial->getSynth()->mt32ram.system) {
-	// We want to do processing 4000 times per second. FIXME: This is pretty arbitrary.
-	maxCounter = SAMPLE_RATE / 4000;
-	// The timer runs at 500kHz. We only need to bother updating it every maxCounter samples, before we do processing.
-	// This is how much to increment it by every maxCounter samples.
-	processTimerIncrement = 500000 * maxCounter / SAMPLE_RATE;
+// We want to do processing 4000 times per second. FIXME: This is pretty arbitrary.
+static const int NOMINAL_PROCESS_TIMER_PERIOD_SAMPLES = SAMPLE_RATE / 4000;
 
+// The timer runs at 500kHz. This is how much to increment it after 8 samples passes.
+// We multiply by 8 to get rid of the fraction and deal with just integers.
+static const int PROCESS_TIMER_INCREMENT_x8 = 8 * 500000 / SAMPLE_RATE;
 
-	// init ptr warnings (load state crashes)
-	part = NULL;
-	partialParam = NULL;
-	patchTemp = NULL;
+TVP::TVP(const Partial *usePartial) :
+	partial(usePartial), system(&usePartial->getSynth()->mt32ram.system) {
 }
 
 static Bit16s keyToPitch(unsigned int key) {
 	// We're using a table to do: return round_to_nearest_or_even((key - 60) * (4096.0 / 12.0))
 	// Banker's rounding is just slightly annoying to do in C++
-	int k = (int)key;
+	int k = int(key);
 	Bit16s pitch = keyToPitchTable[abs(k - 60)];
 	return key < 60 ? -pitch : pitch;
 }
@@ -76,18 +78,20 @@ static inline Bit32s fineToPitch(Bit8u fine) {
 	return (fine - 50) * 4096 / 1200; // One cent per fine offset
 }
 
-static Bit32u calcBasePitch(const Partial *partial, const TimbreParam::PartialParam *partialParam, const MemParams::PatchTemp *patchTemp, unsigned int key) {
+static Bit32u calcBasePitch(const Partial *partial, const TimbreParam::PartialParam *partialParam, const MemParams::PatchTemp *patchTemp, unsigned int key, const ControlROMFeatureSet *controlROMFeatures) {
 	Bit32s basePitch = keyToPitch(key);
 	basePitch = (basePitch * pitchKeyfollowMult[partialParam->wg.pitchKeyfollow]) >> 13; // PORTABILITY NOTE: Assumes arithmetic shift
 	basePitch += coarseToPitch(partialParam->wg.pitchCoarse);
 	basePitch += fineToPitch(partialParam->wg.pitchFine);
-	// NOTE:Mok: This is done on MT-32, but not LAPC-I:
-	//pitch += coarseToPitch(patchTemp->patch.keyShift + 12);
+	if (controlROMFeatures->quirkKeyShift) {
+		// NOTE:Mok: This is done on MT-32, but not LAPC-I:
+		basePitch += coarseToPitch(patchTemp->patch.keyShift + 12);
+	}
 	basePitch += fineToPitch(patchTemp->patch.fineTune);
 
 	const ControlROMPCMStruct *controlROMPCMStruct = partial->getControlROMPCMStruct();
 	if (controlROMPCMStruct != NULL) {
-		basePitch += (Bit32s)((((Bit32s)controlROMPCMStruct->pitchMSB) << 8) | (Bit32s)controlROMPCMStruct->pitchLSB);
+		basePitch += (Bit32s(controlROMPCMStruct->pitchMSB) << 8) | Bit32s(controlROMPCMStruct->pitchLSB);
 	} else {
 		if ((partialParam->wg.waveform & 1) == 0) {
 			basePitch += 37133; // This puts Middle C at around 261.64Hz (assuming no other modifications, masterTune of 64, etc.)
@@ -97,34 +101,43 @@ static Bit32u calcBasePitch(const Partial *partial, const TimbreParam::PartialPa
 			basePitch += 33037;
 		}
 	}
-	if (basePitch < 0) {
+
+	// MT-32 GEN0 does 16-bit calculations here, allowing an integer overflow.
+	// This quirk is observable playing the patch defined for timbre "HIT BOTTOM" in Larry 3.
+	if (controlROMFeatures->quirkBasePitchOverflow) {
+		basePitch = basePitch & 0xffff;
+	} else if (basePitch < 0) {
 		basePitch = 0;
 	}
 	if (basePitch > 59392) {
 		basePitch = 59392;
 	}
-	return (Bit32u)basePitch;
+	return Bit32u(basePitch);
 }
 
 static Bit32u calcVeloMult(Bit8u veloSensitivity, unsigned int velocity) {
-	if (veloSensitivity == 0 || veloSensitivity > 3) {
-		// Note that on CM-32L/LAPC-I veloSensitivity is never > 3, since it's clipped to 3 by the max tables.
+	if (veloSensitivity == 0) {
 		return 21845; // aka floor(4096 / 12 * 64), aka ~64 semitones
 	}
+	unsigned int reversedVelocity = 127 - velocity;
+	unsigned int scaledReversedVelocity;
+	if (veloSensitivity > 3) {
+		// Note that on CM-32L/LAPC-I veloSensitivity is never > 3, since it's clipped to 3 by the max tables.
+		// MT-32 GEN0 has a bug here that leads to unspecified behaviour. We assume it is as follows.
+		scaledReversedVelocity = (reversedVelocity << 8) >> ((3 - veloSensitivity) & 0x1f);
+	} else {
+		scaledReversedVelocity = reversedVelocity << (5 + veloSensitivity);
+	}
 	// When velocity is 127, the multiplier is 21845, aka ~64 semitones (regardless of veloSensitivity).
 	// The lower the velocity, the lower the multiplier. The veloSensitivity determines the amount decreased per velocity value.
-	// The minimum multiplier (with velocity 0, veloSensitivity 3) is 170 (~half a semitone).
-	Bit32u veloMult = 32768;
-	veloMult -= (127 - velocity) << (5 + veloSensitivity);
-	veloMult *= 21845;
-	veloMult >>= 15;
-	return veloMult;
+	// The minimum multiplier on CM-32L/LAPC-I (with velocity 0, veloSensitivity 3) is 170 (~half a semitone).
+	return ((32768 - scaledReversedVelocity) * 21845) >> 15;
 }
 
 static Bit32s calcTargetPitchOffsetWithoutLFO(const TimbreParam::PartialParam *partialParam, int levelIndex, unsigned int velocity) {
 	int veloMult = calcVeloMult(partialParam->pitchEnv.veloSensitivity, velocity);
 	int targetPitchOffsetWithoutLFO = partialParam->pitchEnv.level[levelIndex] - 50;
-	targetPitchOffsetWithoutLFO = (Bit32s)(targetPitchOffsetWithoutLFO * veloMult) >> (16 - partialParam->pitchEnv.depth); // PORTABILITY NOTE: Assumes arithmetic shift
+	targetPitchOffsetWithoutLFO = (targetPitchOffsetWithoutLFO * veloMult) >> (16 - partialParam->pitchEnv.depth); // PORTABILITY NOTE: Assumes arithmetic shift
 	return targetPitchOffsetWithoutLFO;
 }
 
@@ -139,13 +152,13 @@ void TVP::reset(const Part *usePart, const TimbreParam::PartialParam *usePartial
 	// FIXME: We're using a per-TVP timer instead of a system-wide one for convenience.
 	timeElapsed = 0;
 
-	basePitch = calcBasePitch(partial, partialParam, patchTemp, key);
+	basePitch = calcBasePitch(partial, partialParam, patchTemp, key, partial->getSynth()->controlROMFeatures);
 	currentPitchOffset = calcTargetPitchOffsetWithoutLFO(partialParam, 0, velocity);
 	targetPitchOffsetWithoutLFO = currentPitchOffset;
 	phase = 0;
 
 	if (partialParam->pitchEnv.timeKeyfollow) {
-		timeKeyfollowSubtraction = (key - 60) >> (5 - partialParam->pitchEnv.timeKeyfollow); // PORTABILITY NOTE: Assumes arithmetic shift
+		timeKeyfollowSubtraction = Bit32s(key - 60) >> (5 - partialParam->pitchEnv.timeKeyfollow); // PORTABILITY NOTE: Assumes arithmetic shift
 	} else {
 		timeKeyfollowSubtraction = 0;
 	}
@@ -166,28 +179,28 @@ Bit32u TVP::getBasePitch() const {
 void TVP::updatePitch() {
 	Bit32s newPitch = basePitch + currentPitchOffset;
 	if (!partial->isPCM() || (partial->getControlROMPCMStruct()->len & 0x01) == 0) { // FIXME: Use !partial->pcmWaveEntry->unaffectedByMasterTune instead
-		// FIXME: masterTune recalculation doesn't really happen here, and there are various bugs not yet emulated
+		// FIXME: There are various bugs not yet emulated
 		// 171 is ~half a semitone.
-		newPitch += ((system->masterTune - 64) * 171) >> 6; // PORTABILITY NOTE: Assumes arithmetic shift.
+		newPitch += partial->getSynth()->getMasterTunePitchDelta();
 	}
 	if ((partialParam->wg.pitchBenderEnabled & 1) != 0) {
 		newPitch += part->getPitchBend();
 	}
-	if (newPitch < 0) {
+
+	// MT-32 GEN0 does 16-bit calculations here, allowing an integer overflow.
+	// This quirk is exploited e.g. in Colonel's Bequest timbres "Lightning" and "SwmpBackgr".
+	if (partial->getSynth()->controlROMFeatures->quirkPitchEnvelopeOverflow) {
+		newPitch = newPitch & 0xffff;
+	} else if (newPitch < 0) {
 		newPitch = 0;
 	}
-
-// Note: Temporary #ifdef until we have proper "quirk" configuration
-// This is about right emulation of MT-32 GEN0 quirk exploited in Colonel's Bequest timbre "Lightning"
-#ifndef MT32EMU_QUIRK_PITCH_ENVELOPE_OVERFLOW_MT32
 	if (newPitch > 59392) {
 		newPitch = 59392;
 	}
-#endif
-	pitch = (Bit16u)newPitch;
+	pitch = Bit16u(newPitch);
 
 	// FIXME: We're doing this here because that's what the CM-32L does - we should probably move this somewhere more appropriate in future.
-	partial->tva->recalcSustain();
+	partial->getTVA()->recalcSustain();
 }
 
 void TVP::targetPitchOffsetReached() {
@@ -285,13 +298,19 @@ void TVP::startDecay() {
 }
 
 Bit16u TVP::nextPitch() {
-	// FIXME: Write explanation of counter and time increment
+	// We emulate MCU software timer using these counter and processTimerIncrement variables.
+	// The value of nominalProcessTimerPeriod approximates the period in samples
+	// between subsequent firings of the timer that normally occur.
+	// However, accurate emulation is quite complicated because the timer is not guaranteed to fire in time.
+	// This makes pitch variations on real unit non-deterministic and dependent on various factors.
 	if (counter == 0) {
-		timeElapsed += processTimerIncrement;
-		timeElapsed = timeElapsed & 0x00FFFFFF;
+		timeElapsed = (timeElapsed + processTimerIncrement) & 0x00FFFFFF;
+		// This roughly emulates pitch deviations observed on real units when playing a single partial that uses TVP/LFO.
+		counter = NOMINAL_PROCESS_TIMER_PERIOD_SAMPLES + (rand() & 3);
+		processTimerIncrement = (PROCESS_TIMER_INCREMENT_x8 * counter) >> 3;
 		process();
 	}
-	counter = (counter + 1) % maxCounter;
+	counter--;
 	return pitch;
 }
 
@@ -322,165 +341,10 @@ void TVP::process() {
 		negativeBigTicksRemaining = negativeBigTicksRemaining >> rightShifts; // PORTABILITY NOTE: Assumes arithmetic shift
 		rightShifts = 13;
 	}
-	int newResult = ((Bit32s)(negativeBigTicksRemaining * pitchOffsetChangePerBigTick)) >> rightShifts; // PORTABILITY NOTE: Assumes arithmetic shift
+	int newResult = (negativeBigTicksRemaining * pitchOffsetChangePerBigTick) >> rightShifts; // PORTABILITY NOTE: Assumes arithmetic shift
 	newResult += targetPitchOffsetWithoutLFO + lfoPitchOffset;
 	currentPitchOffset = newResult;
 	updatePitch();
 }
 
-
-#ifdef WIN32_DEBUG
-void TVP::rawVerifyState( char *name, Synth *useSynth )
-{
-	TVP *ptr1, *ptr2;
-	TVP tvp_temp(partial);
-
-
-#ifndef WIN32_DUMP
-	return;
-#endif
-
-	ptr1 = this;
-	ptr2 = &tvp_temp;
-	useSynth->rawLoadState( name, ptr2, sizeof(*this) );
-
-
-	if( ptr1->partial != ptr2->partial ) __asm int 3
-	if( ptr1->system != ptr2->system ) __asm int 3
-	if( ptr1->part != ptr2->part ) __asm int 3
-	if( ptr1->partialParam != ptr2->partialParam ) __asm int 3
-	if( ptr1->patchTemp != ptr2->patchTemp ) __asm int 3
-	if( ptr1->maxCounter != ptr2->maxCounter ) __asm int 3
-	if( ptr1->processTimerIncrement != ptr2->processTimerIncrement ) __asm int 3
-	if( ptr1->counter != ptr2->counter ) __asm int 3
-	if( ptr1->timeElapsed != ptr2->timeElapsed ) __asm int 3
-	if( ptr1->phase != ptr2->phase ) __asm int 3
-	if( ptr1->basePitch != ptr2->basePitch ) __asm int 3
-	if( ptr1->targetPitchOffsetWithoutLFO != ptr2->targetPitchOffsetWithoutLFO ) __asm int 3
-	if( ptr1->currentPitchOffset != ptr2->currentPitchOffset ) __asm int 3
-	if( ptr1->lfoPitchOffset != ptr2->lfoPitchOffset ) __asm int 3
-	if( ptr1->timeKeyfollowSubtraction != ptr2->timeKeyfollowSubtraction ) __asm int 3
-	if( ptr1->pitchOffsetChangePerBigTick != ptr2->pitchOffsetChangePerBigTick ) __asm int 3
-	if( ptr1->targetPitchOffsetReachedBigTick != ptr2->targetPitchOffsetReachedBigTick ) __asm int 3
-	if( ptr1->shifts != ptr2->shifts ) __asm int 3
-	if( ptr1->pitch != ptr2->pitch ) __asm int 3
-
-		
-		
-	// avoid destructor problems
-	memset( ptr2, 0, sizeof(*ptr2) );
-}
-#endif
-
-
-void TVP::saveState( std::ostream &stream )
-{
-	Bit16u partialParam_idx1, partialParam_idx2;
-	Bit8u part_idx;
-	Bit8u patchTemp_idx;
-
-
-	// - static fastptr
-	//const Partial * const partial;
-	//const MemParams::System * const system; // FIXME: Only necessary because masterTune calculation is done in the wrong place atm.
-
-
-	// - reloc fastptr (!!)
-	//const Part *part;
-	partial->getSynth()->findPart( part, &part_idx );
-	stream.write(reinterpret_cast<const char*>(&part_idx), sizeof(part_idx) );
-
-
-	// - reloc fastptr (!!)
-	//const TimbreParam::PartialParam *partialParam;
-	partial->getSynth()->findPartialParam( partialParam, &partialParam_idx1, &partialParam_idx2 );
-	stream.write(reinterpret_cast<const char*>(&partialParam_idx1), sizeof(partialParam_idx1) );
-	stream.write(reinterpret_cast<const char*>(&partialParam_idx2), sizeof(partialParam_idx2) );
-
-
-	// - reloc fastptr (!!)
-	//const MemParams::PatchTemp *patchTemp;
-	partial->getSynth()->findPatchTemp( patchTemp, &patchTemp_idx );
-	stream.write(reinterpret_cast<const char*>(&patchTemp_idx), sizeof(patchTemp_idx) );
-
-
-	stream.write(reinterpret_cast<const char*>(&maxCounter), sizeof(maxCounter) );
-	stream.write(reinterpret_cast<const char*>(&processTimerIncrement), sizeof(processTimerIncrement) );
-	stream.write(reinterpret_cast<const char*>(&counter), sizeof(counter) );
-	stream.write(reinterpret_cast<const char*>(&timeElapsed), sizeof(timeElapsed) );
-	stream.write(reinterpret_cast<const char*>(&phase), sizeof(phase) );
-	stream.write(reinterpret_cast<const char*>(&basePitch), sizeof(basePitch) );
-	stream.write(reinterpret_cast<const char*>(&targetPitchOffsetWithoutLFO), sizeof(targetPitchOffsetWithoutLFO) );
-	stream.write(reinterpret_cast<const char*>(&currentPitchOffset), sizeof(currentPitchOffset) );
-	stream.write(reinterpret_cast<const char*>(&lfoPitchOffset), sizeof(lfoPitchOffset) );
-	stream.write(reinterpret_cast<const char*>(&timeKeyfollowSubtraction), sizeof(timeKeyfollowSubtraction) );
-	stream.write(reinterpret_cast<const char*>(&pitchOffsetChangePerBigTick), sizeof(pitchOffsetChangePerBigTick) );
-	stream.write(reinterpret_cast<const char*>(&targetPitchOffsetReachedBigTick), sizeof(targetPitchOffsetReachedBigTick) );
-	stream.write(reinterpret_cast<const char*>(&shifts), sizeof(shifts) );
-	stream.write(reinterpret_cast<const char*>(&pitch), sizeof(pitch) );
-
-
-#ifdef WIN32_DEBUG
-	// DEBUG
-	partial->getSynth()->rawDumpState( "temp-save", this, sizeof(*this) );
-	partial->getSynth()->rawDumpNo++;
-#endif
-}
-
-
-void TVP::loadState( std::istream &stream )
-{
-	Bit16u partialParam_idx1, partialParam_idx2;
-	Bit8u part_idx;
-	Bit8u patchTemp_idx;
-
-
-	// - static fastptr
-	//const Partial * const partial;
-	//const MemParams::System * const system; // FIXME: Only necessary because masterTune calculation is done in the wrong place atm.
-
-
-	// - reloc fastptr (!!)
-	//const Part *part;
-	stream.read(reinterpret_cast<char*>(&part_idx), sizeof(part_idx) );
-	part = partial->getSynth()->indexPart(part_idx);
-
-
-	// - reloc fastptr (!!)
-	//const TimbreParam::PartialParam *partialParam;
-	stream.read(reinterpret_cast<char*>(&partialParam_idx1), sizeof(partialParam_idx1) );
-	stream.read(reinterpret_cast<char*>(&partialParam_idx2), sizeof(partialParam_idx2) );
-	partialParam = partial->getSynth()->indexPartialParam(partialParam_idx1, partialParam_idx2);
-
-
-	// - reloc fastptr (!!)
-	//const MemParams::PatchTemp *patchTemp;
-	stream.read(reinterpret_cast<char*>(&patchTemp_idx), sizeof(patchTemp_idx) );
-	patchTemp = partial->getSynth()->indexPatchTemp(patchTemp_idx);
-
-
-	stream.read(reinterpret_cast<char*>(&maxCounter), sizeof(maxCounter) );
-	stream.read(reinterpret_cast<char*>(&processTimerIncrement), sizeof(processTimerIncrement) );
-	stream.read(reinterpret_cast<char*>(&counter), sizeof(counter) );
-	stream.read(reinterpret_cast<char*>(&timeElapsed), sizeof(timeElapsed) );
-	stream.read(reinterpret_cast<char*>(&phase), sizeof(phase) );
-	stream.read(reinterpret_cast<char*>(&basePitch), sizeof(basePitch) );
-	stream.read(reinterpret_cast<char*>(&targetPitchOffsetWithoutLFO), sizeof(targetPitchOffsetWithoutLFO) );
-	stream.read(reinterpret_cast<char*>(&currentPitchOffset), sizeof(currentPitchOffset) );
-	stream.read(reinterpret_cast<char*>(&lfoPitchOffset), sizeof(lfoPitchOffset) );
-	stream.read(reinterpret_cast<char*>(&timeKeyfollowSubtraction), sizeof(timeKeyfollowSubtraction) );
-	stream.read(reinterpret_cast<char*>(&pitchOffsetChangePerBigTick), sizeof(pitchOffsetChangePerBigTick) );
-	stream.read(reinterpret_cast<char*>(&targetPitchOffsetReachedBigTick), sizeof(targetPitchOffsetReachedBigTick) );
-	stream.read(reinterpret_cast<char*>(&shifts), sizeof(shifts) );
-	stream.read(reinterpret_cast<char*>(&pitch), sizeof(pitch) );
-
-
-#ifdef WIN32_DEBUG
-	// DEBUG
-	partial->getSynth()->rawDumpState( "temp-load", this, sizeof(*this) );
-	this->rawVerifyState( "temp-save", partial->getSynth() );
-	partial->getSynth()->rawDumpNo++;
-#endif
-}
-
-}
+} // namespace MT32Emu
diff --git a/src/mt32/TVP.h b/src/mt32/TVP.h
index e47719c5..896e8c11 100644
--- a/src/mt32/TVP.h
+++ b/src/mt32/TVP.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,8 +18,15 @@
 #ifndef MT32EMU_TVP_H
 #define MT32EMU_TVP_H
 
+#include "globals.h"
+#include "Types.h"
+#include "Structures.h"
+
 namespace MT32Emu {
 
+class Part;
+class Partial;
+
 class TVP {
 private:
 	const Partial * const partial;
@@ -29,7 +36,6 @@ private:
 	const TimbreParam::PartialParam *partialParam;
 	const MemParams::PatchTemp *patchTemp;
 
-	int maxCounter;
 	int processTimerIncrement;
 	int counter;
 	Bit32u timeElapsed;
@@ -60,14 +66,8 @@ public:
 	Bit32u getBasePitch() const;
 	Bit16u nextPitch();
 	void startDecay();
+}; // class TVP
 
-	void saveState( std::ostream &stream );
-	void loadState( std::istream &stream );
-
-	// savestate debugging
-	void rawVerifyState( char *name, Synth *synth );
-};
-
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_TVP_H
diff --git a/src/mt32/Tables.cpp b/src/mt32/Tables.cpp
index cfd2ad34..f12caa6b 100644
--- a/src/mt32/Tables.cpp
+++ b/src/mt32/Tables.cpp
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -15,39 +15,40 @@
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <cmath>
-#include <cstdlib>
-#include <cstring>
+#include "internals.h"
 
-#include "mt32emu.h"
+#include "Tables.h"
 #include "mmath.h"
 
 namespace MT32Emu {
 
+// UNUSED: const int MIDDLEC = 60;
+
 const Tables &Tables::getInstance() {
 	static const Tables instance;
 	return instance;
 }
 
 Tables::Tables() {
-	int lf;
-	for (lf = 0; lf <= 100; lf++) {
+	for (int lf = 0; lf <= 100; lf++) {
 		// CONFIRMED:KG: This matches a ROM table found by Mok
-		float fVal = (2.0f - LOG10F((float)lf + 1.0f)) * 128.0f;
-		int val = (int)(fVal + 1.0);
+		float fVal = (2.0f - LOG10F(float(lf) + 1.0f)) * 128.0f;
+		int val = int(fVal + 1.0);
 		if (val > 255) {
 			val = 255;
 		}
-		levelToAmpSubtraction[lf] = (Bit8u)val;
+		levelToAmpSubtraction[lf] = Bit8u(val);
 	}
 
 	envLogarithmicTime[0] = 64;
-	for (lf = 1; lf <= 255; lf++) {
+	for (int lf = 1; lf <= 255; lf++) {
 		// CONFIRMED:KG: This matches a ROM table found by Mok
-		envLogarithmicTime[lf] = (Bit8u)ceil(64.0f + LOG2F((float)lf) * 8.0f);
+		envLogarithmicTime[lf] = Bit8u(ceil(64.0f + LOG2F(float(lf)) * 8.0f));
 	}
 
-#ifdef EMULATE_LAPC_I // Dummy #ifdef - we'll have runtime emulation mode selection in future.
+#if 0
+	// The table below is to be used in conjunction with emulation of VCA of newer generation units which is currently missing.
+	// These relatively small values are rather intended to fine-tune the overall amplification of the VCA.
 	// CONFIRMED: Based on a table found by Mok in the LAPC-I control ROM
 	// Note that this matches the MT-32 table, but with the values clamped to a maximum of 8.
 	memset(masterVolToAmpSubtraction, 8, 71);
@@ -63,12 +64,12 @@ Tables::Tables() {
 	// CONFIRMED: Based on a table found by Mok in the MT-32 control ROM
 	masterVolToAmpSubtraction[0] = 255;
 	for (int masterVol = 1; masterVol <= 100; masterVol++) {
-		masterVolToAmpSubtraction[masterVol] = (int)(106.31 - 16.0f * LOG2F((float)masterVol));
+		masterVolToAmpSubtraction[masterVol] = Bit8u(106.31 - 16.0f * LOG2F(float(masterVol)));
 	}
 #endif
 
 	for (int i = 0; i <= 100; i++) {
-		pulseWidth100To255[i] = (int)(i * 255 / 100.0f + 0.5f);
+		pulseWidth100To255[i] = Bit8u(i * 255 / 100.0f + 0.5f);
 		//synth->printDebug("%d: %d", i, pulseWidth100To255[i]);
 	}
 
@@ -93,4 +94,4 @@ Tables::Tables() {
 	resAmpDecayFactor = resAmpDecayFactorTable;
 }
 
-}
+} // namespace MT32Emu
diff --git a/src/mt32/Tables.h b/src/mt32/Tables.h
index 8b4580df..47465097 100644
--- a/src/mt32/Tables.h
+++ b/src/mt32/Tables.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,21 +18,16 @@
 #ifndef MT32EMU_TABLES_H
 #define MT32EMU_TABLES_H
 
-namespace MT32Emu {
-
-// Sample rate to use in mixing. With the progress of development, we've found way too many thing dependent.
-// In order to achieve further advance in emulation accuracy, sample rate made fixed throughout the emulator.
-// The output from the synth is supposed to be resampled to convert the sample rate.
-const unsigned int SAMPLE_RATE = 32000;
+#include "globals.h"
+#include "Types.h"
 
-const int MIDDLEC = 60;
-
-class Synth;
+namespace MT32Emu {
 
 class Tables {
 private:
 	Tables();
 	Tables(Tables &);
+	~Tables() {}
 
 public:
 	static const Tables &getInstance();
@@ -60,8 +55,8 @@ public:
 	Bit16u logsin9[512];
 
 	const Bit8u *resAmpDecayFactor;
-};
+}; // class Tables
 
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_TABLES_H
diff --git a/src/mt32/Types.h b/src/mt32/Types.h
new file mode 100644
index 00000000..f70e4795
--- /dev/null
+++ b/src/mt32/Types.h
@@ -0,0 +1,32 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_TYPES_H
+#define MT32EMU_TYPES_H
+
+namespace MT32Emu {
+
+typedef unsigned int       Bit32u;
+typedef   signed int       Bit32s;
+typedef unsigned short int Bit16u;
+typedef   signed short int Bit16s;
+typedef unsigned char      Bit8u;
+typedef   signed char      Bit8s;
+
+}
+
+#endif
diff --git a/src/mt32/c_interface/c_interface.cpp b/src/mt32/c_interface/c_interface.cpp
new file mode 100644
index 00000000..adb1cb6b
--- /dev/null
+++ b/src/mt32/c_interface/c_interface.cpp
@@ -0,0 +1,717 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "../globals.h"
+#include "../Types.h"
+#include "../File.h"
+#include "../FileStream.h"
+#include "../ROMInfo.h"
+#include "../Synth.h"
+#include "../MidiStreamParser.h"
+#include "../SampleRateConverter.h"
+
+#include "c_types.h"
+#include "c_interface.h"
+
+using namespace MT32Emu;
+
+namespace MT32Emu {
+
+struct SamplerateConversionState {
+	double outputSampleRate;
+	SamplerateConversionQuality srcQuality;
+	SampleRateConverter *src;
+};
+
+static mt32emu_service_version getSynthVersionID(mt32emu_service_i) {
+	return MT32EMU_SERVICE_VERSION_CURRENT;
+}
+
+static const mt32emu_service_i_v2 SERVICE_VTABLE = {
+	getSynthVersionID,
+	mt32emu_get_supported_report_handler_version,
+	mt32emu_get_supported_midi_receiver_version,
+	mt32emu_get_library_version_int,
+	mt32emu_get_library_version_string,
+	mt32emu_get_stereo_output_samplerate,
+	mt32emu_create_context,
+	mt32emu_free_context,
+	mt32emu_add_rom_data,
+	mt32emu_add_rom_file,
+	mt32emu_get_rom_info,
+	mt32emu_set_partial_count,
+	mt32emu_set_analog_output_mode,
+	mt32emu_open_synth,
+	mt32emu_close_synth,
+	mt32emu_is_open,
+	mt32emu_get_actual_stereo_output_samplerate,
+	mt32emu_flush_midi_queue,
+	mt32emu_set_midi_event_queue_size,
+	mt32emu_set_midi_receiver,
+	mt32emu_parse_stream,
+	mt32emu_parse_stream_at,
+	mt32emu_play_short_message,
+	mt32emu_play_short_message_at,
+	mt32emu_play_msg,
+	mt32emu_play_sysex,
+	mt32emu_play_msg_at,
+	mt32emu_play_sysex_at,
+	mt32emu_play_msg_now,
+	mt32emu_play_msg_on_part,
+	mt32emu_play_sysex_now,
+	mt32emu_write_sysex,
+	mt32emu_set_reverb_enabled,
+	mt32emu_is_reverb_enabled,
+	mt32emu_set_reverb_overridden,
+	mt32emu_is_reverb_overridden,
+	mt32emu_set_reverb_compatibility_mode,
+	mt32emu_is_mt32_reverb_compatibility_mode,
+	mt32emu_is_default_reverb_mt32_compatible,
+	mt32emu_set_dac_input_mode,
+	mt32emu_get_dac_input_mode,
+	mt32emu_set_midi_delay_mode,
+	mt32emu_get_midi_delay_mode,
+	mt32emu_set_output_gain,
+	mt32emu_get_output_gain,
+	mt32emu_set_reverb_output_gain,
+	mt32emu_get_reverb_output_gain,
+	mt32emu_set_reversed_stereo_enabled,
+	mt32emu_is_reversed_stereo_enabled,
+	mt32emu_render_bit16s,
+	mt32emu_render_float,
+	mt32emu_render_bit16s_streams,
+	mt32emu_render_float_streams,
+	mt32emu_has_active_partials,
+	mt32emu_is_active,
+	mt32emu_get_partial_count,
+	mt32emu_get_part_states,
+	mt32emu_get_partial_states,
+	mt32emu_get_playing_notes,
+	mt32emu_get_patch_name,
+	mt32emu_read_memory,
+	mt32emu_get_best_analog_output_mode,
+	mt32emu_set_stereo_output_samplerate,
+	mt32emu_set_samplerate_conversion_quality,
+	mt32emu_select_renderer_type,
+	mt32emu_get_selected_renderer_type,
+	mt32emu_convert_output_to_synth_timestamp,
+	mt32emu_convert_synth_to_output_timestamp,
+	mt32emu_get_internal_rendered_sample_count,
+	mt32emu_set_nice_amp_ramp_enabled,
+	mt32emu_is_nice_amp_ramp_enabled
+};
+
+} // namespace MT32Emu
+
+struct mt32emu_data {
+	ReportHandler *reportHandler;
+	Synth *synth;
+	const ROMImage *controlROMImage;
+	const ROMImage *pcmROMImage;
+	DefaultMidiStreamParser *midiParser;
+	Bit32u partialCount;
+	AnalogOutputMode analogOutputMode;
+	SamplerateConversionState *srcState;
+};
+
+// Internal C++ utility stuff
+
+namespace MT32Emu {
+
+class DelegatingReportHandlerAdapter : public ReportHandler {
+public:
+	DelegatingReportHandlerAdapter(mt32emu_report_handler_i useReportHandler, void *useInstanceData) :
+		delegate(useReportHandler), instanceData(useInstanceData) {}
+
+protected:
+	const mt32emu_report_handler_i delegate;
+	void * const instanceData;
+
+private:
+	void printDebug(const char *fmt, va_list list) {
+		if (delegate.v0->printDebug == NULL) {
+			ReportHandler::printDebug(fmt, list);
+		} else {
+			delegate.v0->printDebug(instanceData, fmt, list);
+		}
+	}
+
+	void onErrorControlROM() {
+		if (delegate.v0->onErrorControlROM == NULL) {
+			ReportHandler::onErrorControlROM();
+		} else {
+			delegate.v0->onErrorControlROM(instanceData);
+		}
+	}
+
+	void onErrorPCMROM() {
+		if (delegate.v0->onErrorPCMROM == NULL) {
+			ReportHandler::onErrorPCMROM();
+		} else {
+			delegate.v0->onErrorPCMROM(instanceData);
+		}
+	}
+
+	void showLCDMessage(const char *message) {
+		if (delegate.v0->showLCDMessage == NULL) {
+			ReportHandler::showLCDMessage(message);
+		} else {
+			delegate.v0->showLCDMessage(instanceData, message);
+		}
+	}
+
+	void onMIDIMessagePlayed() {
+		if (delegate.v0->onMIDIMessagePlayed == NULL) {
+			ReportHandler::onMIDIMessagePlayed();
+		} else {
+			delegate.v0->onMIDIMessagePlayed(instanceData);
+		}
+	}
+
+	bool onMIDIQueueOverflow() {
+		if (delegate.v0->onMIDIQueueOverflow == NULL) {
+			return ReportHandler::onMIDIQueueOverflow();
+		}
+		return delegate.v0->onMIDIQueueOverflow(instanceData) != MT32EMU_BOOL_FALSE;
+	}
+
+	void onMIDISystemRealtime(Bit8u systemRealtime) {
+		if (delegate.v0->onMIDISystemRealtime == NULL) {
+			ReportHandler::onMIDISystemRealtime(systemRealtime);
+		} else {
+			delegate.v0->onMIDISystemRealtime(instanceData, systemRealtime);
+		}
+	}
+
+	void onDeviceReset() {
+		if (delegate.v0->onDeviceReset == NULL) {
+			ReportHandler::onDeviceReset();
+		} else {
+			delegate.v0->onDeviceReset(instanceData);
+		}
+	}
+
+	void onDeviceReconfig() {
+		if (delegate.v0->onDeviceReconfig == NULL) {
+			ReportHandler::onDeviceReconfig();
+		} else {
+			delegate.v0->onDeviceReconfig(instanceData);
+		}
+	}
+
+	void onNewReverbMode(Bit8u mode) {
+		if (delegate.v0->onNewReverbMode == NULL) {
+			ReportHandler::onNewReverbMode(mode);
+		} else {
+			delegate.v0->onNewReverbMode(instanceData, mode);
+		}
+	}
+
+	void onNewReverbTime(Bit8u time) {
+		if (delegate.v0->onNewReverbTime == NULL) {
+			ReportHandler::onNewReverbTime(time);
+		} else {
+			delegate.v0->onNewReverbTime(instanceData, time);
+		}
+	}
+
+	void onNewReverbLevel(Bit8u level) {
+		if (delegate.v0->onNewReverbLevel == NULL) {
+			ReportHandler::onNewReverbLevel(level);
+		} else {
+			delegate.v0->onNewReverbLevel(instanceData, level);
+		}
+	}
+
+	void onPolyStateChanged(Bit8u partNum) {
+		if (delegate.v0->onPolyStateChanged == NULL) {
+			ReportHandler::onPolyStateChanged(partNum);
+		} else {
+			delegate.v0->onPolyStateChanged(instanceData, partNum);
+		}
+	}
+
+	void onProgramChanged(Bit8u partNum, const char *soundGroupName, const char *patchName) {
+		if (delegate.v0->onProgramChanged == NULL) {
+			ReportHandler::onProgramChanged(partNum, soundGroupName, patchName);
+		} else {
+			delegate.v0->onProgramChanged(instanceData, partNum, soundGroupName, patchName);
+		}
+	}
+};
+
+class DelegatingMidiStreamParser : public DefaultMidiStreamParser {
+public:
+	DelegatingMidiStreamParser(const mt32emu_data *useData, mt32emu_midi_receiver_i useMIDIReceiver, void *useInstanceData) :
+		DefaultMidiStreamParser(*useData->synth), delegate(useMIDIReceiver), instanceData(useInstanceData) {}
+
+protected:
+	mt32emu_midi_receiver_i delegate;
+	void *instanceData;
+
+private:
+	void handleShortMessage(const Bit32u message) {
+		if (delegate.v0->handleShortMessage == NULL) {
+			DefaultMidiStreamParser::handleShortMessage(message);
+		} else {
+			delegate.v0->handleShortMessage(instanceData, message);
+		}
+	}
+
+	void handleSysex(const Bit8u *stream, const Bit32u length) {
+		if (delegate.v0->handleSysex == NULL) {
+			DefaultMidiStreamParser::handleSysex(stream, length);
+		} else {
+			delegate.v0->handleSysex(instanceData, stream, length);
+		}
+	}
+
+	void handleSystemRealtimeMessage(const Bit8u realtime) {
+		if (delegate.v0->handleSystemRealtimeMessage == NULL) {
+			DefaultMidiStreamParser::handleSystemRealtimeMessage(realtime);
+		} else {
+			delegate.v0->handleSystemRealtimeMessage(instanceData, realtime);
+		}
+	}
+};
+
+static mt32emu_return_code addROMFile(mt32emu_data *data, File *file) {
+	const ROMImage *image = ROMImage::makeROMImage(file);
+	const ROMInfo *info = image->getROMInfo();
+	if (info == NULL) {
+		ROMImage::freeROMImage(image);
+		return MT32EMU_RC_ROM_NOT_IDENTIFIED;
+	}
+	if (info->type == ROMInfo::Control) {
+		if (data->controlROMImage != NULL) {
+			delete data->controlROMImage->getFile();
+			ROMImage::freeROMImage(data->controlROMImage);
+		}
+		data->controlROMImage = image;
+		return MT32EMU_RC_ADDED_CONTROL_ROM;
+	} else if (info->type == ROMInfo::PCM) {
+		if (data->pcmROMImage != NULL) {
+			delete data->pcmROMImage->getFile();
+			ROMImage::freeROMImage(data->pcmROMImage);
+		}
+		data->pcmROMImage = image;
+		return MT32EMU_RC_ADDED_PCM_ROM;
+	}
+	ROMImage::freeROMImage(image);
+	return MT32EMU_RC_OK; // No support for reverb ROM yet.
+}
+
+} // namespace MT32Emu
+
+// C-visible implementation
+
+extern "C" {
+
+mt32emu_service_i mt32emu_get_service_i() {
+	mt32emu_service_i i;
+	i.v2 = &SERVICE_VTABLE;
+	return i;
+}
+
+mt32emu_report_handler_version mt32emu_get_supported_report_handler_version() {
+	return MT32EMU_REPORT_HANDLER_VERSION_CURRENT;
+}
+
+mt32emu_midi_receiver_version mt32emu_get_supported_midi_receiver_version() {
+	return MT32EMU_MIDI_RECEIVER_VERSION_CURRENT;
+}
+
+mt32emu_bit32u mt32emu_get_library_version_int() {
+	return Synth::getLibraryVersionInt();
+}
+
+const char *mt32emu_get_library_version_string() {
+	return Synth::getLibraryVersionString();
+}
+
+mt32emu_bit32u mt32emu_get_stereo_output_samplerate(const mt32emu_analog_output_mode analog_output_mode) {
+	return Synth::getStereoOutputSampleRate(static_cast<AnalogOutputMode>(analog_output_mode));
+}
+
+mt32emu_analog_output_mode mt32emu_get_best_analog_output_mode(const double target_samplerate) {
+	return mt32emu_analog_output_mode(SampleRateConverter::getBestAnalogOutputMode(target_samplerate));
+}
+
+mt32emu_context mt32emu_create_context(mt32emu_report_handler_i report_handler, void *instance_data) {
+	mt32emu_data *data = new mt32emu_data;
+	data->reportHandler = (report_handler.v0 != NULL) ? new DelegatingReportHandlerAdapter(report_handler, instance_data) : new ReportHandler;
+	data->synth = new Synth(data->reportHandler);
+	data->midiParser = new DefaultMidiStreamParser(*data->synth);
+	data->controlROMImage = NULL;
+	data->pcmROMImage = NULL;
+	data->partialCount = DEFAULT_MAX_PARTIALS;
+	data->analogOutputMode = AnalogOutputMode_COARSE;
+
+	data->srcState = new SamplerateConversionState;
+	data->srcState->outputSampleRate = 0.0;
+	data->srcState->srcQuality = SamplerateConversionQuality_GOOD;
+	data->srcState->src = NULL;
+
+	return data;
+}
+
+void mt32emu_free_context(mt32emu_context data) {
+	if (data == NULL) return;
+
+	delete data->srcState->src;
+	data->srcState->src = NULL;
+	delete data->srcState;
+	data->srcState = NULL;
+
+	if (data->controlROMImage != NULL) {
+		delete data->controlROMImage->getFile();
+		ROMImage::freeROMImage(data->controlROMImage);
+		data->controlROMImage = NULL;
+	}
+	if (data->pcmROMImage != NULL) {
+		delete data->pcmROMImage->getFile();
+		ROMImage::freeROMImage(data->pcmROMImage);
+		data->pcmROMImage = NULL;
+	}
+	delete data->midiParser;
+	data->midiParser = NULL;
+	delete data->synth;
+	data->synth = NULL;
+	delete data->reportHandler;
+	data->reportHandler = NULL;
+	delete data;
+}
+
+mt32emu_return_code mt32emu_add_rom_data(mt32emu_context context, const mt32emu_bit8u *data, size_t data_size, const mt32emu_sha1_digest *sha1_digest) {
+	if (sha1_digest == NULL) return addROMFile(context, new ArrayFile(data, data_size));
+	return addROMFile(context, new ArrayFile(data, data_size, *sha1_digest));
+}
+
+mt32emu_return_code mt32emu_add_rom_file(mt32emu_context context, const char *filename) {
+	mt32emu_return_code rc = MT32EMU_RC_OK;
+	FileStream *fs = new FileStream;
+	if (fs->open(filename)) {
+		if (fs->getData() != NULL) {
+			rc = addROMFile(context, fs);
+			if (rc > 0) return rc;
+		} else {
+			rc = MT32EMU_RC_FILE_NOT_LOADED;
+		}
+	} else {
+		rc = MT32EMU_RC_FILE_NOT_FOUND;
+	}
+	delete fs;
+	return rc;
+}
+
+void mt32emu_get_rom_info(mt32emu_const_context context, mt32emu_rom_info *rom_info) {
+	const ROMInfo *romInfo = context->controlROMImage == NULL ? NULL : context->controlROMImage->getROMInfo();
+	if (romInfo != NULL) {
+		rom_info->control_rom_id = romInfo->shortName;
+		rom_info->control_rom_description = romInfo->description;
+		rom_info->control_rom_sha1_digest = romInfo->sha1Digest;
+	} else {
+		rom_info->control_rom_id = NULL;
+		rom_info->control_rom_description = NULL;
+		rom_info->control_rom_sha1_digest = NULL;
+	}
+	romInfo = context->pcmROMImage == NULL ? NULL : context->pcmROMImage->getROMInfo();
+	if (romInfo != NULL) {
+		rom_info->pcm_rom_id = romInfo->shortName;
+		rom_info->pcm_rom_description = romInfo->description;
+		rom_info->pcm_rom_sha1_digest = romInfo->sha1Digest;
+	} else {
+		rom_info->pcm_rom_id = NULL;
+		rom_info->pcm_rom_description = NULL;
+		rom_info->pcm_rom_sha1_digest = NULL;
+	}
+}
+
+void mt32emu_set_partial_count(mt32emu_context context, const mt32emu_bit32u partial_count) {
+	context->partialCount = partial_count;
+}
+
+void mt32emu_set_analog_output_mode(mt32emu_context context, const mt32emu_analog_output_mode analog_output_mode) {
+	context->analogOutputMode = static_cast<AnalogOutputMode>(analog_output_mode);
+}
+
+void mt32emu_set_stereo_output_samplerate(mt32emu_context context, const double samplerate) {
+	context->srcState->outputSampleRate = SampleRateConverter::getSupportedOutputSampleRate(samplerate);
+}
+
+void mt32emu_set_samplerate_conversion_quality(mt32emu_context context, const mt32emu_samplerate_conversion_quality quality) {
+	context->srcState->srcQuality = SamplerateConversionQuality(quality);
+}
+
+void mt32emu_select_renderer_type(mt32emu_context context, const mt32emu_renderer_type renderer_type) {
+	context->synth->selectRendererType(static_cast<RendererType>(renderer_type));
+}
+
+mt32emu_renderer_type mt32emu_get_selected_renderer_type(mt32emu_context context) {
+	return static_cast<mt32emu_renderer_type>(context->synth->getSelectedRendererType());
+}
+
+mt32emu_return_code mt32emu_open_synth(mt32emu_const_context context) {
+	if ((context->controlROMImage == NULL) || (context->pcmROMImage == NULL)) {
+		return MT32EMU_RC_MISSING_ROMS;
+	}
+	if (!context->synth->open(*context->controlROMImage, *context->pcmROMImage, context->partialCount, context->analogOutputMode)) {
+		return MT32EMU_RC_FAILED;
+	}
+	SamplerateConversionState &srcState = *context->srcState;
+	const double outputSampleRate = (0.0 < srcState.outputSampleRate) ? srcState.outputSampleRate : context->synth->getStereoOutputSampleRate();
+	srcState.src = new SampleRateConverter(*context->synth, outputSampleRate, srcState.srcQuality);
+	return MT32EMU_RC_OK;
+}
+
+void mt32emu_close_synth(mt32emu_const_context context) {
+	context->synth->close();
+	delete context->srcState->src;
+	context->srcState->src = NULL;
+}
+
+mt32emu_boolean mt32emu_is_open(mt32emu_const_context context) {
+	return context->synth->isOpen() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+mt32emu_bit32u mt32emu_get_actual_stereo_output_samplerate(mt32emu_const_context context) {
+	if (context->srcState->src == NULL) {
+		return context->synth->getStereoOutputSampleRate();
+	}
+	return mt32emu_bit32u(0.5 + context->srcState->src->convertSynthToOutputTimestamp(SAMPLE_RATE));
+}
+
+mt32emu_bit32u mt32emu_convert_output_to_synth_timestamp(mt32emu_const_context context, mt32emu_bit32u output_timestamp) {
+	if (context->srcState->src == NULL) {
+		return output_timestamp;
+	}
+	return mt32emu_bit32u(0.5 + context->srcState->src->convertOutputToSynthTimestamp(output_timestamp));
+}
+
+mt32emu_bit32u mt32emu_convert_synth_to_output_timestamp(mt32emu_const_context context, mt32emu_bit32u synth_timestamp) {
+	if (context->srcState->src == NULL) {
+		return synth_timestamp;
+	}
+	return mt32emu_bit32u(0.5 + context->srcState->src->convertSynthToOutputTimestamp(synth_timestamp));
+}
+
+void mt32emu_flush_midi_queue(mt32emu_const_context context) {
+	context->synth->flushMIDIQueue();
+}
+
+mt32emu_bit32u mt32emu_set_midi_event_queue_size(mt32emu_const_context context, const mt32emu_bit32u queue_size) {
+	return context->synth->setMIDIEventQueueSize(queue_size);
+}
+
+void mt32emu_set_midi_receiver(mt32emu_context context, mt32emu_midi_receiver_i midi_receiver, void *instance_data) {
+	delete context->midiParser;
+	context->midiParser = (midi_receiver.v0 != NULL) ? new DelegatingMidiStreamParser(context, midi_receiver, instance_data) : new DefaultMidiStreamParser(*context->synth);
+}
+
+mt32emu_bit32u mt32emu_get_internal_rendered_sample_count(mt32emu_const_context context) {
+	return context->synth->getInternalRenderedSampleCount();
+}
+
+void mt32emu_parse_stream(mt32emu_const_context context, const mt32emu_bit8u *stream, mt32emu_bit32u length) {
+	context->midiParser->resetTimestamp();
+	context->midiParser->parseStream(stream, length);
+}
+
+void mt32emu_parse_stream_at(mt32emu_const_context context, const mt32emu_bit8u *stream, mt32emu_bit32u length, mt32emu_bit32u timestamp) {
+	context->midiParser->setTimestamp(timestamp);
+	context->midiParser->parseStream(stream, length);
+}
+
+void mt32emu_play_short_message(mt32emu_const_context context, mt32emu_bit32u message) {
+	context->midiParser->resetTimestamp();
+	context->midiParser->processShortMessage(message);
+}
+
+void mt32emu_play_short_message_at(mt32emu_const_context context, mt32emu_bit32u message, mt32emu_bit32u timestamp) {
+	context->midiParser->setTimestamp(timestamp);
+	context->midiParser->processShortMessage(message);
+}
+
+mt32emu_return_code mt32emu_play_msg(mt32emu_const_context context, mt32emu_bit32u msg) {
+	if (!context->synth->isOpen()) return MT32EMU_RC_NOT_OPENED;
+	return (context->synth->playMsg(msg)) ? MT32EMU_RC_OK : MT32EMU_RC_QUEUE_FULL;
+}
+
+mt32emu_return_code mt32emu_play_sysex(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len) {
+	if (!context->synth->isOpen()) return MT32EMU_RC_NOT_OPENED;
+	return (context->synth->playSysex(sysex, len)) ? MT32EMU_RC_OK : MT32EMU_RC_QUEUE_FULL;
+}
+
+mt32emu_return_code mt32emu_play_msg_at(mt32emu_const_context context, mt32emu_bit32u msg, mt32emu_bit32u timestamp) {
+	if (!context->synth->isOpen()) return MT32EMU_RC_NOT_OPENED;
+	return (context->synth->playMsg(msg, timestamp)) ? MT32EMU_RC_OK : MT32EMU_RC_QUEUE_FULL;
+}
+
+mt32emu_return_code mt32emu_play_sysex_at(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len, mt32emu_bit32u timestamp) {
+	if (!context->synth->isOpen()) return MT32EMU_RC_NOT_OPENED;
+	return (context->synth->playSysex(sysex, len, timestamp)) ? MT32EMU_RC_OK : MT32EMU_RC_QUEUE_FULL;
+}
+
+void mt32emu_play_msg_now(mt32emu_const_context context, mt32emu_bit32u msg) {
+	context->synth->playMsgNow(msg);
+}
+
+void mt32emu_play_msg_on_part(mt32emu_const_context context, mt32emu_bit8u part, mt32emu_bit8u code, mt32emu_bit8u note, mt32emu_bit8u velocity) {
+	context->synth->playMsgOnPart(part, code, note, velocity);
+}
+
+void mt32emu_play_sysex_now(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len) {
+	context->synth->playSysexNow(sysex, len);
+}
+
+void mt32emu_write_sysex(mt32emu_const_context context, mt32emu_bit8u channel, const mt32emu_bit8u *sysex, mt32emu_bit32u len) {
+	context->synth->writeSysex(channel, sysex, len);
+}
+
+void mt32emu_set_reverb_enabled(mt32emu_const_context context, const mt32emu_boolean reverb_enabled) {
+	context->synth->setReverbEnabled(reverb_enabled != MT32EMU_BOOL_FALSE);
+}
+
+mt32emu_boolean mt32emu_is_reverb_enabled(mt32emu_const_context context) {
+	return context->synth->isReverbEnabled() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+void mt32emu_set_reverb_overridden(mt32emu_const_context context, const mt32emu_boolean reverb_overridden) {
+	context->synth->setReverbOverridden(reverb_overridden != MT32EMU_BOOL_FALSE);
+}
+
+mt32emu_boolean mt32emu_is_reverb_overridden(mt32emu_const_context context) {
+	return context->synth->isReverbOverridden() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+void mt32emu_set_reverb_compatibility_mode(mt32emu_const_context context, const mt32emu_boolean mt32_compatible_mode) {
+	context->synth->setReverbCompatibilityMode(mt32_compatible_mode != MT32EMU_BOOL_FALSE);
+}
+
+mt32emu_boolean mt32emu_is_mt32_reverb_compatibility_mode(mt32emu_const_context context) {
+	return context->synth->isMT32ReverbCompatibilityMode() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+mt32emu_boolean mt32emu_is_default_reverb_mt32_compatible(mt32emu_const_context context) {
+	return context->synth->isDefaultReverbMT32Compatible() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+void mt32emu_set_dac_input_mode(mt32emu_const_context context, const mt32emu_dac_input_mode mode) {
+	context->synth->setDACInputMode(static_cast<DACInputMode>(mode));
+}
+
+mt32emu_dac_input_mode mt32emu_get_dac_input_mode(mt32emu_const_context context) {
+	return static_cast<mt32emu_dac_input_mode>(context->synth->getDACInputMode());
+}
+
+void mt32emu_set_midi_delay_mode(mt32emu_const_context context, const mt32emu_midi_delay_mode mode) {
+	context->synth->setMIDIDelayMode(static_cast<MIDIDelayMode>(mode));
+}
+
+mt32emu_midi_delay_mode mt32emu_get_midi_delay_mode(mt32emu_const_context context) {
+	return static_cast<mt32emu_midi_delay_mode>(context->synth->getMIDIDelayMode());
+}
+
+void mt32emu_set_output_gain(mt32emu_const_context context, float gain) {
+	context->synth->setOutputGain(gain);
+}
+
+float mt32emu_get_output_gain(mt32emu_const_context context) {
+	return context->synth->getOutputGain();
+}
+
+void mt32emu_set_reverb_output_gain(mt32emu_const_context context, float gain) {
+	context->synth->setReverbOutputGain(gain);
+}
+
+float mt32emu_get_reverb_output_gain(mt32emu_const_context context) {
+	return context->synth->getReverbOutputGain();
+}
+
+void mt32emu_set_reversed_stereo_enabled(mt32emu_const_context context, const mt32emu_boolean enabled) {
+	context->synth->setReversedStereoEnabled(enabled != MT32EMU_BOOL_FALSE);
+}
+
+mt32emu_boolean mt32emu_is_reversed_stereo_enabled(mt32emu_const_context context) {
+	return context->synth->isReversedStereoEnabled() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+void mt32emu_set_nice_amp_ramp_enabled(mt32emu_const_context context, const mt32emu_boolean enabled) {
+	context->synth->setNiceAmpRampEnabled(enabled != MT32EMU_BOOL_FALSE);
+}
+
+mt32emu_boolean mt32emu_is_nice_amp_ramp_enabled(mt32emu_const_context context) {
+	return context->synth->isNiceAmpRampEnabled() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+void mt32emu_render_bit16s(mt32emu_const_context context, mt32emu_bit16s *stream, mt32emu_bit32u len) {
+	if (context->srcState->src != NULL) {
+		context->srcState->src->getOutputSamples(stream, len);
+	} else {
+		context->synth->render(stream, len);
+	}
+}
+
+void mt32emu_render_float(mt32emu_const_context context, float *stream, mt32emu_bit32u len) {
+	if (context->srcState->src != NULL) {
+		context->srcState->src->getOutputSamples(stream, len);
+	} else {
+		context->synth->render(stream, len);
+	}
+}
+
+void mt32emu_render_bit16s_streams(mt32emu_const_context context, const mt32emu_dac_output_bit16s_streams *streams, mt32emu_bit32u len) {
+	context->synth->renderStreams(*reinterpret_cast<const DACOutputStreams<Bit16s> *>(streams), len);
+}
+
+void mt32emu_render_float_streams(mt32emu_const_context context, const mt32emu_dac_output_float_streams *streams, mt32emu_bit32u len) {
+	context->synth->renderStreams(*reinterpret_cast<const DACOutputStreams<float> *>(streams), len);
+}
+
+mt32emu_boolean mt32emu_has_active_partials(mt32emu_const_context context) {
+	return context->synth->hasActivePartials() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+mt32emu_boolean mt32emu_is_active(mt32emu_const_context context) {
+	return context->synth->isActive() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+mt32emu_bit32u mt32emu_get_partial_count(mt32emu_const_context context) {
+	return context->synth->getPartialCount();
+}
+
+mt32emu_bit32u mt32emu_get_part_states(mt32emu_const_context context) {
+	return context->synth->getPartStates();
+}
+
+void mt32emu_get_partial_states(mt32emu_const_context context, mt32emu_bit8u *partial_states) {
+	context->synth->getPartialStates(partial_states);
+}
+
+mt32emu_bit32u mt32emu_get_playing_notes(mt32emu_const_context context, mt32emu_bit8u part_number, mt32emu_bit8u *keys, mt32emu_bit8u *velocities) {
+	return context->synth->getPlayingNotes(part_number, keys, velocities);
+}
+
+const char *mt32emu_get_patch_name(mt32emu_const_context context, mt32emu_bit8u part_number) {
+	return context->synth->getPatchName(part_number);
+}
+
+void mt32emu_read_memory(mt32emu_const_context context, mt32emu_bit32u addr, mt32emu_bit32u len, mt32emu_bit8u *data) {
+	context->synth->readMemory(addr, len, data);
+}
+
+} // extern "C"
diff --git a/src/mt32/c_interface/c_interface.h b/src/mt32/c_interface/c_interface.h
new file mode 100644
index 00000000..f7364003
--- /dev/null
+++ b/src/mt32/c_interface/c_interface.h
@@ -0,0 +1,434 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_C_INTERFACE_H
+#define MT32EMU_C_INTERFACE_H
+
+#include <stddef.h>
+
+#include "../globals.h"
+#include "c_types.h"
+
+#undef MT32EMU_EXPORT
+#define MT32EMU_EXPORT MT32EMU_EXPORT_ATTRIBUTE
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* == Context-independent functions == */
+
+/* === Interface handling === */
+
+/** Returns mt32emu_service_i interface. */
+MT32EMU_EXPORT mt32emu_service_i mt32emu_get_service_i(void);
+
+#if MT32EMU_EXPORTS_TYPE == 2
+#undef MT32EMU_EXPORT
+#define MT32EMU_EXPORT
+#endif
+
+/**
+ * Returns the version ID of mt32emu_report_handler_i interface the library has been compiled with.
+ * This allows a client to fall-back gracefully instead of silently not receiving expected event reports.
+ */
+MT32EMU_EXPORT mt32emu_report_handler_version mt32emu_get_supported_report_handler_version(void);
+
+/**
+ * Returns the version ID of mt32emu_midi_receiver_version_i interface the library has been compiled with.
+ * This allows a client to fall-back gracefully instead of silently not receiving expected MIDI messages.
+ */
+MT32EMU_EXPORT mt32emu_midi_receiver_version mt32emu_get_supported_midi_receiver_version(void);
+
+/**
+ * Returns library version as an integer in format: 0x00MMmmpp, where:
+ * MM - major version number
+ * mm - minor version number
+ * pp - patch number
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_get_library_version_int(void);
+
+/**
+ * Returns library version as a C-string in format: "MAJOR.MINOR.PATCH".
+ */
+MT32EMU_EXPORT const char *mt32emu_get_library_version_string(void);
+
+/**
+ * Returns output sample rate used in emulation of stereo analog circuitry of hardware units for particular analog_output_mode.
+ * See comment for mt32emu_analog_output_mode.
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_get_stereo_output_samplerate(const mt32emu_analog_output_mode analog_output_mode);
+
+/**
+ * Returns the value of analog_output_mode for which the output signal may retain its full frequency spectrum
+ * at the sample rate specified by the target_samplerate argument.
+ * See comment for mt32emu_analog_output_mode.
+ */
+MT32EMU_EXPORT mt32emu_analog_output_mode mt32emu_get_best_analog_output_mode(const double target_samplerate);
+
+/* == Context-dependent functions == */
+
+/** Initialises a new emulation context and installs custom report handler if non-NULL. */
+MT32EMU_EXPORT mt32emu_context mt32emu_create_context(mt32emu_report_handler_i report_handler, void *instance_data);
+
+/** Closes and destroys emulation context. */
+MT32EMU_EXPORT void mt32emu_free_context(mt32emu_context context);
+
+/**
+ * Adds new ROM identified by its SHA1 digest to the emulation context replacing previously added ROM of the same type if any.
+ * Argument sha1_digest can be NULL, in this case the digest will be computed using the actual ROM data.
+ * If sha1_digest is set to non-NULL, it is assumed being correct and will not be recomputed.
+ * This function doesn't immediately change the state of already opened synth. Newly added ROM will take effect upon next call of mt32emu_open_synth().
+ * Returns positive value upon success.
+ */
+MT32EMU_EXPORT mt32emu_return_code mt32emu_add_rom_data(mt32emu_context context, const mt32emu_bit8u *data, size_t data_size, const mt32emu_sha1_digest *sha1_digest);
+
+/**
+ * Loads a ROM file, identify it by SHA1 digest, and adds it to the emulation context replacing previously added ROM of the same type if any.
+ * This function doesn't immediately change the state of already opened synth. Newly added ROM will take effect upon next call of mt32emu_open_synth().
+ * Returns positive value upon success.
+ */
+MT32EMU_EXPORT mt32emu_return_code mt32emu_add_rom_file(mt32emu_context context, const char *filename);
+
+/**
+ * Fills in mt32emu_rom_info structure with identifiers and descriptions of control and PCM ROM files identified and added to the synth context.
+ * If one of the ROM files is not loaded and identified yet, NULL is returned in the corresponding fields of the mt32emu_rom_info structure.
+ */
+MT32EMU_EXPORT void mt32emu_get_rom_info(mt32emu_const_context context, mt32emu_rom_info *rom_info);
+
+/**
+ * Allows to override the default maximum number of partials playing simultaneously within the emulation session.
+ * This function doesn't immediately change the state of already opened synth. Newly set value will take effect upon next call of mt32emu_open_synth().
+ */
+MT32EMU_EXPORT void mt32emu_set_partial_count(mt32emu_context context, const mt32emu_bit32u partial_count);
+
+/**
+ * Allows to override the default mode for emulation of analogue circuitry of the hardware units within the emulation session.
+ * This function doesn't immediately change the state of already opened synth. Newly set value will take effect upon next call of mt32emu_open_synth().
+ */
+MT32EMU_EXPORT void mt32emu_set_analog_output_mode(mt32emu_context context, const mt32emu_analog_output_mode analog_output_mode);
+
+/**
+ * Allows to convert the synthesiser output to any desired sample rate. The samplerate conversion
+ * processes the completely mixed stereo output signal as it passes the analogue circuit emulation,
+ * so emulating the synthesiser output signal passing further through an ADC. When the samplerate
+ * argument is set to 0, the default output sample rate is used which depends on the current
+ * mode of analog circuitry emulation. See mt32emu_analog_output_mode.
+ * This function doesn't immediately change the state of already opened synth.
+ * Newly set value will take effect upon next call of mt32emu_open_synth().
+ */
+MT32EMU_EXPORT void mt32emu_set_stereo_output_samplerate(mt32emu_context context, const double samplerate);
+
+/**
+ * Several samplerate conversion quality options are provided which allow to trade-off the conversion speed vs.
+ * the retained passband width. All the options except FASTEST guarantee full suppression of the aliasing noise
+ * in terms of the 16-bit integer samples.
+ * This function doesn't immediately change the state of already opened synth.
+ * Newly set value will take effect upon next call of mt32emu_open_synth().
+ */
+MT32EMU_EXPORT void mt32emu_set_samplerate_conversion_quality(mt32emu_context context, const mt32emu_samplerate_conversion_quality quality);
+
+/**
+ * Selects new type of the wave generator and renderer to be used during subsequent calls to mt32emu_open_synth().
+ * By default, MT32EMU_RT_BIT16S is selected.
+ * See mt32emu_renderer_type for details.
+ */
+MT32EMU_EXPORT void mt32emu_select_renderer_type(mt32emu_context context, const mt32emu_renderer_type renderer_type);
+
+/**
+ * Returns previously selected type of the wave generator and renderer.
+ * See mt32emu_renderer_type for details.
+ */
+MT32EMU_EXPORT mt32emu_renderer_type mt32emu_get_selected_renderer_type(mt32emu_context context);
+
+/**
+ * Prepares the emulation context to receive MIDI messages and produce output audio data using aforehand added set of ROMs,
+ * and optionally set the maximum partial count and the analog output mode.
+ * Returns MT32EMU_RC_OK upon success.
+ */
+MT32EMU_EXPORT mt32emu_return_code mt32emu_open_synth(mt32emu_const_context context);
+
+/** Closes the emulation context freeing allocated resources. Added ROMs remain unaffected and ready for reuse. */
+MT32EMU_EXPORT void mt32emu_close_synth(mt32emu_const_context context);
+
+/** Returns true if the synth is in completely initialized state, otherwise returns false. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_is_open(mt32emu_const_context context);
+
+/**
+ * Returns actual sample rate of the fully processed output stereo signal.
+ * If samplerate conversion is used (i.e. when mt32emu_set_stereo_output_samplerate() has been invoked with a non-zero value),
+ * the returned value is the desired output samplerate rounded down to the closest integer.
+ * Otherwise, the output samplerate is choosen depending on the emulation mode of stereo analog circuitry of hardware units.
+ * See comment for mt32emu_analog_output_mode for more info.
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_get_actual_stereo_output_samplerate(mt32emu_const_context context);
+
+/**
+ * Returns the number of samples produced at the internal synth sample rate (32000 Hz)
+ * that correspond to the given number of samples at the output sample rate.
+ * Intended to facilitate audio time synchronisation.
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_convert_output_to_synth_timestamp(mt32emu_const_context context, mt32emu_bit32u output_timestamp);
+
+/**
+ * Returns the number of samples produced at the output sample rate
+ * that correspond to the given number of samples at the internal synth sample rate (32000 Hz).
+ * Intended to facilitate audio time synchronisation.
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_convert_synth_to_output_timestamp(mt32emu_const_context context, mt32emu_bit32u synth_timestamp);
+
+/** All the enqueued events are processed by the synth immediately. */
+MT32EMU_EXPORT void mt32emu_flush_midi_queue(mt32emu_const_context context);
+
+/**
+ * Sets size of the internal MIDI event queue. The queue size is set to the minimum power of 2 that is greater or equal to the size specified.
+ * The queue is flushed before reallocation.
+ * Returns the actual queue size being used.
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_set_midi_event_queue_size(mt32emu_const_context context, const mt32emu_bit32u queue_size);
+
+/**
+ * Installs custom MIDI receiver object intended for receiving MIDI messages generated by MIDI stream parser.
+ * MIDI stream parser is involved when functions mt32emu_parse_stream() and mt32emu_play_short_message() or the likes are called.
+ * By default, parsed short MIDI messages and System Exclusive messages are sent to the synth input MIDI queue.
+ * This function allows to override default behaviour. If midi_receiver argument is set to NULL, the default behaviour is restored.
+ */
+MT32EMU_EXPORT void mt32emu_set_midi_receiver(mt32emu_context context, mt32emu_midi_receiver_i midi_receiver, void *instance_data);
+
+/**
+ * Returns current value of the global counter of samples rendered since the synth was created (at the native sample rate 32000 Hz).
+ * This method helps to compute accurate timestamp of a MIDI message to use with the methods below.
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_get_internal_rendered_sample_count(mt32emu_const_context context);
+
+/* Enqueues a MIDI event for subsequent playback.
+ * The MIDI event will be processed not before the specified timestamp.
+ * The timestamp is measured as the global rendered sample count since the synth was created (at the native sample rate 32000 Hz).
+ * The minimum delay involves emulation of the delay introduced while the event is transferred via MIDI interface
+ * and emulation of the MCU busy-loop while it frees partials for use by a new Poly.
+ * Calls from multiple threads must be synchronised, although, no synchronisation is required with the rendering thread.
+ * onMIDIQueueOverflow callback is invoked when the MIDI event queue is full and the message cannot be enqueued.
+ */
+
+/**
+ * Parses a block of raw MIDI bytes and enqueues parsed MIDI messages for further processing ASAP.
+ * SysEx messages are allowed to be fragmented across several calls to this method. Running status is also handled for short messages.
+ * When a System Realtime MIDI message is parsed, onMIDISystemRealtime callback is invoked.
+ * NOTE: the total length of a SysEx message being fragmented shall not exceed MT32EMU_MAX_STREAM_BUFFER_SIZE (32768 bytes).
+ */
+MT32EMU_EXPORT void mt32emu_parse_stream(mt32emu_const_context context, const mt32emu_bit8u *stream, mt32emu_bit32u length);
+
+/**
+ * Parses a block of raw MIDI bytes and enqueues parsed MIDI messages to play at specified time.
+ * SysEx messages are allowed to be fragmented across several calls to this method. Running status is also handled for short messages.
+ * When a System Realtime MIDI message is parsed, onMIDISystemRealtime callback is invoked.
+ * NOTE: the total length of a SysEx message being fragmented shall not exceed MT32EMU_MAX_STREAM_BUFFER_SIZE (32768 bytes).
+ */
+MT32EMU_EXPORT void mt32emu_parse_stream_at(mt32emu_const_context context, const mt32emu_bit8u *stream, mt32emu_bit32u length, mt32emu_bit32u timestamp);
+
+/**
+ * Enqueues a single mt32emu_bit32u-encoded short MIDI message with full processing ASAP.
+ * The short MIDI message may contain no status byte, the running status is used in this case.
+ * When the argument is a System Realtime MIDI message, onMIDISystemRealtime callback is invoked.
+ */
+MT32EMU_EXPORT void mt32emu_play_short_message(mt32emu_const_context context, mt32emu_bit32u message);
+
+/**
+ * Enqueues a single mt32emu_bit32u-encoded short MIDI message to play at specified time with full processing.
+ * The short MIDI message may contain no status byte, the running status is used in this case.
+ * When the argument is a System Realtime MIDI message, onMIDISystemRealtime callback is invoked.
+ */
+MT32EMU_EXPORT void mt32emu_play_short_message_at(mt32emu_const_context context, mt32emu_bit32u message, mt32emu_bit32u timestamp);
+
+/** Enqueues a single short MIDI message to be processed ASAP. The message must contain a status byte. */
+MT32EMU_EXPORT mt32emu_return_code mt32emu_play_msg(mt32emu_const_context context, mt32emu_bit32u msg);
+/** Enqueues a single well formed System Exclusive MIDI message to be processed ASAP. */
+MT32EMU_EXPORT mt32emu_return_code mt32emu_play_sysex(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len);
+
+/** Enqueues a single short MIDI message to play at specified time. The message must contain a status byte. */
+MT32EMU_EXPORT mt32emu_return_code mt32emu_play_msg_at(mt32emu_const_context context, mt32emu_bit32u msg, mt32emu_bit32u timestamp);
+/** Enqueues a single well formed System Exclusive MIDI message to play at specified time. */
+MT32EMU_EXPORT mt32emu_return_code mt32emu_play_sysex_at(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len, mt32emu_bit32u timestamp);
+
+/* WARNING:
+ * The methods below don't ensure minimum 1-sample delay between sequential MIDI events,
+ * and a sequence of NoteOn and immediately succeeding NoteOff messages is always silent.
+ * A thread that invokes these methods must be explicitly synchronised with the thread performing sample rendering.
+ */
+
+/**
+ * Sends a short MIDI message to the synth for immediate playback. The message must contain a status byte.
+ * See the WARNING above.
+ */
+MT32EMU_EXPORT void mt32emu_play_msg_now(mt32emu_const_context context, mt32emu_bit32u msg);
+/**
+ * Sends unpacked short MIDI message to the synth for immediate playback. The message must contain a status byte.
+ * See the WARNING above.
+ */
+MT32EMU_EXPORT void mt32emu_play_msg_on_part(mt32emu_const_context context, mt32emu_bit8u part, mt32emu_bit8u code, mt32emu_bit8u note, mt32emu_bit8u velocity);
+
+/**
+ * Sends a single well formed System Exclusive MIDI message for immediate processing. The length is in bytes.
+ * See the WARNING above.
+ */
+MT32EMU_EXPORT void mt32emu_play_sysex_now(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len);
+/**
+ * Sends inner body of a System Exclusive MIDI message for direct processing. The length is in bytes.
+ * See the WARNING above.
+ */
+MT32EMU_EXPORT void mt32emu_write_sysex(mt32emu_const_context context, mt32emu_bit8u channel, const mt32emu_bit8u *sysex, mt32emu_bit32u len);
+
+/** Allows to disable wet reverb output altogether. */
+MT32EMU_EXPORT void mt32emu_set_reverb_enabled(mt32emu_const_context context, const mt32emu_boolean reverb_enabled);
+/** Returns whether wet reverb output is enabled. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_is_reverb_enabled(mt32emu_const_context context);
+/**
+ * Sets override reverb mode. In this mode, emulation ignores sysexes (or the related part of them) which control the reverb parameters.
+ * This mode is in effect until it is turned off. When the synth is re-opened, the override mode is unchanged but the state
+ * of the reverb model is reset to default.
+ */
+MT32EMU_EXPORT void mt32emu_set_reverb_overridden(mt32emu_const_context context, const mt32emu_boolean reverb_overridden);
+/** Returns whether reverb settings are overridden. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_is_reverb_overridden(mt32emu_const_context context);
+/**
+ * Forces reverb model compatibility mode. By default, the compatibility mode corresponds to the used control ROM version.
+ * Invoking this method with the argument set to true forces emulation of old MT-32 reverb circuit.
+ * When the argument is false, emulation of the reverb circuit used in new generation of MT-32 compatible modules is enforced
+ * (these include CM-32L and LAPC-I).
+ */
+MT32EMU_EXPORT void mt32emu_set_reverb_compatibility_mode(mt32emu_const_context context, const mt32emu_boolean mt32_compatible_mode);
+/** Returns whether reverb is in old MT-32 compatibility mode. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_is_mt32_reverb_compatibility_mode(mt32emu_const_context context);
+/** Returns whether default reverb compatibility mode is the old MT-32 compatibility mode. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_is_default_reverb_mt32_compatible(mt32emu_const_context context);
+
+/** Sets new DAC input mode. See mt32emu_dac_input_mode for details. */
+MT32EMU_EXPORT void mt32emu_set_dac_input_mode(mt32emu_const_context context, const mt32emu_dac_input_mode mode);
+/** Returns current DAC input mode. See mt32emu_dac_input_mode for details. */
+MT32EMU_EXPORT mt32emu_dac_input_mode mt32emu_get_dac_input_mode(mt32emu_const_context context);
+
+/** Sets new MIDI delay mode. See mt32emu_midi_delay_mode for details. */
+MT32EMU_EXPORT void mt32emu_set_midi_delay_mode(mt32emu_const_context context, const mt32emu_midi_delay_mode mode);
+/** Returns current MIDI delay mode. See mt32emu_midi_delay_mode for details. */
+MT32EMU_EXPORT mt32emu_midi_delay_mode mt32emu_get_midi_delay_mode(mt32emu_const_context context);
+
+/**
+ * Sets output gain factor for synth output channels. Applied to all output samples and unrelated with the synth's Master volume,
+ * it rather corresponds to the gain of the output analog circuitry of the hardware units. However, together with mt32emu_set_reverb_output_gain()
+ * it offers to the user a capability to control the gain of reverb and non-reverb output channels independently.
+ */
+MT32EMU_EXPORT void mt32emu_set_output_gain(mt32emu_const_context context, float gain);
+/** Returns current output gain factor for synth output channels. */
+MT32EMU_EXPORT float mt32emu_get_output_gain(mt32emu_const_context context);
+
+/**
+ * Sets output gain factor for the reverb wet output channels. It rather corresponds to the gain of the output
+ * analog circuitry of the hardware units. However, together with mt32emu_set_output_gain() it offers to the user a capability
+ * to control the gain of reverb and non-reverb output channels independently.
+ *
+ * Note: We're currently emulate CM-32L/CM-64 reverb quite accurately and the reverb output level closely
+ * corresponds to the level of digital capture. Although, according to the CM-64 PCB schematic,
+ * there is a difference in the reverb analogue circuit, and the resulting output gain is 0.68
+ * of that for LA32 analogue output. This factor is applied to the reverb output gain.
+ */
+MT32EMU_EXPORT void mt32emu_set_reverb_output_gain(mt32emu_const_context context, float gain);
+/** Returns current output gain factor for reverb wet output channels. */
+MT32EMU_EXPORT float mt32emu_get_reverb_output_gain(mt32emu_const_context context);
+
+/** Swaps left and right output channels. */
+MT32EMU_EXPORT void mt32emu_set_reversed_stereo_enabled(mt32emu_const_context context, const mt32emu_boolean enabled);
+/** Returns whether left and right output channels are swapped. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_is_reversed_stereo_enabled(mt32emu_const_context context);
+
+/**
+ * Allows to toggle the NiceAmpRamp mode.
+ * In this mode, we want to ensure that amp ramp never jumps to the target
+ * value and always gradually increases or decreases. It seems that real units
+ * do not bother to always check if a newly started ramp leads to a jump.
+ * We also prefer the quality improvement over the emulation accuracy,
+ * so this mode is enabled by default.
+ */
+MT32EMU_EXPORT void mt32emu_set_nice_amp_ramp_enabled(mt32emu_const_context context, const mt32emu_boolean enabled);
+/** Returns whether NiceAmpRamp mode is enabled. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_is_nice_amp_ramp_enabled(mt32emu_const_context context);
+
+/**
+ * Renders samples to the specified output stream as if they were sampled at the analog stereo output at the desired sample rate.
+ * If the output sample rate is not specified explicitly, the default output sample rate is used which depends on the current
+ * mode of analog circuitry emulation. See mt32emu_analog_output_mode.
+ * The length is in frames, not bytes (in 16-bit stereo, one frame is 4 bytes). Uses NATIVE byte ordering.
+ */
+MT32EMU_EXPORT void mt32emu_render_bit16s(mt32emu_const_context context, mt32emu_bit16s *stream, mt32emu_bit32u len);
+/** Same as above but outputs to a float stereo stream. */
+MT32EMU_EXPORT void mt32emu_render_float(mt32emu_const_context context, float *stream, mt32emu_bit32u len);
+
+/**
+ * Renders samples to the specified output streams as if they appeared at the DAC entrance.
+ * No further processing performed in analog circuitry emulation is applied to the signal.
+ * NULL may be specified in place of any or all of the stream buffers to skip it.
+ * The length is in samples, not bytes. Uses NATIVE byte ordering.
+ */
+MT32EMU_EXPORT void mt32emu_render_bit16s_streams(mt32emu_const_context context, const mt32emu_dac_output_bit16s_streams *streams, mt32emu_bit32u len);
+/** Same as above but outputs to float streams. */
+MT32EMU_EXPORT void mt32emu_render_float_streams(mt32emu_const_context context, const mt32emu_dac_output_float_streams *streams, mt32emu_bit32u len);
+
+/** Returns true when there is at least one active partial, otherwise false. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_has_active_partials(mt32emu_const_context context);
+
+/** Returns true if mt32emu_has_active_partials() returns true, or reverb is (somewhat unreliably) detected as being active. */
+MT32EMU_EXPORT mt32emu_boolean mt32emu_is_active(mt32emu_const_context context);
+
+/** Returns the maximum number of partials playing simultaneously. */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_get_partial_count(mt32emu_const_context context);
+
+/**
+ * Returns current states of all the parts as a bit set. The least significant bit corresponds to the state of part 1,
+ * total of 9 bits hold the states of all the parts. If the returned bit for a part is set, there is at least one active
+ * non-releasing partial playing on this part. This info is useful in emulating behaviour of LCD display of the hardware units.
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_get_part_states(mt32emu_const_context context);
+
+/**
+ * Fills in current states of all the partials into the array provided. Each byte in the array holds states of 4 partials
+ * starting from the least significant bits. The state of each partial is packed in a pair of bits.
+ * The array must be large enough to accommodate states of all the partials.
+ * @see getPartialCount()
+ */
+MT32EMU_EXPORT void mt32emu_get_partial_states(mt32emu_const_context context, mt32emu_bit8u *partial_states);
+
+/**
+ * Fills in information about currently playing notes on the specified part into the arrays provided. The arrays must be large enough
+ * to accommodate data for all the playing notes. The maximum number of simultaneously playing notes cannot exceed the number of partials.
+ * Argument partNumber should be 0..7 for Part 1..8, or 8 for Rhythm.
+ * Returns the number of currently playing notes on the specified part.
+ */
+MT32EMU_EXPORT mt32emu_bit32u mt32emu_get_playing_notes(mt32emu_const_context context, mt32emu_bit8u part_number, mt32emu_bit8u *keys, mt32emu_bit8u *velocities);
+
+/**
+ * Returns name of the patch set on the specified part.
+ * Argument partNumber should be 0..7 for Part 1..8, or 8 for Rhythm.
+ */
+MT32EMU_EXPORT const char *mt32emu_get_patch_name(mt32emu_const_context context, mt32emu_bit8u part_number);
+
+/** Stores internal state of emulated synth into an array provided (as it would be acquired from hardware). */
+MT32EMU_EXPORT void mt32emu_read_memory(mt32emu_const_context context, mt32emu_bit32u addr, mt32emu_bit32u len, mt32emu_bit8u *data);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif /* #ifndef MT32EMU_C_INTERFACE_H */
diff --git a/src/mt32/c_interface/c_types.h b/src/mt32/c_interface/c_types.h
new file mode 100644
index 00000000..dada610b
--- /dev/null
+++ b/src/mt32/c_interface/c_types.h
@@ -0,0 +1,336 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_C_TYPES_H
+#define MT32EMU_C_TYPES_H
+
+#include <stdarg.h>
+#include <stddef.h>
+
+#include "../globals.h"
+
+#define MT32EMU_C_ENUMERATIONS
+#include "../Enumerations.h"
+#undef MT32EMU_C_ENUMERATIONS
+
+typedef unsigned int       mt32emu_bit32u;
+typedef   signed int       mt32emu_bit32s;
+typedef unsigned short int mt32emu_bit16u;
+typedef   signed short int mt32emu_bit16s;
+typedef unsigned char      mt32emu_bit8u;
+typedef   signed char      mt32emu_bit8s;
+
+typedef char mt32emu_sha1_digest[41];
+
+typedef enum {
+	MT32EMU_BOOL_FALSE, MT32EMU_BOOL_TRUE
+} mt32emu_boolean;
+
+typedef enum {
+	/* Operation completed normally. */
+	MT32EMU_RC_OK = 0,
+	MT32EMU_RC_ADDED_CONTROL_ROM = 1,
+	MT32EMU_RC_ADDED_PCM_ROM = 2,
+
+	/* Definite error occurred. */
+	MT32EMU_RC_ROM_NOT_IDENTIFIED = -1,
+	MT32EMU_RC_FILE_NOT_FOUND = -2,
+	MT32EMU_RC_FILE_NOT_LOADED = -3,
+	MT32EMU_RC_MISSING_ROMS = -4,
+	MT32EMU_RC_NOT_OPENED = -5,
+	MT32EMU_RC_QUEUE_FULL = -6,
+
+	/* Undefined error occurred. */
+	MT32EMU_RC_FAILED = -100
+} mt32emu_return_code;
+
+/** Emulation context */
+typedef struct mt32emu_data *mt32emu_context;
+typedef const struct mt32emu_data *mt32emu_const_context;
+
+/* Convenience aliases */
+#ifndef __cplusplus
+typedef enum mt32emu_analog_output_mode mt32emu_analog_output_mode;
+typedef enum mt32emu_dac_input_mode mt32emu_dac_input_mode;
+typedef enum mt32emu_midi_delay_mode mt32emu_midi_delay_mode;
+typedef enum mt32emu_partial_state mt32emu_partial_state;
+typedef enum mt32emu_samplerate_conversion_quality mt32emu_samplerate_conversion_quality;
+typedef enum mt32emu_renderer_type mt32emu_renderer_type;
+#endif
+
+/** Contains identifiers and descriptions of ROM files being used. */
+typedef struct {
+	const char *control_rom_id;
+	const char *control_rom_description;
+	const char *control_rom_sha1_digest;
+	const char *pcm_rom_id;
+	const char *pcm_rom_description;
+	const char *pcm_rom_sha1_digest;
+} mt32emu_rom_info;
+
+/** Set of multiplexed output bit16s streams appeared at the DAC entrance. */
+typedef struct {
+	mt32emu_bit16s *nonReverbLeft;
+	mt32emu_bit16s *nonReverbRight;
+	mt32emu_bit16s *reverbDryLeft;
+	mt32emu_bit16s *reverbDryRight;
+	mt32emu_bit16s *reverbWetLeft;
+	mt32emu_bit16s *reverbWetRight;
+} mt32emu_dac_output_bit16s_streams;
+
+/** Set of multiplexed output float streams appeared at the DAC entrance. */
+typedef struct {
+	float *nonReverbLeft;
+	float *nonReverbRight;
+	float *reverbDryLeft;
+	float *reverbDryRight;
+	float *reverbWetLeft;
+	float *reverbWetRight;
+} mt32emu_dac_output_float_streams;
+
+/* === Interface handling === */
+
+/** Report handler interface versions */
+typedef enum {
+	MT32EMU_REPORT_HANDLER_VERSION_0 = 0,
+	MT32EMU_REPORT_HANDLER_VERSION_CURRENT = MT32EMU_REPORT_HANDLER_VERSION_0
+} mt32emu_report_handler_version;
+
+/** MIDI receiver interface versions */
+typedef enum {
+	MT32EMU_MIDI_RECEIVER_VERSION_0 = 0,
+	MT32EMU_MIDI_RECEIVER_VERSION_CURRENT = MT32EMU_MIDI_RECEIVER_VERSION_0
+} mt32emu_midi_receiver_version;
+
+/** Synth interface versions */
+typedef enum {
+	MT32EMU_SERVICE_VERSION_0 = 0,
+	MT32EMU_SERVICE_VERSION_1 = 1,
+	MT32EMU_SERVICE_VERSION_2 = 2,
+	MT32EMU_SERVICE_VERSION_CURRENT = MT32EMU_SERVICE_VERSION_2
+} mt32emu_service_version;
+
+/* === Report Handler Interface === */
+
+typedef union mt32emu_report_handler_i mt32emu_report_handler_i;
+
+/** Interface for handling reported events (initial version) */
+typedef struct {
+	/** Returns the actual interface version ID */
+	mt32emu_report_handler_version (*getVersionID)(mt32emu_report_handler_i i);
+
+	/** Callback for debug messages, in vprintf() format */
+	void (*printDebug)(void *instance_data, const char *fmt, va_list list);
+	/** Callbacks for reporting errors */
+	void (*onErrorControlROM)(void *instance_data);
+	void (*onErrorPCMROM)(void *instance_data);
+	/** Callback for reporting about displaying a new custom message on LCD */
+	void (*showLCDMessage)(void *instance_data, const char *message);
+	/** Callback for reporting actual processing of a MIDI message */
+	void (*onMIDIMessagePlayed)(void *instance_data);
+	/**
+	 * Callback for reporting an overflow of the input MIDI queue.
+	 * Returns MT32EMU_BOOL_TRUE if a recovery action was taken
+	 * and yet another attempt to enqueue the MIDI event is desired.
+	 */
+	mt32emu_boolean (*onMIDIQueueOverflow)(void *instance_data);
+	/**
+	 * Callback invoked when a System Realtime MIDI message is detected in functions
+	 * mt32emu_parse_stream and mt32emu_play_short_message and the likes.
+	 */
+	void (*onMIDISystemRealtime)(void *instance_data, mt32emu_bit8u system_realtime);
+	/** Callbacks for reporting system events */
+	void (*onDeviceReset)(void *instance_data);
+	void (*onDeviceReconfig)(void *instance_data);
+	/** Callbacks for reporting changes of reverb settings */
+	void (*onNewReverbMode)(void *instance_data, mt32emu_bit8u mode);
+	void (*onNewReverbTime)(void *instance_data, mt32emu_bit8u time);
+	void (*onNewReverbLevel)(void *instance_data, mt32emu_bit8u level);
+	/** Callbacks for reporting various information */
+	void (*onPolyStateChanged)(void *instance_data, mt32emu_bit8u part_num);
+	void (*onProgramChanged)(void *instance_data, mt32emu_bit8u part_num, const char *sound_group_name, const char *patch_name);
+} mt32emu_report_handler_i_v0;
+
+/**
+ * Extensible interface for handling reported events.
+ * Union intended to view an interface of any subsequent version as any parent interface not requiring a cast.
+ * It is caller's responsibility to check the actual interface version in runtime using the getVersionID() method.
+ */
+union mt32emu_report_handler_i {
+	const mt32emu_report_handler_i_v0 *v0;
+};
+
+/* === MIDI Receiver Interface === */
+
+typedef union mt32emu_midi_receiver_i mt32emu_midi_receiver_i;
+
+/** Interface for receiving MIDI messages generated by MIDI stream parser (initial version) */
+typedef struct {
+	/** Returns the actual interface version ID */
+	mt32emu_midi_receiver_version (*getVersionID)(mt32emu_midi_receiver_i i);
+
+	/** Invoked when a complete short MIDI message is parsed in the input MIDI stream. */
+	void (*handleShortMessage)(void *instance_data, const mt32emu_bit32u message);
+
+	/** Invoked when a complete well-formed System Exclusive MIDI message is parsed in the input MIDI stream. */
+	void (*handleSysex)(void *instance_data, const mt32emu_bit8u stream[], const mt32emu_bit32u length);
+
+	/** Invoked when a System Realtime MIDI message is parsed in the input MIDI stream. */
+	void (*handleSystemRealtimeMessage)(void *instance_data, const mt32emu_bit8u realtime);
+} mt32emu_midi_receiver_i_v0;
+
+/**
+ * Extensible interface for receiving MIDI messages.
+ * Union intended to view an interface of any subsequent version as any parent interface not requiring a cast.
+ * It is caller's responsibility to check the actual interface version in runtime using the getVersionID() method.
+ */
+union mt32emu_midi_receiver_i {
+	const mt32emu_midi_receiver_i_v0 *v0;
+};
+
+/* === Service Interface === */
+
+typedef union mt32emu_service_i mt32emu_service_i;
+
+/**
+ * Basic interface that defines all the library services (initial version).
+ * The members closely resemble C functions declared in c_interface.h, and the intention is to provide for easier
+ * access when the library is dynamically loaded in run-time, e.g. as a plugin. This way the client only needs
+ * to bind to mt32emu_get_service_i() function instead of binding to each function it needs to use.
+ * See c_interface.h for parameter description.
+ */
+#define MT32EMU_SERVICE_I_V0 \
+	/** Returns the actual interface version ID */ \
+	mt32emu_service_version (*getVersionID)(mt32emu_service_i i); \
+	mt32emu_report_handler_version (*getSupportedReportHandlerVersionID)(void); \
+	mt32emu_midi_receiver_version (*getSupportedMIDIReceiverVersionID)(void); \
+\
+	mt32emu_bit32u (*getLibraryVersionInt)(void); \
+	const char *(*getLibraryVersionString)(void); \
+\
+	mt32emu_bit32u (*getStereoOutputSamplerate)(const mt32emu_analog_output_mode analog_output_mode); \
+\
+	mt32emu_context (*createContext)(mt32emu_report_handler_i report_handler, void *instance_data); \
+	void (*freeContext)(mt32emu_context context); \
+	mt32emu_return_code (*addROMData)(mt32emu_context context, const mt32emu_bit8u *data, size_t data_size, const mt32emu_sha1_digest *sha1_digest); \
+	mt32emu_return_code (*addROMFile)(mt32emu_context context, const char *filename); \
+	void (*getROMInfo)(mt32emu_const_context context, mt32emu_rom_info *rom_info); \
+	void (*setPartialCount)(mt32emu_context context, const mt32emu_bit32u partial_count); \
+	void (*setAnalogOutputMode)(mt32emu_context context, const mt32emu_analog_output_mode analog_output_mode); \
+	mt32emu_return_code (*openSynth)(mt32emu_const_context context); \
+	void (*closeSynth)(mt32emu_const_context context); \
+	mt32emu_boolean (*isOpen)(mt32emu_const_context context); \
+	mt32emu_bit32u (*getActualStereoOutputSamplerate)(mt32emu_const_context context); \
+	void (*flushMIDIQueue)(mt32emu_const_context context); \
+	mt32emu_bit32u (*setMIDIEventQueueSize)(mt32emu_const_context context, const mt32emu_bit32u queue_size); \
+	void (*setMIDIReceiver)(mt32emu_context context, mt32emu_midi_receiver_i midi_receiver, void *instance_data); \
+\
+	void (*parseStream)(mt32emu_const_context context, const mt32emu_bit8u *stream, mt32emu_bit32u length); \
+	void (*parseStream_At)(mt32emu_const_context context, const mt32emu_bit8u *stream, mt32emu_bit32u length, mt32emu_bit32u timestamp); \
+	void (*playShortMessage)(mt32emu_const_context context, mt32emu_bit32u message); \
+	void (*playShortMessageAt)(mt32emu_const_context context, mt32emu_bit32u message, mt32emu_bit32u timestamp); \
+	mt32emu_return_code (*playMsg)(mt32emu_const_context context, mt32emu_bit32u msg); \
+	mt32emu_return_code (*playSysex)(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len); \
+	mt32emu_return_code (*playMsgAt)(mt32emu_const_context context, mt32emu_bit32u msg, mt32emu_bit32u timestamp); \
+	mt32emu_return_code (*playSysexAt)(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len, mt32emu_bit32u timestamp); \
+\
+	void (*playMsgNow)(mt32emu_const_context context, mt32emu_bit32u msg); \
+	void (*playMsgOnPart)(mt32emu_const_context context, mt32emu_bit8u part, mt32emu_bit8u code, mt32emu_bit8u note, mt32emu_bit8u velocity); \
+	void (*playSysexNow)(mt32emu_const_context context, const mt32emu_bit8u *sysex, mt32emu_bit32u len); \
+	void (*writeSysex)(mt32emu_const_context context, mt32emu_bit8u channel, const mt32emu_bit8u *sysex, mt32emu_bit32u len); \
+\
+	void (*setReverbEnabled)(mt32emu_const_context context, const mt32emu_boolean reverb_enabled); \
+	mt32emu_boolean (*isReverbEnabled)(mt32emu_const_context context); \
+	void (*setReverbOverridden)(mt32emu_const_context context, const mt32emu_boolean reverb_overridden); \
+	mt32emu_boolean (*isReverbOverridden)(mt32emu_const_context context); \
+	void (*setReverbCompatibilityMode)(mt32emu_const_context context, const mt32emu_boolean mt32_compatible_mode); \
+	mt32emu_boolean (*isMT32ReverbCompatibilityMode)(mt32emu_const_context context); \
+	mt32emu_boolean (*isDefaultReverbMT32Compatible)(mt32emu_const_context context); \
+\
+	void (*setDACInputMode)(mt32emu_const_context context, const mt32emu_dac_input_mode mode); \
+	mt32emu_dac_input_mode (*getDACInputMode)(mt32emu_const_context context); \
+\
+	void (*setMIDIDelayMode)(mt32emu_const_context context, const mt32emu_midi_delay_mode mode); \
+	mt32emu_midi_delay_mode (*getMIDIDelayMode)(mt32emu_const_context context); \
+\
+	void (*setOutputGain)(mt32emu_const_context context, float gain); \
+	float (*getOutputGain)(mt32emu_const_context context); \
+	void (*setReverbOutputGain)(mt32emu_const_context context, float gain); \
+	float (*getReverbOutputGain)(mt32emu_const_context context); \
+\
+	void (*setReversedStereoEnabled)(mt32emu_const_context context, const mt32emu_boolean enabled); \
+	mt32emu_boolean (*isReversedStereoEnabled)(mt32emu_const_context context); \
+\
+	void (*renderBit16s)(mt32emu_const_context context, mt32emu_bit16s *stream, mt32emu_bit32u len); \
+	void (*renderFloat)(mt32emu_const_context context, float *stream, mt32emu_bit32u len); \
+	void (*renderBit16sStreams)(mt32emu_const_context context, const mt32emu_dac_output_bit16s_streams *streams, mt32emu_bit32u len); \
+	void (*renderFloatStreams)(mt32emu_const_context context, const mt32emu_dac_output_float_streams *streams, mt32emu_bit32u len); \
+\
+	mt32emu_boolean (*hasActivePartials)(mt32emu_const_context context); \
+	mt32emu_boolean (*isActive)(mt32emu_const_context context); \
+	mt32emu_bit32u (*getPartialCount)(mt32emu_const_context context); \
+	mt32emu_bit32u (*getPartStates)(mt32emu_const_context context); \
+	void (*getPartialStates)(mt32emu_const_context context, mt32emu_bit8u *partial_states); \
+	mt32emu_bit32u (*getPlayingNotes)(mt32emu_const_context context, mt32emu_bit8u part_number, mt32emu_bit8u *keys, mt32emu_bit8u *velocities); \
+	const char *(*getPatchName)(mt32emu_const_context context, mt32emu_bit8u part_number); \
+	void (*readMemory)(mt32emu_const_context context, mt32emu_bit32u addr, mt32emu_bit32u len, mt32emu_bit8u *data);
+
+#define MT32EMU_SERVICE_I_V1 \
+	mt32emu_analog_output_mode (*getBestAnalogOutputMode)(const double target_samplerate); \
+	void (*setStereoOutputSampleRate)(mt32emu_context context, const double samplerate); \
+	void (*setSamplerateConversionQuality)(mt32emu_context context, const mt32emu_samplerate_conversion_quality quality); \
+	void (*selectRendererType)(mt32emu_context context, mt32emu_renderer_type renderer_type); \
+	mt32emu_renderer_type (*getSelectedRendererType)(mt32emu_context context); \
+	mt32emu_bit32u (*convertOutputToSynthTimestamp)(mt32emu_const_context context, mt32emu_bit32u output_timestamp); \
+	mt32emu_bit32u (*convertSynthToOutputTimestamp)(mt32emu_const_context context, mt32emu_bit32u synth_timestamp);
+
+#define MT32EMU_SERVICE_I_V2 \
+	mt32emu_bit32u (*getInternalRenderedSampleCount)(mt32emu_const_context context); \
+	void (*setNiceAmpRampEnabled)(mt32emu_const_context context, const mt32emu_boolean enabled); \
+	mt32emu_boolean (*isNiceAmpRampEnabled)(mt32emu_const_context context);
+
+typedef struct {
+	MT32EMU_SERVICE_I_V0
+} mt32emu_service_i_v0;
+
+typedef struct {
+	MT32EMU_SERVICE_I_V0
+	MT32EMU_SERVICE_I_V1
+} mt32emu_service_i_v1;
+
+typedef struct {
+	MT32EMU_SERVICE_I_V0
+	MT32EMU_SERVICE_I_V1
+	MT32EMU_SERVICE_I_V2
+} mt32emu_service_i_v2;
+
+/**
+ * Extensible interface for all the library services.
+ * Union intended to view an interface of any subsequent version as any parent interface not requiring a cast.
+ * It is caller's responsibility to check the actual interface version in runtime using the getVersionID() method.
+ */
+union mt32emu_service_i {
+	const mt32emu_service_i_v0 *v0;
+	const mt32emu_service_i_v1 *v1;
+	const mt32emu_service_i_v2 *v2;
+};
+
+#undef MT32EMU_SERVICE_I_V0
+#undef MT32EMU_SERVICE_I_V1
+#undef MT32EMU_SERVICE_I_V2
+
+#endif /* #ifndef MT32EMU_C_TYPES_H */
diff --git a/src/mt32/c_interface/cpp_interface.h b/src/mt32/c_interface/cpp_interface.h
new file mode 100644
index 00000000..3b02c032
--- /dev/null
+++ b/src/mt32/c_interface/cpp_interface.h
@@ -0,0 +1,479 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_CPP_INTERFACE_H
+#define MT32EMU_CPP_INTERFACE_H
+
+#include <cstdarg>
+
+#include "../globals.h"
+#include "c_types.h"
+
+#include "../Types.h"
+#include "../Enumerations.h"
+
+#if MT32EMU_API_TYPE == 2
+
+extern "C" {
+
+/** Returns mt32emu_service_i interface. */
+mt32emu_service_i mt32emu_get_service_i();
+
+}
+
+#define mt32emu_get_supported_report_handler_version i.v0->getSupportedReportHandlerVersionID
+#define mt32emu_get_supported_midi_receiver_version i.v0->getSupportedMIDIReceiverVersionID
+#define mt32emu_get_library_version_int i.v0->getLibraryVersionInt
+#define mt32emu_get_library_version_string i.v0->getLibraryVersionString
+#define mt32emu_get_stereo_output_samplerate i.v0->getStereoOutputSamplerate
+#define mt32emu_get_best_analog_output_mode iV1()->getBestAnalogOutputMode
+#define mt32emu_create_context i.v0->createContext
+#define mt32emu_free_context i.v0->freeContext
+#define mt32emu_add_rom_data i.v0->addROMData
+#define mt32emu_add_rom_file i.v0->addROMFile
+#define mt32emu_get_rom_info i.v0->getROMInfo
+#define mt32emu_set_partial_count i.v0->setPartialCount
+#define mt32emu_set_analog_output_mode i.v0->setAnalogOutputMode
+#define mt32emu_set_stereo_output_samplerate iV1()->setStereoOutputSampleRate
+#define mt32emu_set_samplerate_conversion_quality iV1()->setSamplerateConversionQuality
+#define mt32emu_select_renderer_type iV1()->selectRendererType
+#define mt32emu_get_selected_renderer_type iV1()->getSelectedRendererType
+#define mt32emu_open_synth i.v0->openSynth
+#define mt32emu_close_synth i.v0->closeSynth
+#define mt32emu_is_open i.v0->isOpen
+#define mt32emu_get_actual_stereo_output_samplerate i.v0->getActualStereoOutputSamplerate
+#define mt32emu_convert_output_to_synth_timestamp iV1()->convertOutputToSynthTimestamp
+#define mt32emu_convert_synth_to_output_timestamp iV1()->convertSynthToOutputTimestamp
+#define mt32emu_flush_midi_queue i.v0->flushMIDIQueue
+#define mt32emu_set_midi_event_queue_size i.v0->setMIDIEventQueueSize
+#define mt32emu_set_midi_receiver i.v0->setMIDIReceiver
+#define mt32emu_get_internal_rendered_sample_count iV2()->getInternalRenderedSampleCount
+#define mt32emu_parse_stream i.v0->parseStream
+#define mt32emu_parse_stream_at i.v0->parseStream_At
+#define mt32emu_play_short_message i.v0->playShortMessage
+#define mt32emu_play_short_message_at i.v0->playShortMessageAt
+#define mt32emu_play_msg i.v0->playMsg
+#define mt32emu_play_sysex i.v0->playSysex
+#define mt32emu_play_msg_at i.v0->playMsgAt
+#define mt32emu_play_sysex_at i.v0->playSysexAt
+#define mt32emu_play_msg_now i.v0->playMsgNow
+#define mt32emu_play_msg_on_part i.v0->playMsgOnPart
+#define mt32emu_play_sysex_now i.v0->playSysexNow
+#define mt32emu_write_sysex i.v0->writeSysex
+#define mt32emu_set_reverb_enabled i.v0->setReverbEnabled
+#define mt32emu_is_reverb_enabled i.v0->isReverbEnabled
+#define mt32emu_set_reverb_overridden i.v0->setReverbOverridden
+#define mt32emu_is_reverb_overridden i.v0->isReverbOverridden
+#define mt32emu_set_reverb_compatibility_mode i.v0->setReverbCompatibilityMode
+#define mt32emu_is_mt32_reverb_compatibility_mode i.v0->isMT32ReverbCompatibilityMode
+#define mt32emu_is_default_reverb_mt32_compatible i.v0->isDefaultReverbMT32Compatible
+#define mt32emu_set_dac_input_mode i.v0->setDACInputMode
+#define mt32emu_get_dac_input_mode i.v0->getDACInputMode
+#define mt32emu_set_midi_delay_mode i.v0->setMIDIDelayMode
+#define mt32emu_get_midi_delay_mode i.v0->getMIDIDelayMode
+#define mt32emu_set_output_gain i.v0->setOutputGain
+#define mt32emu_get_output_gain i.v0->getOutputGain
+#define mt32emu_set_reverb_output_gain i.v0->setReverbOutputGain
+#define mt32emu_get_reverb_output_gain i.v0->getReverbOutputGain
+#define mt32emu_set_reversed_stereo_enabled i.v0->setReversedStereoEnabled
+#define mt32emu_is_reversed_stereo_enabled i.v0->isReversedStereoEnabled
+#define mt32emu_set_nice_amp_ramp_enabled iV2()->setNiceAmpRampEnabled
+#define mt32emu_is_nice_amp_ramp_enabled iV2()->isNiceAmpRampEnabled
+#define mt32emu_render_bit16s i.v0->renderBit16s
+#define mt32emu_render_float i.v0->renderFloat
+#define mt32emu_render_bit16s_streams i.v0->renderBit16sStreams
+#define mt32emu_render_float_streams i.v0->renderFloatStreams
+#define mt32emu_has_active_partials i.v0->hasActivePartials
+#define mt32emu_is_active i.v0->isActive
+#define mt32emu_get_partial_count i.v0->getPartialCount
+#define mt32emu_get_part_states i.v0->getPartStates
+#define mt32emu_get_partial_states i.v0->getPartialStates
+#define mt32emu_get_playing_notes i.v0->getPlayingNotes
+#define mt32emu_get_patch_name i.v0->getPatchName
+#define mt32emu_read_memory i.v0->readMemory
+
+#else // #if MT32EMU_API_TYPE == 2
+
+#include "c_interface.h"
+
+#endif // #if MT32EMU_API_TYPE == 2
+
+namespace MT32Emu {
+
+namespace CppInterfaceImpl {
+
+static const mt32emu_report_handler_i NULL_REPORT_HANDLER = { NULL };
+static mt32emu_report_handler_i getReportHandlerThunk();
+static mt32emu_midi_receiver_i getMidiReceiverThunk();
+
+}
+
+/*
+ * The classes below correspond to the interfaces defined in c_types.h and provided for convenience when using C++.
+ * The approach used makes no assumption of any internal class data memory layout, since the C++ standard does not
+ * provide any detail in this area and leaves it up to the implementation. Therefore, this way portability is guaranteed,
+ * despite the implementation may be a little inefficient.
+ * See c_types.h and c_interface.h for description of the corresponding interface methods.
+ */
+
+// Defines the interface for handling reported events.
+// Corresponds to the current version of mt32emu_report_handler_i interface.
+class IReportHandler {
+public:
+	virtual void printDebug(const char *fmt, va_list list) = 0;
+	virtual void onErrorControlROM() = 0;
+	virtual void onErrorPCMROM() = 0;
+	virtual void showLCDMessage(const char *message) = 0;
+	virtual void onMIDIMessagePlayed() = 0;
+	virtual bool onMIDIQueueOverflow() = 0;
+	virtual void onMIDISystemRealtime(Bit8u system_realtime) = 0;
+	virtual void onDeviceReset() = 0;
+	virtual void onDeviceReconfig() = 0;
+	virtual void onNewReverbMode(Bit8u mode) = 0;
+	virtual void onNewReverbTime(Bit8u time) = 0;
+	virtual void onNewReverbLevel(Bit8u level) = 0;
+	virtual void onPolyStateChanged(Bit8u part_num) = 0;
+	virtual void onProgramChanged(Bit8u part_num, const char *sound_group_name, const char *patch_name) = 0;
+
+protected:
+	~IReportHandler() {}
+};
+
+// Defines the interface for receiving MIDI messages generated by MIDI stream parser.
+// Corresponds to the current version of mt32emu_midi_receiver_i interface.
+class IMidiReceiver {
+public:
+	virtual void handleShortMessage(const Bit32u message) = 0;
+	virtual void handleSysex(const Bit8u stream[], const Bit32u length) = 0;
+	virtual void handleSystemRealtimeMessage(const Bit8u realtime) = 0;
+
+protected:
+	~IMidiReceiver() {}
+};
+
+// Defines all the library services.
+// Corresponds to the current version of mt32emu_service_i interface.
+class Service {
+public:
+#if MT32EMU_API_TYPE == 2
+	explicit Service(mt32emu_service_i interface, mt32emu_context context = NULL) : i(interface), c(context) {}
+#else
+	explicit Service(mt32emu_context context = NULL) : c(context) {}
+#endif
+	~Service() { if (c != NULL) mt32emu_free_context(c); }
+
+	// Context-independent methods
+
+#if MT32EMU_API_TYPE == 2
+	mt32emu_service_version getVersionID() { return i.v0->getVersionID(i); }
+#endif
+	mt32emu_report_handler_version getSupportedReportHandlerVersionID() { return mt32emu_get_supported_report_handler_version(); }
+	mt32emu_midi_receiver_version getSupportedMIDIReceiverVersionID() { return mt32emu_get_supported_midi_receiver_version(); }
+
+	Bit32u getLibraryVersionInt() { return mt32emu_get_library_version_int(); }
+	const char *getLibraryVersionString() { return mt32emu_get_library_version_string(); }
+
+	Bit32u getStereoOutputSamplerate(const AnalogOutputMode analog_output_mode) { return mt32emu_get_stereo_output_samplerate(static_cast<mt32emu_analog_output_mode>(analog_output_mode)); }
+	AnalogOutputMode getBestAnalogOutputMode(const double target_samplerate) { return static_cast<AnalogOutputMode>(mt32emu_get_best_analog_output_mode(target_samplerate)); }
+
+	// Context-dependent methods
+
+	mt32emu_context getContext() { return c; }
+	void createContext(mt32emu_report_handler_i report_handler = CppInterfaceImpl::NULL_REPORT_HANDLER, void *instance_data = NULL) { freeContext(); c = mt32emu_create_context(report_handler, instance_data); }
+	void createContext(IReportHandler &report_handler) { createContext(CppInterfaceImpl::getReportHandlerThunk(), &report_handler); }
+	void freeContext() { if (c != NULL) { mt32emu_free_context(c); c = NULL; } }
+	mt32emu_return_code addROMData(const Bit8u *data, size_t data_size, const mt32emu_sha1_digest *sha1_digest = NULL) { return mt32emu_add_rom_data(c, data, data_size, sha1_digest); }
+	mt32emu_return_code addROMFile(const char *filename) { return mt32emu_add_rom_file(c, filename); }
+	void getROMInfo(mt32emu_rom_info *rom_info) { mt32emu_get_rom_info(c, rom_info); }
+	void setPartialCount(const Bit32u partial_count) { mt32emu_set_partial_count(c, partial_count); }
+	void setAnalogOutputMode(const AnalogOutputMode analog_output_mode) { mt32emu_set_analog_output_mode(c, static_cast<mt32emu_analog_output_mode>(analog_output_mode)); }
+	void setStereoOutputSampleRate(const double samplerate) { mt32emu_set_stereo_output_samplerate(c, samplerate); }
+	void setSamplerateConversionQuality(const SamplerateConversionQuality quality) { mt32emu_set_samplerate_conversion_quality(c, static_cast<mt32emu_samplerate_conversion_quality>(quality)); }
+	void selectRendererType(const RendererType newRendererType) { mt32emu_select_renderer_type(c, static_cast<mt32emu_renderer_type>(newRendererType)); }
+	RendererType getSelectedRendererType() { return static_cast<RendererType>(mt32emu_get_selected_renderer_type(c)); }
+	mt32emu_return_code openSynth() { return mt32emu_open_synth(c); }
+	void closeSynth() { mt32emu_close_synth(c); }
+	bool isOpen() { return mt32emu_is_open(c) != MT32EMU_BOOL_FALSE; }
+	Bit32u getActualStereoOutputSamplerate() { return mt32emu_get_actual_stereo_output_samplerate(c); }
+	Bit32u convertOutputToSynthTimestamp(Bit32u output_timestamp) { return mt32emu_convert_output_to_synth_timestamp(c, output_timestamp); }
+	Bit32u convertSynthToOutputTimestamp(Bit32u synth_timestamp) { return mt32emu_convert_synth_to_output_timestamp(c, synth_timestamp); }
+	void flushMIDIQueue() { mt32emu_flush_midi_queue(c); }
+	Bit32u setMIDIEventQueueSize(const Bit32u queue_size) { return mt32emu_set_midi_event_queue_size(c, queue_size); }
+	void setMIDIReceiver(mt32emu_midi_receiver_i midi_receiver, void *instance_data) { mt32emu_set_midi_receiver(c, midi_receiver, instance_data); }
+	void setMIDIReceiver(IMidiReceiver &midi_receiver) { setMIDIReceiver(CppInterfaceImpl::getMidiReceiverThunk(), &midi_receiver); }
+
+	Bit32u getInternalRenderedSampleCount() { return mt32emu_get_internal_rendered_sample_count(c); }
+	void parseStream(const Bit8u *stream, Bit32u length) { mt32emu_parse_stream(c, stream, length); }
+	void parseStream_At(const Bit8u *stream, Bit32u length, Bit32u timestamp) { mt32emu_parse_stream_at(c, stream, length, timestamp); }
+	void playShortMessage(Bit32u message) { mt32emu_play_short_message(c, message); }
+	void playShortMessageAt(Bit32u message, Bit32u timestamp) { mt32emu_play_short_message_at(c, message, timestamp); }
+	mt32emu_return_code playMsg(Bit32u msg) { return mt32emu_play_msg(c, msg); }
+	mt32emu_return_code playSysex(const Bit8u *sysex, Bit32u len) { return mt32emu_play_sysex(c, sysex, len); }
+	mt32emu_return_code playMsgAt(Bit32u msg, Bit32u timestamp) { return mt32emu_play_msg_at(c, msg, timestamp); }
+	mt32emu_return_code playSysexAt(const Bit8u *sysex, Bit32u len, Bit32u timestamp) { return mt32emu_play_sysex_at(c, sysex, len, timestamp); }
+
+	void playMsgNow(Bit32u msg) { mt32emu_play_msg_now(c, msg); }
+	void playMsgOnPart(Bit8u part, Bit8u code, Bit8u note, Bit8u velocity) { mt32emu_play_msg_on_part(c, part, code, note, velocity); }
+	void playSysexNow(const Bit8u *sysex, Bit32u len) { mt32emu_play_sysex_now(c, sysex, len); }
+	void writeSysex(Bit8u channel, const Bit8u *sysex, Bit32u len) { mt32emu_write_sysex(c, channel, sysex, len); }
+
+	void setReverbEnabled(const bool reverb_enabled) { mt32emu_set_reverb_enabled(c, reverb_enabled ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE); }
+	bool isReverbEnabled() { return mt32emu_is_reverb_enabled(c) != MT32EMU_BOOL_FALSE; }
+	void setReverbOverridden(const bool reverb_overridden) { mt32emu_set_reverb_overridden(c, reverb_overridden ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE); }
+	bool isReverbOverridden() { return mt32emu_is_reverb_overridden(c) != MT32EMU_BOOL_FALSE; }
+	void setReverbCompatibilityMode(const bool mt32_compatible_mode) { mt32emu_set_reverb_compatibility_mode(c, mt32_compatible_mode ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE); }
+	bool isMT32ReverbCompatibilityMode() { return mt32emu_is_mt32_reverb_compatibility_mode(c) != MT32EMU_BOOL_FALSE; }
+	bool isDefaultReverbMT32Compatible() { return mt32emu_is_default_reverb_mt32_compatible(c) != MT32EMU_BOOL_FALSE; }
+
+	void setDACInputMode(const DACInputMode mode) { mt32emu_set_dac_input_mode(c, static_cast<mt32emu_dac_input_mode>(mode)); }
+	DACInputMode getDACInputMode() { return static_cast<DACInputMode>(mt32emu_get_dac_input_mode(c)); }
+
+	void setMIDIDelayMode(const MIDIDelayMode mode) { mt32emu_set_midi_delay_mode(c, static_cast<mt32emu_midi_delay_mode>(mode)); }
+	MIDIDelayMode getMIDIDelayMode() { return static_cast<MIDIDelayMode>(mt32emu_get_midi_delay_mode(c)); }
+
+	void setOutputGain(float gain) { mt32emu_set_output_gain(c, gain); }
+	float getOutputGain() { return mt32emu_get_output_gain(c); }
+	void setReverbOutputGain(float gain) { mt32emu_set_reverb_output_gain(c, gain); }
+	float getReverbOutputGain() { return mt32emu_get_reverb_output_gain(c); }
+
+	void setReversedStereoEnabled(const bool enabled) { mt32emu_set_reversed_stereo_enabled(c, enabled ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE); }
+	bool isReversedStereoEnabled() { return mt32emu_is_reversed_stereo_enabled(c) != MT32EMU_BOOL_FALSE; }
+
+	void setNiceAmpRampEnabled(const bool enabled) { mt32emu_set_nice_amp_ramp_enabled(c, enabled ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE); }
+	bool isNiceAmpRampEnabled() { return mt32emu_is_nice_amp_ramp_enabled(c) != MT32EMU_BOOL_FALSE; }
+
+	void renderBit16s(Bit16s *stream, Bit32u len) { mt32emu_render_bit16s(c, stream, len); }
+	void renderFloat(float *stream, Bit32u len) { mt32emu_render_float(c, stream, len); }
+	void renderBit16sStreams(const mt32emu_dac_output_bit16s_streams *streams, Bit32u len) { mt32emu_render_bit16s_streams(c, streams, len); }
+	void renderFloatStreams(const mt32emu_dac_output_float_streams *streams, Bit32u len) { mt32emu_render_float_streams(c, streams, len); }
+
+	bool hasActivePartials() { return mt32emu_has_active_partials(c) != MT32EMU_BOOL_FALSE; }
+	bool isActive() { return mt32emu_is_active(c) != MT32EMU_BOOL_FALSE; }
+	Bit32u getPartialCount() { return mt32emu_get_partial_count(c); }
+	Bit32u getPartStates() { return mt32emu_get_part_states(c); }
+	void getPartialStates(Bit8u *partial_states) { mt32emu_get_partial_states(c, partial_states); }
+	Bit32u getPlayingNotes(Bit8u part_number, Bit8u *keys, Bit8u *velocities) { return mt32emu_get_playing_notes(c, part_number, keys, velocities); }
+	const char *getPatchName(Bit8u part_number) { return mt32emu_get_patch_name(c, part_number); }
+	void readMemory(Bit32u addr, Bit32u len, Bit8u *data) { mt32emu_read_memory(c, addr, len, data); }
+
+private:
+#if MT32EMU_API_TYPE == 2
+	const mt32emu_service_i i;
+#endif
+	mt32emu_context c;
+
+#if MT32EMU_API_TYPE == 2
+	const mt32emu_service_i_v1 *iV1() { return (getVersionID() < MT32EMU_SERVICE_VERSION_1) ? NULL : i.v1; }
+	const mt32emu_service_i_v2 *iV2() { return (getVersionID() < MT32EMU_SERVICE_VERSION_2) ? NULL : i.v2; }
+#endif
+};
+
+namespace CppInterfaceImpl {
+
+static mt32emu_report_handler_version getReportHandlerVersionID(mt32emu_report_handler_i) {
+	return MT32EMU_REPORT_HANDLER_VERSION_CURRENT;
+}
+
+static void printDebug(void *instance_data, const char *fmt, va_list list) {
+	static_cast<IReportHandler *>(instance_data)->printDebug(fmt, list);
+}
+
+static void onErrorControlROM(void *instance_data) {
+	static_cast<IReportHandler *>(instance_data)->onErrorControlROM();
+}
+
+static void onErrorPCMROM(void *instance_data) {
+	static_cast<IReportHandler *>(instance_data)->onErrorPCMROM();
+}
+
+static void showLCDMessage(void *instance_data, const char *message) {
+	static_cast<IReportHandler *>(instance_data)->showLCDMessage(message);
+}
+
+static void onMIDIMessagePlayed(void *instance_data) {
+	static_cast<IReportHandler *>(instance_data)->onMIDIMessagePlayed();
+}
+
+static mt32emu_boolean onMIDIQueueOverflow(void *instance_data) {
+	return static_cast<IReportHandler *>(instance_data)->onMIDIQueueOverflow() ? MT32EMU_BOOL_TRUE : MT32EMU_BOOL_FALSE;
+}
+
+static void onMIDISystemRealtime(void *instance_data, mt32emu_bit8u system_realtime) {
+	static_cast<IReportHandler *>(instance_data)->onMIDISystemRealtime(system_realtime);
+}
+
+static void onDeviceReset(void *instance_data) {
+	static_cast<IReportHandler *>(instance_data)->onDeviceReset();
+}
+
+static void onDeviceReconfig(void *instance_data) {
+	static_cast<IReportHandler *>(instance_data)->onDeviceReconfig();
+}
+
+static void onNewReverbMode(void *instance_data, mt32emu_bit8u mode) {
+	static_cast<IReportHandler *>(instance_data)->onNewReverbMode(mode);
+}
+
+static void onNewReverbTime(void *instance_data, mt32emu_bit8u time) {
+	static_cast<IReportHandler *>(instance_data)->onNewReverbTime(time);
+}
+
+static void onNewReverbLevel(void *instance_data, mt32emu_bit8u level) {
+	static_cast<IReportHandler *>(instance_data)->onNewReverbLevel(level);
+}
+
+static void onPolyStateChanged(void *instance_data, mt32emu_bit8u part_num) {
+	static_cast<IReportHandler *>(instance_data)->onPolyStateChanged(part_num);
+}
+
+static void onProgramChanged(void *instance_data, mt32emu_bit8u part_num, const char *sound_group_name, const char *patch_name) {
+	static_cast<IReportHandler *>(instance_data)->onProgramChanged(part_num, sound_group_name, patch_name);
+}
+
+static mt32emu_report_handler_i getReportHandlerThunk() {
+	static const mt32emu_report_handler_i_v0 REPORT_HANDLER_V0_THUNK = {
+		getReportHandlerVersionID,
+		printDebug,
+		onErrorControlROM,
+		onErrorPCMROM,
+		showLCDMessage,
+		onMIDIMessagePlayed,
+		onMIDIQueueOverflow,
+		onMIDISystemRealtime,
+		onDeviceReset,
+		onDeviceReconfig,
+		onNewReverbMode,
+		onNewReverbTime,
+		onNewReverbLevel,
+		onPolyStateChanged,
+		onProgramChanged
+	};
+
+	static const mt32emu_report_handler_i REPORT_HANDLER_THUNK = { &REPORT_HANDLER_V0_THUNK };
+
+	return REPORT_HANDLER_THUNK;
+}
+
+static mt32emu_midi_receiver_version getMidiReceiverVersionID(mt32emu_midi_receiver_i) {
+	return MT32EMU_MIDI_RECEIVER_VERSION_CURRENT;
+}
+
+static void handleShortMessage(void *instance_data, const mt32emu_bit32u message) {
+	static_cast<IMidiReceiver *>(instance_data)->handleShortMessage(message);
+}
+
+static void handleSysex(void *instance_data, const mt32emu_bit8u stream[], const mt32emu_bit32u length) {
+	static_cast<IMidiReceiver *>(instance_data)->handleSysex(stream, length);
+}
+
+static void handleSystemRealtimeMessage(void *instance_data, const mt32emu_bit8u realtime) {
+	static_cast<IMidiReceiver *>(instance_data)->handleSystemRealtimeMessage(realtime);
+}
+
+static mt32emu_midi_receiver_i getMidiReceiverThunk() {
+	static const mt32emu_midi_receiver_i_v0 MIDI_RECEIVER_V0_THUNK = {
+		getMidiReceiverVersionID,
+		handleShortMessage,
+		handleSysex,
+		handleSystemRealtimeMessage
+	};
+
+	static const mt32emu_midi_receiver_i MIDI_RECEIVER_THUNK = { &MIDI_RECEIVER_V0_THUNK };
+
+	return MIDI_RECEIVER_THUNK;
+}
+
+} // namespace CppInterfaceImpl
+
+} // namespace MT32Emu
+
+#if MT32EMU_API_TYPE == 2
+
+#undef mt32emu_get_supported_report_handler_version
+#undef mt32emu_get_supported_midi_receiver_version
+#undef mt32emu_get_library_version_int
+#undef mt32emu_get_library_version_string
+#undef mt32emu_get_stereo_output_samplerate
+#undef mt32emu_get_best_analog_output_mode
+#undef mt32emu_create_context
+#undef mt32emu_free_context
+#undef mt32emu_add_rom_data
+#undef mt32emu_add_rom_file
+#undef mt32emu_get_rom_info
+#undef mt32emu_set_partial_count
+#undef mt32emu_set_analog_output_mode
+#undef mt32emu_set_stereo_output_samplerate
+#undef mt32emu_set_samplerate_conversion_quality
+#undef mt32emu_select_renderer_type
+#undef mt32emu_get_selected_renderer_type
+#undef mt32emu_open_synth
+#undef mt32emu_close_synth
+#undef mt32emu_is_open
+#undef mt32emu_get_actual_stereo_output_samplerate
+#undef mt32emu_convert_output_to_synth_timestamp
+#undef mt32emu_convert_synth_to_output_timestamp
+#undef mt32emu_flush_midi_queue
+#undef mt32emu_set_midi_event_queue_size
+#undef mt32emu_set_midi_receiver
+#undef mt32emu_get_internal_rendered_sample_count
+#undef mt32emu_parse_stream
+#undef mt32emu_parse_stream_at
+#undef mt32emu_play_short_message
+#undef mt32emu_play_short_message_at
+#undef mt32emu_play_msg
+#undef mt32emu_play_sysex
+#undef mt32emu_play_msg_at
+#undef mt32emu_play_sysex_at
+#undef mt32emu_play_msg_now
+#undef mt32emu_play_msg_on_part
+#undef mt32emu_play_sysex_now
+#undef mt32emu_write_sysex
+#undef mt32emu_set_reverb_enabled
+#undef mt32emu_is_reverb_enabled
+#undef mt32emu_set_reverb_overridden
+#undef mt32emu_is_reverb_overridden
+#undef mt32emu_set_reverb_compatibility_mode
+#undef mt32emu_is_mt32_reverb_compatibility_mode
+#undef mt32emu_is_default_reverb_mt32_compatible
+#undef mt32emu_set_dac_input_mode
+#undef mt32emu_get_dac_input_mode
+#undef mt32emu_set_midi_delay_mode
+#undef mt32emu_get_midi_delay_mode
+#undef mt32emu_set_output_gain
+#undef mt32emu_get_output_gain
+#undef mt32emu_set_reverb_output_gain
+#undef mt32emu_get_reverb_output_gain
+#undef mt32emu_set_reversed_stereo_enabled
+#undef mt32emu_is_reversed_stereo_enabled
+#undef mt32emu_set_nice_amp_ramp_enabled
+#undef mt32emu_is_nice_amp_ramp_enabled
+#undef mt32emu_render_bit16s
+#undef mt32emu_render_float
+#undef mt32emu_render_bit16s_streams
+#undef mt32emu_render_float_streams
+#undef mt32emu_has_active_partials
+#undef mt32emu_is_active
+#undef mt32emu_get_partial_count
+#undef mt32emu_get_part_states
+#undef mt32emu_get_partial_states
+#undef mt32emu_get_playing_notes
+#undef mt32emu_get_patch_name
+#undef mt32emu_read_memory
+
+#endif // #if MT32EMU_API_TYPE == 2
+
+#endif /* #ifndef MT32EMU_CPP_INTERFACE_H */
diff --git a/src/mt32/globals.h b/src/mt32/globals.h
new file mode 100644
index 00000000..2d984c82
--- /dev/null
+++ b/src/mt32/globals.h
@@ -0,0 +1,119 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_GLOBALS_H
+#define MT32EMU_GLOBALS_H
+
+#include "config.h"
+
+/* Support for compiling shared library. */
+#ifdef MT32EMU_SHARED
+#if defined _WIN32 || defined __CYGWIN__
+#ifdef _MSC_VER
+#ifdef mt32emu_EXPORTS
+#define MT32EMU_EXPORT_ATTRIBUTE _declspec(dllexport)
+#else /* #ifdef mt32emu_EXPORTS */
+#define MT32EMU_EXPORT_ATTRIBUTE _declspec(dllimport)
+#endif /* #ifdef mt32emu_EXPORTS */
+#else /* #ifdef _MSC_VER */
+#ifdef mt32emu_EXPORTS
+#define MT32EMU_EXPORT_ATTRIBUTE __attribute__ ((dllexport))
+#else /* #ifdef mt32emu_EXPORTS */
+#define MT32EMU_EXPORT_ATTRIBUTE __attribute__ ((dllimport))
+#endif /* #ifdef mt32emu_EXPORTS */
+#endif /* #ifdef _MSC_VER */
+#else /* #if defined _WIN32 || defined __CYGWIN__ */
+#define MT32EMU_EXPORT_ATTRIBUTE __attribute__ ((visibility("default")))
+#endif /* #if defined _WIN32 || defined __CYGWIN__ */
+#else /* #ifdef MT32EMU_SHARED */
+#define MT32EMU_EXPORT_ATTRIBUTE
+#endif /* #ifdef MT32EMU_SHARED */
+
+#if MT32EMU_EXPORTS_TYPE == 1 || MT32EMU_EXPORTS_TYPE == 2
+#define MT32EMU_EXPORT
+#else
+#define MT32EMU_EXPORT MT32EMU_EXPORT_ATTRIBUTE
+#endif
+
+/* Useful constants */
+
+/* Sample rate to use in mixing. With the progress of development, we've found way too many thing dependent.
+ * In order to achieve further advance in emulation accuracy, sample rate made fixed throughout the emulator,
+ * except the emulation of analogue path.
+ * The output from the synth is supposed to be resampled externally in order to convert to the desired sample rate.
+ */
+#define MT32EMU_SAMPLE_RATE 32000
+
+/* The default value for the maximum number of partials playing simultaneously. */
+#define MT32EMU_DEFAULT_MAX_PARTIALS 32
+
+/* The higher this number, the more memory will be used, but the more samples can be processed in one run -
+ * various parts of sample generation can be processed more efficiently in a single run.
+ * A run's maximum length is that given to Synth::render(), so giving a value here higher than render() is ever
+ * called with will give no gain (but simply waste the memory).
+ * Note that this value does *not* in any way impose limitations on the length given to render(), and has no effect
+ * on the generated audio.
+ * This value must be >= 1.
+ */
+#define MT32EMU_MAX_SAMPLES_PER_RUN 4096
+
+/* The default size of the internal MIDI event queue.
+ * It holds the incoming MIDI events before the rendering engine actually processes them.
+ * The main goal is to fairly emulate the real hardware behaviour which obviously
+ * uses an internal MIDI event queue to gather incoming data as well as the delays
+ * introduced by transferring data via the MIDI interface.
+ * This also facilitates building of an external rendering loop
+ * as the queue stores timestamped MIDI events.
+ */
+#define MT32EMU_DEFAULT_MIDI_EVENT_QUEUE_SIZE 1024
+
+/* Maximum allowed size of MIDI parser input stream buffer.
+ * Should suffice for any reasonable bulk dump SysEx, as the h/w units have only 32K of RAM onboard.
+ */
+#define MT32EMU_MAX_STREAM_BUFFER_SIZE 32768
+
+/* This should correspond to the MIDI buffer size used in real h/w devices.
+ * CM-32L control ROM is using 1000 bytes, and MT-32 GEN0 is using only 240 bytes (semi-confirmed by now).
+ */
+#define MT32EMU_SYSEX_BUFFER_SIZE 1000
+
+#if defined(__cplusplus) && MT32EMU_API_TYPE != 1
+
+namespace MT32Emu
+{
+const unsigned int SAMPLE_RATE = MT32EMU_SAMPLE_RATE;
+#undef MT32EMU_SAMPLE_RATE
+
+const unsigned int DEFAULT_MAX_PARTIALS = MT32EMU_DEFAULT_MAX_PARTIALS;
+#undef MT32EMU_DEFAULT_MAX_PARTIALS
+
+const unsigned int MAX_SAMPLES_PER_RUN = MT32EMU_MAX_SAMPLES_PER_RUN;
+#undef MT32EMU_MAX_SAMPLES_PER_RUN
+
+const unsigned int DEFAULT_MIDI_EVENT_QUEUE_SIZE = MT32EMU_DEFAULT_MIDI_EVENT_QUEUE_SIZE;
+#undef MT32EMU_DEFAULT_MIDI_EVENT_QUEUE_SIZE
+
+const unsigned int MAX_STREAM_BUFFER_SIZE = MT32EMU_MAX_STREAM_BUFFER_SIZE;
+#undef MT32EMU_MAX_STREAM_BUFFER_SIZE
+
+const unsigned int SYSEX_BUFFER_SIZE = MT32EMU_SYSEX_BUFFER_SIZE;
+#undef MT32EMU_SYSEX_BUFFER_SIZE
+}
+
+#endif /* #if defined(__cplusplus) && MT32EMU_API_TYPE != 1 */
+
+#endif /* #ifndef MT32EMU_GLOBALS_H */
diff --git a/src/mt32/internals.h b/src/mt32/internals.h
new file mode 100644
index 00000000..0bae8d9f
--- /dev/null
+++ b/src/mt32/internals.h
@@ -0,0 +1,118 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_INTERNALS_H
+#define MT32EMU_INTERNALS_H
+
+#include "Types.h"
+
+// Debugging
+
+// 0: Standard debug output is not stamped with the rendered sample count
+// 1: Standard debug output is stamped with the rendered sample count
+// NOTE: The "samplestamp" corresponds to the end of the last completed rendering run.
+//       This is important to bear in mind for debug output that occurs during a run.
+#ifndef MT32EMU_DEBUG_SAMPLESTAMPS
+#define MT32EMU_DEBUG_SAMPLESTAMPS 0
+#endif
+
+// 0: No debug output for initialisation progress
+// 1: Debug output for initialisation progress
+#ifndef MT32EMU_MONITOR_INIT
+#define MT32EMU_MONITOR_INIT 0
+#endif
+
+// 0: No debug output for MIDI events
+// 1: Debug output for weird MIDI events
+#ifndef MT32EMU_MONITOR_MIDI
+#define MT32EMU_MONITOR_MIDI 0
+#endif
+
+// 0: No debug output for note on/off
+// 1: Basic debug output for note on/off
+// 2: Comprehensive debug output for note on/off
+#ifndef MT32EMU_MONITOR_INSTRUMENTS
+#define MT32EMU_MONITOR_INSTRUMENTS 0
+#endif
+
+// 0: No debug output for partial allocations
+// 1: Show partial stats when an allocation fails
+// 2: Show partial stats with every new poly
+// 3: Show individual partial allocations/deactivations
+#ifndef MT32EMU_MONITOR_PARTIALS
+#define MT32EMU_MONITOR_PARTIALS 0
+#endif
+
+// 0: No debug output for sysex
+// 1: Basic debug output for sysex
+#ifndef MT32EMU_MONITOR_SYSEX
+#define MT32EMU_MONITOR_SYSEX 0
+#endif
+
+// 0: No debug output for sysex writes to the timbre areas
+// 1: Debug output with the name and location of newly-written timbres
+// 2: Complete dump of timbre parameters for newly-written timbres
+#ifndef MT32EMU_MONITOR_TIMBRES
+#define MT32EMU_MONITOR_TIMBRES 0
+#endif
+
+// 0: No TVA/TVF-related debug output.
+// 1: Shows changes to TVA/TVF target, increment and phase.
+#ifndef MT32EMU_MONITOR_TVA
+#define MT32EMU_MONITOR_TVA 0
+#endif
+#ifndef MT32EMU_MONITOR_TVF
+#define MT32EMU_MONITOR_TVF 0
+#endif
+
+// Configuration
+
+// If non-zero, deletes reverb buffers that are not in use to save memory.
+// If zero, keeps reverb buffers for all modes around all the time to avoid allocating/freeing in the critical path.
+#ifndef MT32EMU_REDUCE_REVERB_MEMORY
+#define MT32EMU_REDUCE_REVERB_MEMORY 1
+#endif
+
+// 0: Maximum speed at the cost of a bit lower emulation accuracy.
+// 1: Maximum achievable emulation accuracy.
+#ifndef MT32EMU_BOSS_REVERB_PRECISE_MODE
+#define MT32EMU_BOSS_REVERB_PRECISE_MODE 0
+#endif
+
+namespace MT32Emu {
+
+typedef Bit16s IntSample;
+typedef Bit32s IntSampleEx;
+typedef float FloatSample;
+
+enum PolyState {
+	POLY_Playing,
+	POLY_Held, // This marks keys that have been released on the keyboard, but are being held by the pedal
+	POLY_Releasing,
+	POLY_Inactive
+};
+
+enum ReverbMode {
+	REVERB_MODE_ROOM,
+	REVERB_MODE_HALL,
+	REVERB_MODE_PLATE,
+	REVERB_MODE_TAP_DELAY
+};
+
+} // namespace MT32Emu
+
+#endif // #ifndef MT32EMU_INTERNALS_H
diff --git a/src/mt32/mmath.h b/src/mt32/mmath.h
index 4b02314a..9a9e642b 100644
--- a/src/mt32/mmath.h
+++ b/src/mt32/mmath.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,720 +18,7 @@
 #ifndef MT32EMU_MMATH_H
 #define MT32EMU_MMATH_H
 
-#define FIXEDPOINT_UDIV(x, y, point) (((x) << (point)) / ((y)))
-#define FIXEDPOINT_SDIV(x, y, point) (((x) * (1 << point)) / ((y)))
-#define FIXEDPOINT_UMULT(x, y, point) (((x) * (y)) >> point)
-#define FIXEDPOINT_SMULT(x, y, point) (((x) * (y)) / (1 << point))
-
-#define FIXEDPOINT_MAKE(x, point) ((Bit32u)((1 << point) * x))
-
-// added by ykhwong (start)
-#pragma once
-/**
-	@brief fast math library for float
-	@author herumi
-	@url http://homepage1.nifty.com/herumi/
-	@note modified new BSD license
-	http://opensource.org/licenses/BSD-3-Clause
-
-	cl /Ox /Ob2 /arch:SSE2 /fp:fast bench.cpp -I../xbyak /EHsc /DNOMINMAX
-	g++ -O3 -fomit-frame-pointer -fno-operator-names -march=core2 -mssse3 -mfpmath=sse -ffast-math -fexcess-precision=fast
-*/
-/*
-	function prototype list
-
-	float fmath::exp(float);
-	float fmath::log(float);
-
-	__m128 fmath::exp_ps(__m128);
-	__m128 fmath::log_ps(__m128);
-
-	if FMATH_USE_XBYAK is defined then Xbyak version are used
-*/
-//#define FMATH_USE_XBYAK
-
-#include <math.h>
-#include <stddef.h>
-#include <assert.h>
-#include <limits>
-#include <stdlib.h>
-#include <float.h>
-#if defined(_WIN32) && !defined(__GNUC__)
-	#include <intrin.h>
-	#ifndef MIE_ALIGN
-		#define MIE_ALIGN(x) __declspec(align(x))
-	#endif
-#else
-	#ifndef __GNUC_PREREQ
-	#define __GNUC_PREREQ(major, minor) ((((__GNUC__) << 16) + (__GNUC_MINOR__)) >= (((major) << 16) + (minor)))
-	#endif
-	#if __GNUC_PREREQ(4, 4) || !defined(__GNUC__)
-		/* GCC >= 4.4 and non-GCC compilers */
-		#include <x86intrin.h>
-	#elif __GNUC_PREREQ(4, 1)
-		/* GCC 4.1, 4.2, and 4.3 do not have x86intrin.h, directly include SSE2 header */
-		#include <emmintrin.h>
-	#endif
-	#ifndef MIE_ALIGN
-		#define MIE_ALIGN(x) __attribute__((aligned(x)))
-	#endif
-#endif
-#ifndef MIE_PACK
-	#define MIE_PACK(x, y, z, w) ((x) * 64 + (y) * 16 + (z) * 4 + (w))
-#endif
-#ifdef FMATH_USE_XBYAK
-	#include "xbyak/xbyak.h"
-	#include "xbyak/xbyak_util.h"
-#endif
-
-#if 1//#ifdef DEBUG
-inline void put(const void *p)
-{
-	const float *f = (const float*)p;
-	printf("{%e, %e, %e, %e}\n", f[0], f[1], f[2], f[3]);
-}
-inline void puti(const void *p)
-{
-	const unsigned int *i = (const unsigned int *)p;
-	printf("{%d, %d, %d, %d}\n", i[0], i[1], i[2], i[3]);
-	printf("{%x, %x, %x, %x}\n", i[0], i[1], i[2], i[3]);
-}
-#endif
-
-namespace fmath {
-
-namespace local {
-
-const size_t EXP_TABLE_SIZE = 10;
-const size_t EXPD_TABLE_SIZE = 11;
-const size_t LOG_TABLE_SIZE = 12;
-
-typedef unsigned long long uint64_t;
-
-union fi {
-	float f;
-	unsigned int i;
-};
-
-union di {
-	double d;
-	uint64_t i;
-};
-
-inline unsigned int mask(int x)
-{
-	return (1U << x) - 1;
-}
-
-inline uint64_t mask64(int x)
-{
-	return (1ULL << x) - 1;
-}
-
-template<class T>
-inline const T* cast_to(const void *p)
-{
-	return reinterpret_cast<const T*>(p);
-}
-
-template<class T, size_t N>
-size_t NumOfArray(const T (&)[N]) { return N; }
-
-/*
-	exp(88.722839f) = inf ; 0x42b17218
-	exp(-87.33655f) = 1.175491e-038f(007fffe6) denormal ; 0xc2aeac50
-	exp(-103.972081f) = 0 ; 0xc2cff1b5
-*/
-template<size_t N = EXP_TABLE_SIZE>
-struct ExpVar {
-	enum {
-		s = N,
-		n = 1 << s,
-		f88 = 0x42b00000 /* 88.0 */
-	};
-	float minX[4];
-	float maxX[4];
-	float a[4];
-	float b[4];
-	float f1[4];
-	unsigned int i127s[4];
-	unsigned int mask_s[4];
-	unsigned int i7fffffff[4];
-	unsigned int tbl[n];
-	ExpVar()
-	{
-		float log_2 = ::logf(2.0f);
-		for (int i = 0; i < 4; i++) {
-			maxX[i] = 88;
-			minX[i] = -88;
-			a[i] = n / log_2;
-			b[i] = log_2 / n;
-			f1[i] = 1.0f;
-			i127s[i] = 127 << s;
-			i7fffffff[i] = 0x7fffffff;
-			mask_s[i] = mask(s);
-		}
-
-		for (int i = 0; i < n; i++) {
-			float y = pow(2.0f, (float)i / n);
-			fi fi;
-			fi.f = y;
-			tbl[i] = fi.i & mask(23);
-		}
-	}
-};
-
-template<size_t sbit_ = EXPD_TABLE_SIZE>
-struct ExpdVar {
-	enum {
-		sbit = sbit_,
-		s = 1UL << sbit,
-		adj = (1UL << (sbit + 10)) - (1UL << sbit)
-	};
-	// A = 1, B = 1, C = 1/2, D = 1/6
-	double C1[2]; // A
-	double C2[2]; // D
-	double C3[2]; // C/D
-	uint64_t tbl[s];
-	const double a;
-	const double ra;
-	ExpdVar()
-		: a(s / ::log(2.0))
-		, ra(1 / a)
-	{
-		for (int i = 0; i < 2; i++) {
-#if 0
-			C1[i] = 1.0;
-			C2[i] = 0.16667794882310216;
-			C3[i] = 2.9997969303278795;
-#else
-			C1[i] = 1.0;
-			C2[i] = 0.16666666685227835064;
-			C3[i] = 3.0000000027955394;
-#endif
-		}
-		for (int i = 0; i < s; i++) {
-			di di;
-			di.d = ::pow(2.0, i * (1.0 / s));
-			tbl[i] = di.i & mask64(52);
-		}
-	}
-};
-
-template<size_t N = LOG_TABLE_SIZE>
-struct LogVar {
-	enum {
-		LEN = N - 1
-	};
-	unsigned int m1[4]; // 0
-	unsigned int m2[4]; // 16
-	unsigned int m3[4]; // 32
-	float m4[4];		// 48
-	unsigned int m5[4]; // 64
-	struct {
-		float app;
-		float rev;
-	} tbl[1 << LEN];
-	float c_log2;
-	LogVar()
-		: c_log2(::logf(2.0f) / (1 << 23))
-	{
-		const double e = 1 / double(1 << 24);
-		const double h = 1 / double(1 << LEN);
-		const size_t n = 1U << LEN;
-		for (size_t i = 0; i < n; i++) {
-			double x = 1 + double(i) / n;
-			double a = ::log(x);
-			tbl[i].app = (float)a;
-			if (i < n - 1) {
-				double b = ::log(x + h - e);
-				tbl[i].rev = (float)((b - a) / ((h - e) * (1 << 23)));
-			} else {
-				tbl[i].rev = (float)(1 / (x * (1 << 23)));
-			}
-		}
-		for (int i = 0; i < 4; i++) {
-			m1[i] = mask(8) << 23;
-			m2[i] = mask(LEN) << (23 - LEN);
-			m3[i] = mask(23 - LEN);
-			m4[i] = c_log2;
-			m5[i] = 127U << 23;
-		}
-	}
-};
-
-#ifdef FMATH_USE_XBYAK
-struct ExpCode : public Xbyak::CodeGenerator {
-	float (*exp_)(float);
-	__m128 (*exp_ps_)(__m128);
-	template<size_t N>
-	ExpCode(const ExpVar<N> *self)
-	{
-		Xbyak::util::Cpu cpu;
-		try {
-			makeExp(self, cpu);
-			exp_ = (float(*)(float))getCode();
-			align(16);
-			exp_ps_ = (__m128(*)(__m128))getCurr();
-			makeExpPs(self, cpu);
-			return;
-		} catch (Xbyak::Error err) {
-			LOG_MSG( "ExpCode ERR:%s(%d)\n", Xbyak::ConvertErrorToString(err), err);
-		} catch (...) {
-			LOG_MSG( "ExpCode ERR:unknown error\n");
-		}
-		::exit(1);
-	}
-	template<size_t N>
-	void makeExp(const ExpVar<N> *self, const Xbyak::util::Cpu& /*cpu*/)
-	{
-		typedef ExpVar<N> Self;
-		using namespace local;
-		using namespace Xbyak;
-
-		inLocalLabel();
-#ifdef XBYAK64
-		const Reg64& base = rcx;
-		const Reg64& a = rax;
-#else
-		const Reg32& base = ecx;
-		const Reg32& a = eax;
-#endif
-
-		mov(base, (size_t)self);
-
-#ifdef XBYAK32
-		movss(xm0, ptr [esp + 4]);
-#endif
-	L(".retry");
-		movaps(xm1, xm0);
-		movd(edx, xm0);
-		mulss(xm1, ptr [base + offsetof(Self, a)]); // t
-		and(edx, 0x7fffffff);
-		cvtss2si(eax, xm1);
-		cmp(edx, ExpVar<N>::f88);
-		jg(".overflow");
-		lea(edx, ptr [eax + (127 << self->s)]);
-		cvtsi2ss(xm1, eax);
-		and(eax, mask(self->s)); // v
-		mov(eax, ptr [base + a * 4 + offsetof(Self, tbl)]); // expVar.tbl[v]
-		shr(edx, self->s);
-		mulss(xm1, ptr [base + offsetof(Self, b)]);
-		shl(edx, 23); // u
-		subss(xm0, xm1); // t
-		or(eax, edx); // fi.f
-		addss(xm0, ptr [base + offsetof(Self, f1)]);
-		movd(xm1, eax);
-		mulss(xm0, xm1);
-#ifdef XBYAK32
-		movss(ptr[esp + 4], xm0);
-		fld(dword[esp + 4]);
-#endif
-		ret();
-	L(".overflow");
-		minss(xm0, ptr [base + offsetof(Self, maxX)]);
-		maxss(xm0, ptr [base + offsetof(Self, minX)]);
-		jmp(".retry");
-		outLocalLabel();
-	}
-	template<size_t N>
-	void makeExpPs(const ExpVar<N> *self, const Xbyak::util::Cpu& cpu)
-	{
-		typedef ExpVar<N> Self;
-		using namespace local;
-		using namespace Xbyak;
-
-		inLocalLabel();
-#ifdef XBYAK64
-		const Reg64& base = rcx;
-		const Reg64& a = rax;
-		const Reg64& d = rdx;
-#else
-		const Reg32& base = ecx;
-		const Reg32& a = eax;
-		const Reg32& d = edx;
-#endif
-
-/*
-	if abs(x) >= maxX then x = max(min(x, maxX), -maxX) and try
-	minps, maxps are very slow then avoid them
-*/
-		const bool useSSE41 = cpu.has(Xbyak::util::Cpu::tSSE41);
-#if defined(XBYAK64_WIN) && !defined(__INTEL_COMPILER)
-		movaps(xm0, ptr [rcx]);
-#endif
-		mov(base, (size_t)self);
-	L(".retry");
-		movaps(xm5, xm0);
-		andps(xm5, ptr [base + offsetof(Self, i7fffffff)]);
-		movaps(xm3, ptr [base + offsetof(Self, a)]);
-		movaps(xm4, ptr [base + offsetof(Self, b)]);
-		pcmpgtd(xm5, ptr [base + offsetof(Self, maxX)]);
-		mulps(xm3, xm0);
-		movaps(xm1, ptr [base + offsetof(Self, i127s)]);
-		pmovmskb(eax, xm5);
-		movaps(xm5, ptr [base + offsetof(Self, mask_s)]);
-		cvtps2dq(xm2, xm3);
-		pand(xm5, xm2);
-		cvtdq2ps(xm3, xm2);
-		test(eax, eax);
-		jnz(".overflow");
-		paddd(xm1, xm2);
-		movd(eax, xm5);
-		mulps(xm4, xm3);
-		pextrw(edx, xm5, 2);
-		subps(xm0, xm4);
-		movd(xm4, ptr [base + a * 4 + offsetof(Self, tbl)]);
-		addps(xm0, ptr [base + offsetof(Self, f1)]);
-		pextrw(eax, xm5, 4);
-		if (useSSE41) {
-			pinsrd(xm4, ptr [base + d * 4 + offsetof(Self, tbl)], 1);
-		} else {
-			movd(xm3, ptr [base + d * 4 + offsetof(Self, tbl)]);
-			movlhps(xm4, xm3);
-		}
-		pextrw(edx, xm5, 6);
-		psrld(xm1, self->s);
-		pslld(xm1, 23);
-		if (useSSE41) {
-			pinsrd(xm4, ptr [base + a * 4 + offsetof(Self, tbl)], 2);
-			pinsrd(xm4, ptr [base + d * 4 + offsetof(Self, tbl)], 3);
-		} else {
-			movd(xm2, ptr [base + a * 4 + offsetof(Self, tbl)]);
-			movd(xm3, ptr [base + d * 4 + offsetof(Self, tbl)]);
-			movlhps(xm2, xm3);
-			shufps(xm4, xm2, MIE_PACK(2, 0, 2, 0));
-		}
-		por(xm1, xm4);
-		mulps(xm0, xm1);
-		ret();
-	L(".overflow");
-		minps(xm0, ptr [base + offsetof(Self, maxX)]);
-		maxps(xm0, ptr [base + offsetof(Self, minX)]);
-		jmp(".retry");
-		outLocalLabel();
-	}
-};
-#endif
-
-/* to define static variables in fmath.hpp */
-template<size_t EXP_N = EXP_TABLE_SIZE, size_t LOG_N = LOG_TABLE_SIZE, size_t EXPD_N = EXPD_TABLE_SIZE>
-struct C {
-	static const ExpVar<EXP_N> expVar;
-	static const LogVar<LOG_N> logVar;
-	static const ExpdVar<EXPD_N> expdVar;
-#ifdef FMATH_USE_XBYAK
-	static const ExpCode& getInstance() {
-		static const ExpCode expCode(&expVar);
-		return expCode;
-	}
-#endif
-};
-
-template<size_t EXP_N, size_t LOG_N, size_t EXPD_N>
-MIE_ALIGN(16) const ExpVar<EXP_N> C<EXP_N, LOG_N, EXPD_N>::expVar;
-
-template<size_t EXP_N, size_t LOG_N, size_t EXPD_N>
-MIE_ALIGN(16) const LogVar<LOG_N> C<EXP_N, LOG_N, EXPD_N>::logVar;
-
-template<size_t EXP_N, size_t LOG_N, size_t EXPD_N>
-MIE_ALIGN(16) const ExpdVar<EXPD_N> C<EXP_N, LOG_N, EXPD_N>::expdVar;
-
-} // fmath::local
-
-#ifdef FMATH_USE_XBYAK
-inline float expC(float x)
-#else
-inline float exp(float x)
-#endif
-{
-	using namespace local;
-	const ExpVar<>& expVar = C<>::expVar;
-
-#if 1
-	__m128 x1 = _mm_set_ss(x);
-
-	int limit = _mm_cvtss_si32(x1) & 0x7fffffff;
-	if (limit > ExpVar<>::f88) {
-		x1 = _mm_min_ss(x1, _mm_load_ss(expVar.maxX));
-		x1 = _mm_max_ss(x1, _mm_load_ss(expVar.minX));
-	}
-
-	int r = _mm_cvtss_si32(_mm_mul_ss(x1, _mm_load_ss(expVar.a)));
-	unsigned int v = r & mask(expVar.s);
-	float t = _mm_cvtss_f32(x1) - r * expVar.b[0];
-	int u = r >> expVar.s;
-	fi fi;
-	fi.i = ((u + 127) << 23) | expVar.tbl[v];
-	return (1 + t) * fi.f;
-#else
-	x = std::min(x, expVar.maxX[0]);
-	x = std::max(x, expVar.minX[0]);
-	float t = x * expVar.a[0];
-	const float magic = (1 << 23) + (1 << 22); // to round
-	t += magic;
-	fi fi;
-	fi.f = t;
-	t = x - (t - magic) * expVar.b[0];
-	int u = ((fi.i + (127 << expVar.s)) >> expVar.s) << 23;
-	unsigned int v = fi.i & mask(expVar.s);
-	fi.i = u | expVar.tbl[v];
-	return (1 + t) * fi.f;
-//	return (1 + t) * pow(2, (float)u) * pow(2, (float)v / n);
-#endif
-}
-
-/*
-	remark : -ffast-math option of gcc may generate bad code for fmath::expd
-*/
-inline double expd(double x)
-{
-	if (x <= -708.39641853226408) return 0;
-	if (x >= 709.78271289338397) return std::numeric_limits<double>::infinity();
-	using namespace local;
-	const ExpdVar<>& c = C<>::expdVar;
-	const uint64_t b = 3ULL << 51;
-	di di;
-	di.d = x * c.a + b;
-	uint64_t iax = c.tbl[di.i & mask(c.sbit)];
-
-	double t = (di.d - b) * c.ra - x;
-	uint64_t u = ((di.i + c.adj) >> c.sbit) << 52;
-	double y = (c.C3[0] - t) * (t * t) * c.C2[0] - t + c.C1[0];
-//	double y = (2.999796930327879362111743 - t) * (t * t) * 0.166677948823102161853172 - t + 1.000000000000000000488181;
-
-	di.i = u | iax;
-	return y * di.d;
-}
-
-inline void expd_v(double *px, int n)
-{
-	using namespace local;
-	const ExpdVar<>& c = C<>::expdVar;
-	const uint64_t b = 3ULL << 51;
-	assert((n % 2) == 0);
-	const __m128d mC1 = *cast_to<__m128d>(c.C1);
-	const __m128d mC2 = *cast_to<__m128d>(c.C2);
-	const __m128d mC3 = *cast_to<__m128d>(c.C3);
-	const __m128d ma = _mm_set1_pd(c.a);
-	const __m128d mra = _mm_set1_pd(c.ra);
-	const __m128i madj = _mm_set1_epi32(c.adj);
-	MIE_ALIGN(16) const double expMax[2] = { 709.78271289338397, 709.78271289338397 };
-	MIE_ALIGN(16) const double expMin[2] = { -708.39641853226408, -708.39641853226408 };
-	for (unsigned int i = 0; i < (unsigned int)n; i += 2) {
-		__m128d x = _mm_load_pd(px);
-		x = _mm_min_pd(x, *(const __m128d*)expMax);
-		x = _mm_max_pd(x, *(const __m128d*)expMin);
-
-		__m128d d = _mm_mul_pd(x, ma);
-		d = _mm_add_pd(d, _mm_set1_pd(b));
-		int adr0 = _mm_cvtsi128_si32(_mm_castpd_si128(d)) & mask(c.sbit);
-		int adr1 = _mm_cvtsi128_si32(_mm_srli_si128(_mm_castpd_si128(d), 8)) & mask(c.sbit);
-
-		__m128i iaxL = _mm_castpd_si128(_mm_load_sd((const double*)&c.tbl[adr0]));
-		__m128i iax = _mm_castpd_si128(_mm_load_sd((const double*)&c.tbl[adr1]));
-		iax = _mm_unpacklo_epi64(iaxL, iax);
-
-		__m128d t = _mm_sub_pd(_mm_mul_pd(_mm_sub_pd(d, _mm_set1_pd(b)), mra), x);
-		__m128i u = _mm_castpd_si128(d);
-		u = _mm_add_epi64(u, madj);
-		u = _mm_srli_epi64(u, c.sbit);
-		u = _mm_slli_epi64(u, 52);
-		u = _mm_or_si128(u, iax);
-		__m128d y = _mm_mul_pd(_mm_sub_pd(mC3, t), _mm_mul_pd(t, t));
-		y = _mm_mul_pd(y, mC2);
-		y = _mm_add_pd(_mm_sub_pd(y, t), mC1);
-		_mm_store_pd(px, _mm_mul_pd(y, _mm_castsi128_pd(u)));
-		px += 2;
-	}
-}
-
-#ifdef FMATH_USE_XBYAK
-inline __m128 exp_psC(__m128 x)
-#else
-inline __m128 exp_ps(__m128 x)
-#endif
-{
-	using namespace local;
-	const ExpVar<>& expVar = C<>::expVar;
-
-	__m128i limit = _mm_castps_si128(_mm_and_ps(x, *cast_to<__m128>(expVar.i7fffffff)));
-	int over = _mm_movemask_epi8(_mm_cmpgt_epi32(limit, *cast_to<__m128i>(expVar.maxX)));
-	if (over) {
-		x = _mm_min_ps(x, _mm_load_ps(expVar.maxX));
-		x = _mm_max_ps(x, _mm_load_ps(expVar.minX));
-	}
-
-	__m128i r = _mm_cvtps_epi32(_mm_mul_ps(x, *cast_to<__m128>(expVar.a)));
-	__m128 t = _mm_sub_ps(x, _mm_mul_ps(_mm_cvtepi32_ps(r), *cast_to<__m128>(expVar.b)));
-	t = _mm_add_ps(t, *cast_to<__m128>(expVar.f1));
-
-	__m128i v4 = _mm_and_si128(r, *cast_to<__m128i>(expVar.mask_s));
-	__m128i u4 = _mm_add_epi32(r, *cast_to<__m128i>(expVar.i127s));
-	u4 = _mm_srli_epi32(u4, expVar.s);
-	u4 = _mm_slli_epi32(u4, 23);
-
-	unsigned int v0, v1, v2, v3;
-	v0 = _mm_cvtsi128_si32(v4);
-	v1 = _mm_extract_epi16(v4, 2);
-	v2 = _mm_extract_epi16(v4, 4);
-	v3 = _mm_extract_epi16(v4, 6);
-#if 1
-	__m128 t0, t1, t2, t3;
-
-#if 0
-	t0 = _mm_castsi128_ps(_mm_set1_epi32(expVar.tbl[v0]));
-	t1 = _mm_castsi128_ps(_mm_set1_epi32(expVar.tbl[v1]));
-	t2 = _mm_castsi128_ps(_mm_set1_epi32(expVar.tbl[v2]));
-	t3 = _mm_castsi128_ps(_mm_set1_epi32(expVar.tbl[v3]));
-#else // faster but gcc puts warnings
-	t0 = _mm_set_ss(*(const float*)&expVar.tbl[v0]);
-	t1 = _mm_set_ss(*(const float*)&expVar.tbl[v1]);
-	t2 = _mm_set_ss(*(const float*)&expVar.tbl[v2]);
-	t3 = _mm_set_ss(*(const float*)&expVar.tbl[v3]);
-#endif
-
-	t1 = _mm_movelh_ps(t1, t3);
-	t1 = _mm_castsi128_ps(_mm_slli_epi64(_mm_castps_si128(t1), 32));
-	t0 = _mm_movelh_ps(t0, t2);
-	t0 = _mm_or_ps(t0, t1);
-#else
-	__m128i ti = _mm_castps_si128(_mm_load_ss((const float*)&expVar.tbl[v0]));
-	ti = _mm_insert_epi32(ti, expVar.tbl[v1], 1);
-	ti = _mm_insert_epi32(ti, expVar.tbl[v2], 2);
-	ti = _mm_insert_epi32(ti, expVar.tbl[v3], 3);
-	__m128 t0 = _mm_castsi128_ps(ti);
-#endif
-	t0 = _mm_or_ps(t0, _mm_castsi128_ps(u4));
-
-	t = _mm_mul_ps(t, t0);
-
-	return t;
-}
-
-inline float log(float x)
-{
-	using namespace local;
-	const LogVar<>& logVar = C<>::logVar;
-	const size_t logLen = logVar.LEN;
-
-	fi fi;
-	fi.f = x;
-	int a = fi.i & (mask(8) << 23);
-	unsigned int b1 = fi.i & (mask(logLen) << (23 - logLen));
-	unsigned int b2 = fi.i & mask(23 - logLen);
-	int idx = b1 >> (23 - logLen);
-	float f = float(a - (127 << 23)) * logVar.c_log2 + logVar.tbl[idx].app + float(b2) * logVar.tbl[idx].rev;
-	return f;
-}
-
-inline __m128 log_ps(__m128 x)
-{
-	using namespace local;
-	const LogVar<>& logVar = C<>::logVar;
-
-	__m128i xi = _mm_castps_si128(x);
-	__m128i idx = _mm_srli_epi32(_mm_and_si128(xi, *cast_to<__m128i>(logVar.m2)), (23 - logVar.LEN));
-	__m128 a  = _mm_cvtepi32_ps(_mm_sub_epi32(_mm_and_si128(xi, *cast_to<__m128i>(logVar.m1)), *cast_to<__m128i>(logVar.m5)));
-	__m128 b2 = _mm_cvtepi32_ps(_mm_and_si128(xi, *cast_to<__m128i>(logVar.m3)));
-
-	a = _mm_mul_ps(a, *cast_to<__m128>(logVar.m4)); // c_log2
-
-	unsigned int i0 = _mm_cvtsi128_si32(idx);
-
-#if 1
-	unsigned int i1 = _mm_extract_epi16(idx, 2);
-	unsigned int i2 = _mm_extract_epi16(idx, 4);
-	unsigned int i3 = _mm_extract_epi16(idx, 6);
-#else
-	idx = _mm_srli_si128(idx, 4);
-	unsigned int i1 = _mm_cvtsi128_si32(idx);
-
-	idx = _mm_srli_si128(idx, 4);
-	unsigned int i2 = _mm_cvtsi128_si32(idx);
-
-	idx = _mm_srli_si128(idx, 4);
-	unsigned int i3 = _mm_cvtsi128_si32(idx);
-#endif
-
-	__m128 app, rev;
-	__m128i L = _mm_loadl_epi64(cast_to<__m128i>(&logVar.tbl[i0].app));
-	__m128i H = _mm_loadl_epi64(cast_to<__m128i>(&logVar.tbl[i1].app));
-	__m128 t = _mm_castsi128_ps(_mm_unpacklo_epi64(L, H));
-	L = _mm_loadl_epi64(cast_to<__m128i>(&logVar.tbl[i2].app));
-	H = _mm_loadl_epi64(cast_to<__m128i>(&logVar.tbl[i3].app));
-	rev = _mm_castsi128_ps(_mm_unpacklo_epi64(L, H));
-	app = _mm_shuffle_ps(t, rev, MIE_PACK(2, 0, 2, 0));
-	rev = _mm_shuffle_ps(t, rev, MIE_PACK(3, 1, 3, 1));
-
-	a = _mm_add_ps(a, app);
-	rev = _mm_mul_ps(b2, rev);
-	return _mm_add_ps(a, rev);
-}
-
-#ifndef __CYGWIN__
-// cygwin defines log2() in global namespace!
-// log2(x) = log(x) / log(2)
-inline float log2(float x) { return fmath::log(x) * 1.442695f; }
-#endif
-
-/*
-	for given y > 0
-	get f_y(x) := pow(x, y) for x >= 0
-*/
-class PowGenerator {
-	enum {
-		N = 11
-	};
-	float tbl0_[256];
-	struct {
-		float app;
-		float rev;
-	} tbl1_[1 << N];
-public:
-	PowGenerator(float y)
-	{
-		for (int i = 0; i < 256; i++) {
-			tbl0_[i] = ::powf(2, (i - 127) * y);
-		}
-		const double e = 1 / double(1 << 24);
-		const double h = 1 / double(1 << N);
-		const size_t n = 1U << N;
-		for (size_t i = 0; i < n; i++) {
-			double x = 1 + double(i) / n;
-			double a = ::pow(x, (double)y);
-			tbl1_[i].app = (float)a;
-			double b = ::pow(x + h - e, (double)y);
-			tbl1_[i].rev = (float)((b - a) / (h - e) / (1 << 23));
-		}
-	}
-	float get(float x) const
-	{
-		using namespace local;
-		fi fi;
-		fi.f = x;
-		int a = (fi.i >> 23) & mask(8);
-		unsigned int b = fi.i & mask(23);
-		unsigned int b1 = b & (mask(N) << (23 - N));
-		unsigned int b2 = b & mask(23 - N);
-		float f;
-		int idx = b1 >> (23 - N);
-		f = tbl0_[a] * (tbl1_[idx].app + float(b2) * tbl1_[idx].rev);
-		return f;
-	}
-};
-
-// for Xbyak version
-#ifdef FMATH_USE_XBYAK
-float (*const exp)(float) = local::C<>::getInstance().exp_;
-__m128 (*const exp_ps)(__m128) = local::C<>::getInstance().exp_ps_;
-#endif
-
-// exp2(x) = pow(2, x)
-inline float exp2(float x) { return fmath::exp(x * 0.6931472f); }
-
-} // fmath
-// added by ykhwong (end)
+#include <cmath>
 
 namespace MT32Emu {
 
@@ -744,11 +31,11 @@ const float FLOAT_LN_2 = 0.6931472f;
 const float FLOAT_LN_10 = 2.3025851f;
 
 static inline float POWF(float x, float y) {
-	fmath::PowGenerator f(y); return f.get(x);
+	return pow(x, y);
 }
 
 static inline float EXPF(float x) {
-	return fmath::exp(x);
+	return exp(x);
 }
 
 static inline float EXP2F(float x) {
@@ -756,26 +43,26 @@ static inline float EXP2F(float x) {
 	// on OSX exp2f() is 1.59 times faster than "exp() and the multiplication with FLOAT_LN_2"
 	return exp2f(x);
 #else
-	return fmath::exp2(x);
+	return exp(FLOAT_LN_2 * x);
 #endif
 }
 
 static inline float EXP10F(float x) {
-	return fmath::exp(FLOAT_LN_10 * x);
+	return exp(FLOAT_LN_10 * x);
 }
 
 static inline float LOGF(float x) {
-	return fmath::log(x);
+	return log(x);
 }
 
 static inline float LOG2F(float x) {
-	return fmath::log(x) / FLOAT_LN_2;
+	return log(x) / FLOAT_LN_2;
 }
 
 static inline float LOG10F(float x) {
 	return log10(x);
 }
 
-}
+} // namespace MT32Emu
 
-#endif
+#endif // #ifndef MT32EMU_MMATH_H
diff --git a/src/mt32/mt32emu.h b/src/mt32/mt32emu.h
index e399de4f..6b93121b 100644
--- a/src/mt32/mt32emu.h
+++ b/src/mt32/mt32emu.h
@@ -1,5 +1,5 @@
 /* Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009 Dean Beeler, Jerome Fisher
- * Copyright (C) 2011, 2012, 2013 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
+ * Copyright (C) 2011-2017 Dean Beeler, Jerome Fisher, Sergey V. Mikayev
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU Lesser General Public License as published by
@@ -18,99 +18,67 @@
 #ifndef MT32EMU_MT32EMU_H
 #define MT32EMU_MT32EMU_H
 
-// Debugging
-
-// 0: Standard debug output is not stamped with the rendered sample count
-// 1: Standard debug output is stamped with the rendered sample count
-// NOTE: The "samplestamp" corresponds to the end of the last completed rendering run.
-//       This is important to bear in mind for debug output that occurs during a run.
-#define MT32EMU_DEBUG_SAMPLESTAMPS 0
-
-// 0: No debug output for initialisation progress
-// 1: Debug output for initialisation progress
-#define MT32EMU_MONITOR_INIT 0
-
-// 0: No debug output for MIDI events
-// 1: Debug output for weird MIDI events
-#define MT32EMU_MONITOR_MIDI 0
-
-// 0: No debug output for note on/off
-// 1: Basic debug output for note on/off
-// 2: Comprehensive debug output for note on/off
-#define MT32EMU_MONITOR_INSTRUMENTS 0
-
-// 0: No debug output for partial allocations
-// 1: Show partial stats when an allocation fails
-// 2: Show partial stats with every new poly
-// 3: Show individual partial allocations/deactivations
-#define MT32EMU_MONITOR_PARTIALS 0
-
-// 0: No debug output for sysex
-// 1: Basic debug output for sysex
-#define MT32EMU_MONITOR_SYSEX 0
+#include "config.h"
+
+/* API Configuration */
+
+/* 0: Use full-featured C++ API. Well suitable when the library is to be linked statically.
+ *    When the library is shared, ABI compatibility may be an issue. Therefore, it should
+ *    only be used within a project comprising of several modules to share the library code.
+ * 1: Use C-compatible API. Make the library looks as a regular C library with well-defined ABI.
+ *    This is also crucial when the library is to be linked with modules in a different
+ *    language, either statically or dynamically.
+ * 2: Use plugin-like API via C-interface wrapped in a C++ class. This is mainly intended
+ *    for a shared library being dynamically loaded in run-time. To get access to all the library
+ *    services, a client application only needs to bind with a single factory function.
+ * 3: Use optimised C++ API compatible with the plugin API (type 2). The facade class also wraps
+ *    the C functions but they are invoked directly. This enables the compiler to generate better
+ *    code for the library when linked statically yet being consistent with the plugin-like API.
+ */
 
-// 0: No debug output for sysex writes to the timbre areas
-// 1: Debug output with the name and location of newly-written timbres
-// 2: Complete dump of timbre parameters for newly-written timbres
-#define MT32EMU_MONITOR_TIMBRES 0
+#ifdef MT32EMU_API_TYPE
+#if MT32EMU_API_TYPE == 0 && (MT32EMU_EXPORTS_TYPE == 1 || MT32EMU_EXPORTS_TYPE == 2)
+#error Incompatible setting MT32EMU_API_TYPE=0
+#elif MT32EMU_API_TYPE == 1 && (MT32EMU_EXPORTS_TYPE == 0 || MT32EMU_EXPORTS_TYPE == 2)
+#error Incompatible setting MT32EMU_API_TYPE=1
+#elif MT32EMU_API_TYPE == 2 && (MT32EMU_EXPORTS_TYPE == 0)
+#error Incompatible setting MT32EMU_API_TYPE=2
+#elif MT32EMU_API_TYPE == 3 && (MT32EMU_EXPORTS_TYPE == 0 || MT32EMU_EXPORTS_TYPE == 2)
+#error Incompatible setting MT32EMU_API_TYPE=3
+#endif
+#else /* #ifdef MT32EMU_API_TYPE */
+#if 0 < MT32EMU_EXPORTS_TYPE && MT32EMU_EXPORTS_TYPE < 3
+#define MT32EMU_API_TYPE MT32EMU_EXPORTS_TYPE
+#else
+#define MT32EMU_API_TYPE 0
+#endif
+#endif /* #ifdef MT32EMU_API_TYPE */
 
-// 0: No TVA/TVF-related debug output.
-// 1: Shows changes to TVA/TVF target, increment and phase.
-#define MT32EMU_MONITOR_TVA 0
-#define MT32EMU_MONITOR_TVF 0
+/* MT32EMU_SHARED should be defined when building shared library, especially for Windows platforms. */
+/*
+#define MT32EMU_SHARED
+*/
 
-// Configuration
-// The maximum number of partials playing simultaneously
-#define MT32EMU_MAX_PARTIALS 256
-// The maximum number of notes playing simultaneously per part.
-// No point making it more than MT32EMU_MAX_PARTIALS, since each note needs at least one partial.
-#define MT32EMU_MAX_POLY 256
+#include "globals.h"
 
-// If non-zero, deletes reverb buffers that are not in use to save memory.
-// If zero, keeps reverb buffers for all modes around all the time to avoid allocating/freeing in the critical path.
-#define MT32EMU_REDUCE_REVERB_MEMORY 1
+#if !defined(__cplusplus) || MT32EMU_API_TYPE == 1
 
-// 0: Use legacy Freeverb
-// 1: Use Accurate Reverb model aka AReverb
-// 2: Use Bit-perfect Boss Reverb model aka BReverb (for developers, not much practical use)
-#define MT32EMU_USE_REVERBMODEL 1
+#include "c_interface/c_interface.h"
 
-// 0: Use refined wave generator based on logarithmic fixed-point computations and LUTs
-// 1: Use legacy accurate wave generator based on float computations
-#define MT32EMU_ACCURATE_WG 0
+#elif MT32EMU_API_TYPE == 2 || MT32EMU_API_TYPE == 3
 
-namespace MT32Emu
-{
-// The higher this number, the more memory will be used, but the more samples can be processed in one run -
-// various parts of sample generation can be processed more efficiently in a single run.
-// A run's maximum length is that given to Synth::render(), so giving a value here higher than render() is ever
-// called with will give no gain (but simply waste the memory).
-// Note that this value does *not* in any way impose limitations on the length given to render(), and has no effect
-// on the generated audio.
-// This value must be >= 1.
-const unsigned int MAX_SAMPLES_PER_RUN = 4096;
+#include "c_interface/cpp_interface.h"
 
-// This determines the amount of memory available for simulating delays.
-// If set too low, partials aborted to allow other partials to play will not end gracefully, but will terminate
-// abruptly and potentially cause a pop/crackle in the audio output.
-// This value must be >= 1.
-const unsigned int MAX_PRERENDER_SAMPLES = 1024;
-}
+#else /* #if !defined(__cplusplus) || MT32EMU_API_TYPE == 1 */
 
-#include "Structures.h"
+#include "Types.h"
 #include "File.h"
 #include "FileStream.h"
-#include "Tables.h"
-#include "Poly.h"
-#include "LA32Ramp.h"
-#include "LA32WaveGenerator.h"
-#include "LegacyWaveGenerator.h"
-#include "TVA.h"
-#include "TVP.h"
-#include "TVF.h"
-#include "Partial.h"
-#include "Part.h"
 #include "ROMInfo.h"
 #include "Synth.h"
+#include "MidiStreamParser.h"
+#include "SampleRateConverter.h"
 
-#endif
+#endif /* #if !defined(__cplusplus) || MT32EMU_API_TYPE == 1 */
+
+#endif /* #ifndef MT32EMU_MT32EMU_H */
diff --git a/src/mt32/sha1/sha1.cpp b/src/mt32/sha1/sha1.cpp
index fdcbdcc0..9b91cd9f 100644
--- a/src/mt32/sha1/sha1.cpp
+++ b/src/mt32/sha1/sha1.cpp
@@ -1,589 +1,185 @@
 /*
- *  sha1.cpp
- *
- *  Copyright (C) 1998, 2009
- *  Paul E. Jones <paulej@packetizer.com>
- *  All Rights Reserved.
- *
- *****************************************************************************
- *  $Id: sha1.cpp 12 2009-06-22 19:34:25Z paulej $
- *****************************************************************************
- *
- *  Description:
- *      This class implements the Secure Hashing Standard as defined
- *      in FIPS PUB 180-1 published April 17, 1995.
- *
- *      The Secure Hashing Standard, which uses the Secure Hashing
- *      Algorithm (SHA), produces a 160-bit message digest for a
- *      given data stream.  In theory, it is highly improbable that
- *      two messages will produce the same message digest.  Therefore,
- *      this algorithm can serve as a means of providing a "fingerprint"
- *      for a message.
- *
- *  Portability Issues:
- *      SHA-1 is defined in terms of 32-bit "words".  This code was
- *      written with the expectation that the processor has at least
- *      a 32-bit machine word size.  If the machine word size is larger,
- *      the code should still function properly.  One caveat to that
- *      is that the input functions taking characters and character arrays
- *      assume that only 8 bits of information are stored in each character.
- *
- *  Caveats:
- *      SHA-1 is designed to work with messages less than 2^64 bits long.
- *      Although SHA-1 allows a message digest to be generated for
- *      messages of any number of bits less than 2^64, this implementation
- *      only works with messages with a length that is a multiple of 8
- *      bits.
- *
+ Copyright (c) 2011, Micael Hildenborg
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Micael Hildenborg nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY Micael Hildenborg ''AS IS'' AND ANY
+ EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ DISCLAIMED. IN NO EVENT SHALL Micael Hildenborg BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
-#include "sha1.h"
-
-/*  
- *  SHA1
- *
- *  Description:
- *      This is the constructor for the sha1 class.
- *
- *  Parameters:
- *      None.
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *
- */
-SHA1::SHA1()
-{
-    Reset();
-}
-
-/*  
- *  ~SHA1
- *
- *  Description:
- *      This is the destructor for the sha1 class
- *
- *  Parameters:
- *      None.
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *
- */
-SHA1::~SHA1()
-{
-    // The destructor does nothing
-}
-
-/*  
- *  Reset
- *
- *  Description:
- *      This function will initialize the sha1 class member variables
- *      in preparation for computing a new message digest.
- *
- *  Parameters:
- *      None.
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *
+/*
+ Contributors:
+ Gustav
+ Several members in the gamedev.se forum.
+ Gregory Petrosyan
  */
-void SHA1::Reset()
-{
-    Length_Low          = 0;
-    Length_High         = 0;
-    Message_Block_Index = 0;
-
-    H[0]        = 0x67452301;
-    H[1]        = 0xEFCDAB89;
-    H[2]        = 0x98BADCFE;
-    H[3]        = 0x10325476;
-    H[4]        = 0xC3D2E1F0;
 
-    Computed    = false;
-    Corrupted   = false;
-}
-
-/*  
- *  Result
- *
- *  Description:
- *      This function will return the 160-bit message digest into the
- *      array provided.
- *
- *  Parameters:
- *      message_digest_array: [out]
- *          This is an array of five unsigned integers which will be filled
- *          with the message digest that has been computed.
- *
- *  Returns:
- *      True if successful, false if it failed.
- *
- *  Comments:
- *
- */
-bool SHA1::Result(unsigned *message_digest_array)
-{
-    int i;                                  // Counter
-
-    if (Corrupted)
-    {
-        return false;
-    }
-
-    if (!Computed)
-    {
-        PadMessage();
-        Computed = true;
-    }
-
-    for(i = 0; i < 5; i++)
-    {
-        message_digest_array[i] = H[i];
-    }
-
-    return true;
-}
+#include "sha1.h"
 
-/*  
- *  Input
- *
- *  Description:
- *      This function accepts an array of octets as the next portion of
- *      the message.
- *
- *  Parameters:
- *      message_array: [in]
- *          An array of characters representing the next portion of the
- *          message.
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *
- */
-void SHA1::Input(   const unsigned char *message_array,
-                    unsigned            length)
+namespace sha1
 {
-    if (!length)
+    namespace // local
     {
-        return;
-    }
-
-    if (Computed || Corrupted)
-    {
-        Corrupted = true;
-        return;
-    }
-
-    while(length-- && !Corrupted)
-    {
-        Message_Block[Message_Block_Index++] = (*message_array & 0xFF);
+        // Rotate an integer value to left.
+        inline unsigned int rol(const unsigned int value,
+                const unsigned int steps)
+        {
+            return ((value << steps) | (value >> (32 - steps)));
+        }
 
-        Length_Low += 8;
-        Length_Low &= 0xFFFFFFFF;               // Force it to 32 bits
-        if (Length_Low == 0)
+        // Sets the first 16 integers in the buffert to zero.
+        // Used for clearing the W buffert.
+        inline void clearWBuffert(unsigned int* buffert)
         {
-            Length_High++;
-            Length_High &= 0xFFFFFFFF;          // Force it to 32 bits
-            if (Length_High == 0)
+            for (int pos = 16; --pos >= 0;)
             {
-                Corrupted = true;               // Message is too long
+                buffert[pos] = 0;
             }
         }
 
-        if (Message_Block_Index == 64)
+        void innerHash(unsigned int* result, unsigned int* w)
         {
-            ProcessMessageBlock();
-        }
-
-        message_array++;
-    }
-}
-
-/*  
- *  Input
- *
- *  Description:
- *      This function accepts an array of octets as the next portion of
- *      the message.
- *
- *  Parameters:
- *      message_array: [in]
- *          An array of characters representing the next portion of the
- *          message.
- *      length: [in]
- *          The length of the message_array
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *
- */
-void SHA1::Input(   const char  *message_array,
-                    unsigned    length)
-{
-    Input((unsigned char *) message_array, length);
-}
-
-/*  
- *  Input
- *
- *  Description:
- *      This function accepts a single octets as the next message element.
- *
- *  Parameters:
- *      message_element: [in]
- *          The next octet in the message.
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *
- */
-void SHA1::Input(unsigned char message_element)
-{
-    Input(&message_element, 1);
-}
-
-/*  
- *  Input
- *
- *  Description:
- *      This function accepts a single octet as the next message element.
- *
- *  Parameters:
- *      message_element: [in]
- *          The next octet in the message.
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *
- */
-void SHA1::Input(char message_element)
-{
-    Input((unsigned char *) &message_element, 1);
-}
-
-/*  
- *  operator<<
- *
- *  Description:
- *      This operator makes it convenient to provide character strings to
- *      the SHA1 object for processing.
- *
- *  Parameters:
- *      message_array: [in]
- *          The character array to take as input.
- *
- *  Returns:
- *      A reference to the SHA1 object.
- *
- *  Comments:
- *      Each character is assumed to hold 8 bits of information.
- *
- */
-SHA1& SHA1::operator<<(const char *message_array)
-{
-    const char *p = message_array;
-
-    while(*p)
-    {
-        Input(*p);
-        p++;
-    }
-
-    return *this;
-}
-
-/*  
- *  operator<<
- *
- *  Description:
- *      This operator makes it convenient to provide character strings to
- *      the SHA1 object for processing.
- *
- *  Parameters:
- *      message_array: [in]
- *          The character array to take as input.
- *
- *  Returns:
- *      A reference to the SHA1 object.
- *
- *  Comments:
- *      Each character is assumed to hold 8 bits of information.
- *
- */
-SHA1& SHA1::operator<<(const unsigned char *message_array)
-{
-    const unsigned char *p = message_array;
-
-    while(*p)
-    {
-        Input(*p);
-        p++;
-    }
-
-    return *this;
-}
-
-/*  
- *  operator<<
- *
- *  Description:
- *      This function provides the next octet in the message.
- *
- *  Parameters:
- *      message_element: [in]
- *          The next octet in the message
- *
- *  Returns:
- *      A reference to the SHA1 object.
- *
- *  Comments:
- *      The character is assumed to hold 8 bits of information.
- *
- */
-SHA1& SHA1::operator<<(const char message_element)
-{
-    Input((unsigned char *) &message_element, 1);
-
-    return *this;
-}
-
-/*  
- *  operator<<
- *
- *  Description:
- *      This function provides the next octet in the message.
- *
- *  Parameters:
- *      message_element: [in]
- *          The next octet in the message
- *
- *  Returns:
- *      A reference to the SHA1 object.
- *
- *  Comments:
- *      The character is assumed to hold 8 bits of information.
- *
- */
-SHA1& SHA1::operator<<(const unsigned char message_element)
-{
-    Input(&message_element, 1);
-
-    return *this;
-}
-
-/*  
- *  ProcessMessageBlock
- *
- *  Description:
- *      This function will process the next 512 bits of the message
- *      stored in the Message_Block array.
- *
- *  Parameters:
- *      None.
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *      Many of the variable names in this function, especially the single
- *      character names, were used because those were the names used
- *      in the publication.
- *
- */
-void SHA1::ProcessMessageBlock()
-{
-    const unsigned K[] =    {               // Constants defined for SHA-1
-                                0x5A827999,
-                                0x6ED9EBA1,
-                                0x8F1BBCDC,
-                                0xCA62C1D6
-                            };
-    int         t;                          // Loop counter
-    unsigned    temp;                       // Temporary word value
-    unsigned    W[80];                      // Word sequence
-    unsigned    A, B, C, D, E;              // Word buffers
+            unsigned int a = result[0];
+            unsigned int b = result[1];
+            unsigned int c = result[2];
+            unsigned int d = result[3];
+            unsigned int e = result[4];
+
+            int round = 0;
+
+            #define sha1macro(func,val) \
+			{ \
+                const unsigned int t = rol(a, 5) + (func) + e + val + w[round]; \
+				e = d; \
+				d = c; \
+				c = rol(b, 30); \
+				b = a; \
+				a = t; \
+			}
+
+            while (round < 16)
+            {
+                sha1macro((b & c) | (~b & d), 0x5a827999)
+                ++round;
+            }
+            while (round < 20)
+            {
+                w[round] = rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]), 1);
+                sha1macro((b & c) | (~b & d), 0x5a827999)
+                ++round;
+            }
+            while (round < 40)
+            {
+                w[round] = rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]), 1);
+                sha1macro(b ^ c ^ d, 0x6ed9eba1)
+                ++round;
+            }
+            while (round < 60)
+            {
+                w[round] = rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]), 1);
+                sha1macro((b & c) | (b & d) | (c & d), 0x8f1bbcdc)
+                ++round;
+            }
+            while (round < 80)
+            {
+                w[round] = rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]), 1);
+                sha1macro(b ^ c ^ d, 0xca62c1d6)
+                ++round;
+            }
 
-    /*
-     *  Initialize the first 16 words in the array W
-     */
-    for(t = 0; t < 16; t++)
-    {
-        W[t] = ((unsigned) Message_Block[t * 4]) << 24;
-        W[t] |= ((unsigned) Message_Block[t * 4 + 1]) << 16;
-        W[t] |= ((unsigned) Message_Block[t * 4 + 2]) << 8;
-        W[t] |= ((unsigned) Message_Block[t * 4 + 3]);
-    }
+            #undef sha1macro
 
-    for(t = 16; t < 80; t++)
-    {
-       W[t] = CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
-    }
-
-    A = H[0];
-    B = H[1];
-    C = H[2];
-    D = H[3];
-    E = H[4];
+            result[0] += a;
+            result[1] += b;
+            result[2] += c;
+            result[3] += d;
+            result[4] += e;
+        }
+    } // namespace
 
-    for(t = 0; t < 20; t++)
+    void calc(const void* src, const int bytelength, unsigned char* hash)
     {
-        temp = CircularShift(5,A) + ((B & C) | ((~B) & D)) + E + W[t] + K[0];
-        temp &= 0xFFFFFFFF;
-        E = D;
-        D = C;
-        C = CircularShift(30,B);
-        B = A;
-        A = temp;
-    }
+        // Init the result array.
+        unsigned int result[5] = { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 };
 
-    for(t = 20; t < 40; t++)
-    {
-        temp = CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
-        temp &= 0xFFFFFFFF;
-        E = D;
-        D = C;
-        C = CircularShift(30,B);
-        B = A;
-        A = temp;
-    }
+        // Cast the void src pointer to be the byte array we can work with.
+        const unsigned char* sarray = static_cast<const unsigned char*>(src);
 
-    for(t = 40; t < 60; t++)
-    {
-        temp = CircularShift(5,A) +
-               ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
-        temp &= 0xFFFFFFFF;
-        E = D;
-        D = C;
-        C = CircularShift(30,B);
-        B = A;
-        A = temp;
-    }
+        // The reusable round buffer
+        unsigned int w[80];
 
-    for(t = 60; t < 80; t++)
-    {
-        temp = CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
-        temp &= 0xFFFFFFFF;
-        E = D;
-        D = C;
-        C = CircularShift(30,B);
-        B = A;
-        A = temp;
-    }
+        // Loop through all complete 64byte blocks.
+        const int endOfFullBlocks = bytelength - 64;
+        int endCurrentBlock;
+        int currentBlock = 0;
 
-    H[0] = (H[0] + A) & 0xFFFFFFFF;
-    H[1] = (H[1] + B) & 0xFFFFFFFF;
-    H[2] = (H[2] + C) & 0xFFFFFFFF;
-    H[3] = (H[3] + D) & 0xFFFFFFFF;
-    H[4] = (H[4] + E) & 0xFFFFFFFF;
+        while (currentBlock <= endOfFullBlocks)
+        {
+            endCurrentBlock = currentBlock + 64;
 
-    Message_Block_Index = 0;
-}
+            // Init the round buffer with the 64 byte block data.
+            for (int roundPos = 0; currentBlock < endCurrentBlock; currentBlock += 4)
+            {
+                // This line will swap endian on big endian and keep endian on little endian.
+                w[roundPos++] = static_cast<unsigned int>(sarray[currentBlock + 3])
+                        | (static_cast<unsigned int>(sarray[currentBlock + 2]) << 8)
+                        | (static_cast<unsigned int>(sarray[currentBlock + 1]) << 16)
+                        | (static_cast<unsigned int>(sarray[currentBlock]) << 24);
+            }
+            innerHash(result, w);
+        }
 
-/*  
- *  PadMessage
- *
- *  Description:
- *      According to the standard, the message must be padded to an even
- *      512 bits.  The first padding bit must be a '1'.  The last 64 bits
- *      represent the length of the original message.  All bits in between
- *      should be 0.  This function will pad the message according to those
- *      rules by filling the message_block array accordingly.  It will also
- *      call ProcessMessageBlock() appropriately.  When it returns, it
- *      can be assumed that the message digest has been computed.
- *
- *  Parameters:
- *      None.
- *
- *  Returns:
- *      Nothing.
- *
- *  Comments:
- *
- */
-void SHA1::PadMessage()
-{
-    /*
-     *  Check to see if the current message block is too small to hold
-     *  the initial padding bits and length.  If so, we will pad the
-     *  block, process it, and then continue padding into a second block.
-     */
-    if (Message_Block_Index > 55)
-    {
-        Message_Block[Message_Block_Index++] = 0x80;
-        while(Message_Block_Index < 64)
+        // Handle the last and not full 64 byte block if existing.
+        endCurrentBlock = bytelength - currentBlock;
+        clearWBuffert(w);
+        int lastBlockBytes = 0;
+        for (;lastBlockBytes < endCurrentBlock; ++lastBlockBytes)
         {
-            Message_Block[Message_Block_Index++] = 0;
+            w[lastBlockBytes >> 2] |= static_cast<unsigned int>(sarray[lastBlockBytes + currentBlock]) << ((3 - (lastBlockBytes & 3)) << 3);
         }
+        w[lastBlockBytes >> 2] |= 0x80 << ((3 - (lastBlockBytes & 3)) << 3);
+        if (endCurrentBlock >= 56)
+        {
+            innerHash(result, w);
+            clearWBuffert(w);
+        }
+        w[15] = bytelength << 3;
+        innerHash(result, w);
 
-        ProcessMessageBlock();
-
-        while(Message_Block_Index < 56)
+        // Store hash in result pointer, and make sure we get in in the correct order on both endian models.
+        for (int hashByte = 20; --hashByte >= 0;)
         {
-            Message_Block[Message_Block_Index++] = 0;
+            hash[hashByte] = (result[hashByte >> 2] >> (((3 - hashByte) & 0x3) << 3)) & 0xff;
         }
     }
-    else
+
+    void toHexString(const unsigned char* hash, char* hexstring)
     {
-        Message_Block[Message_Block_Index++] = 0x80;
-        while(Message_Block_Index < 56)
+        const char hexDigits[] = { "0123456789abcdef" };
+
+        for (int hashByte = 20; --hashByte >= 0;)
         {
-            Message_Block[Message_Block_Index++] = 0;
+            hexstring[hashByte << 1] = hexDigits[(hash[hashByte] >> 4) & 0xf];
+            hexstring[(hashByte << 1) + 1] = hexDigits[hash[hashByte] & 0xf];
         }
-
+        hexstring[40] = 0;
     }
-
-    /*
-     *  Store the message length as the last 8 octets
-     */
-    Message_Block[56] = (Length_High >> 24) & 0xFF;
-    Message_Block[57] = (Length_High >> 16) & 0xFF;
-    Message_Block[58] = (Length_High >> 8) & 0xFF;
-    Message_Block[59] = (Length_High) & 0xFF;
-    Message_Block[60] = (Length_Low >> 24) & 0xFF;
-    Message_Block[61] = (Length_Low >> 16) & 0xFF;
-    Message_Block[62] = (Length_Low >> 8) & 0xFF;
-    Message_Block[63] = (Length_Low) & 0xFF;
-
-    ProcessMessageBlock();
-}
-
-
-/*  
- *  CircularShift
- *
- *  Description:
- *      This member function will perform a circular shifting operation.
- *
- *  Parameters:
- *      bits: [in]
- *          The number of bits to shift (1-31)
- *      word: [in]
- *          The value to shift (assumes a 32-bit integer)
- *
- *  Returns:
- *      The shifted value.
- *
- *  Comments:
- *
- */
-unsigned SHA1::CircularShift(int bits, unsigned word)
-{
-    return ((word << bits) & 0xFFFFFFFF) | ((word & 0xFFFFFFFF) >> (32-bits));
-}
+} // namespace sha1
diff --git a/src/mt32/sha1/sha1.h b/src/mt32/sha1/sha1.h
index c0efa1c9..96d8ce4d 100644
--- a/src/mt32/sha1/sha1.h
+++ b/src/mt32/sha1/sha1.h
@@ -1,89 +1,49 @@
 /*
- *  sha1.h
- *
- *  Copyright (C) 1998, 2009
- *  Paul E. Jones <paulej@packetizer.com>
- *  All Rights Reserved.
- *
- *****************************************************************************
- *  $Id: sha1.h 12 2009-06-22 19:34:25Z paulej $
- *****************************************************************************
- *
- *  Description:
- *      This class implements the Secure Hashing Standard as defined
- *      in FIPS PUB 180-1 published April 17, 1995.
- *
- *      Many of the variable names in this class, especially the single
- *      character names, were used because those were the names used
- *      in the publication.
- *
- *      Please read the file sha1.cpp for more information.
- *
+ Copyright (c) 2011, Micael Hildenborg
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Micael Hildenborg nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY Micael Hildenborg ''AS IS'' AND ANY
+ EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ DISCLAIMED. IN NO EVENT SHALL Micael Hildenborg BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef _SHA1_H_
-#define _SHA1_H_
+#ifndef SHA1_DEFINED
+#define SHA1_DEFINED
 
-class SHA1
+namespace sha1
 {
 
-    public:
+    /**
+     @param src points to any kind of data to be hashed.
+     @param bytelength the number of bytes to hash from the src pointer.
+     @param hash should point to a buffer of at least 20 bytes of size for storing the sha1 result in.
+     */
+    void calc(const void* src, const int bytelength, unsigned char* hash);
 
-        SHA1();
-        virtual ~SHA1();
+    /**
+     @param hash is 20 bytes of sha1 hash. This is the same data that is the result from the calc function.
+     @param hexstring should point to a buffer of at least 41 bytes of size for storing the hexadecimal representation of the hash. A zero will be written at position 40, so the buffer will be a valid zero ended string.
+     */
+    void toHexString(const unsigned char* hash, char* hexstring);
 
-        /*
-         *  Re-initialize the class
-         */
-        void Reset();
+} // namespace sha1
 
-        /*
-         *  Returns the message digest
-         */
-        bool Result(unsigned *message_digest_array);
-
-        /*
-         *  Provide input to SHA1
-         */
-        void Input( const unsigned char *message_array,
-                    unsigned            length);
-        void Input( const char  *message_array,
-                    unsigned    length);
-        void Input(unsigned char message_element);
-        void Input(char message_element);
-        SHA1& operator<<(const char *message_array);
-        SHA1& operator<<(const unsigned char *message_array);
-        SHA1& operator<<(const char message_element);
-        SHA1& operator<<(const unsigned char message_element);
-
-    private:
-
-        /*
-         *  Process the next 512 bits of the message
-         */
-        void ProcessMessageBlock();
-
-        /*
-         *  Pads the current message block to 512 bits
-         */
-        void PadMessage();
-
-        /*
-         *  Performs a circular left shift operation
-         */
-        inline unsigned CircularShift(int bits, unsigned word);
-
-        unsigned H[5];                      // Message digest buffers
-
-        unsigned Length_Low;                // Message length in bits
-        unsigned Length_High;               // Message length in bits
-
-        unsigned char Message_Block[64];    // 512-bit message blocks
-        int Message_Block_Index;            // Index into message block array
-
-        bool Computed;                      // Is the digest computed?
-        bool Corrupted;                     // Is the message digest corruped?
-    
-};
-
-#endif
+#endif // SHA1_DEFINED
diff --git a/src/mt32/srchelper/InternalResampler.cpp b/src/mt32/srchelper/InternalResampler.cpp
new file mode 100644
index 00000000..32040845
--- /dev/null
+++ b/src/mt32/srchelper/InternalResampler.cpp
@@ -0,0 +1,74 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "InternalResampler.h"
+
+#include "srctools/include/SincResampler.h"
+#include "srctools/include/ResamplerModel.h"
+
+#include "../Synth.h"
+
+using namespace SRCTools;
+
+namespace MT32Emu {
+
+class SynthWrapper : public FloatSampleProvider {
+	Synth &synth;
+
+public:
+	SynthWrapper(Synth &useSynth) : synth(useSynth)
+	{}
+
+	void getOutputSamples(FloatSample *outBuffer, unsigned int size) {
+		synth.render(outBuffer, size);
+	}
+};
+
+static FloatSampleProvider &createModel(Synth &synth, SRCTools::FloatSampleProvider &synthSource, double targetSampleRate, SamplerateConversionQuality quality) {
+	static const double MAX_AUDIBLE_FREQUENCY = 20000.0;
+
+	const double sourceSampleRate = synth.getStereoOutputSampleRate();
+	if (quality != SamplerateConversionQuality_FASTEST) {
+		const bool oversampledMode = synth.getStereoOutputSampleRate() == Synth::getStereoOutputSampleRate(AnalogOutputMode_OVERSAMPLED);
+		// Oversampled input allows to bypass IIR interpolation stage and, in some cases, IIR decimation stage
+		if (oversampledMode && (0.5 * sourceSampleRate) <= targetSampleRate) {
+			// NOTE: In the oversampled mode, the transition band starts at 20kHz and ends at 28kHz
+			double passband = MAX_AUDIBLE_FREQUENCY;
+			double stopband = 0.5 * sourceSampleRate + MAX_AUDIBLE_FREQUENCY;
+			ResamplerStage &resamplerStage = *SincResampler::createSincResampler(sourceSampleRate, targetSampleRate, passband, stopband, ResamplerModel::DEFAULT_DB_SNR, ResamplerModel::DEFAULT_WINDOWED_SINC_MAX_UPSAMPLE_FACTOR);
+			return ResamplerModel::createResamplerModel(synthSource, resamplerStage);
+		}
+	}
+	return ResamplerModel::createResamplerModel(synthSource, sourceSampleRate, targetSampleRate, static_cast<ResamplerModel::Quality>(quality));
+}
+
+} // namespace MT32Emu
+
+using namespace MT32Emu;
+
+InternalResampler::InternalResampler(Synth &synth, double targetSampleRate, SamplerateConversionQuality quality) :
+	synthSource(*new SynthWrapper(synth)),
+	model(createModel(synth, synthSource, targetSampleRate, quality))
+{}
+
+InternalResampler::~InternalResampler() {
+	ResamplerModel::freeResamplerModel(model, synthSource);
+	delete &synthSource;
+}
+
+void InternalResampler::getOutputSamples(float *buffer, unsigned int length) {
+	model.getOutputSamples(buffer, length);
+}
diff --git a/src/mt32/srchelper/InternalResampler.h b/src/mt32/srchelper/InternalResampler.h
new file mode 100644
index 00000000..be540775
--- /dev/null
+++ b/src/mt32/srchelper/InternalResampler.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_INTERNAL_RESAMPLER_H
+#define MT32EMU_INTERNAL_RESAMPLER_H
+
+#include "../Enumerations.h"
+
+#include "srctools/include/FloatSampleProvider.h"
+
+namespace MT32Emu {
+
+class Synth;
+
+class InternalResampler {
+public:
+	InternalResampler(Synth &synth, double targetSampleRate, SamplerateConversionQuality quality);
+	~InternalResampler();
+
+	void getOutputSamples(float *buffer, unsigned int length);
+
+private:
+	SRCTools::FloatSampleProvider &synthSource;
+	SRCTools::FloatSampleProvider &model;
+};
+
+} // namespace MT32Emu
+
+#endif // MT32EMU_INTERNAL_RESAMPLER_H
diff --git a/src/mt32/srchelper/SamplerateAdapter.cpp b/src/mt32/srchelper/SamplerateAdapter.cpp
new file mode 100644
index 00000000..715d2987
--- /dev/null
+++ b/src/mt32/srchelper/SamplerateAdapter.cpp
@@ -0,0 +1,99 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "SamplerateAdapter.h"
+
+#include "../Synth.h"
+
+using namespace MT32Emu;
+
+static const unsigned int CHANNEL_COUNT = 2;
+
+long SamplerateAdapter::getInputSamples(void *cb_data, float **data) {
+	SamplerateAdapter *instance = static_cast<SamplerateAdapter *>(cb_data);
+	unsigned int length = instance->inBufferSize < 1 ? 1 : (MAX_SAMPLES_PER_RUN < instance->inBufferSize ? MAX_SAMPLES_PER_RUN : instance->inBufferSize);
+	instance->synth.render(instance->inBuffer, length);
+	*data = instance->inBuffer;
+	instance->inBufferSize -= length;
+	return length;
+}
+
+SamplerateAdapter::SamplerateAdapter(Synth &useSynth, double targetSampleRate, SamplerateConversionQuality quality) :
+	synth(useSynth),
+	inBuffer(new float[CHANNEL_COUNT * MAX_SAMPLES_PER_RUN]),
+	inBufferSize(MAX_SAMPLES_PER_RUN),
+	inputToOutputRatio(useSynth.getStereoOutputSampleRate() / targetSampleRate),
+	outputToInputRatio(targetSampleRate / useSynth.getStereoOutputSampleRate())
+{
+	int error;
+	int conversionType;
+	switch (quality) {
+	case SamplerateConversionQuality_FASTEST:
+		conversionType = SRC_LINEAR;
+		break;
+	case SamplerateConversionQuality_FAST:
+		conversionType = SRC_SINC_FASTEST;
+		break;
+	case SamplerateConversionQuality_BEST:
+		conversionType = SRC_SINC_BEST_QUALITY;
+		break;
+	case SamplerateConversionQuality_GOOD:
+	default:
+		conversionType = SRC_SINC_MEDIUM_QUALITY;
+		break;
+	};
+	resampler = src_callback_new(getInputSamples, conversionType, CHANNEL_COUNT, &error, this);
+	if (error != 0) {
+		synth.printDebug("SamplerateAdapter: Creation of Samplerate instance failed: %s\n", src_strerror(error));
+		src_delete(resampler);
+		resampler = NULL;
+	}
+}
+
+SamplerateAdapter::~SamplerateAdapter() {
+	delete[] inBuffer;
+	src_delete(resampler);
+}
+
+void SamplerateAdapter::getOutputSamples(float *buffer, unsigned int length) {
+	if (resampler == NULL) {
+		Synth::muteSampleBuffer(buffer, CHANNEL_COUNT * length);
+		return;
+	}
+	while (length > 0) {
+		inBufferSize = static_cast<unsigned int>(length * inputToOutputRatio + 0.5);
+		long gotFrames = src_callback_read(resampler, outputToInputRatio, long(length), buffer);
+		int error = src_error(resampler);
+		if (error != 0) {
+			synth.printDebug("SamplerateAdapter: Samplerate error during processing: %s > resetting\n", src_strerror(error));
+			error = src_reset(resampler);
+			if (error != 0) {
+				synth.printDebug("SamplerateAdapter: Samplerate failed to reset: %s\n", src_strerror(error));
+				src_delete(resampler);
+				resampler = NULL;
+				Synth::muteSampleBuffer(buffer, CHANNEL_COUNT * length);
+				synth.printDebug("SamplerateAdapter: Samplerate disabled\n");
+				return;
+			}
+			continue;
+		}
+		if (gotFrames <= 0) {
+			synth.printDebug("SamplerateAdapter: got %li frames from Samplerate, weird\n", gotFrames);
+		}
+		buffer += CHANNEL_COUNT * gotFrames;
+		length -= gotFrames;
+	}
+}
diff --git a/src/mt32/srchelper/SamplerateAdapter.h b/src/mt32/srchelper/SamplerateAdapter.h
new file mode 100644
index 00000000..0991fd77
--- /dev/null
+++ b/src/mt32/srchelper/SamplerateAdapter.h
@@ -0,0 +1,48 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_SAMPLERATE_ADAPTER_H
+#define MT32EMU_SAMPLERATE_ADAPTER_H
+
+#include <samplerate.h>
+
+#include "../Enumerations.h"
+
+namespace MT32Emu {
+
+class Synth;
+
+class SamplerateAdapter {
+public:
+	SamplerateAdapter(Synth &synth, double targetSampleRate, SamplerateConversionQuality quality);
+	~SamplerateAdapter();
+
+	void getOutputSamples(float *outBuffer, unsigned int length);
+
+private:
+	Synth &synth;
+	float * const inBuffer;
+	unsigned int inBufferSize;
+	const double inputToOutputRatio;
+	const double outputToInputRatio;
+	SRC_STATE *resampler;
+
+	static long getInputSamples(void *cb_data, float **data);
+};
+
+} // namespace MT32Emu
+
+#endif // MT32EMU_SAMPLERATE_ADAPTER_H
diff --git a/src/mt32/srchelper/SoxrAdapter.cpp b/src/mt32/srchelper/SoxrAdapter.cpp
new file mode 100644
index 00000000..5e8dca97
--- /dev/null
+++ b/src/mt32/srchelper/SoxrAdapter.cpp
@@ -0,0 +1,106 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "SoxrAdapter.h"
+
+#include "../Synth.h"
+
+using namespace MT32Emu;
+
+static const unsigned int CHANNEL_COUNT = 2;
+
+size_t SoxrAdapter::getInputSamples(void *input_fn_state, soxr_in_t *data, size_t requested_len) {
+	unsigned int length = requested_len < 1 ? 1 : (MAX_SAMPLES_PER_RUN < requested_len ? MAX_SAMPLES_PER_RUN : static_cast<unsigned int>(requested_len));
+	SoxrAdapter *instance = static_cast<SoxrAdapter *>(input_fn_state);
+	instance->synth.render(instance->inBuffer, length);
+	*data = instance->inBuffer;
+	return length;
+}
+
+SoxrAdapter::SoxrAdapter(Synth &useSynth, double targetSampleRate, SamplerateConversionQuality quality) :
+	synth(useSynth),
+	inBuffer(new float[CHANNEL_COUNT * MAX_SAMPLES_PER_RUN])
+{
+	soxr_io_spec_t ioSpec = soxr_io_spec(SOXR_FLOAT32_I, SOXR_FLOAT32_I);
+	unsigned long qualityRecipe;
+	switch (quality) {
+	case SamplerateConversionQuality_FASTEST:
+		qualityRecipe = SOXR_QQ;
+		break;
+	case SamplerateConversionQuality_FAST:
+		qualityRecipe = SOXR_LQ;
+		break;
+	case SamplerateConversionQuality_GOOD:
+		qualityRecipe = SOXR_MQ;
+		break;
+	case SamplerateConversionQuality_BEST:
+	default:
+		qualityRecipe = SOXR_16_BITQ;
+		break;
+	};
+	soxr_quality_spec_t qSpec = soxr_quality_spec(qualityRecipe, 0);
+	soxr_runtime_spec_t rtSpec = soxr_runtime_spec(1);
+	soxr_error_t error;
+	resampler = soxr_create(synth.getStereoOutputSampleRate(), targetSampleRate, CHANNEL_COUNT, &error, &ioSpec, &qSpec, &rtSpec);
+	if (error != NULL) {
+		synth.printDebug("SoxrAdapter: Creation of SOXR instance failed: %s\n", soxr_strerror(error));
+		soxr_delete(resampler);
+		resampler = NULL;
+		return;
+	}
+	error = soxr_set_input_fn(resampler, getInputSamples, this, MAX_SAMPLES_PER_RUN);
+	if (error != NULL) {
+		synth.printDebug("SoxrAdapter: Installing sample feed for SOXR failed: %s\n", soxr_strerror(error));
+		soxr_delete(resampler);
+		resampler = NULL;
+	}
+}
+
+SoxrAdapter::~SoxrAdapter() {
+	delete[] inBuffer;
+	if (resampler != NULL) {
+		soxr_delete(resampler);
+	}
+}
+
+void SoxrAdapter::getOutputSamples(float *buffer, unsigned int length) {
+	if (resampler == NULL) {
+		Synth::muteSampleBuffer(buffer, CHANNEL_COUNT * length);
+		return;
+	}
+	while (length > 0) {
+		size_t gotFrames = soxr_output(resampler, buffer, size_t(length));
+		soxr_error_t error = soxr_error(resampler);
+		if (error != NULL) {
+			synth.printDebug("SoxrAdapter: SOXR error during processing: %s > resetting\n", soxr_strerror(error));
+			error = soxr_clear(resampler);
+			if (error != NULL) {
+				synth.printDebug("SoxrAdapter: SOXR failed to reset: %s\n", soxr_strerror(error));
+				soxr_delete(resampler);
+				resampler = NULL;
+				Synth::muteSampleBuffer(buffer, CHANNEL_COUNT * length);
+				synth.printDebug("SoxrAdapter: SOXR disabled\n");
+				return;
+			}
+			continue;
+		}
+		if (gotFrames == 0) {
+			synth.printDebug("SoxrAdapter: got 0 frames from SOXR, weird\n");
+		}
+		buffer += CHANNEL_COUNT * gotFrames;
+		length -= static_cast<unsigned int>(gotFrames);
+	}
+}
diff --git a/src/mt32/srchelper/SoxrAdapter.h b/src/mt32/srchelper/SoxrAdapter.h
new file mode 100644
index 00000000..b97ca4da
--- /dev/null
+++ b/src/mt32/srchelper/SoxrAdapter.h
@@ -0,0 +1,45 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_SOXR_ADAPTER_H
+#define MT32EMU_SOXR_ADAPTER_H
+
+#include <soxr.h>
+
+#include "../Enumerations.h"
+
+namespace MT32Emu {
+
+class Synth;
+
+class SoxrAdapter {
+public:
+	SoxrAdapter(Synth &synth, double targetSampleRate, SamplerateConversionQuality quality);
+	~SoxrAdapter();
+
+	void getOutputSamples(float *buffer, unsigned int length);
+
+private:
+	Synth &synth;
+	float * const inBuffer;
+	soxr_t resampler;
+
+	static size_t getInputSamples(void *input_fn_state, soxr_in_t *data, size_t requested_len);
+};
+
+} // namespace MT32Emu
+
+#endif // MT32EMU_SOXR_ADAPTER_H
diff --git a/src/mt32/srchelper/srctools/include/FIRResampler.h b/src/mt32/srchelper/srctools/include/FIRResampler.h
new file mode 100644
index 00000000..7c09bf8d
--- /dev/null
+++ b/src/mt32/srchelper/srctools/include/FIRResampler.h
@@ -0,0 +1,67 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SRCTOOLS_FIR_RESAMPLER_H
+#define SRCTOOLS_FIR_RESAMPLER_H
+
+#include "ResamplerStage.h"
+
+namespace SRCTools {
+
+typedef FloatSample FIRCoefficient;
+
+static const unsigned int FIR_INTERPOLATOR_CHANNEL_COUNT = 2;
+
+class FIRResampler : public ResamplerStage {
+public:
+	FIRResampler(const unsigned int upsampleFactor, const double downsampleFactor, const FIRCoefficient kernel[], const unsigned int kernelLength);
+	~FIRResampler();
+
+	void process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength);
+	unsigned int estimateInLength(const unsigned int outLength) const;
+
+private:
+	const struct Constants {
+		// Filter coefficients
+		const FIRCoefficient *taps;
+		// Indicates whether to interpolate filter taps
+		bool usePhaseInterpolation;
+		// Size of array of filter coefficients
+		unsigned int numberOfTaps;
+		// Upsampling factor
+		unsigned int numberOfPhases;
+		// Downsampling factor
+		double phaseIncrement;
+		// Index of last delay line element, generally greater than numberOfTaps to form a proper binary mask
+		unsigned int delayLineMask;
+		// Delay line
+		FloatSample(*ringBuffer)[FIR_INTERPOLATOR_CHANNEL_COUNT];
+
+		Constants(const unsigned int upsampleFactor, const double downsampleFactor, const FIRCoefficient kernel[], const unsigned int kernelLength);
+	} constants;
+	// Index of current sample in delay line
+	unsigned int ringBufferPosition;
+	// Current phase
+	double phase;
+
+	bool needNextInSample() const;
+	void addInSamples(const FloatSample *&inSamples);
+	void getOutSamplesStereo(FloatSample *&outSamples);
+}; // class FIRResampler
+
+} // namespace SRCTools
+
+#endif // SRCTOOLS_FIR_RESAMPLER_H
diff --git a/src/mt32/srchelper/srctools/include/FloatSampleProvider.h b/src/mt32/srchelper/srctools/include/FloatSampleProvider.h
new file mode 100644
index 00000000..9820769f
--- /dev/null
+++ b/src/mt32/srchelper/srctools/include/FloatSampleProvider.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SRCTOOLS_FLOAT_SAMPLE_PROVIDER_H
+#define SRCTOOLS_FLOAT_SAMPLE_PROVIDER_H
+
+namespace SRCTools {
+
+typedef float FloatSample;
+
+/** Interface defines an abstract source of samples. It can either define a single channel stream or a stream with interleaved channels. */
+class FloatSampleProvider {
+public:
+	virtual ~FloatSampleProvider() {}
+
+	virtual void getOutputSamples(FloatSample *outBuffer, unsigned int size) = 0;
+};
+
+} // namespace SRCTools
+
+#endif // SRCTOOLS_FLOAT_SAMPLE_PROVIDER_H
diff --git a/src/mt32/srchelper/srctools/include/IIR2xResampler.h b/src/mt32/srchelper/srctools/include/IIR2xResampler.h
new file mode 100644
index 00000000..0bfe1c4c
--- /dev/null
+++ b/src/mt32/srchelper/srctools/include/IIR2xResampler.h
@@ -0,0 +1,100 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SRCTOOLS_IIR_2X_RESAMPLER_H
+#define SRCTOOLS_IIR_2X_RESAMPLER_H
+
+#include "ResamplerStage.h"
+
+namespace SRCTools {
+
+static const unsigned int IIR_RESAMPER_CHANNEL_COUNT = 2;
+static const unsigned int IIR_SECTION_ORDER = 2;
+
+typedef FloatSample IIRCoefficient;
+typedef FloatSample BufferedSample;
+
+typedef BufferedSample SectionBuffer[IIR_SECTION_ORDER];
+
+// Non-trivial coefficients of a 2nd-order section of a parallel bank
+// (zero-order numerator coefficient is always zero, zero-order denominator coefficient is always unity)
+struct IIRSection {
+	IIRCoefficient num1;
+	IIRCoefficient num2;
+	IIRCoefficient den1;
+	IIRCoefficient den2;
+};
+
+class IIRResampler : public ResamplerStage {
+public:
+	enum Quality {
+		// Used when providing custom IIR filter coefficients.
+		CUSTOM,
+		// Use fast elliptic filter with symmetric ripple: N=8, Ap=As=-99 dB, fp=0.125, fs = 0.25 (in terms of sample rate)
+		FAST,
+		// Use average elliptic filter with symmetric ripple: N=12, Ap=As=-106 dB, fp=0.193, fs = 0.25 (in terms of sample rate)
+		GOOD,
+		// Use sharp elliptic filter with symmetric ripple: N=18, Ap=As=-106 dB, fp=0.238, fs = 0.25 (in terms of sample rate)
+		BEST
+	};
+
+	// Returns the retained fraction of the passband for the given standard quality value
+	static double getPassbandFractionForQuality(Quality quality);
+
+protected:
+	explicit IIRResampler(const Quality quality);
+	explicit IIRResampler(const unsigned int useSectionsCount, const IIRCoefficient useFIR, const IIRSection useSections[]);
+	~IIRResampler();
+
+	const struct Constants {
+		// Coefficient of the 0-order FIR part
+		IIRCoefficient fir;
+		// 2nd-order sections that comprise a parallel bank
+		const IIRSection *sections;
+		// Number of 2nd-order sections
+		unsigned int sectionsCount;
+		// Delay line per channel per section
+		SectionBuffer *buffer;
+
+		Constants(const unsigned int useSectionsCount, const IIRCoefficient useFIR, const IIRSection useSections[], const Quality quality);
+	} constants;
+}; // class IIRResampler
+
+class IIR2xInterpolator : public IIRResampler {
+public:
+	explicit IIR2xInterpolator(const Quality quality);
+	explicit IIR2xInterpolator(const unsigned int useSectionsCount, const IIRCoefficient useFIR, const IIRSection useSections[]);
+
+	void process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength);
+	unsigned int estimateInLength(const unsigned int outLength) const;
+
+private:
+	FloatSample lastInputSamples[IIR_RESAMPER_CHANNEL_COUNT];
+	unsigned int phase;
+};
+
+class IIR2xDecimator : public IIRResampler {
+public:
+	explicit IIR2xDecimator(const Quality quality);
+	explicit IIR2xDecimator(const unsigned int useSectionsCount, const IIRCoefficient useFIR, const IIRSection useSections[]);
+
+	void process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength);
+	unsigned int estimateInLength(const unsigned int outLength) const;
+};
+
+} // namespace SRCTools
+
+#endif // SRCTOOLS_IIR_2X_RESAMPLER_H
diff --git a/src/mt32/srchelper/srctools/include/LinearResampler.h b/src/mt32/srchelper/srctools/include/LinearResampler.h
new file mode 100644
index 00000000..c81ff2a3
--- /dev/null
+++ b/src/mt32/srchelper/srctools/include/LinearResampler.h
@@ -0,0 +1,42 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SRCTOOLS_LINEAR_RESAMPLER_H
+#define SRCTOOLS_LINEAR_RESAMPLER_H
+
+#include "ResamplerStage.h"
+
+namespace SRCTools {
+
+static const unsigned int LINEAR_RESAMPER_CHANNEL_COUNT = 2;
+
+class LinearResampler : public ResamplerStage {
+public:
+	LinearResampler(double sourceSampleRate, double targetSampleRate);
+	~LinearResampler() {}
+
+	unsigned int estimateInLength(const unsigned int outLength) const;
+	void process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength);
+
+private:
+	const double inputToOutputRatio;
+	double position;
+	FloatSample lastInputSamples[LINEAR_RESAMPER_CHANNEL_COUNT];
+};
+
+} // namespace SRCTools
+
+#endif // SRCTOOLS_LINEAR_RESAMPLER_H
diff --git a/src/mt32/srchelper/srctools/include/ResamplerModel.h b/src/mt32/srchelper/srctools/include/ResamplerModel.h
new file mode 100644
index 00000000..f0ac2370
--- /dev/null
+++ b/src/mt32/srchelper/srctools/include/ResamplerModel.h
@@ -0,0 +1,63 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SRCTOOLS_RESAMPLER_MODEL_H
+#define SRCTOOLS_RESAMPLER_MODEL_H
+
+#include "FloatSampleProvider.h"
+
+namespace SRCTools {
+
+class ResamplerStage;
+
+/** Model consists of one or more ResampleStage instances connected in a cascade. */
+namespace ResamplerModel {
+
+// Seems to be a good choice for 16-bit integer samples.
+static const double DEFAULT_DB_SNR = 106;
+
+// When using linear interpolation, oversampling factor necessary to achieve the DEFAULT_DB_SNR is about 256.
+// This figure is the upper estimation, and it can be found by analysing the frequency response of the linear interpolator.
+// When less SNR is desired, this value should also decrease in accordance.
+static const unsigned int DEFAULT_WINDOWED_SINC_MAX_DOWNSAMPLE_FACTOR = 256;
+
+// In the default resampler model, the input to the windowed sinc filter is always at least 2x oversampled during upsampling,
+// so oversampling factor of 128 should be sufficient to achieve the DEFAULT_DB_SNR with linear interpolation.
+static const unsigned int DEFAULT_WINDOWED_SINC_MAX_UPSAMPLE_FACTOR = DEFAULT_WINDOWED_SINC_MAX_DOWNSAMPLE_FACTOR / 2;
+
+
+enum Quality {
+	// Use when the speed is more important than the audio quality.
+	FASTEST,
+	// Use FAST quality setting of the IIR stage (50% of passband retained).
+	FAST,
+	// Use GOOD quality setting of the IIR stage (77% of passband retained).
+	GOOD,
+	// Use BEST quality setting of the IIR stage (95% of passband retained).
+	BEST
+};
+
+FloatSampleProvider &createResamplerModel(FloatSampleProvider &source, double sourceSampleRate, double targetSampleRate, Quality quality);
+FloatSampleProvider &createResamplerModel(FloatSampleProvider &source, ResamplerStage **stages, unsigned int stageCount);
+FloatSampleProvider &createResamplerModel(FloatSampleProvider &source, ResamplerStage &stage);
+
+void freeResamplerModel(FloatSampleProvider &model, FloatSampleProvider &source);
+
+} // namespace ResamplerModel
+
+} // namespace SRCTools
+
+#endif // SRCTOOLS_RESAMPLER_MODEL_H
diff --git a/src/mt32/srchelper/srctools/include/ResamplerStage.h b/src/mt32/srchelper/srctools/include/ResamplerStage.h
new file mode 100644
index 00000000..e335c0c3
--- /dev/null
+++ b/src/mt32/srchelper/srctools/include/ResamplerStage.h
@@ -0,0 +1,38 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SRCTOOLS_RESAMPLER_STAGE_H
+#define SRCTOOLS_RESAMPLER_STAGE_H
+
+#include "FloatSampleProvider.h"
+
+namespace SRCTools {
+
+/** Interface defines an abstract source of samples. It can either define a single channel stream or a stream with interleaved channels. */
+class ResamplerStage {
+public:
+	virtual ~ResamplerStage() {}
+
+	/** Returns a lower estimation of required number of input samples to produce the specified number of output samples. */
+	virtual unsigned int estimateInLength(const unsigned int outLength) const = 0;
+
+	/** Generates output samples. The arguments are adjusted in accordance with the number of samples processed. */
+	virtual void process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength) = 0;
+};
+
+} // namespace SRCTools
+
+#endif // SRCTOOLS_RESAMPLER_STAGE_H
diff --git a/src/mt32/srchelper/srctools/include/SincResampler.h b/src/mt32/srchelper/srctools/include/SincResampler.h
new file mode 100644
index 00000000..1551a1ed
--- /dev/null
+++ b/src/mt32/srchelper/srctools/include/SincResampler.h
@@ -0,0 +1,46 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SRCTOOLS_SINC_RESAMPLER_H
+#define SRCTOOLS_SINC_RESAMPLER_H
+
+#include "FIRResampler.h"
+
+namespace SRCTools {
+
+class ResamplerStage;
+
+namespace SincResampler {
+
+	ResamplerStage *createSincResampler(const double inputFrequency, const double outputFrequency, const double passbandFrequency, const double stopbandFrequency, const double dbSNR, const unsigned int maxUpsampleFactor);
+
+	namespace Utils {
+		void computeResampleFactors(unsigned int &upsampleFactor, double &downsampleFactor, const double inputFrequency, const double outputFrequency, const unsigned int maxUpsampleFactor);
+		unsigned int greatestCommonDivisor(unsigned int a, unsigned int b);
+	}
+
+	namespace KaizerWindow {
+		double estimateBeta(double dbRipple);
+		unsigned int estimateOrder(double dbRipple, double fp, double fs);
+		double bessel(const double x);
+		void windowedSinc(FIRCoefficient kernel[], const unsigned int order, const double fc, const double beta, const double amp);
+	}
+
+} // namespace SincResampler
+
+} // namespace SRCTools
+
+#endif // SRCTOOLS_SINC_RESAMPLER_H
diff --git a/src/mt32/srchelper/srctools/src/FIRResampler.cpp b/src/mt32/srchelper/srctools/src/FIRResampler.cpp
new file mode 100644
index 00000000..15d95c5f
--- /dev/null
+++ b/src/mt32/srchelper/srctools/src/FIRResampler.cpp
@@ -0,0 +1,107 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cmath>
+#include <cstring>
+
+#include "../include/FIRResampler.h"
+
+using namespace SRCTools;
+
+FIRResampler::Constants::Constants(const unsigned int upsampleFactor, const double downsampleFactor, const FIRCoefficient kernel[], const unsigned int kernelLength) {
+	usePhaseInterpolation = downsampleFactor != floor(downsampleFactor);
+	FIRCoefficient *kernelCopy = new FIRCoefficient[kernelLength];
+	memcpy(kernelCopy, kernel, kernelLength * sizeof(FIRCoefficient));
+	taps = kernelCopy;
+	numberOfTaps = kernelLength;
+	numberOfPhases = upsampleFactor;
+	phaseIncrement = downsampleFactor;
+	unsigned int minDelayLineLength = static_cast<unsigned int>(ceil(double(kernelLength) / upsampleFactor));
+	unsigned int delayLineLength = 2;
+	while (delayLineLength < minDelayLineLength) delayLineLength <<= 1;
+	delayLineMask = delayLineLength - 1;
+	ringBuffer = new FloatSample[delayLineLength][FIR_INTERPOLATOR_CHANNEL_COUNT];
+	FloatSample *s = *ringBuffer;
+	FloatSample *e = ringBuffer[delayLineLength];
+	while (s < e) *(s++) = 0;
+}
+
+FIRResampler::FIRResampler(const unsigned int upsampleFactor, const double downsampleFactor, const FIRCoefficient kernel[], const unsigned int kernelLength) :
+	constants(upsampleFactor, downsampleFactor, kernel, kernelLength),
+	ringBufferPosition(0),
+	phase(constants.numberOfPhases)
+{}
+
+FIRResampler::~FIRResampler() {
+	delete[] constants.ringBuffer;
+	delete[] constants.taps;
+}
+
+void FIRResampler::process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength) {
+	while (outLength > 0) {
+		while (needNextInSample()) {
+			if (inLength == 0) return;
+			addInSamples(inSamples);
+			--inLength;
+		}
+		getOutSamplesStereo(outSamples);
+		--outLength;
+	}
+}
+
+unsigned int FIRResampler::estimateInLength(const unsigned int outLength) const {
+	return static_cast<unsigned int>((outLength * constants.phaseIncrement + phase) / constants.numberOfPhases);
+}
+
+bool FIRResampler::needNextInSample() const {
+	return constants.numberOfPhases <= phase;
+}
+
+void FIRResampler::addInSamples(const FloatSample *&inSamples) {
+	ringBufferPosition = (ringBufferPosition - 1) & constants.delayLineMask;
+	for (unsigned int i = 0; i < FIR_INTERPOLATOR_CHANNEL_COUNT; i++) {
+		constants.ringBuffer[ringBufferPosition][i] = *(inSamples++);
+	}
+	phase -= constants.numberOfPhases;
+}
+
+// Optimised for processing stereo interleaved streams
+void FIRResampler::getOutSamplesStereo(FloatSample *&outSamples) {
+	FloatSample leftSample = 0.0;
+	FloatSample rightSample = 0.0;
+	unsigned int delaySampleIx = ringBufferPosition;
+	if (constants.usePhaseInterpolation) {
+		double phaseFraction = phase - floor(phase);
+		unsigned int maxTapIx = phaseFraction == 0 ? constants.numberOfTaps : constants.numberOfTaps - 1;
+		for (unsigned int tapIx = static_cast<unsigned int>(phase); tapIx < maxTapIx; tapIx += constants.numberOfPhases) {
+			FIRCoefficient tap = FIRCoefficient(constants.taps[tapIx] + (constants.taps[tapIx + 1] - constants.taps[tapIx]) * phaseFraction);
+			leftSample += tap * constants.ringBuffer[delaySampleIx][0];
+			rightSample += tap * constants.ringBuffer[delaySampleIx][1];
+			delaySampleIx = (delaySampleIx + 1) & constants.delayLineMask;
+		}
+	} else {
+		// Optimised for rational resampling ratios when phase is always integer
+		for (unsigned int tapIx = static_cast<unsigned int>(phase); tapIx < constants.numberOfTaps; tapIx += constants.numberOfPhases) {
+			FIRCoefficient tap = constants.taps[tapIx];
+			leftSample += tap * constants.ringBuffer[delaySampleIx][0];
+			rightSample += tap * constants.ringBuffer[delaySampleIx][1];
+			delaySampleIx = (delaySampleIx + 1) & constants.delayLineMask;
+		}
+	}
+	*(outSamples++) = leftSample;
+	*(outSamples++) = rightSample;
+	phase += constants.phaseIncrement;
+}
diff --git a/src/mt32/srchelper/srctools/src/IIR2xResampler.cpp b/src/mt32/srchelper/srctools/src/IIR2xResampler.cpp
new file mode 100644
index 00000000..1adc5935
--- /dev/null
+++ b/src/mt32/srchelper/srctools/src/IIR2xResampler.cpp
@@ -0,0 +1,229 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cstddef>
+
+#include "../include/IIR2xResampler.h"
+
+namespace SRCTools {
+
+	// Avoid denormals degrading performance, using biased input
+	static const BufferedSample BIAS = 1e-20f;
+
+	// Sharp elliptic filter with symmetric ripple: N=18, Ap=As=-106 dB, fp=0.238, fs = 0.25 (in terms of sample rate)
+	static const IIRCoefficient FIR_BEST = 0.0014313792470984f;
+	static const IIRSection SECTIONS_BEST[] = {
+		{ 2.85800356692148000f,-0.2607342682253230f,-0.602478421807085f, 0.109823442522145f },
+		{ -4.39519408383016000f, 1.4651975326003500f,-0.533817668127954f, 0.226045921792036f },
+		{ 0.86638550740991800f,-2.1053851417898500f,-0.429134968401065f, 0.403512574222174f },
+		{ 1.67161485530774000f, 0.7963595880494520f,-0.324989203363446f, 0.580756666711889f },
+		{ -1.19962759276471000f, 0.5873595178851540f,-0.241486447489019f, 0.724264899930934f },
+		{ 0.01631779946479250f,-0.6282334739461620f,-0.182766025706656f, 0.827774001858882f },
+		{ 0.28404415859352400f, 0.1038619997715160f,-0.145276649558926f, 0.898510501923554f },
+		{ -0.08105788424234910f, 0.0781551578108934f,-0.123965846623366f, 0.947105257601873f },
+		{ -0.00872608905948005f,-0.0222098231712466f,-0.115056854360748f, 0.983542001125711f }
+	};
+
+	// Average elliptic filter with symmetric ripple: N=12, Ap=As=-106 dB, fp=0.193, fs = 0.25 (in terms of sample rate)
+	static const IIRCoefficient FIR_GOOD = 0.000891054570268146f;
+	static const IIRSection SECTIONS_GOOD[] = {
+		{ 2.2650157226725700f,-0.4034180565140230f,-0.750061486095301f, 0.157801404511953f },
+		{ -3.2788261989161700f, 1.3952152147542600f,-0.705854270206788f, 0.265564985645774f },
+		{ 0.4397975114813240f,-1.3957634748753100f,-0.639718853965265f, 0.435324134360315f },
+		{ 0.9827040216680520f, 0.1837182774040940f,-0.578569965618418f, 0.615205557837542f },
+		{ -0.3759752818621670f, 0.3266073609399490f,-0.540913588637109f, 0.778264420176574f },
+		{ -0.0253548089519618f,-0.0925779221603846f,-0.537704370375240f, 0.925800083252964f }
+	};
+
+	// Fast elliptic filter with symmetric ripple: N=8, Ap=As=-99 dB, fp=0.125, fs = 0.25 (in terms of sample rate)
+	static const IIRCoefficient FIR_FAST = 0.000882837778745889f;
+	static const IIRSection SECTIONS_FAST[] = {
+		{ 1.215377077431620f,-0.35864455030878000f,-0.972220718789242f, 0.252934735930620f },
+		{ -1.525654419254140f, 0.86784918631245500f,-0.977713689358124f, 0.376580616703668f },
+		{ 0.136094441564220f,-0.50414116798010400f,-1.007004471865290f, 0.584048854845331f },
+		{ 0.180604082285806f,-0.00467624342403851f,-1.093486919012100f, 0.844904524843996f }
+	};
+
+	static inline BufferedSample calcNumerator(const IIRSection &section, const BufferedSample buffer1, const BufferedSample buffer2) {
+		return section.num1 * buffer1 + section.num2 * buffer2;
+	}
+
+	static inline BufferedSample calcDenominator(const IIRSection &section, const BufferedSample input, const BufferedSample buffer1, const BufferedSample buffer2) {
+		return input - section.den1 * buffer1 - section.den2 * buffer2;
+	}
+
+} // namespace SRCTools
+
+using namespace SRCTools;
+
+double IIRResampler::getPassbandFractionForQuality(Quality quality) {
+	switch (quality) {
+	case FAST:
+		return 0.5;
+	case GOOD:
+		return 0.7708;
+	case BEST:
+		return 0.9524;
+	default:
+		return 0;
+	}
+}
+
+IIRResampler::Constants::Constants(const unsigned int useSectionsCount, const IIRCoefficient useFIR, const IIRSection useSections[], const Quality quality) {
+	if (quality == CUSTOM) {
+		sectionsCount = useSectionsCount;
+		fir = useFIR;
+		sections = useSections;
+	} else {
+		unsigned int sectionsSize;
+		switch (quality) {
+		case FAST:
+			fir = FIR_FAST;
+			sections = SECTIONS_FAST;
+			sectionsSize = sizeof(SECTIONS_FAST);
+			break;
+		case GOOD:
+			fir = FIR_GOOD;
+			sections = SECTIONS_GOOD;
+			sectionsSize = sizeof(SECTIONS_GOOD);
+			break;
+		case BEST:
+			fir = FIR_BEST;
+			sections = SECTIONS_BEST;
+			sectionsSize = sizeof(SECTIONS_BEST);
+			break;
+		default:
+			sectionsSize = 0;
+			break;
+		}
+		sectionsCount = (sectionsSize / sizeof(IIRSection));
+	}
+	const unsigned int delayLineSize = IIR_RESAMPER_CHANNEL_COUNT * sectionsCount;
+	buffer = new SectionBuffer[delayLineSize];
+	BufferedSample *s = buffer[0];
+	BufferedSample *e = buffer[delayLineSize];
+	while (s < e) *(s++) = 0;
+}
+
+IIRResampler::IIRResampler(const Quality quality) :
+	constants(0, 0.0f, NULL, quality)
+{}
+
+IIRResampler::IIRResampler(const unsigned int useSectionsCount, const IIRCoefficient useFIR, const IIRSection useSections[]) :
+	constants(useSectionsCount, useFIR, useSections, IIRResampler::CUSTOM)
+{}
+
+IIRResampler::~IIRResampler() {
+	delete[] constants.buffer;
+}
+
+IIR2xInterpolator::IIR2xInterpolator(const Quality quality) :
+	IIRResampler(quality),
+	phase(1)
+{
+	for (unsigned int chIx = 0; chIx < IIR_RESAMPER_CHANNEL_COUNT; ++chIx) {
+		lastInputSamples[chIx] = 0;
+	}
+}
+
+IIR2xInterpolator::IIR2xInterpolator(const unsigned int useSectionsCount, const IIRCoefficient useFIR, const IIRSection useSections[]) :
+	IIRResampler(useSectionsCount, useFIR, useSections),
+	phase(1)
+{
+	for (unsigned int chIx = 0; chIx < IIR_RESAMPER_CHANNEL_COUNT; ++chIx) {
+		lastInputSamples[chIx] = 0;
+	}
+}
+
+void IIR2xInterpolator::process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength) {
+	static const IIRCoefficient INTERPOLATOR_AMP = 2.0;
+
+	while (outLength > 0 && inLength > 0) {
+		SectionBuffer *bufferp = constants.buffer;
+		for (unsigned int chIx = 0; chIx < IIR_RESAMPER_CHANNEL_COUNT; ++chIx) {
+			const FloatSample lastInputSample = lastInputSamples[chIx];
+			const FloatSample inSample = inSamples[chIx];
+			BufferedSample tmpOut = phase == 0 ? 0 : inSample * constants.fir;
+			for (unsigned int i = 0; i < constants.sectionsCount; ++i) {
+				const IIRSection &section = constants.sections[i];
+				SectionBuffer &buffer = *bufferp;
+				// For 2x interpolation, calculation of the numerator reduces to a single multiplication depending on the phase.
+				if (phase == 0) {
+					const BufferedSample numOutSample = section.num1 * lastInputSample;
+					const BufferedSample denOutSample = calcDenominator(section, BIAS + numOutSample, buffer[0], buffer[1]);
+					buffer[1] = denOutSample;
+					tmpOut += denOutSample;
+				} else {
+					const BufferedSample numOutSample = section.num2 * lastInputSample;
+					const BufferedSample denOutSample = calcDenominator(section, BIAS + numOutSample, buffer[1], buffer[0]);
+					buffer[0] = denOutSample;
+					tmpOut += denOutSample;
+				}
+				bufferp++;
+			}
+			*(outSamples++) = FloatSample(INTERPOLATOR_AMP * tmpOut);
+			if (phase > 0) {
+				lastInputSamples[chIx] = inSample;
+			}
+		}
+		outLength--;
+		if (phase > 0) {
+			inSamples += IIR_RESAMPER_CHANNEL_COUNT;
+			inLength--;
+			phase = 0;
+		} else {
+			phase = 1;
+		}
+	}
+}
+
+unsigned int IIR2xInterpolator::estimateInLength(const unsigned int outLength) const {
+	return outLength >> 1;
+}
+
+IIR2xDecimator::IIR2xDecimator(const Quality quality) :
+	IIRResampler(quality)
+{}
+
+IIR2xDecimator::IIR2xDecimator(const unsigned int useSectionsCount, const IIRCoefficient useFIR, const IIRSection useSections[]) :
+	IIRResampler(useSectionsCount, useFIR, useSections)
+{}
+
+void IIR2xDecimator::process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength) {
+	while (outLength > 0 && inLength > 1) {
+		SectionBuffer *bufferp = constants.buffer;
+		for (unsigned int chIx = 0; chIx < IIR_RESAMPER_CHANNEL_COUNT; ++chIx) {
+			BufferedSample tmpOut = inSamples[chIx] * constants.fir;
+			for (unsigned int i = 0; i < constants.sectionsCount; ++i) {
+				const IIRSection &section = constants.sections[i];
+				SectionBuffer &buffer = *bufferp;
+				// For 2x decimation, calculation of the numerator is not performed for odd output samples which are to be omitted.
+				tmpOut += calcNumerator(section, buffer[0], buffer[1]);
+				buffer[1] = calcDenominator(section, BIAS + inSamples[chIx], buffer[0], buffer[1]);
+				buffer[0] = calcDenominator(section, BIAS + inSamples[chIx + IIR_RESAMPER_CHANNEL_COUNT], buffer[1], buffer[0]);
+				bufferp++;
+			}
+			*(outSamples++) = FloatSample(tmpOut);
+		}
+		outLength--;
+		inLength -= 2;
+		inSamples += 2 * IIR_RESAMPER_CHANNEL_COUNT;
+	}
+}
+
+unsigned int IIR2xDecimator::estimateInLength(const unsigned int outLength) const {
+	return outLength << 1;
+}
diff --git a/src/mt32/srchelper/srctools/src/LinearResampler.cpp b/src/mt32/srchelper/srctools/src/LinearResampler.cpp
new file mode 100644
index 00000000..e7b60c62
--- /dev/null
+++ b/src/mt32/srchelper/srctools/src/LinearResampler.cpp
@@ -0,0 +1,47 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "../include/LinearResampler.h"
+
+using namespace SRCTools;
+
+LinearResampler::LinearResampler(double sourceSampleRate, double targetSampleRate) :
+	inputToOutputRatio(sourceSampleRate / targetSampleRate),
+	position(1.0) // Preload delay line which effectively makes resampler zero phase
+{}
+
+void LinearResampler::process(const FloatSample *&inSamples, unsigned int &inLength, FloatSample *&outSamples, unsigned int &outLength) {
+	if (inLength == 0) return;
+	while (outLength > 0) {
+		while (1.0 <= position) {
+			position--;
+			inLength--;
+			for (unsigned int chIx = 0; chIx < LINEAR_RESAMPER_CHANNEL_COUNT; ++chIx) {
+				lastInputSamples[chIx] = *(inSamples++);
+			}
+			if (inLength == 0) return;
+		}
+		for (unsigned int chIx = 0; chIx < LINEAR_RESAMPER_CHANNEL_COUNT; chIx++) {
+			*(outSamples++) = FloatSample(lastInputSamples[chIx] + position * (inSamples[chIx] - lastInputSamples[chIx]));
+		}
+		outLength--;
+		position += inputToOutputRatio;
+	}
+}
+
+unsigned int LinearResampler::estimateInLength(const unsigned int outLength) const {
+	return static_cast<unsigned int>(outLength * inputToOutputRatio);
+}
diff --git a/src/mt32/srchelper/srctools/src/ResamplerModel.cpp b/src/mt32/srchelper/srctools/src/ResamplerModel.cpp
new file mode 100644
index 00000000..44b969cb
--- /dev/null
+++ b/src/mt32/srchelper/srctools/src/ResamplerModel.cpp
@@ -0,0 +1,153 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cmath>
+#include <cstddef>
+
+#include "../include/ResamplerModel.h"
+
+#include "../include/ResamplerStage.h"
+#include "../include/SincResampler.h"
+#include "../include/IIR2xResampler.h"
+#include "../include/LinearResampler.h"
+
+namespace SRCTools {
+
+namespace ResamplerModel {
+
+static const unsigned int CHANNEL_COUNT = 2;
+static const unsigned int MAX_SAMPLES_PER_RUN = 4096;
+
+class CascadeStage : public FloatSampleProvider {
+friend void freeResamplerModel(FloatSampleProvider &model, FloatSampleProvider &source);
+public:
+	CascadeStage(FloatSampleProvider &source, ResamplerStage &resamplerStage);
+
+	void getOutputSamples(FloatSample *outBuffer, unsigned int size);
+
+protected:
+	ResamplerStage &resamplerStage;
+
+private:
+	FloatSampleProvider &source;
+	FloatSample buffer[CHANNEL_COUNT * MAX_SAMPLES_PER_RUN];
+	const FloatSample *bufferPtr;
+	unsigned int size;
+};
+
+class InternalResamplerCascadeStage : public CascadeStage {
+public:
+	InternalResamplerCascadeStage(FloatSampleProvider &useSource, ResamplerStage &useResamplerStage) :
+		CascadeStage(useSource, useResamplerStage)
+	{}
+
+	~InternalResamplerCascadeStage() {
+		delete &resamplerStage;
+	}
+};
+
+} // namespace ResamplerModel
+
+} // namespace SRCTools
+
+using namespace SRCTools;
+
+FloatSampleProvider &ResamplerModel::createResamplerModel(FloatSampleProvider &source, double sourceSampleRate, double targetSampleRate, Quality quality) {
+	if (sourceSampleRate == targetSampleRate) {
+		return source;
+	}
+	if (quality == FASTEST) {
+		return *new InternalResamplerCascadeStage(source, *new LinearResampler(sourceSampleRate, targetSampleRate));
+	}
+	const IIRResampler::Quality iirQuality = static_cast<IIRResampler::Quality>(quality);
+	const double iirPassbandFraction = IIRResampler::getPassbandFractionForQuality(iirQuality);
+	if (sourceSampleRate < targetSampleRate) {
+		ResamplerStage *iir2xInterpolator = new IIR2xInterpolator(iirQuality);
+		FloatSampleProvider &iir2xInterpolatorStage = *new InternalResamplerCascadeStage(source, *iir2xInterpolator);
+
+		if (2.0 * sourceSampleRate == targetSampleRate) {
+			return iir2xInterpolatorStage;
+		}
+
+		double passband = 0.5 * sourceSampleRate * iirPassbandFraction;
+		double stopband = 1.5 * sourceSampleRate;
+		ResamplerStage *sincResampler = SincResampler::createSincResampler(2.0 * sourceSampleRate, targetSampleRate, passband, stopband, DEFAULT_DB_SNR, DEFAULT_WINDOWED_SINC_MAX_UPSAMPLE_FACTOR);
+		return *new InternalResamplerCascadeStage(iir2xInterpolatorStage, *sincResampler);
+	}
+
+	if (sourceSampleRate == 2.0 * targetSampleRate) {
+		ResamplerStage *iir2xDecimator = new IIR2xDecimator(iirQuality);
+		return *new InternalResamplerCascadeStage(source, *iir2xDecimator);
+	}
+
+	double passband = 0.5 * targetSampleRate * iirPassbandFraction;
+	double stopband = 1.5 * targetSampleRate;
+	double sincOutSampleRate = 2.0 * targetSampleRate;
+	const unsigned int maxUpsampleFactor = static_cast<unsigned int>(ceil(DEFAULT_WINDOWED_SINC_MAX_DOWNSAMPLE_FACTOR * sincOutSampleRate / sourceSampleRate));
+	ResamplerStage *sincResampler = SincResampler::createSincResampler(sourceSampleRate, sincOutSampleRate, passband, stopband, DEFAULT_DB_SNR, maxUpsampleFactor);
+	FloatSampleProvider &sincResamplerStage = *new InternalResamplerCascadeStage(source, *sincResampler);
+
+	ResamplerStage *iir2xDecimator = new IIR2xDecimator(iirQuality);
+	return *new InternalResamplerCascadeStage(sincResamplerStage, *iir2xDecimator);
+}
+
+FloatSampleProvider &ResamplerModel::createResamplerModel(FloatSampleProvider &source, ResamplerStage **resamplerStages, unsigned int stageCount) {
+	FloatSampleProvider *prevStage = &source;
+	for (unsigned int i = 0; i < stageCount; i++) {
+		prevStage = new CascadeStage(*prevStage, *(resamplerStages[i]));
+	}
+	return *prevStage;
+}
+
+FloatSampleProvider &ResamplerModel::createResamplerModel(FloatSampleProvider &source, ResamplerStage &stage) {
+	return *new CascadeStage(source, stage);
+}
+
+void ResamplerModel::freeResamplerModel(FloatSampleProvider &model, FloatSampleProvider &source) {
+	FloatSampleProvider *currentStage = &model;
+	while (currentStage != &source) {
+		CascadeStage *cascadeStage = dynamic_cast<CascadeStage *>(currentStage);
+		if (cascadeStage == NULL) return;
+		FloatSampleProvider &prevStage = cascadeStage->source;
+		delete currentStage;
+		currentStage = &prevStage;
+	}
+}
+
+using namespace ResamplerModel;
+
+CascadeStage::CascadeStage(FloatSampleProvider &useSource, ResamplerStage &useResamplerStage) :
+	resamplerStage(useResamplerStage),
+	source(useSource),
+	bufferPtr(buffer),
+	size()
+{}
+
+void CascadeStage::getOutputSamples(FloatSample *outBuffer, unsigned int length) {
+	while (length > 0) {
+		if (size == 0) {
+			size = resamplerStage.estimateInLength(length);
+			if (size < 1) {
+				size = 1;
+			} else if (MAX_SAMPLES_PER_RUN < size) {
+				size = MAX_SAMPLES_PER_RUN;
+			}
+			source.getOutputSamples(buffer, size);
+			bufferPtr = buffer;
+		}
+		resamplerStage.process(bufferPtr, size, outBuffer, length);
+	}
+}
diff --git a/src/mt32/srchelper/srctools/src/SincResampler.cpp b/src/mt32/srchelper/srctools/src/SincResampler.cpp
new file mode 100644
index 00000000..fff27037
--- /dev/null
+++ b/src/mt32/srchelper/srctools/src/SincResampler.cpp
@@ -0,0 +1,136 @@
+/* Copyright (C) 2015-2017 Sergey V. Mikayev
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <cmath>
+
+#ifdef SRCTOOLS_SINC_RESAMPLER_DEBUG_LOG
+#include <iostream>
+#endif
+
+#include "../include/SincResampler.h"
+
+#ifndef M_PI
+static const double M_PI = 3.1415926535897932;
+#endif
+
+using namespace SRCTools;
+
+using namespace SincResampler;
+
+using namespace Utils;
+
+void Utils::computeResampleFactors(unsigned int &upsampleFactor, double &downsampleFactor, const double inputFrequency, const double outputFrequency, const unsigned int maxUpsampleFactor) {
+	static const double RATIONAL_RATIO_ACCURACY_FACTOR = 1E15;
+
+	upsampleFactor = static_cast<unsigned int>(outputFrequency);
+	unsigned int downsampleFactorInt = static_cast<unsigned int>(inputFrequency);
+	if ((upsampleFactor == outputFrequency) && (downsampleFactorInt == inputFrequency)) {
+		// Input and output frequencies are integers, try to reduce them
+		const unsigned int gcd = greatestCommonDivisor(upsampleFactor, downsampleFactorInt);
+		if (gcd > 1) {
+			upsampleFactor /= gcd;
+			downsampleFactor = downsampleFactorInt / gcd;
+		} else {
+			downsampleFactor = downsampleFactorInt;
+		}
+		if (upsampleFactor <= maxUpsampleFactor) return;
+	} else {
+		// Try to recover rational resample ratio by brute force
+		double inputToOutputRatio = inputFrequency / outputFrequency;
+		for (unsigned int i = 1; i <= maxUpsampleFactor; ++i) {
+			double testFactor = inputToOutputRatio * i;
+			if (floor(RATIONAL_RATIO_ACCURACY_FACTOR * testFactor + 0.5) == RATIONAL_RATIO_ACCURACY_FACTOR * floor(testFactor + 0.5)) {
+				// inputToOutputRatio found to be rational within the accuracy
+				upsampleFactor = i;
+				downsampleFactor = floor(testFactor + 0.5);
+				return;
+			}
+		}
+	}
+	// Use interpolation of FIR taps as the last resort
+	upsampleFactor = maxUpsampleFactor;
+	downsampleFactor = maxUpsampleFactor * inputFrequency / outputFrequency;
+}
+
+unsigned int Utils::greatestCommonDivisor(unsigned int a, unsigned int b) {
+	while (0 < b) {
+		unsigned int r = a % b;
+		a = b;
+		b = r;
+	}
+	return a;
+}
+
+double KaizerWindow::estimateBeta(double dbRipple) {
+	return 0.1102 * (dbRipple - 8.7);
+}
+
+unsigned int KaizerWindow::estimateOrder(double dbRipple, double fp, double fs) {
+	const double transBW = (fs - fp);
+	return static_cast<unsigned int>(ceil((dbRipple - 8) / (2.285 * 2 * M_PI * transBW)));
+}
+
+double KaizerWindow::bessel(const double x) {
+	static const double EPS = 1.11E-16;
+
+	double sum = 0.0;
+	double f = 1.0;
+	for (unsigned int i = 1;; ++i) {
+		f *= (0.5 * x / i);
+		double f2 = f * f;
+		if (f2 <= sum * EPS) break;
+		sum += f2;
+	}
+	return 1.0 + sum;
+}
+
+void KaizerWindow::windowedSinc(FIRCoefficient kernel[], const unsigned int order, const double fc, const double beta, const double amp) {
+	const double fc_pi = M_PI * fc;
+	const double recipOrder = 1.0 / order;
+	const double mult = 2.0 * fc * amp / bessel(beta);
+	for (int i = order, j = 0; 0 <= i; i -= 2, ++j) {
+		double xw = i * recipOrder;
+		double win = bessel(beta * sqrt(fabs(1.0 - xw * xw)));
+		double xs = i * fc_pi;
+		double sinc = (i == 0) ? 1.0 : sin(xs) / xs;
+		FIRCoefficient imp = FIRCoefficient(mult * sinc * win);
+		kernel[j] = imp;
+		kernel[order - j] = imp;
+	}
+}
+
+ResamplerStage *SincResampler::createSincResampler(const double inputFrequency, const double outputFrequency, const double passbandFrequency, const double stopbandFrequency, const double dbSNR, const unsigned int maxUpsampleFactor) {
+	unsigned int upsampleFactor;
+	double downsampleFactor;
+	computeResampleFactors(upsampleFactor, downsampleFactor, inputFrequency, outputFrequency, maxUpsampleFactor);
+	double baseSamplePeriod = 1.0 / (inputFrequency * upsampleFactor);
+	double fp = passbandFrequency * baseSamplePeriod;
+	double fs = stopbandFrequency * baseSamplePeriod;
+	double fc = 0.5 * (fp + fs);
+	double beta = KaizerWindow::estimateBeta(dbSNR);
+	unsigned int order = KaizerWindow::estimateOrder(dbSNR, fp, fs);
+	const unsigned int kernelLength = order + 1;
+
+#ifdef SRCTOOLS_SINC_RESAMPLER_DEBUG_LOG
+	std::clog << "FIR: " << upsampleFactor << "/" << downsampleFactor << ", N=" << kernelLength << ", NPh=" << kernelLength / double(upsampleFactor) << ", C=" << 0.5 / fc << ", fp=" << fp << ", fs=" << fs << ", M=" << maxUpsampleFactor << std::endl;
+#endif
+
+	FIRCoefficient *windowedSincKernel = new FIRCoefficient[kernelLength];
+	KaizerWindow::windowedSinc(windowedSincKernel, order, fc, beta, upsampleFactor);
+	ResamplerStage *windowedSincStage = new FIRResampler(upsampleFactor, downsampleFactor, windowedSincKernel, kernelLength);
+	delete[] windowedSincKernel;
+	return windowedSincStage;
+}
-- 
2.16.2.windows.1


From 0401c2cf899aa9e72dcfdffdbe266d46ab0711a2 Mon Sep 17 00:00:00 2001
From: Heydojo <white.tw.tw@gmail.com>
Date: Thu, 15 Mar 2018 13:28:31 +0000
Subject: [PATCH 2/8] dosbox.cpp patch for libmt32emu_2_3_0

---
 src/dosbox.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/dosbox.cpp b/src/dosbox.cpp
index a44331cd..9a728afb 100644
--- a/src/dosbox.cpp
+++ b/src/dosbox.cpp
@@ -74,6 +74,7 @@
 #include "pci_bus.h"
 #include "parport.h"
 #include "clockdomain.h"
+#include "mt32options.h
 
 #ifdef WIN32
 #define WIN32_LEAN_AND_MEAN
-- 
2.16.2.windows.1


From bd3b4bb52ed1523c4cf3ea41cd6fca92260a71c6 Mon Sep 17 00:00:00 2001
From: Heydojo <white.tw.tw@gmail.com>
Date: Thu, 15 Mar 2018 13:36:40 +0000
Subject: [PATCH 3/8] gui/Makefile patch for libmt32emu_2_3_0

---
 src/gui/Makefile.am | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gui/Makefile.am b/src/gui/Makefile.am
index 676657dd..e9ddadf6 100644
--- a/src/gui/Makefile.am
+++ b/src/gui/Makefile.am
@@ -17,6 +17,6 @@ if C_MT32
 AM_CPPFLAGS += -I$(top_srcdir)/src/mt32
 
 libgui_a_SOURCES += \
-	midi_mt32.h
+	midi_mt32.h midi_mt32.cpp
 endif
 
-- 
2.16.2.windows.1


From 28a56af650bdba2a2f98d6a9150a97636be3e20b Mon Sep 17 00:00:00 2001
From: Heydojo <white.tw.tw@gmail.com>
Date: Thu, 15 Mar 2018 13:44:02 +0000
Subject: [PATCH 4/8] gui/midi.cpp patch for libmt32emu_2_3_0

---
 src/gui/midi.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gui/midi.cpp b/src/gui/midi.cpp
index d0fc613f..aa0c599e 100644
--- a/src/gui/midi.cpp
+++ b/src/gui/midi.cpp
@@ -128,6 +128,7 @@ static struct {
 
 #if C_MT32
 #include "midi_mt32.h"
+static MidiHandler_mt32 &Midi_mt32 = MidiHandler_mt32::GetInstance();
 #endif
 
 #if C_FLUIDSYNTH
-- 
2.16.2.windows.1


From b396fc62f778b61b91fc48cf7563f50ef8c6ced9 Mon Sep 17 00:00:00 2001
From: Heydojo <white.tw.tw@gmail.com>
Date: Thu, 15 Mar 2018 13:59:27 +0000
Subject: [PATCH 5/8] midi_mt32.cpp patch for libmt32emu_2_3_0

---
 src/gui/midi_mt32.cpp | 299 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 299 insertions(+)
 create mode 100644 src/gui/midi_mt32.cpp

diff --git a/src/gui/midi_mt32.cpp b/src/gui/midi_mt32.cpp
new file mode 100644
index 00000000..112d6adb
--- /dev/null
+++ b/src/gui/midi_mt32.cpp
@@ -0,0 +1,299 @@
+#include <SDL_thread.h>
+#include <SDL_endian.h>
+#include "control.h"
+
+#ifndef DOSBOX_MIDI_H
+#include "midi.h"
+#endif
+
+#include "midi_mt32.h"
+
+static const Bitu MILLIS_PER_SECOND = 1000;
+
+MidiHandler_mt32 &MidiHandler_mt32::GetInstance() {
+	static MidiHandler_mt32 midiHandler_mt32;
+	return midiHandler_mt32;
+}
+
+const char *MidiHandler_mt32::GetName(void) {
+	return "mt32";
+}
+
+bool MidiHandler_mt32::Open(const char *conf) {
+	service = new MT32Emu::Service();
+	Bit32u version = service->getLibraryVersionInt();
+	if (version < 0x020100) {
+		delete service;
+		service = NULL;
+		LOG_MSG("MT32: libmt32emu version is too old: %s", service->getLibraryVersionString());
+		return false;
+	}
+	service->createContext(getReportHandlerInterface(), this);
+	mt32emu_return_code rc;
+
+	Section_prop *section = static_cast<Section_prop *>(control->GetSection("midi"));
+	const char *romDir = section->Get_string("mt32.romdir");
+	if (romDir == NULL) romDir = "./"; // Paranoid NULL-check, should never happen
+	size_t romDirLen = strlen(romDir);
+	bool addPathSeparator = false;
+	if (romDirLen < 1) {
+		romDir = "./";
+	} else if (4080 < romDirLen) {
+		LOG_MSG("MT32: mt32.romdir is too long, using the current dir.");
+		romDir = "./";
+	} else {
+		char lastChar = romDir[strlen(romDir) - 1];
+		addPathSeparator = lastChar != '/' && lastChar != '\\';
+	}
+
+	char pathName[4096];
+
+	makeROMPathName(pathName, romDir, "CM32L_CONTROL.ROM", addPathSeparator);
+	if (MT32EMU_RC_ADDED_CONTROL_ROM != service->addROMFile(pathName)) {
+		makeROMPathName(pathName, romDir, "MT32_CONTROL.ROM", addPathSeparator);
+		if (MT32EMU_RC_ADDED_CONTROL_ROM != service->addROMFile(pathName)) {
+			delete service;
+			service = NULL;
+			LOG_MSG("MT32: Control ROM file not found");
+			return false;
+		}
+	}
+	makeROMPathName(pathName, romDir, "CM32L_PCM.ROM", addPathSeparator);
+	if (MT32EMU_RC_ADDED_PCM_ROM != service->addROMFile(pathName)) {
+		makeROMPathName(pathName, romDir, "MT32_PCM.ROM", addPathSeparator);
+		if (MT32EMU_RC_ADDED_PCM_ROM != service->addROMFile(pathName)) {
+			delete service;
+			service = NULL;
+			LOG_MSG("MT32: PCM ROM file not found");
+			return false;
+		}
+	}
+
+	service->setPartialCount(Bit32u(section->Get_int("mt32.partials")));
+	service->setAnalogOutputMode((MT32Emu::AnalogOutputMode)section->Get_int("mt32.analog"));
+	int sampleRate = section->Get_int("mt32.rate");
+	service->setStereoOutputSampleRate(sampleRate);
+	service->setSamplerateConversionQuality((MT32Emu::SamplerateConversionQuality)section->Get_int("mt32.src.quality"));
+
+	if (MT32EMU_RC_OK != (rc = service->openSynth())) {
+		delete service;
+		service = NULL;
+		LOG_MSG("MT32: Error initialising emulation: %i", rc);
+		return false;
+	}
+
+	if (strcmp(section->Get_string("mt32.reverb.mode"), "auto") != 0) {
+		Bit8u reverbsysex[] = {0x10, 0x00, 0x01, 0x00, 0x05, 0x03};
+		reverbsysex[3] = (Bit8u)atoi(section->Get_string("mt32.reverb.mode"));
+		reverbsysex[4] = (Bit8u)section->Get_int("mt32.reverb.time");
+		reverbsysex[5] = (Bit8u)section->Get_int("mt32.reverb.level");
+		service->writeSysex(16, reverbsysex, 6);
+		service->setReverbOverridden(true);
+	}
+
+	service->setDACInputMode((MT32Emu::DACInputMode)section->Get_int("mt32.dac"));
+
+	service->setReversedStereoEnabled(section->Get_bool("mt32.reverse.stereo"));
+	service->setNiceAmpRampEnabled(section->Get_bool("mt32.niceampramp"));
+	noise = section->Get_bool("mt32.verbose");
+	renderInThread = section->Get_bool("mt32.thread");
+
+	if (noise) LOG_MSG("MT32: Set maximum number of partials %d", service->getPartialCount());
+
+	if (noise) LOG_MSG("MT32: Adding mixer channel at sample rate %d", sampleRate);
+	chan = MIXER_AddChannel(mixerCallBack, sampleRate, "MT32");
+
+	if (renderInThread) {
+		stopProcessing = false;
+		playPos = 0;
+		int chunkSize = section->Get_int("mt32.chunk");
+		minimumRenderFrames = (chunkSize * sampleRate) / MILLIS_PER_SECOND;
+		int latency = section->Get_int("mt32.prebuffer");
+		if (latency <= chunkSize) {
+			latency = 2 * chunkSize;
+			LOG_MSG("MT32: chunk length must be less than prebuffer length, prebuffer length reset to %i ms.", latency);
+		}
+		framesPerAudioBuffer = (latency * sampleRate) / MILLIS_PER_SECOND;
+		audioBufferSize = framesPerAudioBuffer << 1;
+		audioBuffer = new Bit16s[audioBufferSize];
+		service->renderBit16s(audioBuffer, framesPerAudioBuffer - 1);
+		renderPos = (framesPerAudioBuffer - 1) << 1;
+		playedBuffers = 1;
+		lock = SDL_CreateMutex();
+		framesInBufferChanged = SDL_CreateCond();
+		thread = SDL_CreateThread(processingThread, NULL);
+	}
+	chan->Enable(true);
+
+	open = true;
+	return true;
+}
+
+void MidiHandler_mt32::Close(void) {
+	if (!open) return;
+	chan->Enable(false);
+	if (renderInThread) {
+		stopProcessing = true;
+		SDL_LockMutex(lock);
+		SDL_CondSignal(framesInBufferChanged);
+		SDL_UnlockMutex(lock);
+		SDL_WaitThread(thread, NULL);
+		thread = NULL;
+		SDL_DestroyMutex(lock);
+		lock = NULL;
+		SDL_DestroyCond(framesInBufferChanged);
+		framesInBufferChanged = NULL;
+		delete[] audioBuffer;
+		audioBuffer = NULL;
+	}
+	MIXER_DelChannel(chan);
+	chan = NULL;
+	service->closeSynth();
+	delete service;
+	service = NULL;
+	open = false;
+}
+
+void MidiHandler_mt32::PlayMsg(Bit8u *msg) {
+	if (renderInThread) {
+		service->playMsgAt(SDL_SwapLE32(*(Bit32u *)msg), getMidiEventTimestamp());
+	} else {
+		service->playMsg(SDL_SwapLE32(*(Bit32u *)msg));
+	}
+}
+
+void MidiHandler_mt32::PlaySysex(Bit8u *sysex, Bitu len) {
+	if (renderInThread) {
+		service->playSysexAt(sysex, len, getMidiEventTimestamp());
+	} else {
+		service->playSysex(sysex, len);
+	}
+}
+
+void MidiHandler_mt32::mixerCallBack(Bitu len) {
+	MidiHandler_mt32::GetInstance().handleMixerCallBack(len);
+}
+
+int MidiHandler_mt32::processingThread(void *) {
+	MidiHandler_mt32::GetInstance().renderingLoop();
+	return 0;
+}
+
+void MidiHandler_mt32::makeROMPathName(char pathName[], const char romDir[], const char fileName[], bool addPathSeparator) {
+	strcpy(pathName, romDir);
+	if (addPathSeparator) {
+		strcat(pathName, "/");
+	}
+	strcat(pathName, fileName);
+}
+
+mt32emu_report_handler_i MidiHandler_mt32::getReportHandlerInterface() {
+	class ReportHandler {
+	public:
+		static mt32emu_report_handler_version getReportHandlerVersionID(mt32emu_report_handler_i) {
+			return MT32EMU_REPORT_HANDLER_VERSION_0;
+		}
+
+		static void printDebug(void *instance_data, const char *fmt, va_list list) {
+			MidiHandler_mt32 &midiHandler_mt32 = *(MidiHandler_mt32 *)instance_data;
+			if (midiHandler_mt32.noise) {
+				char s[1024];
+				vsnprintf(s, 1023, fmt, list);
+				LOG_MSG("MT32: %s", s);
+			}
+		}
+
+		static void onErrorControlROM(void *) {
+			LOG_MSG("MT32: Couldn't open Control ROM file");
+		}
+
+		static void onErrorPCMROM(void *) {
+			LOG_MSG("MT32: Couldn't open PCM ROM file");
+		}
+
+		static void showLCDMessage(void *, const char *message) {
+			LOG_MSG("MT32: LCD-Message: %s", message);
+		}
+	};
+
+	static const mt32emu_report_handler_i_v0 REPORT_HANDLER_V0_IMPL = {
+		ReportHandler::getReportHandlerVersionID,
+		ReportHandler::printDebug,
+		ReportHandler::onErrorControlROM,
+		ReportHandler::onErrorPCMROM,
+		ReportHandler::showLCDMessage
+	};
+
+	static const mt32emu_report_handler_i REPORT_HANDLER_I = { &REPORT_HANDLER_V0_IMPL };
+
+	return REPORT_HANDLER_I;
+}
+
+MidiHandler_mt32::MidiHandler_mt32() : open(false), chan(NULL), service(NULL), thread(NULL) {
+}
+
+MidiHandler_mt32::~MidiHandler_mt32() {
+	Close();
+}
+
+void MidiHandler_mt32::handleMixerCallBack(Bitu len) {
+	if (renderInThread) {
+		while (renderPos == playPos) {
+			SDL_LockMutex(lock);
+			SDL_CondWait(framesInBufferChanged, lock);
+			SDL_UnlockMutex(lock);
+			if (stopProcessing) return;
+		}
+		Bitu renderPosSnap = renderPos;
+		Bitu playPosSnap = playPos;
+		Bitu samplesReady = (renderPosSnap < playPosSnap) ? audioBufferSize - playPosSnap : renderPosSnap - playPosSnap;
+		if (len > (samplesReady >> 1)) {
+			len = samplesReady >> 1;
+		}
+		chan->AddSamples_s16(len, audioBuffer + playPosSnap);
+		playPosSnap += (len << 1);
+		while (audioBufferSize <= playPosSnap) {
+			playPosSnap -= audioBufferSize;
+			playedBuffers++;
+		}
+		playPos = playPosSnap;
+		renderPosSnap = renderPos;
+		const Bitu samplesFree = (renderPosSnap < playPosSnap) ? playPosSnap - renderPosSnap : audioBufferSize + playPosSnap - renderPosSnap;
+		if (minimumRenderFrames <= (samplesFree >> 1)) {
+			SDL_LockMutex(lock);
+			SDL_CondSignal(framesInBufferChanged);
+			SDL_UnlockMutex(lock);
+		}
+	} else {
+		service->renderBit16s((Bit16s *)MixTemp, len);
+		chan->AddSamples_s16(len, (Bit16s *)MixTemp);
+	}
+}
+
+void MidiHandler_mt32::renderingLoop() {
+	while (!stopProcessing) {
+		const Bitu renderPosSnap = renderPos;
+		const Bitu playPosSnap = playPos;
+		Bitu samplesToRender;
+		if (renderPosSnap < playPosSnap) {
+			samplesToRender = playPosSnap - renderPosSnap - 2;
+		} else {
+			samplesToRender = audioBufferSize - renderPosSnap;
+			if (playPosSnap == 0) samplesToRender -= 2;
+		}
+		Bitu framesToRender = samplesToRender >> 1;
+		if ((framesToRender == 0) || ((framesToRender < minimumRenderFrames) && (renderPosSnap < playPosSnap))) {
+			SDL_LockMutex(lock);
+			SDL_CondWait(framesInBufferChanged, lock);
+			SDL_UnlockMutex(lock);
+		} else {
+			service->renderBit16s(audioBuffer + renderPosSnap, framesToRender);
+			renderPos = (renderPosSnap + samplesToRender) % audioBufferSize;
+			if (renderPosSnap == playPos) {
+				SDL_LockMutex(lock);
+				SDL_CondSignal(framesInBufferChanged);
+				SDL_UnlockMutex(lock);
+			}
+		}
+	}
+}
\ No newline at end of file
-- 
2.16.2.windows.1


From 3dd3dd9bfc2707bf7322d731619e095029ea6464 Mon Sep 17 00:00:00 2001
From: Heydojo <white.tw.tw@gmail.com>
Date: Thu, 15 Mar 2018 15:42:14 +0000
Subject: [PATCH 6/8] midi_mt32.h patch for libmt32emu_2_3_0

---
 src/gui/midi_mt32.cpp |  34 +++---
 src/gui/midi_mt32.h   | 295 ++++++--------------------------------------------
 2 files changed, 55 insertions(+), 274 deletions(-)

diff --git a/src/gui/midi_mt32.cpp b/src/gui/midi_mt32.cpp
index 112d6adb..866c3c23 100644
--- a/src/gui/midi_mt32.cpp
+++ b/src/gui/midi_mt32.cpp
@@ -25,7 +25,7 @@ bool MidiHandler_mt32::Open(const char *conf) {
 	if (version < 0x020100) {
 		delete service;
 		service = NULL;
-		LOG_MSG("MT32: libmt32emu version is too old: %s", service->getLibraryVersionString());
+		LOG(LOG_MISC,LOG_WARN)("MT32: libmt32emu version is too old: %s", service->getLibraryVersionString());
 		return false;
 	}
 	service->createContext(getReportHandlerInterface(), this);
@@ -39,7 +39,7 @@ bool MidiHandler_mt32::Open(const char *conf) {
 	if (romDirLen < 1) {
 		romDir = "./";
 	} else if (4080 < romDirLen) {
-		LOG_MSG("MT32: mt32.romdir is too long, using the current dir.");
+		LOG(LOG_MISC,LOG_WARN)("MT32: mt32.romdir is too long, using the current dir.");
 		romDir = "./";
 	} else {
 		char lastChar = romDir[strlen(romDir) - 1];
@@ -54,7 +54,7 @@ bool MidiHandler_mt32::Open(const char *conf) {
 		if (MT32EMU_RC_ADDED_CONTROL_ROM != service->addROMFile(pathName)) {
 			delete service;
 			service = NULL;
-			LOG_MSG("MT32: Control ROM file not found");
+			LOG(LOG_MISC,LOG_WARN)("MT32: Control ROM file not found");
 			return false;
 		}
 	}
@@ -64,7 +64,7 @@ bool MidiHandler_mt32::Open(const char *conf) {
 		if (MT32EMU_RC_ADDED_PCM_ROM != service->addROMFile(pathName)) {
 			delete service;
 			service = NULL;
-			LOG_MSG("MT32: PCM ROM file not found");
+			LOG(LOG_MISC,LOG_WARN)("MT32: PCM ROM file not found");
 			return false;
 		}
 	}
@@ -78,7 +78,7 @@ bool MidiHandler_mt32::Open(const char *conf) {
 	if (MT32EMU_RC_OK != (rc = service->openSynth())) {
 		delete service;
 		service = NULL;
-		LOG_MSG("MT32: Error initialising emulation: %i", rc);
+		LOG(LOG_MISC,LOG_WARN)("MT32: Error initialising emulation: %i", rc);
 		return false;
 	}
 
@@ -98,9 +98,9 @@ bool MidiHandler_mt32::Open(const char *conf) {
 	noise = section->Get_bool("mt32.verbose");
 	renderInThread = section->Get_bool("mt32.thread");
 
-	if (noise) LOG_MSG("MT32: Set maximum number of partials %d", service->getPartialCount());
+	if (noise) LOG(LOG_MISC,LOG_WARN)("MT32: Set maximum number of partials %d", service->getPartialCount());
 
-	if (noise) LOG_MSG("MT32: Adding mixer channel at sample rate %d", sampleRate);
+	if (noise) LOG(LOG_MISC,LOG_WARN)("MT32: Adding mixer channel at sample rate %d", sampleRate);
 	chan = MIXER_AddChannel(mixerCallBack, sampleRate, "MT32");
 
 	if (renderInThread) {
@@ -111,7 +111,7 @@ bool MidiHandler_mt32::Open(const char *conf) {
 		int latency = section->Get_int("mt32.prebuffer");
 		if (latency <= chunkSize) {
 			latency = 2 * chunkSize;
-			LOG_MSG("MT32: chunk length must be less than prebuffer length, prebuffer length reset to %i ms.", latency);
+			LOG(LOG_MISC,LOG_WARN)("MT32: chunk length must be less than prebuffer length, prebuffer length reset to %i ms.", latency);
 		}
 		framesPerAudioBuffer = (latency * sampleRate) / MILLIS_PER_SECOND;
 		audioBufferSize = framesPerAudioBuffer << 1;
@@ -199,20 +199,28 @@ mt32emu_report_handler_i MidiHandler_mt32::getReportHandlerInterface() {
 			if (midiHandler_mt32.noise) {
 				char s[1024];
 				vsnprintf(s, 1023, fmt, list);
-				LOG_MSG("MT32: %s", s);
+				LOG(LOG_MISC,LOG_WARN)("MT32: %s", s);
 			}
 		}
 
 		static void onErrorControlROM(void *) {
-			LOG_MSG("MT32: Couldn't open Control ROM file");
+			LOG(LOG_MISC,LOG_WARN)("MT32: Couldn't open Control ROM file");
+			LOG(LOG_MISC,LOG_WARN)("MT32 emulation cannot work without the CONTROL ROM files.");
+			LOG(LOG_MISC,LOG_WARN)("To eliminate this error message, either change mididevice= to something else, or");
+			LOG(LOG_MISC,LOG_WARN)("point the emulator to the directory containing");
+			LOG(LOG_MISC,LOG_WARN)("CM32L_CONTROL.ROM and MT32_CONTROL.ROM using the romdir= configuration option");
 		}
 
 		static void onErrorPCMROM(void *) {
-			LOG_MSG("MT32: Couldn't open PCM ROM file");
+			LOG(LOG_MISC,LOG_WARN)("MT32: Couldn't open PCM ROM file");
+			LOG(LOG_MISC,LOG_WARN)("MT32 emulation cannot work without the PCM ROM files.");
+			LOG(LOG_MISC,LOG_WARN)("To eliminate this error message, either change mididevice= to something else, or");
+			LOG(LOG_MISC,LOG_WARN)("point the emulator to the directory containing");
+			LOG(LOG_MISC,LOG_WARN)("CM32L_PCM.ROM and MT32_PCM.ROM using the romdir= configuration option");
 		}
 
 		static void showLCDMessage(void *, const char *message) {
-			LOG_MSG("MT32: LCD-Message: %s", message);
+			LOG(LOG_MISC,LOG_DEBUG)("MT32: LCD-Message: %s", message);
 		}
 	};
 
@@ -229,7 +237,7 @@ mt32emu_report_handler_i MidiHandler_mt32::getReportHandlerInterface() {
 	return REPORT_HANDLER_I;
 }
 
-MidiHandler_mt32::MidiHandler_mt32() : open(false), chan(NULL), service(NULL), thread(NULL) {
+MidiHandler_mt32::MidiHandler_mt32() : chan(NULL), service(NULL), thread(NULL), open(false) {
 }
 
 MidiHandler_mt32::~MidiHandler_mt32() {
diff --git a/src/gui/midi_mt32.h b/src/gui/midi_mt32.h
index 95a8712a..c9d790ae 100644
--- a/src/gui/midi_mt32.h
+++ b/src/gui/midi_mt32.h
@@ -1,280 +1,53 @@
+#ifndef DOSBOX_MIDI_MT32_H
+#define DOSBOX_MIDI_MT32_H
+#define MT32EMU_API_TYPE 3
 #include "mt32emu.h"
-#include <SDL_thread.h>
-#include <SDL_timer.h>
 #include "mixer.h"
-#include "control.h"
 
-class RingBuffer {
-private:
-	static const unsigned int bufferSize = 1024;
-	volatile unsigned int startpos;
-	volatile unsigned int endpos;
-	Bit64u ringBuffer[bufferSize];
+#if MT32EMU_VERSION_MAJOR != 2 || MT32EMU_VERSION_MINOR < 1
+#error Incompatible mt32emu library version
+#endif
 
-public:
-	RingBuffer() {
-		startpos = 0;
-		endpos = 0;
-	}
+struct SDL_Thread;
 
-	bool put(Bit32u data) {
-		unsigned int newEndpos = endpos;
-		newEndpos++;
-		if (newEndpos == bufferSize) newEndpos = 0;
-		if (startpos == newEndpos) return false;
-		ringBuffer[endpos] = data;
-		endpos = newEndpos;
-		return true;
-	}
+class MidiHandler_mt32 : public MidiHandler {
+public:
+	static MidiHandler_mt32 &GetInstance(void);
 
-	Bit32u get() {
-		if (startpos == endpos) return 0;
-		Bit32u data = (Bit32u)ringBuffer[startpos]; /* <- FIXME: Um.... really? */
-		startpos++;
-		if (startpos == bufferSize) startpos = 0;
-		return data;
-	}
-	void reset() {
-		startpos = 0;
-		endpos = 0;
-	}
-};
+	const char *GetName(void);
+	bool Open(const char *conf);
+	void Close(void);
+	void PlayMsg(Bit8u *msg);
+	void PlaySysex(Bit8u *sysex, Bitu len);
 
-static class MidiHandler_mt32 : public MidiHandler {
 private:
-	static const Bitu MIXER_BUFFER_SIZE = MIXER_BUFSIZE >> 2;
 	MixerChannel *chan;
-	MT32Emu::Synth *synth;
-	RingBuffer midiBuffer;
+	MT32Emu::Service *service;
 	SDL_Thread *thread;
-	SDL_mutex *synthMutex;
-	SDL_semaphore *procIdleSem, *mixerReqSem;
-	Bit16s mixerBuffer[2 * MIXER_BUFFER_SIZE];
-	volatile Bitu mixerBufferSize;
+	SDL_mutex *lock;
+	SDL_cond *framesInBufferChanged;
+	Bit16s *audioBuffer;
+	Bitu audioBufferSize;
+	Bitu framesPerAudioBuffer;
+	Bitu minimumRenderFrames;
+	volatile Bitu renderPos, playPos, playedBuffers;
 	volatile bool stopProcessing;
-	bool open, noise, reverseStereo, renderInThread;
-	Bit16s numPartials;
-
-	class MT32ReportHandler : public MT32Emu::ReportHandler {
-	protected:
-		virtual void onErrorControlROM() {
-			LOG(LOG_MISC,LOG_WARN)("MT32: Couldn't open Control ROM file");
-		}
-
-		virtual void onErrorPCMROM() {
-			LOG(LOG_MISC,LOG_WARN)("MT32: Couldn't open PCM ROM file");
-		}
-
-		virtual void showLCDMessage(const char *message) {
-			LOG(LOG_MISC,LOG_DEBUG)("MT32: LCD-Message: %s", message);
-		}
-
-		virtual void printDebug(const char *fmt, va_list list);
-	} reportHandler;
+	bool open, noise, renderInThread;
 
 	static void mixerCallBack(Bitu len);
 	static int processingThread(void *);
+	static void makeROMPathName(char pathName[], const char romDir[], const char fileName[], bool addPathSeparator);
+	static mt32emu_report_handler_i getReportHandlerInterface();
 
-public:
-	MidiHandler_mt32() : chan(NULL), synth(NULL), thread(NULL), synthMutex(NULL), procIdleSem(NULL), mixerReqSem(NULL), open(false) {}
-
-	~MidiHandler_mt32() {
-		Close();
-	}
-
-	const char *GetName(void) {
-		return "mt32";
-	}
-
-    void user_romhelp(void) {
-        /* don't just grunt and say "ROM file not found", help the user get the ROMs in place so we can work! */
-        /* we're now 25 years past the era of limited RAM and "error code -25" we have more than enough disk and RAM
-         * to contain explanatory text where the user went wrong! */
-        LOG_MSG("MT32 emulation cannot work without the PCM and CONTROL ROM files.");
-        LOG_MSG("To eliminate this error message, either change mididevice= to something else, or");
-        LOG_MSG("place the ROM files in what will be the \"current working directory\" for DOSBox-X");
-        LOG_MSG("when it starts up and initializes MIDI emulation.");
-        LOG_MSG("The ROM files are: CM32L_CONTROL.ROM, MT32_CONTROL.ROM, CM32L_PCM.ROM, MT32_PCM.ROM");
-    }
-
-	bool Open(const char *conf) {
-		MT32Emu::FileStream controlROMFile;
-		MT32Emu::FileStream pcmROMFile;
-
-        /* TODO: Add an option through midiconfig for the user to tell us where to look for ROMs.
-         *       That way they don't have to sit there in the root directory of the DOS game alongside
-         *       the game files. Much like Fluidsynth MIDI support where you can use midiconfig to
-         *       tell it where the soundfonts are. */
-
-		if (!controlROMFile.open("CM32L_CONTROL.ROM")) {
-			if (!controlROMFile.open("MT32_CONTROL.ROM")) {
-				LOG(LOG_MISC,LOG_WARN)("MT32: Control ROM file not found");
-                user_romhelp();
-				return false;
-			}
-		}
-		if (!pcmROMFile.open("CM32L_PCM.ROM")) {
-			if (!pcmROMFile.open("MT32_PCM.ROM")) {
-				LOG(LOG_MISC,LOG_WARN)("MT32: PCM ROM file not found");
-                user_romhelp();
-				return false;
-			}
-		}
-
-		Section_prop *section = static_cast<Section_prop *>(control->GetSection("midi"));
-
-		const MT32Emu::ROMImage *controlROMImage = MT32Emu::ROMImage::makeROMImage(&controlROMFile);
-		const MT32Emu::ROMImage *pcmROMImage = MT32Emu::ROMImage::makeROMImage(&pcmROMFile);
-
-		synth = new MT32Emu::Synth(&reportHandler);
+	MidiHandler_mt32();
+	~MidiHandler_mt32();
 
-		/* NTS: Read and apply mt32.partials BEFORE opening the synth, because the
-			synth assumes an initial number of partials, and allocates PartialManager()
-			instances which in turn initialize THAT many partials. If we later
-			call setPartialLimit() with the (often lower) number we wanted, then
-			a memory leak will occur because the PartialManager() will only free
-			the new lower limit and leave the rest in memory. */
-		numPartials = section->Get_int("mt32.partials");
-		if(numPartials>MT32EMU_MAX_PARTIALS) numPartials=MT32EMU_MAX_PARTIALS;
-		synth->setPartialLimit(numPartials);
-
-		if (!synth->open(*controlROMImage, *pcmROMImage)) {
-			LOG(LOG_MISC,LOG_WARN)("MT32: Error initialising emulation");
-			return false;
-		}
-
-		if (strcmp(section->Get_string("mt32.reverb.mode"), "auto") != 0) {
-			Bit8u reverbsysex[] = {0x10, 0x00, 0x01, 0x00, 0x05, 0x03};
-			reverbsysex[3] = (Bit8u)atoi(section->Get_string("mt32.reverb.mode"));
-			reverbsysex[4] = (Bit8u)section->Get_int("mt32.reverb.time");
-			reverbsysex[5] = (Bit8u)section->Get_int("mt32.reverb.level");
-			synth->writeSysex(16, reverbsysex, 6);
-			synth->setReverbOverridden(true);
-		} else {
-			LOG(LOG_MISC,LOG_DEBUG)("MT32: Using default reverb");
-		}
-
-		if (strcmp(section->Get_string("mt32.dac"), "auto") != 0) {
-			synth->setDACInputMode((MT32Emu::DACInputMode)atoi(section->Get_string("mt32.dac")));
-			// PURE mode = 1/2 reverb output
-			if( atoi(section->Get_string("mt32.dac")) == 1 ) {
-				synth->setReverbOutputGain( 0.68f / 2 );
- 			}
-		}
-
-		reverseStereo = strcmp(section->Get_string("mt32.reverse.stereo"), "on") == 0;
-		noise = strcmp(section->Get_string("mt32.verbose"), "on") == 0;
-		renderInThread = strcmp(section->Get_string("mt32.thread"), "on") == 0;
-
-		chan = MIXER_AddChannel(mixerCallBack, MT32Emu::SAMPLE_RATE, "MT32");
-		if (renderInThread) {
-			mixerBufferSize = 0;
-			stopProcessing = false;
-			synthMutex = SDL_CreateMutex();
-			procIdleSem = SDL_CreateSemaphore(0);
-			mixerReqSem = SDL_CreateSemaphore(0);
-			thread = SDL_CreateThread(processingThread, NULL);
-			//if (thread == NULL || synthMutex == NULL || sleepMutex == NULL) renderInThread = false;
-		}
-		chan->Enable(true);
-
-		open = true;
-		return true;
-	}
-
-	void Close(void) {
-		if (!open) return;
-		chan->Enable(false);
-		if (renderInThread) {
-			stopProcessing = true;
-			SDL_SemPost(mixerReqSem);
-			SDL_WaitThread(thread, NULL);
-			thread = NULL;
-			SDL_DestroyMutex(synthMutex);
-			synthMutex = NULL;
-			SDL_DestroySemaphore(procIdleSem);
-			procIdleSem = NULL;
-			SDL_DestroySemaphore(mixerReqSem);
-			mixerReqSem = NULL;
-		}
-		MIXER_DelChannel(chan);
-		chan = NULL;
-		synth->close();
-		delete synth;
-		synth = NULL;
-		open = false;
-	}
-
-	void PlayMsg(Bit8u *msg) {
-		//if (!midiBuffer.put(*(Bit32u *)msg | (Bit64u(playPos + AUDIO_BUFFER_SIZE) << 32))) LOG_MSG("MT32: Playback buffer full!");
-		if (!midiBuffer.put(*(Bit32u *)msg)) { } //LOG_MSG("MT32: Playback buffer full!");
-	}
-
-	void PlaySysex(Bit8u *sysex, Bitu len) {
-		if (renderInThread) SDL_LockMutex(synthMutex);
-		synth->playSysex(sysex, len);
-		if (renderInThread) SDL_UnlockMutex(synthMutex);
+	Bit32u inline getMidiEventTimestamp() {
+		return service->convertOutputToSynthTimestamp(Bit32u(playedBuffers * framesPerAudioBuffer + (playPos >> 1)));
 	}
 
-	MT32Emu::Synth* GetSynth() { return synth; }
-
-	void Reset() {
-		midiBuffer.reset();
-
-		if (renderInThread) SDL_LockMutex(synthMutex);
-		mixerBufferSize = 0;
-		if (renderInThread) SDL_UnlockMutex(synthMutex);
-	}
-
-private:
-	void render(Bitu len, Bit16s *buf) {
-		Bit32u msg = midiBuffer.get();
-		if (msg != 0) synth->playMsg(msg);
-		synth->render(buf, len);
-		if (reverseStereo) {
-			Bit16s *revBuf = buf;
-			for(Bitu i = 0; i < len; i++) {
-				Bit16s left = revBuf[0];
-				Bit16s right = revBuf[1];
-				*revBuf++ = right;
-				*revBuf++ = left;
-			}
-		}
-		chan->AddSamples_s16(len, buf);
-	}
-} midiHandler_mt32;
-
-void MidiHandler_mt32::MT32ReportHandler::printDebug(const char *fmt, va_list list) {
-	if (midiHandler_mt32.noise) {
-		char s[1024];
-		strcpy(s, "MT32: ");
-		vsnprintf(s + 6, 1017, fmt, list);
-		LOG_MSG(s);
-	}
-}
-
-void MidiHandler_mt32::mixerCallBack(Bitu len) {
-	if (midiHandler_mt32.renderInThread) {
-		SDL_SemWait(midiHandler_mt32.procIdleSem);
-		midiHandler_mt32.mixerBufferSize += len;
-		SDL_SemPost(midiHandler_mt32.mixerReqSem);
-	} else {
-		midiHandler_mt32.render(len, (Bit16s *)MixTemp);
-	}
-}
+	void handleMixerCallBack(Bitu len);
+	void renderingLoop();
+};
 
-int MidiHandler_mt32::processingThread(void *) {
-	while (!midiHandler_mt32.stopProcessing) {
-		SDL_SemPost(midiHandler_mt32.procIdleSem);
-		SDL_SemWait(midiHandler_mt32.mixerReqSem);
-		for (;;) {
-			Bitu samplesToRender = midiHandler_mt32.mixerBufferSize;
-			if (samplesToRender == 0) break;
-			SDL_LockMutex(midiHandler_mt32.synthMutex);
-			midiHandler_mt32.render(samplesToRender, midiHandler_mt32.mixerBuffer);
-			SDL_UnlockMutex(midiHandler_mt32.synthMutex);
-			midiHandler_mt32.mixerBufferSize -= samplesToRender;
-		}
-	}
-	return 0;
-}
+#endif /* DOSBOX_MIDI_MT32_H */
\ No newline at end of file
-- 
2.16.2.windows.1


From cfa29fc1568281bd1d5f7fe6ed5393cc649aaf67 Mon Sep 17 00:00:00 2001
From: Heydojo <white.tw.tw@gmail.com>
Date: Thu, 15 Mar 2018 17:02:00 +0000
Subject: [PATCH 7/8] dosbox.cpp patch for libmt32emu_2_3_0

---
 src/dosbox.cpp | 143 +++++++++++++++++++++++++++++++++++++++++----------------
 1 file changed, 103 insertions(+), 40 deletions(-)

diff --git a/src/dosbox.cpp b/src/dosbox.cpp
index 9a728afb..5ffdf958 100644
--- a/src/dosbox.cpp
+++ b/src/dosbox.cpp
@@ -1640,58 +1640,121 @@ void DOSBOX_SetupConfigSections(void) {
 	Pint->SetMinMax(-1,15);
 	Pint->Set_help("MPU-401 IRQ. -1 to automatically choose.");
 
-	Pstring = secprop->Add_string("mt32.reverse.stereo",Property::Changeable::WhenIdle,"off");
-	Pstring->Set_values(mt32ReverseStereo);
-	Pstring->Set_help("Reverse stereo channels for MT-32 output");
-
-	Pstring = secprop->Add_string("mt32.verbose",Property::Changeable::WhenIdle,"off");
-	Pstring->Set_values(mt32log);
-	Pstring->Set_help("MT-32 debug logging");
-
-	Pstring = secprop->Add_string("mt32.thread",Property::Changeable::WhenIdle,"off");
-	Pstring->Set_values(mt32thread);
-	Pstring->Set_help("MT-32 rendering in separate thread");
-
-	Pstring = secprop->Add_string("mt32.dac",Property::Changeable::WhenIdle,"auto");
-	Pstring->Set_values(mt32DACModes);
-	Pstring->Set_help("MT-32 DAC input emulation mode\n"
-		"Nice = 0 - default\n"
-		"Produces samples at double the volume, without tricks.\n"
-		"Higher quality than the real devices\n\n"
-
-		"Pure = 1\n"
-		"Produces samples that exactly match the bits output from the emulated LA32.\n"
-		"Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)\n"
-		"Much less likely to overdrive than any other mode.\n"
-		"Half the volume of any of the other modes, meaning its volume relative to the reverb\n"
-		"output when mixed together directly will sound wrong. So, reverb level must be lowered.\n"
-		"Perfect for developers while debugging :)\n\n"
-
-		"GENERATION1 = 2\n"
-		"Re-orders the LA32 output bits as in early generation MT-32s (according to Wikipedia).\n"
-		"Bit order at DAC (where each number represents the original LA32 output bit number, and XX means the bit is always low):\n"
-		"15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 XX\n\n"
-
-		"GENERATION2 = 3\n"
-		"Re-orders the LA32 output bits as in later geneerations (personally confirmed on my CM-32L - KG).\n"
-		"Bit order at DAC (where each number represents the original LA32 output bit number):\n"
-		"15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 14\n");
+	Pstring = secprop->Add_string("mt32.romdir",Property::Changeable::WhenIdle,"");
+	Pstring->Set_help("Name of the directory where MT-32 Control and PCM ROM files can be found. Emulation requires these files to work.\n"
+						"  Accepted file names are as follows:\n"
+						"    MT32_CONTROL.ROM or CM32L_CONTROL.ROM - control ROM file.\n"
+						"    MT32_PCM.ROM or CM32L_PCM.ROM - PCM ROM file.");
+
+	Pbool = secprop->Add_bool("mt32.reverse.stereo",Property::Changeable::WhenIdle,false);
+	Pbool->Set_help("Reverse stereo channels for MT-32 output");
+
+	Pbool = secprop->Add_bool("mt32.verbose",Property::Changeable::WhenIdle,false);
+	Pbool->Set_help("MT-32 debug logging");
+
+	Pbool = secprop->Add_bool("mt32.thread",Property::Changeable::WhenIdle,false);
+	Pbool->Set_help("MT-32 rendering in separate thread");
+
+	const char *mt32chunk[] = {"2", "3", "16", "99", "100",0};
+	Pint = secprop->Add_int("mt32.chunk",Property::Changeable::WhenIdle,16);
+	Pint->Set_values(mt32chunk);
+	Pint->SetMinMax(2,100);
+	Pint->Set_help("Minimum milliseconds of data to render at once.\n"
+	"Increasing this value reduces rendering overhead which may improve performance but also increases audio lag.\n"
+	"Valid for rendering in separate thread only.");
+
+	const char *mt32prebuffer[] = {"3", "4", "32", "199", "200",0};
+	Pint = secprop->Add_int("mt32.prebuffer",Property::Changeable::WhenIdle,32);
+	Pint->Set_values(mt32prebuffer);
+	Pint->SetMinMax(3,200);
+	Pint->Set_help("How many milliseconds of data to render ahead.\n"
+	"Increasing this value may help to avoid underruns but also increases audio lag.\n"
+	"Cannot be set less than or equal to mt32.chunk value.\n"
+	"Valid for rendering in separate thread only.");
+
+	const char *mt32partials[] = {"8", "9", "32", "255", "256",0};
+	Pint = secprop->Add_int("mt32.partials",Property::Changeable::WhenIdle,32);
+	Pint->Set_values(mt32partials);
+	Pint->SetMinMax(8,256);
+	Pint->Set_help("The maximum number of partials playing simultaneously.");
+
+	const char *mt32DACModes[] = {"0", "1", "2", "3",0};
+	Pint = secprop->Add_int("mt32.dac",Property::Changeable::WhenIdle,0);
+	Pint->Set_values(mt32DACModes);
+	Pint->Set_help("MT-32 DAC input emulation mode\n"
+	"Nice = 0 - default\n"
+	"Produces samples at double the volume, without tricks.\n"
+	"Higher quality than the real devices\n\n"
+
+	"Pure = 1\n"
+	"Produces samples that exactly match the bits output from the emulated LA32.\n"
+	"Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)\n"
+	"Much less likely to overdrive than any other mode.\n"
+	"Half the volume of any of the other modes.\n"
+	"Perfect for developers while debugging :)\n\n"
+
+	"GENERATION1 = 2\n"
+	"Re-orders the LA32 output bits as in early generation MT-32s (according to Wikipedia).\n"
+	"Bit order at DAC (where each number represents the original LA32 output bit number, and XX means the bit is always low):\n"
+	"15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 XX\n\n"
+
+	"GENERATION2 = 3\n"
+	"Re-orders the LA32 output bits as in later generations (personally confirmed on my CM-32L - KG).\n"
+	"Bit order at DAC (where each number represents the original LA32 output bit number):\n"
+	"15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 14");
+
+	const char *mt32analogModes[] = {"0", "1", "2", "3",0};
+	Pint = secprop->Add_int("mt32.analog",Property::Changeable::WhenIdle,2);
+	Pint->Set_values(mt32analogModes);
+	Pint->Set_help("MT-32 analogue output emulation mode\n"
+	"Digital = 0\n"
+	"Only digital path is emulated. The output samples correspond to the digital output signal appeared at the DAC entrance.\n"
+	"Fastest mode.\n\n"
+
+	"Coarse = 1\n"
+	"Coarse emulation of LPF circuit. High frequencies are boosted, sample rate remains unchanged.\n"
+	"A bit better sounding but also a bit slower.\n\n"
+
+	"Accurate = 2 - default\n"
+	"Finer emulation of LPF circuit. Output signal is upsampled to 48 kHz to allow emulation of audible mirror spectra above 16 kHz,\n"
+	"which is passed through the LPF circuit without significant attenuation.\n"
+	"Sounding is closer to the analog output from real hardware but also slower than the modes 0 and 1.\n\n"
+
+	"Oversampled = 3\n"
+	"Same as the default mode 2 but the output signal is 2x oversampled, i.e. the output sample rate is 96 kHz.\n"
+	"Even slower than all the other modes but better retains highest frequencies while further resampled in DOSBox mixer.");
 
+	const char *mt32reverbModes[] = {"0", "1", "2", "3", "auto",0};
 	Pstring = secprop->Add_string("mt32.reverb.mode",Property::Changeable::WhenIdle,"auto");
 	Pstring->Set_values(mt32reverbModes);
 	Pstring->Set_help("MT-32 reverb mode");
 
+	const char *mt32reverbTimes[] = {"0", "1", "2", "3", "4", "5", "6", "7",0};
 	Pint = secprop->Add_int("mt32.reverb.time",Property::Changeable::WhenIdle,5);
 	Pint->Set_values(mt32reverbTimes);
-	Pint->Set_help("MT-32 reverb decaying time"); 
+	Pint->Set_help("MT-32 reverb decaying time");
 
+	const char *mt32reverbLevels[] = {"0", "1", "2", "3", "4", "5", "6", "7",0};
 	Pint = secprop->Add_int("mt32.reverb.level",Property::Changeable::WhenIdle,3);
 	Pint->Set_values(mt32reverbLevels);
 	Pint->Set_help("MT-32 reverb level");
 
-	Pint = secprop->Add_int("mt32.partials",Property::Changeable::WhenIdle,32);
-	Pint->SetMinMax(0,256);
-	Pint->Set_help("MT-32 max partials allowed (0-256)");
+	Pint = secprop->Add_int("mt32.rate", Property::Changeable::WhenIdle, 44100);
+	Pint->Set_values(rates);
+	Pint->Set_help("Sample rate of MT-32 emulation.");
+
+	const char *mt32srcQuality[] = {"0", "1", "2", "3",0};
+	Pint = secprop->Add_int("mt32.src.quality", Property::Changeable::WhenIdle, 2);
+	Pint->Set_values(mt32srcQuality);
+	Pint->Set_help("MT-32 sample rate conversion quality\n"
+	"Value '0' is for the fastest conversion, value '3' provides for the best conversion quality. Default is 2.");
+
+	Pbool = secprop->Add_bool("mt32.niceampramp", Property::Changeable::WhenIdle, true);
+	Pbool->Set_help("Toggles \"Nice Amp Ramp\" mode that improves amplitude ramp for sustaining instruments.\n"
+	"Quick changes of volume or expression on a MIDI channel may result in amp jumps on real hardware.\n"
+	"When \"Nice Amp Ramp\" mode is enabled, amp changes gradually instead.\n"
+	"Otherwise, the emulation accuracy is preserved.\n"
+	"Default is true.");
 
 	secprop=control->AddSection_prop("debug",&Null_Init);
 
-- 
2.16.2.windows.1


From 376d3f35c4c8ebd95e9ab09685abdbe0f19a26de Mon Sep 17 00:00:00 2001
From: Heydojo <white.tw.tw@gmail.com>
Date: Thu, 15 Mar 2018 17:08:23 +0000
Subject: [PATCH 8/8] dosbox.cpp patch 2 for libmt32emu_2_3_0

---
 src/dosbox.cpp | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/dosbox.cpp b/src/dosbox.cpp
index 5ffdf958..06d8e28a 100644
--- a/src/dosbox.cpp
+++ b/src/dosbox.cpp
@@ -74,7 +74,6 @@
 #include "pci_bus.h"
 #include "parport.h"
 #include "clockdomain.h"
-#include "mt32options.h
 
 #ifdef WIN32
 #define WIN32_LEAN_AND_MEAN
-- 
2.16.2.windows.1

