; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\dev\dosbox-x\vs2008\zlib\inffast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
; Function compile flags: /Odtp
; File c:\dev\dosbox-x\vs2008\zlib\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
tv326 = -92						; size = 4
tv319 = -88						; size = 4
_state$ = -84						; size = 4
_out$ = -80						; size = 4
_op$ = -76						; size = 4
_from$ = -72						; size = 4
_dmask$ = -68						; size = 4
_wsize$ = -64						; size = 4
_hold$ = -60						; size = 4
_dist$ = -56						; size = 4
_lcode$ = -52						; size = 4
_end$ = -48						; size = 4
_lmask$ = -44						; size = 4
_wnext$ = -40						; size = 4
_bits$ = -36						; size = 4
_len$ = -32						; size = 4
_in$ = -28						; size = 4
_whave$ = -24						; size = 4
_dcode$ = -20						; size = 4
_last$ = -16						; size = 4
_window$ = -12						; size = 4
_here$ = -8						; size = 4
_beg$ = -4						; size = 4
_strm$ = 8						; size = 4
_start$ = 12						; size = 4
_inflate_fast PROC					; COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 71   :     struct inflate_state FAR *state;
; 72   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 73   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 74   :     unsigned char FAR *out;     /* local strm->next_out */
; 75   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 76   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 77   : #ifdef INFLATE_STRICT
; 78   :     unsigned dmax;              /* maximum distance from zlib header */
; 79   : #endif
; 80   :     unsigned wsize;             /* window size or zero if not using window */
; 81   :     unsigned whave;             /* valid bytes in the window */
; 82   :     unsigned wnext;             /* window write index */
; 83   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 84   :     unsigned long hold;         /* local strm->hold */
; 85   :     unsigned bits;              /* local strm->bits */
; 86   :     code const FAR *lcode;      /* local strm->lencode */
; 87   :     code const FAR *dcode;      /* local strm->distcode */
; 88   :     unsigned lmask;             /* mask for first level of length codes */
; 89   :     unsigned dmask;             /* mask for first level of distance codes */
; 90   :     code here;                  /* retrieved table entry */
; 91   :     unsigned op;                /* code bits, operation, extra bits, or */
; 92   :                                 /*  window position, window bytes to copy */
; 93   :     unsigned len;               /* match length, unused bytes */
; 94   :     unsigned dist;              /* match distance */
; 95   :     unsigned char FAR *from;    /* where to copy match from */
; 96   : 
; 97   :     /* copy state to local variables */
; 98   :     state = (struct inflate_state FAR *)strm->state;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000c	89 4d ac	 mov	 DWORD PTR _state$[ebp], ecx

; 99   :     in = strm->next_in - OFF;

  0000f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00012	8b 02		 mov	 eax, DWORD PTR [edx]
  00014	83 e8 01	 sub	 eax, 1
  00017	89 45 e4	 mov	 DWORD PTR _in$[ebp], eax

; 100  :     last = in + (strm->avail_in - 5);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00020	8b 45 e4	 mov	 eax, DWORD PTR _in$[ebp]
  00023	8d 4c 10 fb	 lea	 ecx, DWORD PTR [eax+edx-5]
  00027	89 4d f0	 mov	 DWORD PTR _last$[ebp], ecx

; 101  :     out = strm->next_out - OFF;

  0002a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0002d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00030	83 e8 01	 sub	 eax, 1
  00033	89 45 b0	 mov	 DWORD PTR _out$[ebp], eax

; 102  :     beg = out - (start - strm->avail_out);

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _start$[ebp]
  0003c	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  0003f	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00042	2b c2		 sub	 eax, edx
  00044	89 45 fc	 mov	 DWORD PTR _beg$[ebp], eax

; 103  :     end = out + (strm->avail_out - 257);

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0004a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004d	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00050	8d 8c 10 ff fe
	ff ff		 lea	 ecx, DWORD PTR [eax+edx-257]
  00057	89 4d d0	 mov	 DWORD PTR _end$[ebp], ecx

; 104  : #ifdef INFLATE_STRICT
; 105  :     dmax = state->dmax;
; 106  : #endif
; 107  :     wsize = state->wsize;

  0005a	8b 55 ac	 mov	 edx, DWORD PTR _state$[ebp]
  0005d	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00060	89 45 c0	 mov	 DWORD PTR _wsize$[ebp], eax

; 108  :     whave = state->whave;

  00063	8b 4d ac	 mov	 ecx, DWORD PTR _state$[ebp]
  00066	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00069	89 55 e8	 mov	 DWORD PTR _whave$[ebp], edx

; 109  :     wnext = state->wnext;

  0006c	8b 45 ac	 mov	 eax, DWORD PTR _state$[ebp]
  0006f	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00072	89 4d d8	 mov	 DWORD PTR _wnext$[ebp], ecx

; 110  :     window = state->window;

  00075	8b 55 ac	 mov	 edx, DWORD PTR _state$[ebp]
  00078	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0007b	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 111  :     hold = state->hold;

  0007e	8b 4d ac	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00084	89 55 c4	 mov	 DWORD PTR _hold$[ebp], edx

; 112  :     bits = state->bits;

  00087	8b 45 ac	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0008d	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx

; 113  :     lcode = state->lencode;

  00090	8b 55 ac	 mov	 edx, DWORD PTR _state$[ebp]
  00093	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00096	89 45 cc	 mov	 DWORD PTR _lcode$[ebp], eax

; 114  :     dcode = state->distcode;

  00099	8b 4d ac	 mov	 ecx, DWORD PTR _state$[ebp]
  0009c	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0009f	89 55 ec	 mov	 DWORD PTR _dcode$[ebp], edx

; 115  :     lmask = (1U << state->lenbits) - 1;

  000a2	8b 45 ac	 mov	 eax, DWORD PTR _state$[ebp]
  000a5	ba 01 00 00 00	 mov	 edx, 1
  000aa	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000ad	d3 e2		 shl	 edx, cl
  000af	83 ea 01	 sub	 edx, 1
  000b2	89 55 d4	 mov	 DWORD PTR _lmask$[ebp], edx

; 116  :     dmask = (1U << state->distbits) - 1;

  000b5	8b 45 ac	 mov	 eax, DWORD PTR _state$[ebp]
  000b8	ba 01 00 00 00	 mov	 edx, 1
  000bd	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  000c0	d3 e2		 shl	 edx, cl
  000c2	83 ea 01	 sub	 edx, 1
  000c5	89 55 bc	 mov	 DWORD PTR _dmask$[ebp], edx
$LN55@inflate_fa:

; 117  : 
; 118  :     /* decode literals and length/distances until end-of-block or not enough
; 119  :        input data or output space */
; 120  :     do {
; 121  :         if (bits < 15) {

  000c8	83 7d dc 0f	 cmp	 DWORD PTR _bits$[ebp], 15 ; 0000000fH
  000cc	73 46		 jae	 SHORT $LN52@inflate_fa

; 122  :             hold += (unsigned long)(PUP(in)) << bits;

  000ce	8b 45 e4	 mov	 eax, DWORD PTR _in$[ebp]
  000d1	83 c0 01	 add	 eax, 1
  000d4	89 45 e4	 mov	 DWORD PTR _in$[ebp], eax
  000d7	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  000da	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000dd	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  000e0	d3 e2		 shl	 edx, cl
  000e2	03 55 c4	 add	 edx, DWORD PTR _hold$[ebp]
  000e5	89 55 c4	 mov	 DWORD PTR _hold$[ebp], edx

; 123  :             bits += 8;

  000e8	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  000eb	83 c0 08	 add	 eax, 8
  000ee	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax

; 124  :             hold += (unsigned long)(PUP(in)) << bits;

  000f1	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  000f4	83 c1 01	 add	 ecx, 1
  000f7	89 4d e4	 mov	 DWORD PTR _in$[ebp], ecx
  000fa	8b 55 e4	 mov	 edx, DWORD PTR _in$[ebp]
  000fd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00100	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00103	d3 e0		 shl	 eax, cl
  00105	03 45 c4	 add	 eax, DWORD PTR _hold$[ebp]
  00108	89 45 c4	 mov	 DWORD PTR _hold$[ebp], eax

; 125  :             bits += 8;

  0010b	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  0010e	83 c1 08	 add	 ecx, 8
  00111	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
$LN52@inflate_fa:

; 126  :         }
; 127  :         here = lcode[hold & lmask];

  00114	8b 55 c4	 mov	 edx, DWORD PTR _hold$[ebp]
  00117	23 55 d4	 and	 edx, DWORD PTR _lmask$[ebp]
  0011a	8b 45 cc	 mov	 eax, DWORD PTR _lcode$[ebp]
  0011d	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00120	89 4d f8	 mov	 DWORD PTR _here$[ebp], ecx
$dolen$77608:

; 128  :       dolen:
; 129  :         op = (unsigned)(here.bits);

  00123	0f b6 55 f9	 movzx	 edx, BYTE PTR _here$[ebp+1]
  00127	89 55 b4	 mov	 DWORD PTR _op$[ebp], edx

; 130  :         hold >>= op;

  0012a	8b 45 c4	 mov	 eax, DWORD PTR _hold$[ebp]
  0012d	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  00130	d3 e8		 shr	 eax, cl
  00132	89 45 c4	 mov	 DWORD PTR _hold$[ebp], eax

; 131  :         bits -= op;

  00135	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00138	2b 4d b4	 sub	 ecx, DWORD PTR _op$[ebp]
  0013b	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx

; 132  :         op = (unsigned)(here.op);

  0013e	0f b6 55 f8	 movzx	 edx, BYTE PTR _here$[ebp]
  00142	89 55 b4	 mov	 DWORD PTR _op$[ebp], edx

; 133  :         if (op == 0) {                          /* literal */

  00145	83 7d b4 00	 cmp	 DWORD PTR _op$[ebp], 0
  00149	75 16		 jne	 SHORT $LN51@inflate_fa

; 134  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 135  :                     "inflate:         literal '%c'\n" :
; 136  :                     "inflate:         literal 0x%02x\n", here.val));
; 137  :             PUP(out) = (unsigned char)(here.val);

  0014b	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  0014e	83 c0 01	 add	 eax, 1
  00151	89 45 b0	 mov	 DWORD PTR _out$[ebp], eax
  00154	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  00157	8a 55 fa	 mov	 dl, BYTE PTR _here$[ebp+2]
  0015a	88 11		 mov	 BYTE PTR [ecx], dl
  0015c	e9 33 05 00 00	 jmp	 $LN54@inflate_fa
$LN51@inflate_fa:

; 138  :         }
; 139  :         else if (op & 16) {                     /* length base */

  00161	8b 45 b4	 mov	 eax, DWORD PTR _op$[ebp]
  00164	83 e0 10	 and	 eax, 16			; 00000010H
  00167	0f 84 cf 04 00
	00		 je	 $LN49@inflate_fa

; 140  :             len = (unsigned)(here.val);

  0016d	0f b7 4d fa	 movzx	 ecx, WORD PTR _here$[ebp+2]
  00171	89 4d e0	 mov	 DWORD PTR _len$[ebp], ecx

; 141  :             op &= 15;                           /* number of extra bits */

  00174	8b 55 b4	 mov	 edx, DWORD PTR _op$[ebp]
  00177	83 e2 0f	 and	 edx, 15			; 0000000fH
  0017a	89 55 b4	 mov	 DWORD PTR _op$[ebp], edx

; 142  :             if (op) {

  0017d	74 55		 je	 SHORT $LN48@inflate_fa

; 143  :                 if (bits < op) {

  0017f	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  00182	3b 45 b4	 cmp	 eax, DWORD PTR _op$[ebp]
  00185	73 23		 jae	 SHORT $LN47@inflate_fa

; 144  :                     hold += (unsigned long)(PUP(in)) << bits;

  00187	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  0018a	83 c1 01	 add	 ecx, 1
  0018d	89 4d e4	 mov	 DWORD PTR _in$[ebp], ecx
  00190	8b 55 e4	 mov	 edx, DWORD PTR _in$[ebp]
  00193	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00196	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00199	d3 e0		 shl	 eax, cl
  0019b	03 45 c4	 add	 eax, DWORD PTR _hold$[ebp]
  0019e	89 45 c4	 mov	 DWORD PTR _hold$[ebp], eax

; 145  :                     bits += 8;

  001a1	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  001a4	83 c1 08	 add	 ecx, 8
  001a7	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
$LN47@inflate_fa:

; 146  :                 }
; 147  :                 len += (unsigned)hold & ((1U << op) - 1);

  001aa	ba 01 00 00 00	 mov	 edx, 1
  001af	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  001b2	d3 e2		 shl	 edx, cl
  001b4	83 ea 01	 sub	 edx, 1
  001b7	23 55 c4	 and	 edx, DWORD PTR _hold$[ebp]
  001ba	03 55 e0	 add	 edx, DWORD PTR _len$[ebp]
  001bd	89 55 e0	 mov	 DWORD PTR _len$[ebp], edx

; 148  :                 hold >>= op;

  001c0	8b 45 c4	 mov	 eax, DWORD PTR _hold$[ebp]
  001c3	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  001c6	d3 e8		 shr	 eax, cl
  001c8	89 45 c4	 mov	 DWORD PTR _hold$[ebp], eax

; 149  :                 bits -= op;

  001cb	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  001ce	2b 4d b4	 sub	 ecx, DWORD PTR _op$[ebp]
  001d1	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
$LN48@inflate_fa:

; 150  :             }
; 151  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 152  :             if (bits < 15) {

  001d4	83 7d dc 0f	 cmp	 DWORD PTR _bits$[ebp], 15 ; 0000000fH
  001d8	73 46		 jae	 SHORT $LN46@inflate_fa

; 153  :                 hold += (unsigned long)(PUP(in)) << bits;

  001da	8b 55 e4	 mov	 edx, DWORD PTR _in$[ebp]
  001dd	83 c2 01	 add	 edx, 1
  001e0	89 55 e4	 mov	 DWORD PTR _in$[ebp], edx
  001e3	8b 45 e4	 mov	 eax, DWORD PTR _in$[ebp]
  001e6	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  001e9	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  001ec	d3 e2		 shl	 edx, cl
  001ee	03 55 c4	 add	 edx, DWORD PTR _hold$[ebp]
  001f1	89 55 c4	 mov	 DWORD PTR _hold$[ebp], edx

; 154  :                 bits += 8;

  001f4	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  001f7	83 c0 08	 add	 eax, 8
  001fa	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax

; 155  :                 hold += (unsigned long)(PUP(in)) << bits;

  001fd	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  00200	83 c1 01	 add	 ecx, 1
  00203	89 4d e4	 mov	 DWORD PTR _in$[ebp], ecx
  00206	8b 55 e4	 mov	 edx, DWORD PTR _in$[ebp]
  00209	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0020c	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  0020f	d3 e0		 shl	 eax, cl
  00211	03 45 c4	 add	 eax, DWORD PTR _hold$[ebp]
  00214	89 45 c4	 mov	 DWORD PTR _hold$[ebp], eax

; 156  :                 bits += 8;

  00217	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  0021a	83 c1 08	 add	 ecx, 8
  0021d	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
$LN46@inflate_fa:

; 157  :             }
; 158  :             here = dcode[hold & dmask];

  00220	8b 55 c4	 mov	 edx, DWORD PTR _hold$[ebp]
  00223	23 55 bc	 and	 edx, DWORD PTR _dmask$[ebp]
  00226	8b 45 ec	 mov	 eax, DWORD PTR _dcode$[ebp]
  00229	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0022c	89 4d f8	 mov	 DWORD PTR _here$[ebp], ecx
$dodist$77623:

; 159  :           dodist:
; 160  :             op = (unsigned)(here.bits);

  0022f	0f b6 55 f9	 movzx	 edx, BYTE PTR _here$[ebp+1]
  00233	89 55 b4	 mov	 DWORD PTR _op$[ebp], edx

; 161  :             hold >>= op;

  00236	8b 45 c4	 mov	 eax, DWORD PTR _hold$[ebp]
  00239	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  0023c	d3 e8		 shr	 eax, cl
  0023e	89 45 c4	 mov	 DWORD PTR _hold$[ebp], eax

; 162  :             bits -= op;

  00241	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00244	2b 4d b4	 sub	 ecx, DWORD PTR _op$[ebp]
  00247	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx

; 163  :             op = (unsigned)(here.op);

  0024a	0f b6 55 f8	 movzx	 edx, BYTE PTR _here$[ebp]
  0024e	89 55 b4	 mov	 DWORD PTR _op$[ebp], edx

; 164  :             if (op & 16) {                      /* distance base */

  00251	8b 45 b4	 mov	 eax, DWORD PTR _op$[ebp]
  00254	83 e0 10	 and	 eax, 16			; 00000010H
  00257	0f 84 9a 03 00
	00		 je	 $LN45@inflate_fa

; 165  :                 dist = (unsigned)(here.val);

  0025d	0f b7 4d fa	 movzx	 ecx, WORD PTR _here$[ebp+2]
  00261	89 4d c8	 mov	 DWORD PTR _dist$[ebp], ecx

; 166  :                 op &= 15;                       /* number of extra bits */

  00264	8b 55 b4	 mov	 edx, DWORD PTR _op$[ebp]
  00267	83 e2 0f	 and	 edx, 15			; 0000000fH
  0026a	89 55 b4	 mov	 DWORD PTR _op$[ebp], edx

; 167  :                 if (bits < op) {

  0026d	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  00270	3b 45 b4	 cmp	 eax, DWORD PTR _op$[ebp]
  00273	73 4e		 jae	 SHORT $LN44@inflate_fa

; 168  :                     hold += (unsigned long)(PUP(in)) << bits;

  00275	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  00278	83 c1 01	 add	 ecx, 1
  0027b	89 4d e4	 mov	 DWORD PTR _in$[ebp], ecx
  0027e	8b 55 e4	 mov	 edx, DWORD PTR _in$[ebp]
  00281	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00284	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00287	d3 e0		 shl	 eax, cl
  00289	03 45 c4	 add	 eax, DWORD PTR _hold$[ebp]
  0028c	89 45 c4	 mov	 DWORD PTR _hold$[ebp], eax

; 169  :                     bits += 8;

  0028f	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00292	83 c1 08	 add	 ecx, 8
  00295	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx

; 170  :                     if (bits < op) {

  00298	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  0029b	3b 55 b4	 cmp	 edx, DWORD PTR _op$[ebp]
  0029e	73 23		 jae	 SHORT $LN44@inflate_fa

; 171  :                         hold += (unsigned long)(PUP(in)) << bits;

  002a0	8b 45 e4	 mov	 eax, DWORD PTR _in$[ebp]
  002a3	83 c0 01	 add	 eax, 1
  002a6	89 45 e4	 mov	 DWORD PTR _in$[ebp], eax
  002a9	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  002ac	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  002af	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  002b2	d3 e2		 shl	 edx, cl
  002b4	03 55 c4	 add	 edx, DWORD PTR _hold$[ebp]
  002b7	89 55 c4	 mov	 DWORD PTR _hold$[ebp], edx

; 172  :                         bits += 8;

  002ba	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  002bd	83 c0 08	 add	 eax, 8
  002c0	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax
$LN44@inflate_fa:

; 173  :                     }
; 174  :                 }
; 175  :                 dist += (unsigned)hold & ((1U << op) - 1);

  002c3	ba 01 00 00 00	 mov	 edx, 1
  002c8	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  002cb	d3 e2		 shl	 edx, cl
  002cd	83 ea 01	 sub	 edx, 1
  002d0	23 55 c4	 and	 edx, DWORD PTR _hold$[ebp]
  002d3	03 55 c8	 add	 edx, DWORD PTR _dist$[ebp]
  002d6	89 55 c8	 mov	 DWORD PTR _dist$[ebp], edx

; 176  : #ifdef INFLATE_STRICT
; 177  :                 if (dist > dmax) {
; 178  :                     strm->msg = (char *)"invalid distance too far back";
; 179  :                     state->mode = BAD;
; 180  :                     break;
; 181  :                 }
; 182  : #endif
; 183  :                 hold >>= op;

  002d9	8b 45 c4	 mov	 eax, DWORD PTR _hold$[ebp]
  002dc	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  002df	d3 e8		 shr	 eax, cl
  002e1	89 45 c4	 mov	 DWORD PTR _hold$[ebp], eax

; 184  :                 bits -= op;

  002e4	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  002e7	2b 4d b4	 sub	 ecx, DWORD PTR _op$[ebp]
  002ea	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx

; 185  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 186  :                 op = (unsigned)(out - beg);     /* max distance in output */

  002ed	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  002f0	2b 55 fc	 sub	 edx, DWORD PTR _beg$[ebp]
  002f3	89 55 b4	 mov	 DWORD PTR _op$[ebp], edx

; 187  :                 if (dist > op) {                /* see if copy from window */

  002f6	8b 45 c8	 mov	 eax, DWORD PTR _dist$[ebp]
  002f9	3b 45 b4	 cmp	 eax, DWORD PTR _op$[ebp]
  002fc	0f 86 43 02 00
	00		 jbe	 $LN42@inflate_fa

; 188  :                     op = dist - op;             /* distance back in window */

  00302	8b 4d c8	 mov	 ecx, DWORD PTR _dist$[ebp]
  00305	2b 4d b4	 sub	 ecx, DWORD PTR _op$[ebp]
  00308	89 4d b4	 mov	 DWORD PTR _op$[ebp], ecx

; 189  :                     if (op > whave) {

  0030b	8b 55 b4	 mov	 edx, DWORD PTR _op$[ebp]
  0030e	3b 55 e8	 cmp	 edx, DWORD PTR _whave$[ebp]
  00311	76 24		 jbe	 SHORT $LN41@inflate_fa

; 190  :                         if (state->sane) {

  00313	8b 45 ac	 mov	 eax, DWORD PTR _state$[ebp]
  00316	83 b8 c0 1b 00
	00 00		 cmp	 DWORD PTR [eax+7104], 0
  0031d	74 18		 je	 SHORT $LN41@inflate_fa

; 191  :                             strm->msg =
; 192  :                                 (char *)"invalid distance too far back";

  0031f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00322	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 193  :                             state->mode = BAD;

  00329	8b 55 ac	 mov	 edx, DWORD PTR _state$[ebp]
  0032c	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 194  :                             break;

  00332	e9 71 03 00 00	 jmp	 $LN53@inflate_fa
$LN41@inflate_fa:

; 195  :                         }
; 196  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 197  :                         if (len <= op - whave) {
; 198  :                             do {
; 199  :                                 PUP(out) = 0;
; 200  :                             } while (--len);
; 201  :                             continue;
; 202  :                         }
; 203  :                         len -= op - whave;
; 204  :                         do {
; 205  :                             PUP(out) = 0;
; 206  :                         } while (--op > whave);
; 207  :                         if (op == 0) {
; 208  :                             from = out - dist;
; 209  :                             do {
; 210  :                                 PUP(out) = PUP(from);
; 211  :                             } while (--len);
; 212  :                             continue;
; 213  :                         }
; 214  : #endif
; 215  :                     }
; 216  :                     from = window - OFF;

  00337	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0033a	83 e8 01	 sub	 eax, 1
  0033d	89 45 b8	 mov	 DWORD PTR _from$[ebp], eax

; 217  :                     if (wnext == 0) {           /* very common case */

  00340	83 7d d8 00	 cmp	 DWORD PTR _wnext$[ebp], 0
  00344	75 52		 jne	 SHORT $LN39@inflate_fa

; 218  :                         from += wsize - op;

  00346	8b 4d c0	 mov	 ecx, DWORD PTR _wsize$[ebp]
  00349	2b 4d b4	 sub	 ecx, DWORD PTR _op$[ebp]
  0034c	03 4d b8	 add	 ecx, DWORD PTR _from$[ebp]
  0034f	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx

; 219  :                         if (op < len) {         /* some from window */

  00352	8b 55 b4	 mov	 edx, DWORD PTR _op$[ebp]
  00355	3b 55 e0	 cmp	 edx, DWORD PTR _len$[ebp]
  00358	73 39		 jae	 SHORT $LN38@inflate_fa

; 220  :                             len -= op;

  0035a	8b 45 e0	 mov	 eax, DWORD PTR _len$[ebp]
  0035d	2b 45 b4	 sub	 eax, DWORD PTR _op$[ebp]
  00360	89 45 e0	 mov	 DWORD PTR _len$[ebp], eax
$LN37@inflate_fa:

; 221  :                             do {
; 222  :                                 PUP(out) = PUP(from);

  00363	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  00366	83 c1 01	 add	 ecx, 1
  00369	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx
  0036c	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  0036f	83 c2 01	 add	 edx, 1
  00372	89 55 b0	 mov	 DWORD PTR _out$[ebp], edx
  00375	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00378	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  0037b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0037d	88 10		 mov	 BYTE PTR [eax], dl

; 223  :                             } while (--op);

  0037f	8b 45 b4	 mov	 eax, DWORD PTR _op$[ebp]
  00382	83 e8 01	 sub	 eax, 1
  00385	89 45 b4	 mov	 DWORD PTR _op$[ebp], eax
  00388	75 d9		 jne	 SHORT $LN37@inflate_fa

; 224  :                             from = out - dist;  /* rest from output */

  0038a	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  0038d	2b 4d c8	 sub	 ecx, DWORD PTR _dist$[ebp]
  00390	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx
$LN38@inflate_fa:

; 225  :                         }

  00393	e9 ff 00 00 00	 jmp	 $LN19@inflate_fa
$LN39@inflate_fa:

; 226  :                     }
; 227  :                     else if (wnext < op) {      /* wrap around window */

  00398	8b 55 d8	 mov	 edx, DWORD PTR _wnext$[ebp]
  0039b	3b 55 b4	 cmp	 edx, DWORD PTR _op$[ebp]
  0039e	0f 83 a6 00 00
	00		 jae	 $LN33@inflate_fa

; 228  :                         from += wsize + wnext - op;

  003a4	8b 45 c0	 mov	 eax, DWORD PTR _wsize$[ebp]
  003a7	03 45 d8	 add	 eax, DWORD PTR _wnext$[ebp]
  003aa	2b 45 b4	 sub	 eax, DWORD PTR _op$[ebp]
  003ad	03 45 b8	 add	 eax, DWORD PTR _from$[ebp]
  003b0	89 45 b8	 mov	 DWORD PTR _from$[ebp], eax

; 229  :                         op -= wnext;

  003b3	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  003b6	2b 4d d8	 sub	 ecx, DWORD PTR _wnext$[ebp]
  003b9	89 4d b4	 mov	 DWORD PTR _op$[ebp], ecx

; 230  :                         if (op < len) {         /* some from end of window */

  003bc	8b 55 b4	 mov	 edx, DWORD PTR _op$[ebp]
  003bf	3b 55 e0	 cmp	 edx, DWORD PTR _len$[ebp]
  003c2	0f 83 80 00 00
	00		 jae	 $LN32@inflate_fa

; 231  :                             len -= op;

  003c8	8b 45 e0	 mov	 eax, DWORD PTR _len$[ebp]
  003cb	2b 45 b4	 sub	 eax, DWORD PTR _op$[ebp]
  003ce	89 45 e0	 mov	 DWORD PTR _len$[ebp], eax
$LN31@inflate_fa:

; 232  :                             do {
; 233  :                                 PUP(out) = PUP(from);

  003d1	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  003d4	83 c1 01	 add	 ecx, 1
  003d7	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx
  003da	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  003dd	83 c2 01	 add	 edx, 1
  003e0	89 55 b0	 mov	 DWORD PTR _out$[ebp], edx
  003e3	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  003e6	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  003e9	8a 11		 mov	 dl, BYTE PTR [ecx]
  003eb	88 10		 mov	 BYTE PTR [eax], dl

; 234  :                             } while (--op);

  003ed	8b 45 b4	 mov	 eax, DWORD PTR _op$[ebp]
  003f0	83 e8 01	 sub	 eax, 1
  003f3	89 45 b4	 mov	 DWORD PTR _op$[ebp], eax
  003f6	75 d9		 jne	 SHORT $LN31@inflate_fa

; 235  :                             from = window - OFF;

  003f8	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  003fb	83 e9 01	 sub	 ecx, 1
  003fe	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx

; 236  :                             if (wnext < len) {  /* some from start of window */

  00401	8b 55 d8	 mov	 edx, DWORD PTR _wnext$[ebp]
  00404	3b 55 e0	 cmp	 edx, DWORD PTR _len$[ebp]
  00407	73 3f		 jae	 SHORT $LN32@inflate_fa

; 237  :                                 op = wnext;

  00409	8b 45 d8	 mov	 eax, DWORD PTR _wnext$[ebp]
  0040c	89 45 b4	 mov	 DWORD PTR _op$[ebp], eax

; 238  :                                 len -= op;

  0040f	8b 4d e0	 mov	 ecx, DWORD PTR _len$[ebp]
  00412	2b 4d b4	 sub	 ecx, DWORD PTR _op$[ebp]
  00415	89 4d e0	 mov	 DWORD PTR _len$[ebp], ecx
$LN27@inflate_fa:

; 239  :                                 do {
; 240  :                                     PUP(out) = PUP(from);

  00418	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  0041b	83 c2 01	 add	 edx, 1
  0041e	89 55 b8	 mov	 DWORD PTR _from$[ebp], edx
  00421	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00424	83 c0 01	 add	 eax, 1
  00427	89 45 b0	 mov	 DWORD PTR _out$[ebp], eax
  0042a	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  0042d	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  00430	8a 02		 mov	 al, BYTE PTR [edx]
  00432	88 01		 mov	 BYTE PTR [ecx], al

; 241  :                                 } while (--op);

  00434	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  00437	83 e9 01	 sub	 ecx, 1
  0043a	89 4d b4	 mov	 DWORD PTR _op$[ebp], ecx
  0043d	75 d9		 jne	 SHORT $LN27@inflate_fa

; 242  :                                 from = out - dist;      /* rest from output */

  0043f	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  00442	2b 55 c8	 sub	 edx, DWORD PTR _dist$[ebp]
  00445	89 55 b8	 mov	 DWORD PTR _from$[ebp], edx
$LN32@inflate_fa:

; 243  :                             }
; 244  :                         }
; 245  :                     }
; 246  :                     else {                      /* contiguous in window */

  00448	eb 4d		 jmp	 SHORT $LN19@inflate_fa
$LN33@inflate_fa:

; 247  :                         from += wnext - op;

  0044a	8b 45 d8	 mov	 eax, DWORD PTR _wnext$[ebp]
  0044d	2b 45 b4	 sub	 eax, DWORD PTR _op$[ebp]
  00450	03 45 b8	 add	 eax, DWORD PTR _from$[ebp]
  00453	89 45 b8	 mov	 DWORD PTR _from$[ebp], eax

; 248  :                         if (op < len) {         /* some from window */

  00456	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  00459	3b 4d e0	 cmp	 ecx, DWORD PTR _len$[ebp]
  0045c	73 39		 jae	 SHORT $LN19@inflate_fa

; 249  :                             len -= op;

  0045e	8b 55 e0	 mov	 edx, DWORD PTR _len$[ebp]
  00461	2b 55 b4	 sub	 edx, DWORD PTR _op$[ebp]
  00464	89 55 e0	 mov	 DWORD PTR _len$[ebp], edx
$LN22@inflate_fa:

; 250  :                             do {
; 251  :                                 PUP(out) = PUP(from);

  00467	8b 45 b8	 mov	 eax, DWORD PTR _from$[ebp]
  0046a	83 c0 01	 add	 eax, 1
  0046d	89 45 b8	 mov	 DWORD PTR _from$[ebp], eax
  00470	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  00473	83 c1 01	 add	 ecx, 1
  00476	89 4d b0	 mov	 DWORD PTR _out$[ebp], ecx
  00479	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  0047c	8b 45 b8	 mov	 eax, DWORD PTR _from$[ebp]
  0047f	8a 08		 mov	 cl, BYTE PTR [eax]
  00481	88 0a		 mov	 BYTE PTR [edx], cl

; 252  :                             } while (--op);

  00483	8b 55 b4	 mov	 edx, DWORD PTR _op$[ebp]
  00486	83 ea 01	 sub	 edx, 1
  00489	89 55 b4	 mov	 DWORD PTR _op$[ebp], edx
  0048c	75 d9		 jne	 SHORT $LN22@inflate_fa

; 253  :                             from = out - dist;  /* rest from output */

  0048e	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00491	2b 45 c8	 sub	 eax, DWORD PTR _dist$[ebp]
  00494	89 45 b8	 mov	 DWORD PTR _from$[ebp], eax
$LN19@inflate_fa:

; 254  :                         }
; 255  :                     }
; 256  :                     while (len > 2) {

  00497	83 7d e0 02	 cmp	 DWORD PTR _len$[ebp], 2
  0049b	76 5f		 jbe	 SHORT $LN18@inflate_fa

; 257  :                         PUP(out) = PUP(from);

  0049d	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  004a0	83 c1 01	 add	 ecx, 1
  004a3	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx
  004a6	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  004a9	83 c2 01	 add	 edx, 1
  004ac	89 55 b0	 mov	 DWORD PTR _out$[ebp], edx
  004af	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  004b2	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  004b5	8a 11		 mov	 dl, BYTE PTR [ecx]
  004b7	88 10		 mov	 BYTE PTR [eax], dl

; 258  :                         PUP(out) = PUP(from);

  004b9	8b 45 b8	 mov	 eax, DWORD PTR _from$[ebp]
  004bc	83 c0 01	 add	 eax, 1
  004bf	89 45 b8	 mov	 DWORD PTR _from$[ebp], eax
  004c2	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  004c5	83 c1 01	 add	 ecx, 1
  004c8	89 4d b0	 mov	 DWORD PTR _out$[ebp], ecx
  004cb	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  004ce	8b 45 b8	 mov	 eax, DWORD PTR _from$[ebp]
  004d1	8a 08		 mov	 cl, BYTE PTR [eax]
  004d3	88 0a		 mov	 BYTE PTR [edx], cl

; 259  :                         PUP(out) = PUP(from);

  004d5	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  004d8	83 c2 01	 add	 edx, 1
  004db	89 55 b8	 mov	 DWORD PTR _from$[ebp], edx
  004de	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  004e1	83 c0 01	 add	 eax, 1
  004e4	89 45 b0	 mov	 DWORD PTR _out$[ebp], eax
  004e7	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  004ea	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  004ed	8a 02		 mov	 al, BYTE PTR [edx]
  004ef	88 01		 mov	 BYTE PTR [ecx], al

; 260  :                         len -= 3;

  004f1	8b 4d e0	 mov	 ecx, DWORD PTR _len$[ebp]
  004f4	83 e9 03	 sub	 ecx, 3
  004f7	89 4d e0	 mov	 DWORD PTR _len$[ebp], ecx

; 261  :                     }

  004fa	eb 9b		 jmp	 SHORT $LN19@inflate_fa
$LN18@inflate_fa:

; 262  :                     if (len) {

  004fc	83 7d e0 00	 cmp	 DWORD PTR _len$[ebp], 0
  00500	74 3e		 je	 SHORT $LN17@inflate_fa

; 263  :                         PUP(out) = PUP(from);

  00502	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  00505	83 c2 01	 add	 edx, 1
  00508	89 55 b8	 mov	 DWORD PTR _from$[ebp], edx
  0050b	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  0050e	83 c0 01	 add	 eax, 1
  00511	89 45 b0	 mov	 DWORD PTR _out$[ebp], eax
  00514	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  00517	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  0051a	8a 02		 mov	 al, BYTE PTR [edx]
  0051c	88 01		 mov	 BYTE PTR [ecx], al

; 264  :                         if (len > 1)

  0051e	83 7d e0 01	 cmp	 DWORD PTR _len$[ebp], 1
  00522	76 1c		 jbe	 SHORT $LN17@inflate_fa

; 265  :                             PUP(out) = PUP(from);

  00524	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  00527	83 c1 01	 add	 ecx, 1
  0052a	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx
  0052d	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  00530	83 c2 01	 add	 edx, 1
  00533	89 55 b0	 mov	 DWORD PTR _out$[ebp], edx
  00536	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00539	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  0053c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0053e	88 10		 mov	 BYTE PTR [eax], dl
$LN17@inflate_fa:

; 266  :                     }
; 267  :                 }
; 268  :                 else {

  00540	e9 b0 00 00 00	 jmp	 $LN15@inflate_fa
$LN42@inflate_fa:

; 269  :                     from = out - dist;          /* copy direct from output */

  00545	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00548	2b 45 c8	 sub	 eax, DWORD PTR _dist$[ebp]
  0054b	89 45 b8	 mov	 DWORD PTR _from$[ebp], eax
$LN14@inflate_fa:

; 270  :                     do {                        /* minimum length is three */
; 271  :                         PUP(out) = PUP(from);

  0054e	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  00551	83 c1 01	 add	 ecx, 1
  00554	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx
  00557	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  0055a	83 c2 01	 add	 edx, 1
  0055d	89 55 b0	 mov	 DWORD PTR _out$[ebp], edx
  00560	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00563	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  00566	8a 11		 mov	 dl, BYTE PTR [ecx]
  00568	88 10		 mov	 BYTE PTR [eax], dl

; 272  :                         PUP(out) = PUP(from);

  0056a	8b 45 b8	 mov	 eax, DWORD PTR _from$[ebp]
  0056d	83 c0 01	 add	 eax, 1
  00570	89 45 b8	 mov	 DWORD PTR _from$[ebp], eax
  00573	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  00576	83 c1 01	 add	 ecx, 1
  00579	89 4d b0	 mov	 DWORD PTR _out$[ebp], ecx
  0057c	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  0057f	8b 45 b8	 mov	 eax, DWORD PTR _from$[ebp]
  00582	8a 08		 mov	 cl, BYTE PTR [eax]
  00584	88 0a		 mov	 BYTE PTR [edx], cl

; 273  :                         PUP(out) = PUP(from);

  00586	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  00589	83 c2 01	 add	 edx, 1
  0058c	89 55 b8	 mov	 DWORD PTR _from$[ebp], edx
  0058f	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  00592	83 c0 01	 add	 eax, 1
  00595	89 45 b0	 mov	 DWORD PTR _out$[ebp], eax
  00598	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  0059b	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  0059e	8a 02		 mov	 al, BYTE PTR [edx]
  005a0	88 01		 mov	 BYTE PTR [ecx], al

; 274  :                         len -= 3;

  005a2	8b 4d e0	 mov	 ecx, DWORD PTR _len$[ebp]
  005a5	83 e9 03	 sub	 ecx, 3
  005a8	89 4d e0	 mov	 DWORD PTR _len$[ebp], ecx

; 275  :                     } while (len > 2);

  005ab	83 7d e0 02	 cmp	 DWORD PTR _len$[ebp], 2
  005af	77 9d		 ja	 SHORT $LN14@inflate_fa

; 276  :                     if (len) {

  005b1	83 7d e0 00	 cmp	 DWORD PTR _len$[ebp], 0
  005b5	74 3e		 je	 SHORT $LN15@inflate_fa

; 277  :                         PUP(out) = PUP(from);

  005b7	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  005ba	83 c2 01	 add	 edx, 1
  005bd	89 55 b8	 mov	 DWORD PTR _from$[ebp], edx
  005c0	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  005c3	83 c0 01	 add	 eax, 1
  005c6	89 45 b0	 mov	 DWORD PTR _out$[ebp], eax
  005c9	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  005cc	8b 55 b8	 mov	 edx, DWORD PTR _from$[ebp]
  005cf	8a 02		 mov	 al, BYTE PTR [edx]
  005d1	88 01		 mov	 BYTE PTR [ecx], al

; 278  :                         if (len > 1)

  005d3	83 7d e0 01	 cmp	 DWORD PTR _len$[ebp], 1
  005d7	76 1c		 jbe	 SHORT $LN15@inflate_fa

; 279  :                             PUP(out) = PUP(from);

  005d9	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  005dc	83 c1 01	 add	 ecx, 1
  005df	89 4d b8	 mov	 DWORD PTR _from$[ebp], ecx
  005e2	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  005e5	83 c2 01	 add	 edx, 1
  005e8	89 55 b0	 mov	 DWORD PTR _out$[ebp], edx
  005eb	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  005ee	8b 4d b8	 mov	 ecx, DWORD PTR _from$[ebp]
  005f1	8a 11		 mov	 dl, BYTE PTR [ecx]
  005f3	88 10		 mov	 BYTE PTR [eax], dl
$LN15@inflate_fa:

; 280  :                     }
; 281  :                 }

  005f5	eb 43		 jmp	 SHORT $LN9@inflate_fa
$LN45@inflate_fa:

; 282  :             }
; 283  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  005f7	8b 45 b4	 mov	 eax, DWORD PTR _op$[ebp]
  005fa	83 e0 40	 and	 eax, 64			; 00000040H
  005fd	75 26		 jne	 SHORT $LN8@inflate_fa

; 284  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  005ff	0f b7 55 fa	 movzx	 edx, WORD PTR _here$[ebp+2]
  00603	b8 01 00 00 00	 mov	 eax, 1
  00608	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  0060b	d3 e0		 shl	 eax, cl
  0060d	83 e8 01	 sub	 eax, 1
  00610	23 45 c4	 and	 eax, DWORD PTR _hold$[ebp]
  00613	03 d0		 add	 edx, eax
  00615	8b 4d ec	 mov	 ecx, DWORD PTR _dcode$[ebp]
  00618	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  0061b	89 55 f8	 mov	 DWORD PTR _here$[ebp], edx

; 285  :                 goto dodist;

  0061e	e9 0c fc ff ff	 jmp	 $dodist$77623

; 286  :             }
; 287  :             else {

  00623	eb 15		 jmp	 SHORT $LN9@inflate_fa
$LN8@inflate_fa:

; 288  :                 strm->msg = (char *)"invalid distance code";

  00625	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00628	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 289  :                 state->mode = BAD;

  0062f	8b 4d ac	 mov	 ecx, DWORD PTR _state$[ebp]
  00632	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 290  :                 break;

  00638	eb 6e		 jmp	 SHORT $LN53@inflate_fa
$LN9@inflate_fa:

; 291  :             }

  0063a	eb 58		 jmp	 SHORT $LN54@inflate_fa
$LN49@inflate_fa:

; 292  :         }
; 293  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  0063c	8b 55 b4	 mov	 edx, DWORD PTR _op$[ebp]
  0063f	83 e2 40	 and	 edx, 64			; 00000040H
  00642	75 26		 jne	 SHORT $LN5@inflate_fa

; 294  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  00644	0f b7 45 fa	 movzx	 eax, WORD PTR _here$[ebp+2]
  00648	ba 01 00 00 00	 mov	 edx, 1
  0064d	8b 4d b4	 mov	 ecx, DWORD PTR _op$[ebp]
  00650	d3 e2		 shl	 edx, cl
  00652	83 ea 01	 sub	 edx, 1
  00655	23 55 c4	 and	 edx, DWORD PTR _hold$[ebp]
  00658	03 c2		 add	 eax, edx
  0065a	8b 4d cc	 mov	 ecx, DWORD PTR _lcode$[ebp]
  0065d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00660	89 55 f8	 mov	 DWORD PTR _here$[ebp], edx
  00663	e9 bb fa ff ff	 jmp	 $dolen$77608

; 295  :             goto dolen;

  00668	eb 2a		 jmp	 SHORT $LN54@inflate_fa
$LN5@inflate_fa:

; 296  :         }
; 297  :         else if (op & 32) {                     /* end-of-block */

  0066a	8b 45 b4	 mov	 eax, DWORD PTR _op$[ebp]
  0066d	83 e0 20	 and	 eax, 32			; 00000020H
  00670	74 0d		 je	 SHORT $LN3@inflate_fa

; 298  :             Tracevv((stderr, "inflate:         end of block\n"));
; 299  :             state->mode = TYPE;

  00672	8b 4d ac	 mov	 ecx, DWORD PTR _state$[ebp]
  00675	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 300  :             break;

  0067b	eb 2b		 jmp	 SHORT $LN53@inflate_fa

; 301  :         }
; 302  :         else {

  0067d	eb 15		 jmp	 SHORT $LN54@inflate_fa
$LN3@inflate_fa:

; 303  :             strm->msg = (char *)"invalid literal/length code";

  0067f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00682	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 304  :             state->mode = BAD;

  00689	8b 45 ac	 mov	 eax, DWORD PTR _state$[ebp]
  0068c	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 305  :             break;

  00692	eb 14		 jmp	 SHORT $LN53@inflate_fa
$LN54@inflate_fa:

; 306  :         }
; 307  :     } while (in < last && out < end);

  00694	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  00697	3b 4d f0	 cmp	 ecx, DWORD PTR _last$[ebp]
  0069a	73 0c		 jae	 SHORT $LN53@inflate_fa
  0069c	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  0069f	3b 55 d0	 cmp	 edx, DWORD PTR _end$[ebp]
  006a2	0f 82 20 fa ff
	ff		 jb	 $LN55@inflate_fa
$LN53@inflate_fa:

; 308  : 
; 309  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 310  :     len = bits >> 3;

  006a8	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  006ab	c1 e8 03	 shr	 eax, 3
  006ae	89 45 e0	 mov	 DWORD PTR _len$[ebp], eax

; 311  :     in -= len;

  006b1	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  006b4	2b 4d e0	 sub	 ecx, DWORD PTR _len$[ebp]
  006b7	89 4d e4	 mov	 DWORD PTR _in$[ebp], ecx

; 312  :     bits -= len << 3;

  006ba	8b 55 e0	 mov	 edx, DWORD PTR _len$[ebp]
  006bd	c1 e2 03	 shl	 edx, 3
  006c0	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  006c3	2b c2		 sub	 eax, edx
  006c5	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax

; 313  :     hold &= (1U << bits) - 1;

  006c8	ba 01 00 00 00	 mov	 edx, 1
  006cd	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  006d0	d3 e2		 shl	 edx, cl
  006d2	83 ea 01	 sub	 edx, 1
  006d5	23 55 c4	 and	 edx, DWORD PTR _hold$[ebp]
  006d8	89 55 c4	 mov	 DWORD PTR _hold$[ebp], edx

; 314  : 
; 315  :     /* update state and return */
; 316  :     strm->next_in = in + OFF;

  006db	8b 45 e4	 mov	 eax, DWORD PTR _in$[ebp]
  006de	83 c0 01	 add	 eax, 1
  006e1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  006e4	89 01		 mov	 DWORD PTR [ecx], eax

; 317  :     strm->next_out = out + OFF;

  006e6	8b 55 b0	 mov	 edx, DWORD PTR _out$[ebp]
  006e9	83 c2 01	 add	 edx, 1
  006ec	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  006ef	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 318  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  006f2	8b 4d e4	 mov	 ecx, DWORD PTR _in$[ebp]
  006f5	3b 4d f0	 cmp	 ecx, DWORD PTR _last$[ebp]
  006f8	73 0e		 jae	 SHORT $LN58@inflate_fa
  006fa	8b 55 f0	 mov	 edx, DWORD PTR _last$[ebp]
  006fd	2b 55 e4	 sub	 edx, DWORD PTR _in$[ebp]
  00700	83 c2 05	 add	 edx, 5
  00703	89 55 a8	 mov	 DWORD PTR tv319[ebp], edx
  00706	eb 10		 jmp	 SHORT $LN59@inflate_fa
$LN58@inflate_fa:
  00708	8b 45 e4	 mov	 eax, DWORD PTR _in$[ebp]
  0070b	2b 45 f0	 sub	 eax, DWORD PTR _last$[ebp]
  0070e	b9 05 00 00 00	 mov	 ecx, 5
  00713	2b c8		 sub	 ecx, eax
  00715	89 4d a8	 mov	 DWORD PTR tv319[ebp], ecx
$LN59@inflate_fa:
  00718	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0071b	8b 45 a8	 mov	 eax, DWORD PTR tv319[ebp]
  0071e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 319  :     strm->avail_out = (unsigned)(out < end ?
; 320  :                                  257 + (end - out) : 257 - (out - end));

  00721	8b 4d b0	 mov	 ecx, DWORD PTR _out$[ebp]
  00724	3b 4d d0	 cmp	 ecx, DWORD PTR _end$[ebp]
  00727	73 11		 jae	 SHORT $LN60@inflate_fa
  00729	8b 55 d0	 mov	 edx, DWORD PTR _end$[ebp]
  0072c	2b 55 b0	 sub	 edx, DWORD PTR _out$[ebp]
  0072f	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00735	89 55 a4	 mov	 DWORD PTR tv326[ebp], edx
  00738	eb 10		 jmp	 SHORT $LN61@inflate_fa
$LN60@inflate_fa:
  0073a	8b 45 b0	 mov	 eax, DWORD PTR _out$[ebp]
  0073d	2b 45 d0	 sub	 eax, DWORD PTR _end$[ebp]
  00740	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  00745	2b c8		 sub	 ecx, eax
  00747	89 4d a4	 mov	 DWORD PTR tv326[ebp], ecx
$LN61@inflate_fa:
  0074a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0074d	8b 45 a4	 mov	 eax, DWORD PTR tv326[ebp]
  00750	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 321  :     state->hold = hold;

  00753	8b 4d ac	 mov	 ecx, DWORD PTR _state$[ebp]
  00756	8b 55 c4	 mov	 edx, DWORD PTR _hold$[ebp]
  00759	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 322  :     state->bits = bits;

  0075c	8b 45 ac	 mov	 eax, DWORD PTR _state$[ebp]
  0075f	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00762	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 323  :     return;
; 324  : }

  00765	8b e5		 mov	 esp, ebp
  00767	5d		 pop	 ebp
  00768	c3		 ret	 0
_inflate_fast ENDP
END
