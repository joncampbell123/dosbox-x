; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\dev\dosbox-x\vs2008\zlib\zutil.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@	; `string'
PUBLIC	??_C@_0N@DFPGLBGC@buffer?5error?$AA@		; `string'
PUBLIC	??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@	; `string'
PUBLIC	??_C@_0L@HAHMBNLP@data?5error?$AA@		; `string'
PUBLIC	??_C@_0N@MKKNPMJD@stream?5error?$AA@		; `string'
PUBLIC	??_C@_0L@KIJFAKBJ@file?5error?$AA@		; `string'
PUBLIC	??_C@_0L@FNAOCBOG@stream?5end?$AA@		; `string'
PUBLIC	??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@	; `string'
PUBLIC	_z_errmsg
_z_errmsg DD	FLAT:??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
	DD	FLAT:??_C@_0L@FNAOCBOG@stream?5end?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
	DD	FLAT:??_C@_0L@KIJFAKBJ@file?5error?$AA@
	DD	FLAT:??_C@_0N@MKKNPMJD@stream?5error?$AA@
	DD	FLAT:??_C@_0L@HAHMBNLP@data?5error?$AA@
	DD	FLAT:??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@
	DD	FLAT:??_C@_0N@DFPGLBGC@buffer?5error?$AA@
	DD	FLAT:??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@
	DD	FLAT:??_C@_00CNPNBAHC@?$AA@
;	COMDAT ??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@
CONST	SEGMENT
??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@ DB 'incompatible version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DFPGLBGC@buffer?5error?$AA@
CONST	SEGMENT
??_C@_0N@DFPGLBGC@buffer?5error?$AA@ DB 'buffer error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@
CONST	SEGMENT
??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@ DB 'insufficient memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HAHMBNLP@data?5error?$AA@
CONST	SEGMENT
??_C@_0L@HAHMBNLP@data?5error?$AA@ DB 'data error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MKKNPMJD@stream?5error?$AA@
CONST	SEGMENT
??_C@_0N@MKKNPMJD@stream?5error?$AA@ DB 'stream error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KIJFAKBJ@file?5error?$AA@
CONST	SEGMENT
??_C@_0L@KIJFAKBJ@file?5error?$AA@ DB 'file error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FNAOCBOG@stream?5end?$AA@
CONST	SEGMENT
??_C@_0L@FNAOCBOG@stream?5end?$AA@ DB 'stream end', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
CONST	SEGMENT
??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@ DB 'need dictionary', 00H ; `string'
CONST	ENDS
PUBLIC	_zcfree
; Function compile flags: /Odtp
; File c:\dev\dosbox-x\vs2008\zlib\zutil.c
;	COMDAT _zcfree
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_ptr$ = 12						; size = 4
_zcfree	PROC						; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 318  :     free(ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _ptr$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000d	83 c4 04	 add	 esp, 4

; 319  :     if (opaque) return; /* make compiler happy */
; 320  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_zcfree	ENDP
_TEXT	ENDS
PUBLIC	_zcalloc
; Function compile flags: /Odtp
;	COMDAT _zcalloc
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_items$ = 12						; size = 4
_size$ = 16						; size = 4
_zcalloc PROC						; COMDAT

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 309  :     if (opaque) items += size - size; /* make compiler happy */

  00003	83 7d 08 00	 cmp	 DWORD PTR _opaque$[ebp], 0
  00007	74 0c		 je	 SHORT $LN1@zcalloc
  00009	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  0000c	2b 45 10	 sub	 eax, DWORD PTR _size$[ebp]
  0000f	03 45 0c	 add	 eax, DWORD PTR _items$[ebp]
  00012	89 45 0c	 mov	 DWORD PTR _items$[ebp], eax
$LN1@zcalloc:

; 310  :     return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
; 311  :                               (voidpf)calloc(items, size);

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _items$[ebp]
  00018	0f af 4d 10	 imul	 ecx, DWORD PTR _size$[ebp]
  0001c	51		 push	 ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00023	83 c4 04	 add	 esp, 4

; 312  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_zcalloc ENDP
_TEXT	ENDS
PUBLIC	_zError@4
; Function compile flags: /Odtp
;	COMDAT _zError@4
_TEXT	SEGMENT
_err$ = 8						; size = 4
_zError@4 PROC						; COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  :     return ERR_MSG(err);

  00003	b8 02 00 00 00	 mov	 eax, 2
  00008	2b 45 08	 sub	 eax, DWORD PTR _err$[ebp]
  0000b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _z_errmsg[eax*4]

; 140  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
_zError@4 ENDP
_TEXT	ENDS
PUBLIC	_zlibCompileFlags@0
; Function compile flags: /Odtp
;	COMDAT _zlibCompileFlags@0
_TEXT	SEGMENT
tv85 = -20						; size = 4
tv78 = -16						; size = 4
tv71 = -12						; size = 4
tv64 = -8						; size = 4
_flags$ = -4						; size = 4
_zlibCompileFlags@0 PROC				; COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 37   :     uLong flags;
; 38   : 
; 39   :     flags = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _flags$[ebp], 0

; 40   :     switch ((int)(sizeof(uInt))) {

  0000d	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR tv64[ebp], 4
  00014	83 7d f8 02	 cmp	 DWORD PTR tv64[ebp], 2
  00018	74 0e		 je	 SHORT $LN22@zlibCompil
  0001a	83 7d f8 04	 cmp	 DWORD PTR tv64[ebp], 4
  0001e	74 0a		 je	 SHORT $LN21@zlibCompil
  00020	83 7d f8 08	 cmp	 DWORD PTR tv64[ebp], 8
  00024	74 0f		 je	 SHORT $LN20@zlibCompil
  00026	eb 18		 jmp	 SHORT $LN19@zlibCompil
$LN22@zlibCompil:

; 41   :     case 2:     break;

  00028	eb 1f		 jmp	 SHORT $LN23@zlibCompil
$LN21@zlibCompil:

; 42   :     case 4:     flags += 1;     break;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  0002d	83 c0 01	 add	 eax, 1
  00030	89 45 fc	 mov	 DWORD PTR _flags$[ebp], eax
  00033	eb 14		 jmp	 SHORT $LN23@zlibCompil
$LN20@zlibCompil:

; 43   :     case 8:     flags += 2;     break;

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _flags$[ebp]
  00038	83 c1 02	 add	 ecx, 2
  0003b	89 4d fc	 mov	 DWORD PTR _flags$[ebp], ecx
  0003e	eb 09		 jmp	 SHORT $LN23@zlibCompil
$LN19@zlibCompil:

; 44   :     default:    flags += 3;

  00040	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  00043	83 c2 03	 add	 edx, 3
  00046	89 55 fc	 mov	 DWORD PTR _flags$[ebp], edx
$LN23@zlibCompil:

; 45   :     }
; 46   :     switch ((int)(sizeof(uLong))) {

  00049	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR tv71[ebp], 4
  00050	83 7d f4 02	 cmp	 DWORD PTR tv71[ebp], 2
  00054	74 0e		 je	 SHORT $LN16@zlibCompil
  00056	83 7d f4 04	 cmp	 DWORD PTR tv71[ebp], 4
  0005a	74 0a		 je	 SHORT $LN15@zlibCompil
  0005c	83 7d f4 08	 cmp	 DWORD PTR tv71[ebp], 8
  00060	74 0f		 je	 SHORT $LN14@zlibCompil
  00062	eb 18		 jmp	 SHORT $LN13@zlibCompil
$LN16@zlibCompil:

; 47   :     case 2:     break;

  00064	eb 1f		 jmp	 SHORT $LN17@zlibCompil
$LN15@zlibCompil:

; 48   :     case 4:     flags += 1 << 2;        break;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  00069	83 c0 04	 add	 eax, 4
  0006c	89 45 fc	 mov	 DWORD PTR _flags$[ebp], eax
  0006f	eb 14		 jmp	 SHORT $LN17@zlibCompil
$LN14@zlibCompil:

; 49   :     case 8:     flags += 2 << 2;        break;

  00071	8b 4d fc	 mov	 ecx, DWORD PTR _flags$[ebp]
  00074	83 c1 08	 add	 ecx, 8
  00077	89 4d fc	 mov	 DWORD PTR _flags$[ebp], ecx
  0007a	eb 09		 jmp	 SHORT $LN17@zlibCompil
$LN13@zlibCompil:

; 50   :     default:    flags += 3 << 2;

  0007c	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  0007f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00082	89 55 fc	 mov	 DWORD PTR _flags$[ebp], edx
$LN17@zlibCompil:

; 51   :     }
; 52   :     switch ((int)(sizeof(voidpf))) {

  00085	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR tv78[ebp], 4
  0008c	83 7d f0 02	 cmp	 DWORD PTR tv78[ebp], 2
  00090	74 0e		 je	 SHORT $LN10@zlibCompil
  00092	83 7d f0 04	 cmp	 DWORD PTR tv78[ebp], 4
  00096	74 0a		 je	 SHORT $LN9@zlibCompil
  00098	83 7d f0 08	 cmp	 DWORD PTR tv78[ebp], 8
  0009c	74 0f		 je	 SHORT $LN8@zlibCompil
  0009e	eb 18		 jmp	 SHORT $LN7@zlibCompil
$LN10@zlibCompil:

; 53   :     case 2:     break;

  000a0	eb 1f		 jmp	 SHORT $LN11@zlibCompil
$LN9@zlibCompil:

; 54   :     case 4:     flags += 1 << 4;        break;

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  000a5	83 c0 10	 add	 eax, 16			; 00000010H
  000a8	89 45 fc	 mov	 DWORD PTR _flags$[ebp], eax
  000ab	eb 14		 jmp	 SHORT $LN11@zlibCompil
$LN8@zlibCompil:

; 55   :     case 8:     flags += 2 << 4;        break;

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _flags$[ebp]
  000b0	83 c1 20	 add	 ecx, 32			; 00000020H
  000b3	89 4d fc	 mov	 DWORD PTR _flags$[ebp], ecx
  000b6	eb 09		 jmp	 SHORT $LN11@zlibCompil
$LN7@zlibCompil:

; 56   :     default:    flags += 3 << 4;

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  000bb	83 c2 30	 add	 edx, 48			; 00000030H
  000be	89 55 fc	 mov	 DWORD PTR _flags$[ebp], edx
$LN11@zlibCompil:

; 57   :     }
; 58   :     switch ((int)(sizeof(z_off_t))) {

  000c1	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR tv85[ebp], 4
  000c8	83 7d ec 02	 cmp	 DWORD PTR tv85[ebp], 2
  000cc	74 0e		 je	 SHORT $LN4@zlibCompil
  000ce	83 7d ec 04	 cmp	 DWORD PTR tv85[ebp], 4
  000d2	74 0a		 je	 SHORT $LN3@zlibCompil
  000d4	83 7d ec 08	 cmp	 DWORD PTR tv85[ebp], 8
  000d8	74 0f		 je	 SHORT $LN2@zlibCompil
  000da	eb 1b		 jmp	 SHORT $LN1@zlibCompil
$LN4@zlibCompil:

; 59   :     case 2:     break;

  000dc	eb 25		 jmp	 SHORT $LN5@zlibCompil
$LN3@zlibCompil:

; 60   :     case 4:     flags += 1 << 6;        break;

  000de	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  000e1	83 c0 40	 add	 eax, 64			; 00000040H
  000e4	89 45 fc	 mov	 DWORD PTR _flags$[ebp], eax
  000e7	eb 1a		 jmp	 SHORT $LN5@zlibCompil
$LN2@zlibCompil:

; 61   :     case 8:     flags += 2 << 6;        break;

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _flags$[ebp]
  000ec	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000f2	89 4d fc	 mov	 DWORD PTR _flags$[ebp], ecx
  000f5	eb 0c		 jmp	 SHORT $LN5@zlibCompil
$LN1@zlibCompil:

; 62   :     default:    flags += 3 << 6;

  000f7	8b 55 fc	 mov	 edx, DWORD PTR _flags$[ebp]
  000fa	81 c2 c0 00 00
	00		 add	 edx, 192		; 000000c0H
  00100	89 55 fc	 mov	 DWORD PTR _flags$[ebp], edx
$LN5@zlibCompil:

; 63   :     }
; 64   : #ifdef DEBUG
; 65   :     flags += 1 << 8;
; 66   : #endif
; 67   : #if defined(ASMV) || defined(ASMINF)
; 68   :     flags += 1 << 9;
; 69   : #endif
; 70   : #ifdef ZLIB_WINAPI
; 71   :     flags += 1 << 10;

  00103	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]
  00106	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  0010b	89 45 fc	 mov	 DWORD PTR _flags$[ebp], eax

; 72   : #endif
; 73   : #ifdef BUILDFIXED
; 74   :     flags += 1 << 12;
; 75   : #endif
; 76   : #ifdef DYNAMIC_CRC_TABLE
; 77   :     flags += 1 << 13;
; 78   : #endif
; 79   : #ifdef NO_GZCOMPRESS
; 80   :     flags += 1L << 16;
; 81   : #endif
; 82   : #ifdef NO_GZIP
; 83   :     flags += 1L << 17;
; 84   : #endif
; 85   : #ifdef PKZIP_BUG_WORKAROUND
; 86   :     flags += 1L << 20;
; 87   : #endif
; 88   : #ifdef FASTEST
; 89   :     flags += 1L << 21;
; 90   : #endif
; 91   : #if defined(STDC) || defined(Z_HAVE_STDARG_H)
; 92   : #  ifdef NO_vsnprintf
; 93   :     flags += 1L << 25;
; 94   : #    ifdef HAS_vsprintf_void
; 95   :     flags += 1L << 26;
; 96   : #    endif
; 97   : #  else
; 98   : #    ifdef HAS_vsnprintf_void
; 99   :     flags += 1L << 26;
; 100  : #    endif
; 101  : #  endif
; 102  : #else
; 103  :     flags += 1L << 24;
; 104  : #  ifdef NO_snprintf
; 105  :     flags += 1L << 25;
; 106  : #    ifdef HAS_sprintf_void
; 107  :     flags += 1L << 26;
; 108  : #    endif
; 109  : #  else
; 110  : #    ifdef HAS_snprintf_void
; 111  :     flags += 1L << 26;
; 112  : #    endif
; 113  : #  endif
; 114  : #endif
; 115  :     return flags;

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _flags$[ebp]

; 116  : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
_zlibCompileFlags@0 ENDP
_TEXT	ENDS
PUBLIC	_zlibVersion@0
; Function compile flags: /Odtp
;	COMDAT _zlibVersion@0
_TEXT	SEGMENT
_zlibVersion@0 PROC					; COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 32   :     return ZLIB_VERSION;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@

; 33   : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_zlibVersion@0 ENDP
END
