; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\dev\dosbox-x\vs2008\zlib\gzread.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	__imp__memchr:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp__close:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
PUBLIC	_gzclose_r@4
; Function compile flags: /Odtp
; File c:\dev\dosbox-x\vs2008\zlib\gzread.c
;	COMDAT _gzclose_r@4
_TEXT	SEGMENT
tv88 = -16						; size = 4
_state$ = -12						; size = 4
_err$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose_r@4 PROC					; COMDAT

; 569  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 570  :     int ret, err;
; 571  :     gz_statep state;
; 572  : 
; 573  :     /* get internal structure */
; 574  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN3@gzclose_r

; 575  :         return Z_STREAM_ERROR;

  0000c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00011	e9 be 00 00 00	 jmp	 $LN4@gzclose_r
$LN3@gzclose_r:

; 576  :     state = (gz_statep)file;

  00016	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 577  : 
; 578  :     /* check that we're reading */
; 579  :     if (state->mode != GZ_READ)

  0001c	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001f	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00026	74 0a		 je	 SHORT $LN2@gzclose_r

; 580  :         return Z_STREAM_ERROR;

  00028	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002d	e9 a2 00 00 00	 jmp	 $LN4@gzclose_r
$LN2@gzclose_r:

; 581  : 
; 582  :     /* free memory and close file */
; 583  :     if (state->size) {

  00032	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00035	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  00039	74 2c		 je	 SHORT $LN1@gzclose_r

; 584  :         inflateEnd(&(state->strm));

  0003b	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0003e	83 c0 64	 add	 eax, 100		; 00000064H
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _inflateEnd@4

; 585  :         free(state->out);

  00047	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0004a	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0004d	52		 push	 edx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00054	83 c4 04	 add	 esp, 4

; 586  :         free(state->in);

  00057	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0005a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0005d	51		 push	 ecx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00064	83 c4 04	 add	 esp, 4
$LN1@gzclose_r:

; 587  :     }
; 588  :     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;

  00067	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0006a	33 c0		 xor	 eax, eax
  0006c	83 7a 5c fb	 cmp	 DWORD PTR [edx+92], -5	; fffffffbH
  00070	0f 95 c0	 setne	 al
  00073	83 e8 01	 sub	 eax, 1
  00076	83 e0 fb	 and	 eax, -5			; fffffffbH
  00079	89 45 f8	 mov	 DWORD PTR _err$[ebp], eax

; 589  :     gz_error(state, Z_OK, NULL);

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _gz_error
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 590  :     free(state->path);

  0008c	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0008f	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00092	50		 push	 eax
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00099	83 c4 04	 add	 esp, 4

; 591  :     ret = close(state->fd);

  0009c	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0009f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a2	52		 push	 edx
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__close
  000a9	83 c4 04	 add	 esp, 4
  000ac	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 592  :     free(state);

  000af	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000b9	83 c4 04	 add	 esp, 4

; 593  :     return ret ? Z_ERRNO : err;

  000bc	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000c0	74 09		 je	 SHORT $LN6@gzclose_r
  000c2	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR tv88[ebp], -1
  000c9	eb 06		 jmp	 SHORT $LN7@gzclose_r
$LN6@gzclose_r:
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _err$[ebp]
  000ce	89 4d f0	 mov	 DWORD PTR tv88[ebp], ecx
$LN7@gzclose_r:
  000d1	8b 45 f0	 mov	 eax, DWORD PTR tv88[ebp]
$LN4@gzclose_r:

; 594  : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
_gzclose_r@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_load
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_have$ = 20						; size = 4
_gz_load PROC						; COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 26   :     int ret;
; 27   : 
; 28   :     *have = 0;

  00004	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  00007	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN6@gz_load:

; 29   :     do {
; 30   :         ret = read(state->fd, buf + *have, len - *have);

  0000d	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  00010	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00013	2b 11		 sub	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0001c	03 08		 add	 ecx, DWORD PTR [eax]
  0001e	51		 push	 ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00022	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__read
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 31   :         if (ret <= 0)

  00032	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00036	7f 02		 jg	 SHORT $LN3@gz_load

; 32   :             break;

  00038	eb 17		 jmp	 SHORT $LN4@gz_load
$LN3@gz_load:

; 33   :         *have += ret;

  0003a	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	03 55 fc	 add	 edx, DWORD PTR _ret$[ebp]
  00042	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx

; 34   :     } while (*have < len);

  00047	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  0004a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004c	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  0004f	72 bc		 jb	 SHORT $LN6@gz_load
$LN4@gz_load:

; 35   :     if (ret < 0) {

  00051	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00055	7d 26		 jge	 SHORT $LN2@gz_load

; 36   :         gz_error(state, Z_ERRNO, zstrerror());

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]
  0005f	50		 push	 eax
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  00066	83 c4 04	 add	 esp, 4
  00069	50		 push	 eax
  0006a	6a ff		 push	 -1
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 _gz_error
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 37   :         return -1;

  00078	83 c8 ff	 or	 eax, -1
  0007b	eb 12		 jmp	 SHORT $LN7@gz_load
$LN2@gz_load:

; 38   :     }
; 39   :     if (ret == 0)

  0007d	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00081	75 0a		 jne	 SHORT $LN1@gz_load

; 40   :         state->eof = 1;

  00083	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00086	c7 42 40 01 00
	00 00		 mov	 DWORD PTR [edx+64], 1
$LN1@gz_load:

; 41   :     return 0;

  0008d	33 c0		 xor	 eax, eax
$LN7@gz_load:

; 42   : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_gz_load ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_avail
_TEXT	SEGMENT
_q$79566 = -20						; size = 4
_n$79567 = -16						; size = 4
_p$79565 = -12						; size = 4
_got$ = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_avail PROC						; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 54   :     unsigned got;
; 55   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 56   : 
; 57   :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  00016	74 11		 je	 SHORT $LN7@gz_avail
  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	83 7a 5c fb	 cmp	 DWORD PTR [edx+92], -5	; fffffffbH
  0001f	74 08		 je	 SHORT $LN7@gz_avail

; 58   :         return -1;

  00021	83 c8 ff	 or	 eax, -1
  00024	e9 a7 00 00 00	 jmp	 $LN8@gz_avail
$LN7@gz_avail:

; 59   :     if (state->eof == 0) {

  00029	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002c	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00030	0f 85 98 00 00
	00		 jne	 $LN6@gz_avail

; 60   :         if (strm->avail_in) {       /* copy what's there to the start */

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00039	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0003d	74 41		 je	 SHORT $LN5@gz_avail

; 61   :             unsigned char *p = state->in;

  0003f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00042	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00045	89 45 f4	 mov	 DWORD PTR _p$79565[ebp], eax

; 62   :             unsigned const char *q = strm->next_in;

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	89 55 ec	 mov	 DWORD PTR _q$79566[ebp], edx

; 63   :             unsigned n = strm->avail_in;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00053	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00056	89 4d f0	 mov	 DWORD PTR _n$79567[ebp], ecx
$LN4@gz_avail:

; 64   :             do {
; 65   :                 *p++ = *q++;

  00059	8b 55 f4	 mov	 edx, DWORD PTR _p$79565[ebp]
  0005c	8b 45 ec	 mov	 eax, DWORD PTR _q$79566[ebp]
  0005f	8a 08		 mov	 cl, BYTE PTR [eax]
  00061	88 0a		 mov	 BYTE PTR [edx], cl
  00063	8b 55 f4	 mov	 edx, DWORD PTR _p$79565[ebp]
  00066	83 c2 01	 add	 edx, 1
  00069	89 55 f4	 mov	 DWORD PTR _p$79565[ebp], edx
  0006c	8b 45 ec	 mov	 eax, DWORD PTR _q$79566[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 ec	 mov	 DWORD PTR _q$79566[ebp], eax

; 66   :             } while (--n);

  00075	8b 4d f0	 mov	 ecx, DWORD PTR _n$79567[ebp]
  00078	83 e9 01	 sub	 ecx, 1
  0007b	89 4d f0	 mov	 DWORD PTR _n$79567[ebp], ecx
  0007e	75 d9		 jne	 SHORT $LN4@gz_avail
$LN5@gz_avail:

; 67   :         }
; 68   :         if (gz_load(state, state->in + strm->avail_in,
; 69   :                     state->size - strm->avail_in, &got) == -1)

  00080	8d 55 f8	 lea	 edx, DWORD PTR _got$[ebp]
  00083	52		 push	 edx
  00084	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0008a	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0008d	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00090	52		 push	 edx
  00091	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00094	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00097	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0009a	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0009d	51		 push	 ecx
  0009e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _gz_load
  000a7	83 c4 10	 add	 esp, 16			; 00000010H
  000aa	83 f8 ff	 cmp	 eax, -1
  000ad	75 05		 jne	 SHORT $LN1@gz_avail

; 70   :             return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	eb 1c		 jmp	 SHORT $LN8@gz_avail
$LN1@gz_avail:

; 71   :         strm->avail_in += got;

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ba	03 55 f8	 add	 edx, DWORD PTR _got$[ebp]
  000bd	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000c0	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 72   :         strm->next_in = state->in;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000c6	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000c9	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000cc	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@gz_avail:

; 73   :     }
; 74   :     return 0;

  000ce	33 c0		 xor	 eax, eax
$LN8@gz_avail:

; 75   : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
_gz_avail ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_decomp
_TEXT	SEGMENT
tv92 = -16						; size = 4
_ret$ = -12						; size = 4
_had$ = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_decomp PROC						; COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 175  :     int ret = Z_OK;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 176  :     unsigned had;
; 177  :     z_streamp strm = &(state->strm);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00010	83 c0 64	 add	 eax, 100		; 00000064H
  00013	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 178  : 
; 179  :     /* fill output buffer up to end of deflate stream */
; 180  :     had = strm->avail_out;

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00019	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0001c	89 55 f8	 mov	 DWORD PTR _had$[ebp], edx
$LN11@gz_decomp:

; 181  :     do {
; 182  :         /* get more input for inflate() */
; 183  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00022	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00026	75 19		 jne	 SHORT $LN8@gz_decomp
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _gz_avail
  00031	83 c4 04	 add	 esp, 4
  00034	83 f8 ff	 cmp	 eax, -1
  00037	75 08		 jne	 SHORT $LN8@gz_decomp

; 184  :             return -1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	e9 f0 00 00 00	 jmp	 $LN12@gz_decomp
$LN8@gz_decomp:

; 185  :         if (strm->avail_in == 0) {

  00041	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00044	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00048	75 18		 jne	 SHORT $LN7@gz_decomp

; 186  :             gz_error(state, Z_BUF_ERROR, "unexpected end of file");

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  0004f	6a fb		 push	 -5			; fffffffbH
  00051	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _gz_error
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 187  :             break;

  0005d	e9 9e 00 00 00	 jmp	 $LN9@gz_decomp
$LN7@gz_decomp:

; 188  :         }
; 189  : 
; 190  :         /* decompress and handle errors */
; 191  :         ret = inflate(strm, Z_NO_FLUSH);

  00062	6a 00		 push	 0
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _inflate@8
  0006d	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 192  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  00070	83 7d f4 fe	 cmp	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  00074	74 06		 je	 SHORT $LN5@gz_decomp
  00076	83 7d f4 02	 cmp	 DWORD PTR _ret$[ebp], 2
  0007a	75 1b		 jne	 SHORT $LN6@gz_decomp
$LN5@gz_decomp:

; 193  :             gz_error(state, Z_STREAM_ERROR,
; 194  :                      "internal error: inflate stream corrupt");

  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  00081	6a fe		 push	 -2			; fffffffeH
  00083	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _gz_error
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  :             return -1;

  0008f	83 c8 ff	 or	 eax, -1
  00092	e9 9a 00 00 00	 jmp	 $LN12@gz_decomp
$LN6@gz_decomp:

; 196  :         }
; 197  :         if (ret == Z_MEM_ERROR) {

  00097	83 7d f4 fc	 cmp	 DWORD PTR _ret$[ebp], -4 ; fffffffcH
  0009b	75 18		 jne	 SHORT $LN4@gz_decomp

; 198  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000a2	6a fc		 push	 -4			; fffffffcH
  000a4	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _gz_error
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 199  :             return -1;

  000b0	83 c8 ff	 or	 eax, -1
  000b3	eb 7c		 jmp	 SHORT $LN12@gz_decomp
$LN4@gz_decomp:

; 200  :         }
; 201  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  000b5	83 7d f4 fd	 cmp	 DWORD PTR _ret$[ebp], -3 ; fffffffdH
  000b9	75 32		 jne	 SHORT $LN10@gz_decomp

; 202  :             gz_error(state, Z_DATA_ERROR,
; 203  :                      strm->msg == NULL ? "compressed data error" : strm->msg);

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000be	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  000c2	75 09		 jne	 SHORT $LN14@gz_decomp
  000c4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], OFFSET ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
  000cb	eb 09		 jmp	 SHORT $LN15@gz_decomp
$LN14@gz_decomp:
  000cd	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000d0	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000d3	89 45 f0	 mov	 DWORD PTR tv92[ebp], eax
$LN15@gz_decomp:
  000d6	8b 4d f0	 mov	 ecx, DWORD PTR tv92[ebp]
  000d9	51		 push	 ecx
  000da	6a fd		 push	 -3			; fffffffdH
  000dc	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000df	52		 push	 edx
  000e0	e8 00 00 00 00	 call	 _gz_error
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  :             return -1;

  000e8	83 c8 ff	 or	 eax, -1
  000eb	eb 44		 jmp	 SHORT $LN12@gz_decomp
$LN10@gz_decomp:

; 205  :         }
; 206  :     } while (strm->avail_out && ret != Z_STREAM_END);

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000f0	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000f4	74 0a		 je	 SHORT $LN9@gz_decomp
  000f6	83 7d f4 01	 cmp	 DWORD PTR _ret$[ebp], 1
  000fa	0f 85 1f ff ff
	ff		 jne	 $LN11@gz_decomp
$LN9@gz_decomp:

; 207  : 
; 208  :     /* update available output */
; 209  :     state->x.have = had - strm->avail_out;

  00100	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00103	8b 55 f8	 mov	 edx, DWORD PTR _had$[ebp]
  00106	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  00109	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0010c	89 10		 mov	 DWORD PTR [eax], edx

; 210  :     state->x.next = strm->next_out - state->x.have;

  0010e	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00111	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00114	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00117	2b 02		 sub	 eax, DWORD PTR [edx]
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0011c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 211  : 
; 212  :     /* if the gzip stream completed successfully, look for another */
; 213  :     if (ret == Z_STREAM_END)

  0011f	83 7d f4 01	 cmp	 DWORD PTR _ret$[ebp], 1
  00123	75 0a		 jne	 SHORT $LN1@gz_decomp

; 214  :         state->how = LOOK;

  00125	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00128	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
$LN1@gz_decomp:

; 215  : 
; 216  :     /* good decompression */
; 217  :     return 0;

  0012f	33 c0		 xor	 eax, eax
$LN12@gz_decomp:

; 218  : }

  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
_gz_decomp ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_look
_TEXT	SEGMENT
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_look PROC						; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 89   :     z_streamp strm = &(state->strm);

  00004	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00007	83 c0 64	 add	 eax, 100		; 00000064H
  0000a	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 90   : 
; 91   :     /* allocate read buffers and inflate memory */
; 92   :     if (state->size == 0) {

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00014	0f 85 32 01 00
	00		 jne	 $LN12@gz_look

; 93   :         /* allocate buffers */
; 94   :         state->in = (unsigned char *)malloc(state->want);

  0001a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001d	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002d	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 95   :         state->out = (unsigned char *)malloc(state->want << 1);

  00030	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00033	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00036	d1 e0		 shl	 eax, 1
  00038	50		 push	 eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003f	83 c4 04	 add	 esp, 4
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00045	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 96   :         if (state->in == NULL || state->out == NULL) {

  00048	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0004b	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0004f	74 09		 je	 SHORT $LN10@gz_look
  00051	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00054	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00058	75 4d		 jne	 SHORT $LN11@gz_look
$LN10@gz_look:

; 97   :             if (state->out != NULL)

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005d	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  00061	74 10		 je	 SHORT $LN9@gz_look

; 98   :                 free(state->out);

  00063	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00066	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00069	50		 push	 eax
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00070	83 c4 04	 add	 esp, 4
$LN9@gz_look:

; 99   :             if (state->in != NULL)

  00073	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00076	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0007a	74 10		 je	 SHORT $LN8@gz_look

; 100  :                 free(state->in);

  0007c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0007f	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00089	83 c4 04	 add	 esp, 4
$LN8@gz_look:

; 101  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00091	6a fc		 push	 -4			; fffffffcH
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _gz_error
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 102  :             return -1;

  0009f	83 c8 ff	 or	 eax, -1
  000a2	e9 a8 01 00 00	 jmp	 $LN13@gz_look
$LN11@gz_look:

; 103  :         }
; 104  :         state->size = state->want;

  000a7	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000aa	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ad	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000b0	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 105  : 
; 106  :         /* allocate inflate memory */
; 107  :         state->strm.zalloc = Z_NULL;

  000b3	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b6	c7 82 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+132], 0

; 108  :         state->strm.zfree = Z_NULL;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+136], 0

; 109  :         state->strm.opaque = Z_NULL;

  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000d0	c7 81 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+140], 0

; 110  :         state->strm.avail_in = 0;

  000da	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000dd	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 111  :         state->strm.next_in = Z_NULL;

  000e4	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000e7	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [eax+100], 0

; 112  :         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */

  000ee	6a 38		 push	 56			; 00000038H
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  000f5	6a 1f		 push	 31			; 0000001fH
  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000fa	83 c1 64	 add	 ecx, 100		; 00000064H
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _inflateInit2_@16
  00103	85 c0		 test	 eax, eax
  00105	74 45		 je	 SHORT $LN12@gz_look

; 113  :             free(state->out);

  00107	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0010a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0010d	50		 push	 eax
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00114	83 c4 04	 add	 esp, 4

; 114  :             free(state->in);

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0011a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0011d	52		 push	 edx
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00124	83 c4 04	 add	 esp, 4

; 115  :             state->size = 0;

  00127	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0012a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 116  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00136	6a fc		 push	 -4			; fffffffcH
  00138	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0013b	51		 push	 ecx
  0013c	e8 00 00 00 00	 call	 _gz_error
  00141	83 c4 0c	 add	 esp, 12			; 0000000cH

; 117  :             return -1;

  00144	83 c8 ff	 or	 eax, -1
  00147	e9 03 01 00 00	 jmp	 $LN13@gz_look
$LN12@gz_look:

; 118  :         }
; 119  :     }
; 120  : 
; 121  :     /* get at least the magic bytes in the input buffer */
; 122  :     if (strm->avail_in < 2) {

  0014c	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0014f	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  00153	73 29		 jae	 SHORT $LN6@gz_look

; 123  :         if (gz_avail(state) == -1)

  00155	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 _gz_avail
  0015e	83 c4 04	 add	 esp, 4
  00161	83 f8 ff	 cmp	 eax, -1
  00164	75 08		 jne	 SHORT $LN5@gz_look

; 124  :             return -1;

  00166	83 c8 ff	 or	 eax, -1
  00169	e9 e1 00 00 00	 jmp	 $LN13@gz_look
$LN5@gz_look:

; 125  :         if (strm->avail_in == 0)

  0016e	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00171	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00175	75 07		 jne	 SHORT $LN6@gz_look

; 126  :             return 0;

  00177	33 c0		 xor	 eax, eax
  00179	e9 d1 00 00 00	 jmp	 $LN13@gz_look
$LN6@gz_look:

; 127  :     }
; 128  : 
; 129  :     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
; 130  :        a logical dilemma here when considering the case of a partially written
; 131  :        gzip file, to wit, if a single 31 byte is written, then we cannot tell
; 132  :        whether this is a single-byte file, or just a partially written gzip
; 133  :        file -- for here we assume that if a gzip file is being written, then
; 134  :        the header will be written in a single operation, so that reading a
; 135  :        single byte is sufficient indication that it is not a gzip file) */
; 136  :     if (strm->avail_in > 1 &&
; 137  :             strm->next_in[0] == 31 && strm->next_in[1] == 139) {

  0017e	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00181	83 7a 04 01	 cmp	 DWORD PTR [edx+4], 1
  00185	76 42		 jbe	 SHORT $LN3@gz_look
  00187	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  0018a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018c	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0018f	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  00192	75 35		 jne	 SHORT $LN3@gz_look
  00194	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00197	8b 08		 mov	 ecx, DWORD PTR [eax]
  00199	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0019d	81 fa 8b 00 00
	00		 cmp	 edx, 139		; 0000008bH
  001a3	75 24		 jne	 SHORT $LN3@gz_look

; 138  :         inflateReset(strm);

  001a5	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  001a8	50		 push	 eax
  001a9	e8 00 00 00 00	 call	 _inflateReset@4

; 139  :         state->how = GZIP;

  001ae	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001b1	c7 41 30 02 00
	00 00		 mov	 DWORD PTR [ecx+48], 2

; 140  :         state->direct = 0;

  001b8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001bb	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 141  :         return 0;

  001c2	33 c0		 xor	 eax, eax
  001c4	e9 86 00 00 00	 jmp	 $LN13@gz_look
$LN3@gz_look:

; 142  :     }
; 143  : 
; 144  :     /* no gzip header -- if we were decoding gzip before, then this is trailing
; 145  :        garbage.  Ignore the trailing garbage and finish. */
; 146  :     if (state->direct == 0) {

  001c9	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001cc	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  001d0	75 21		 jne	 SHORT $LN2@gz_look

; 147  :         strm->avail_in = 0;

  001d2	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  001d5	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 148  :         state->eof = 1;

  001dc	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001df	c7 42 40 01 00
	00 00		 mov	 DWORD PTR [edx+64], 1

; 149  :         state->x.have = 0;

  001e6	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001e9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 150  :         return 0;

  001ef	33 c0		 xor	 eax, eax
  001f1	eb 5c		 jmp	 SHORT $LN13@gz_look
$LN2@gz_look:

; 151  :     }
; 152  : 
; 153  :     /* doing raw i/o, copy any leftover input to output -- this assumes that
; 154  :        the output buffer is larger than the input buffer, which also assures
; 155  :        space for gzungetc() */
; 156  :     state->x.next = state->out;

  001f3	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001f6	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001f9	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  001fc	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 157  :     if (strm->avail_in) {

  001ff	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00202	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00206	74 31		 je	 SHORT $LN1@gz_look

; 158  :         memcpy(state->x.next, strm->next_in, strm->avail_in);

  00208	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0020b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0020e	50		 push	 eax
  0020f	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00212	8b 11		 mov	 edx, DWORD PTR [ecx]
  00214	52		 push	 edx
  00215	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00218	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0021b	51		 push	 ecx
  0021c	e8 00 00 00 00	 call	 _memcpy
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  :         state->x.have = strm->avail_in;

  00224	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00227	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  0022a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0022d	89 0a		 mov	 DWORD PTR [edx], ecx

; 160  :         strm->avail_in = 0;

  0022f	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00232	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN1@gz_look:

; 161  :     }
; 162  :     state->how = COPY;

  00239	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0023c	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1

; 163  :     state->direct = 1;

  00243	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00246	c7 41 2c 01 00
	00 00		 mov	 DWORD PTR [ecx+44], 1

; 164  :     return 0;

  0024d	33 c0		 xor	 eax, eax
$LN13@gz_look:

; 165  : }

  0024f	8b e5		 mov	 esp, ebp
  00251	5d		 pop	 ebp
  00252	c3		 ret	 0
_gz_look ENDP
PUBLIC	_gzdirect@4
; Function compile flags: /Odtp
;	COMDAT _gzdirect@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzdirect@4 PROC					; COMDAT

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 550  :     gz_statep state;
; 551  : 
; 552  :     /* get internal structure */
; 553  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 04		 jne	 SHORT $LN2@gzdirect

; 554  :         return 0;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 35		 jmp	 SHORT $LN3@gzdirect
$LN2@gzdirect:

; 555  :     state = (gz_statep)file;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00011	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 556  : 
; 557  :     /* if the state is not known, but we can find out, then do so (this is
; 558  :        mainly for right after a gzopen() or gzdopen()) */
; 559  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00017	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0001e	75 1d		 jne	 SHORT $LN1@gzdirect
  00020	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00023	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00027	75 14		 jne	 SHORT $LN1@gzdirect
  00029	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002f	75 0c		 jne	 SHORT $LN1@gzdirect

; 560  :         (void)gz_look(state);

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _gz_look
  0003a	83 c4 04	 add	 esp, 4
$LN1@gzdirect:

; 561  : 
; 562  :     /* return 1 if transparent, 0 if processing a gzip stream */
; 563  :     return state->direct;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00040	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
$LN3@gzdirect:

; 564  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
_gzdirect@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_fetch
_TEXT	SEGMENT
tv66 = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_fetch PROC						; COMDAT

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 229  :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax
$LN13@gz_fetch:

; 230  : 
; 231  :     do {
; 232  :         switch(state->how) {

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00015	89 55 f8	 mov	 DWORD PTR tv66[ebp], edx
  00018	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001c	74 11		 je	 SHORT $LN8@gz_fetch
  0001e	83 7d f8 01	 cmp	 DWORD PTR tv66[ebp], 1
  00022	74 36		 je	 SHORT $LN5@gz_fetch
  00024	83 7d f8 02	 cmp	 DWORD PTR tv66[ebp], 2
  00028	74 6a		 je	 SHORT $LN3@gz_fetch
  0002a	e9 95 00 00 00	 jmp	 $LN12@gz_fetch
$LN8@gz_fetch:

; 233  :         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
; 234  :             if (gz_look(state) == -1)

  0002f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _gz_look
  00038	83 c4 04	 add	 esp, 4
  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	75 08		 jne	 SHORT $LN7@gz_fetch

; 235  :                 return -1;

  00040	83 c8 ff	 or	 eax, -1
  00043	e9 a0 00 00 00	 jmp	 $LN14@gz_fetch
$LN7@gz_fetch:

; 236  :             if (state->how == LOOK)

  00048	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0004b	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  0004f	75 07		 jne	 SHORT $LN6@gz_fetch

; 237  :                 return 0;

  00051	33 c0		 xor	 eax, eax
  00053	e9 90 00 00 00	 jmp	 $LN14@gz_fetch
$LN6@gz_fetch:

; 238  :             break;

  00058	eb 6a		 jmp	 SHORT $LN12@gz_fetch
$LN5@gz_fetch:

; 239  :         case COPY:      /* -> COPY */
; 240  :             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
; 241  :                     == -1)

  0005a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005d	52		 push	 edx
  0005e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00061	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00064	d1 e1		 shl	 ecx, 1
  00066	51		 push	 ecx
  00067	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0006d	50		 push	 eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _gz_load
  00077	83 c4 10	 add	 esp, 16			; 00000010H
  0007a	83 f8 ff	 cmp	 eax, -1
  0007d	75 05		 jne	 SHORT $LN4@gz_fetch

; 242  :                 return -1;

  0007f	83 c8 ff	 or	 eax, -1
  00082	eb 64		 jmp	 SHORT $LN14@gz_fetch
$LN4@gz_fetch:

; 243  :             state->x.next = state->out;

  00084	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00087	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0008d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 244  :             return 0;

  00090	33 c0		 xor	 eax, eax
  00092	eb 54		 jmp	 SHORT $LN14@gz_fetch
$LN3@gz_fetch:

; 245  :         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
; 246  :             strm->avail_out = state->size << 1;

  00094	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00097	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0009a	d1 e0		 shl	 eax, 1
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0009f	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 247  :             strm->next_out = state->out;

  000a2	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000a5	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a8	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000ab	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 248  :             if (gz_decomp(state) == -1)

  000ae	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _gz_decomp
  000b7	83 c4 04	 add	 esp, 4
  000ba	83 f8 ff	 cmp	 eax, -1
  000bd	75 05		 jne	 SHORT $LN12@gz_fetch

; 249  :                 return -1;

  000bf	83 c8 ff	 or	 eax, -1
  000c2	eb 24		 jmp	 SHORT $LN14@gz_fetch
$LN12@gz_fetch:

; 250  :         }
; 251  :     } while (state->x.have == 0 && (!state->eof || strm->avail_in));

  000c4	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c7	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ca	75 1a		 jne	 SHORT $LN11@gz_fetch
  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000cf	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  000d3	0f 84 36 ff ff
	ff		 je	 $LN13@gz_fetch
  000d9	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000dc	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000e0	0f 85 29 ff ff
	ff		 jne	 $LN13@gz_fetch
$LN11@gz_fetch:

; 252  :     return 0;

  000e6	33 c0		 xor	 eax, eax
$LN14@gz_fetch:

; 253  : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_gz_fetch ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_skip
_TEXT	SEGMENT
tv70 = -16						; size = 4
tv129 = -12						; size = 8
_n$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 8
_gz_skip PROC						; COMDAT

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
$LN7@gz_skip:

; 260  :     unsigned n;
; 261  : 
; 262  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 263  :     while (len)

  00006	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00009	0b 45 10	 or	 eax, DWORD PTR _len$[ebp+4]
  0000c	0f 84 c2 00 00
	00		 je	 $LN6@gz_skip

; 264  :         /* skip over whatever is in output buffer */
; 265  :         if (state->x.have) {

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00015	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00018	0f 84 85 00 00
	00		 je	 $LN5@gz_skip

; 266  :             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
; 267  :                 (unsigned)len : state->x.have;

  0001e	33 d2		 xor	 edx, edx
  00020	75 29		 jne	 SHORT $LN10@gz_skip
  00022	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	33 d2		 xor	 edx, edx
  00029	89 4d f4	 mov	 DWORD PTR tv129[ebp], ecx
  0002c	89 55 f8	 mov	 DWORD PTR tv129[ebp+4], edx
  0002f	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp+4]
  00032	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp+4]
  00035	7f 14		 jg	 SHORT $LN10@gz_skip
  00037	7c 08		 jl	 SHORT $LN12@gz_skip
  00039	8b 4d f4	 mov	 ecx, DWORD PTR tv129[ebp]
  0003c	3b 4d 0c	 cmp	 ecx, DWORD PTR _len$[ebp]
  0003f	77 0a		 ja	 SHORT $LN10@gz_skip
$LN12@gz_skip:
  00041	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN11@gz_skip
$LN10@gz_skip:
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  0004e	89 4d f0	 mov	 DWORD PTR tv70[ebp], ecx
$LN11@gz_skip:
  00051	8b 55 f0	 mov	 edx, DWORD PTR tv70[ebp]
  00054	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 268  :             state->x.have -= n;

  00057	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  0005f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00062	89 0a		 mov	 DWORD PTR [edx], ecx

; 269  :             state->x.next += n;

  00064	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  0006d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00070	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 270  :             state->x.pos += n;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00076	33 c9		 xor	 ecx, ecx
  00078	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0007b	03 42 08	 add	 eax, DWORD PTR [edx+8]
  0007e	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00081	13 d1		 adc	 edx, ecx
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00086	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00089	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 271  :             len -= n;

  0008c	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  0008f	33 c0		 xor	 eax, eax
  00091	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00094	2b ca		 sub	 ecx, edx
  00096	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp+4]
  00099	1b d0		 sbb	 edx, eax
  0009b	89 4d 0c	 mov	 DWORD PTR _len$[ebp], ecx
  0009e	89 55 10	 mov	 DWORD PTR _len$[ebp+4], edx
  000a1	eb 2c		 jmp	 SHORT $LN4@gz_skip
$LN5@gz_skip:

; 272  :         }
; 273  : 
; 274  :         /* output buffer empty -- return if we're at the end of the input */
; 275  :         else if (state->eof && state->strm.avail_in == 0)

  000a3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a6	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  000aa	74 0d		 je	 SHORT $LN3@gz_skip
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000af	83 79 68 00	 cmp	 DWORD PTR [ecx+104], 0
  000b3	75 04		 jne	 SHORT $LN3@gz_skip

; 276  :             break;

  000b5	eb 1d		 jmp	 SHORT $LN6@gz_skip

; 277  : 
; 278  :         /* need more data to skip -- load up output buffer */
; 279  :         else {

  000b7	eb 16		 jmp	 SHORT $LN4@gz_skip
$LN3@gz_skip:

; 280  :             /* get more output, looking for header if required */
; 281  :             if (gz_fetch(state) == -1)

  000b9	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 _gz_fetch
  000c2	83 c4 04	 add	 esp, 4
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 05		 jne	 SHORT $LN4@gz_skip

; 282  :                 return -1;

  000ca	83 c8 ff	 or	 eax, -1
  000cd	eb 07		 jmp	 SHORT $LN8@gz_skip
$LN4@gz_skip:

; 283  :         }

  000cf	e9 32 ff ff ff	 jmp	 $LN7@gz_skip
$LN6@gz_skip:

; 284  :     return 0;

  000d4	33 c0		 xor	 eax, eax
$LN8@gz_skip:

; 285  : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
_gz_skip ENDP
PUBLIC	_gzgets@12
; Function compile flags: /Odtp
;	COMDAT _gzgets@12
_TEXT	SEGMENT
tv90 = -24						; size = 4
_str$ = -20						; size = 4
_state$ = -16						; size = 4
_left$ = -12						; size = 4
_n$ = -8						; size = 4
_eol$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzgets@12 PROC						; COMDAT

; 487  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 488  :     unsigned left, n;
; 489  :     char *str;
; 490  :     unsigned char *eol;
; 491  :     gz_statep state;
; 492  : 
; 493  :     /* check parameters and get internal structure */
; 494  :     if (file == NULL || buf == NULL || len < 1)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	74 0c		 je	 SHORT $LN14@gzgets
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _buf$[ebp], 0
  00010	74 06		 je	 SHORT $LN14@gzgets
  00012	83 7d 10 01	 cmp	 DWORD PTR _len$[ebp], 1
  00016	7d 07		 jge	 SHORT $LN15@gzgets
$LN14@gzgets:

; 495  :         return NULL;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 7e 01 00 00	 jmp	 $LN16@gzgets
$LN15@gzgets:

; 496  :     state = (gz_statep)file;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00022	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 497  : 
; 498  :     /* check that we're reading and that there's no (serious) error */
; 499  :     if (state->mode != GZ_READ ||
; 500  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00025	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00028	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0002f	75 12		 jne	 SHORT $LN12@gzgets
  00031	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00034	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00038	74 10		 je	 SHORT $LN13@gzgets
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0003d	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00041	74 07		 je	 SHORT $LN13@gzgets
$LN12@gzgets:

; 501  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 53 01 00 00	 jmp	 $LN16@gzgets
$LN13@gzgets:

; 502  : 
; 503  :     /* process a skip request */
; 504  :     if (state->seek) {

  0004a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0004d	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00051	74 2d		 je	 SHORT $LN11@gzgets

; 505  :         state->seek = 0;

  00053	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00056	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 506  :         if (gz_skip(state, state->skip) == -1)

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00060	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00063	51		 push	 ecx
  00064	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00067	52		 push	 edx
  00068	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _gz_skip
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	83 f8 ff	 cmp	 eax, -1
  00077	75 07		 jne	 SHORT $LN11@gzgets

; 507  :             return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 1d 01 00 00	 jmp	 $LN16@gzgets
$LN11@gzgets:

; 508  :     }
; 509  : 
; 510  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 511  :        append a terminating zero to the string (we don't check for a zero in
; 512  :        the contents, let the user worry about that) */
; 513  :     str = buf;

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00083	89 4d ec	 mov	 DWORD PTR _str$[ebp], ecx

; 514  :     left = (unsigned)len - 1;

  00086	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00089	83 ea 01	 sub	 edx, 1
  0008c	89 55 f4	 mov	 DWORD PTR _left$[ebp], edx

; 515  :     if (left) do {

  0008f	0f 84 f3 00 00
	00		 je	 $LN9@gzgets
$LN8@gzgets:

; 516  :         /* assure that something is in the output buffer */
; 517  :         if (state->x.have == 0 && gz_fetch(state) == -1)

  00095	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00098	83 38 00	 cmp	 DWORD PTR [eax], 0
  0009b	75 18		 jne	 SHORT $LN5@gzgets
  0009d	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _gz_fetch
  000a6	83 c4 04	 add	 esp, 4
  000a9	83 f8 ff	 cmp	 eax, -1
  000ac	75 07		 jne	 SHORT $LN5@gzgets

; 518  :             return NULL;                /* error */

  000ae	33 c0		 xor	 eax, eax
  000b0	e9 e8 00 00 00	 jmp	 $LN16@gzgets
$LN5@gzgets:

; 519  :         if (state->x.have == 0) {       /* end of file */

  000b5	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000b8	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000bb	75 0f		 jne	 SHORT $LN4@gzgets

; 520  :             state->past = 1;            /* read past end */

  000bd	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000c0	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [eax+68], 1

; 521  :             break;                      /* return what we have */

  000c7	e9 bc 00 00 00	 jmp	 $LN9@gzgets
$LN4@gzgets:

; 522  :         }
; 523  : 
; 524  :         /* look for end-of-line in current output buffer */
; 525  :         n = state->x.have > left ? left : state->x.have;

  000cc	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000cf	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d1	3b 55 f4	 cmp	 edx, DWORD PTR _left$[ebp]
  000d4	76 08		 jbe	 SHORT $LN18@gzgets
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _left$[ebp]
  000d9	89 45 e8	 mov	 DWORD PTR tv90[ebp], eax
  000dc	eb 08		 jmp	 SHORT $LN19@gzgets
$LN18@gzgets:
  000de	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000e1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e3	89 55 e8	 mov	 DWORD PTR tv90[ebp], edx
$LN19@gzgets:
  000e6	8b 45 e8	 mov	 eax, DWORD PTR tv90[ebp]
  000e9	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 526  :         eol = (unsigned char *)memchr(state->x.next, '\n', n);

  000ec	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000ef	51		 push	 ecx
  000f0	6a 0a		 push	 10			; 0000000aH
  000f2	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000f5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f8	50		 push	 eax
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memchr
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00102	89 45 fc	 mov	 DWORD PTR _eol$[ebp], eax

; 527  :         if (eol != NULL)

  00105	83 7d fc 00	 cmp	 DWORD PTR _eol$[ebp], 0
  00109	74 0f		 je	 SHORT $LN3@gzgets

; 528  :             n = (unsigned)(eol - state->x.next) + 1;

  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0010e	8b 55 fc	 mov	 edx, DWORD PTR _eol$[ebp]
  00111	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00114	83 c2 01	 add	 edx, 1
  00117	89 55 f8	 mov	 DWORD PTR _n$[ebp], edx
$LN3@gzgets:

; 529  : 
; 530  :         /* copy through end-of-line, or remainder if not found */
; 531  :         memcpy(buf, state->x.next, n);

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00121	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00124	52		 push	 edx
  00125	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _memcpy
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 532  :         state->x.have -= n;

  00131	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00134	8b 11		 mov	 edx, DWORD PTR [ecx]
  00136	2b 55 f8	 sub	 edx, DWORD PTR _n$[ebp]
  00139	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0013c	89 10		 mov	 DWORD PTR [eax], edx

; 533  :         state->x.next += n;

  0013e	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00141	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00144	03 55 f8	 add	 edx, DWORD PTR _n$[ebp]
  00147	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0014a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 534  :         state->x.pos += n;

  0014d	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00150	33 d2		 xor	 edx, edx
  00152	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00155	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  00158	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0015b	13 c2		 adc	 eax, edx
  0015d	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00160	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00163	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 535  :         left -= n;

  00166	8b 45 f4	 mov	 eax, DWORD PTR _left$[ebp]
  00169	2b 45 f8	 sub	 eax, DWORD PTR _n$[ebp]
  0016c	89 45 f4	 mov	 DWORD PTR _left$[ebp], eax

; 536  :         buf += n;

  0016f	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00172	03 4d f8	 add	 ecx, DWORD PTR _n$[ebp]
  00175	89 4d 0c	 mov	 DWORD PTR _buf$[ebp], ecx

; 537  :     } while (left && eol == NULL);

  00178	83 7d f4 00	 cmp	 DWORD PTR _left$[ebp], 0
  0017c	74 0a		 je	 SHORT $LN9@gzgets
  0017e	83 7d fc 00	 cmp	 DWORD PTR _eol$[ebp], 0
  00182	0f 84 0d ff ff
	ff		 je	 $LN8@gzgets
$LN9@gzgets:

; 538  : 
; 539  :     /* return terminated string, or if nothing, end of file */
; 540  :     if (buf == str)

  00188	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0018b	3b 55 ec	 cmp	 edx, DWORD PTR _str$[ebp]
  0018e	75 04		 jne	 SHORT $LN1@gzgets

; 541  :         return NULL;

  00190	33 c0		 xor	 eax, eax
  00192	eb 09		 jmp	 SHORT $LN16@gzgets
$LN1@gzgets:

; 542  :     buf[0] = 0;

  00194	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00197	c6 00 00	 mov	 BYTE PTR [eax], 0

; 543  :     return str;

  0019a	8b 45 ec	 mov	 eax, DWORD PTR _str$[ebp]
$LN16@gzgets:

; 544  : }

  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c2 0c 00	 ret	 12			; 0000000cH
_gzgets@12 ENDP
_TEXT	ENDS
PUBLIC	_gzungetc@8
; Function compile flags: /Odtp
;	COMDAT _gzungetc@8
_TEXT	SEGMENT
_src$79726 = -12					; size = 4
_dest$79727 = -8					; size = 4
_state$ = -4						; size = 4
_c$ = 8							; size = 4
_file$ = 12						; size = 4
_gzungetc@8 PROC					; COMDAT

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 427  :     gz_statep state;
; 428  : 
; 429  :     /* get internal structure */
; 430  :     if (file == NULL)

  00006	83 7d 0c 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN11@gzungetc

; 431  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 a3 01 00 00	 jmp	 $LN12@gzungetc
$LN11@gzungetc:

; 432  :     state = (gz_statep)file;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 433  : 
; 434  :     /* check that we're reading and that there's no (serious) error */
; 435  :     if (state->mode != GZ_READ ||
; 436  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00024	75 12		 jne	 SHORT $LN9@gzungetc
  00026	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00029	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0002d	74 11		 je	 SHORT $LN10@gzungetc
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00036	74 08		 je	 SHORT $LN10@gzungetc
$LN9@gzungetc:

; 437  :         return -1;

  00038	83 c8 ff	 or	 eax, -1
  0003b	e9 77 01 00 00	 jmp	 $LN12@gzungetc
$LN10@gzungetc:

; 438  : 
; 439  :     /* process a skip request */
; 440  :     if (state->seek) {

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00043	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00047	74 2e		 je	 SHORT $LN8@gzungetc

; 441  :         state->seek = 0;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004c	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 442  :         if (gz_skip(state, state->skip) == -1)

  00053	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00056	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00059	51		 push	 ecx
  0005a	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0005d	52		 push	 edx
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _gz_skip
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	83 f8 ff	 cmp	 eax, -1
  0006d	75 08		 jne	 SHORT $LN8@gzungetc

; 443  :             return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	e9 40 01 00 00	 jmp	 $LN12@gzungetc
$LN8@gzungetc:

; 444  :     }
; 445  : 
; 446  :     /* can't push EOF */
; 447  :     if (c < 0)

  00077	83 7d 08 00	 cmp	 DWORD PTR _c$[ebp], 0
  0007b	7d 08		 jge	 SHORT $LN6@gzungetc

; 448  :         return -1;

  0007d	83 c8 ff	 or	 eax, -1
  00080	e9 32 01 00 00	 jmp	 $LN12@gzungetc
$LN6@gzungetc:

; 449  : 
; 450  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 451  :     if (state->x.have == 0) {

  00085	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00088	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0008b	75 54		 jne	 SHORT $LN5@gzungetc

; 452  :         state->x.have = 1;

  0008d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00090	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 453  :         state->x.next = state->out + (state->size << 1) - 1;

  00096	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00099	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0009c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0009f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000a2	8d 4c 48 ff	 lea	 ecx, DWORD PTR [eax+ecx*2-1]
  000a6	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000a9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 454  :         state->x.next[0] = c;

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000af	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b2	8a 55 08	 mov	 dl, BYTE PTR _c$[ebp]
  000b5	88 11		 mov	 BYTE PTR [ecx], dl

; 455  :         state->x.pos--;

  000b7	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bd	83 e9 01	 sub	 ecx, 1
  000c0	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000c3	83 da 00	 sbb	 edx, 0
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000c9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000cc	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 456  :         state->past = 0;

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000d2	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 457  :         return c;

  000d9	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000dc	e9 d6 00 00 00	 jmp	 $LN12@gzungetc
$LN5@gzungetc:

; 458  :     }
; 459  : 
; 460  :     /* if no room, give up (must have already done a gzungetc()) */
; 461  :     if (state->x.have == (state->size << 1)) {

  000e1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000e4	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000e7	d1 e0		 shl	 eax, 1
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000ec	39 01		 cmp	 DWORD PTR [ecx], eax
  000ee	75 1b		 jne	 SHORT $LN4@gzungetc

; 462  :         gz_error(state, Z_DATA_ERROR, "out of room to push characters");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  000f5	6a fd		 push	 -3			; fffffffdH
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _gz_error
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 463  :         return -1;

  00103	83 c8 ff	 or	 eax, -1
  00106	e9 ac 00 00 00	 jmp	 $LN12@gzungetc
$LN4@gzungetc:

; 464  :     }
; 465  : 
; 466  :     /* slide output data if needed and insert byte before existing data */
; 467  :     if (state->x.next == state->out) {

  0010b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0010e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00111	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00114	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  00117	75 52		 jne	 SHORT $LN3@gzungetc

; 468  :         unsigned char *src = state->out + state->x.have;

  00119	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0011c	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0011f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00122	03 0a		 add	 ecx, DWORD PTR [edx]
  00124	89 4d f4	 mov	 DWORD PTR _src$79726[ebp], ecx

; 469  :         unsigned char *dest = state->out + (state->size << 1);

  00127	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0012a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0012d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00130	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00133	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00136	89 4d f8	 mov	 DWORD PTR _dest$79727[ebp], ecx
$LN2@gzungetc:

; 470  :         while (src > state->out)

  00139	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0013c	8b 45 f4	 mov	 eax, DWORD PTR _src$79726[ebp]
  0013f	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  00142	76 1e		 jbe	 SHORT $LN1@gzungetc

; 471  :             *--dest = *--src;

  00144	8b 4d f4	 mov	 ecx, DWORD PTR _src$79726[ebp]
  00147	83 e9 01	 sub	 ecx, 1
  0014a	89 4d f4	 mov	 DWORD PTR _src$79726[ebp], ecx
  0014d	8b 55 f8	 mov	 edx, DWORD PTR _dest$79727[ebp]
  00150	83 ea 01	 sub	 edx, 1
  00153	89 55 f8	 mov	 DWORD PTR _dest$79727[ebp], edx
  00156	8b 45 f8	 mov	 eax, DWORD PTR _dest$79727[ebp]
  00159	8b 4d f4	 mov	 ecx, DWORD PTR _src$79726[ebp]
  0015c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0015e	88 10		 mov	 BYTE PTR [eax], dl
  00160	eb d7		 jmp	 SHORT $LN2@gzungetc
$LN1@gzungetc:

; 472  :         state->x.next = dest;

  00162	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00165	8b 4d f8	 mov	 ecx, DWORD PTR _dest$79727[ebp]
  00168	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@gzungetc:

; 473  :     }
; 474  :     state->x.have++;

  0016b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0016e	8b 02		 mov	 eax, DWORD PTR [edx]
  00170	83 c0 01	 add	 eax, 1
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00176	89 01		 mov	 DWORD PTR [ecx], eax

; 475  :     state->x.next--;

  00178	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0017b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0017e	83 e8 01	 sub	 eax, 1
  00181	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00184	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 476  :     state->x.next[0] = c;

  00187	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0018a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0018d	8a 4d 08	 mov	 cl, BYTE PTR _c$[ebp]
  00190	88 08		 mov	 BYTE PTR [eax], cl

; 477  :     state->x.pos--;

  00192	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00195	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00198	83 e8 01	 sub	 eax, 1
  0019b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0019e	83 d9 00	 sbb	 ecx, 0
  001a1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001a4	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001a7	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 478  :     state->past = 0;

  001aa	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001ad	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 479  :     return c;

  001b4	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
$LN12@gzungetc:

; 480  : }

  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c2 08 00	 ret	 8
_gzungetc@8 ENDP
_TEXT	ENDS
PUBLIC	_gzread@12
; Function compile flags: /Odtp
;	COMDAT _gzread@12
_TEXT	SEGMENT
tv87 = -20						; size = 4
_state$ = -16						; size = 4
_got$ = -12						; size = 4
_strm$ = -8						; size = 4
_n$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzread@12 PROC						; COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 293  :     unsigned got, n;
; 294  :     gz_statep state;
; 295  :     z_streamp strm;
; 296  : 
; 297  :     /* get internal structure */
; 298  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN22@gzread

; 299  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 04 02 00 00	 jmp	 $LN23@gzread
$LN22@gzread:

; 300  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 301  :     strm = &(state->strm);

  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 64	 add	 ecx, 100		; 00000064H
  00020	89 4d f8	 mov	 DWORD PTR _strm$[ebp], ecx

; 302  : 
; 303  :     /* check that we're reading and that there's no (serious) error */
; 304  :     if (state->mode != GZ_READ ||
; 305  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  00023	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  0002d	75 12		 jne	 SHORT $LN20@gzread
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00036	74 11		 je	 SHORT $LN21@gzread
  00038	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0003b	83 79 5c fb	 cmp	 DWORD PTR [ecx+92], -5	; fffffffbH
  0003f	74 08		 je	 SHORT $LN21@gzread
$LN20@gzread:

; 306  :         return -1;

  00041	83 c8 ff	 or	 eax, -1
  00044	e9 cf 01 00 00	 jmp	 $LN23@gzread
$LN21@gzread:

; 307  : 
; 308  :     /* since an int is returned, make sure len fits in one, otherwise return
; 309  :        with an error (this avoids the flaw in the interface) */
; 310  :     if ((int)len < 0) {

  00049	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  0004d	7d 1b		 jge	 SHORT $LN19@gzread

; 311  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00054	6a fd		 push	 -3			; fffffffdH
  00056	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _gz_error
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 312  :         return -1;

  00062	83 c8 ff	 or	 eax, -1
  00065	e9 ae 01 00 00	 jmp	 $LN23@gzread
$LN19@gzread:

; 313  :     }
; 314  : 
; 315  :     /* if len is zero, avoid unnecessary operations */
; 316  :     if (len == 0)

  0006a	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  0006e	75 07		 jne	 SHORT $LN18@gzread

; 317  :         return 0;

  00070	33 c0		 xor	 eax, eax
  00072	e9 a1 01 00 00	 jmp	 $LN23@gzread
$LN18@gzread:

; 318  : 
; 319  :     /* process a skip request */
; 320  :     if (state->seek) {

  00077	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0007a	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  0007e	74 2e		 je	 SHORT $LN17@gzread

; 321  :         state->seek = 0;

  00080	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00083	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 322  :         if (gz_skip(state, state->skip) == -1)

  0008a	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0008d	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00090	50		 push	 eax
  00091	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00094	51		 push	 ecx
  00095	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 _gz_skip
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	83 f8 ff	 cmp	 eax, -1
  000a4	75 08		 jne	 SHORT $LN17@gzread

; 323  :             return -1;

  000a6	83 c8 ff	 or	 eax, -1
  000a9	e9 6a 01 00 00	 jmp	 $LN23@gzread
$LN17@gzread:

; 324  :     }
; 325  : 
; 326  :     /* get len bytes to buf, or less than len if at the end */
; 327  :     got = 0;

  000ae	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0
$LN15@gzread:

; 328  :     do {
; 329  :         /* first just try copying data from the output buffer */
; 330  :         if (state->x.have) {

  000b5	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000b8	83 38 00	 cmp	 DWORD PTR [eax], 0
  000bb	74 58		 je	 SHORT $LN12@gzread

; 331  :             n = state->x.have > len ? len : state->x.have;

  000bd	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c2	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  000c5	76 08		 jbe	 SHORT $LN25@gzread
  000c7	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  000ca	89 45 ec	 mov	 DWORD PTR tv87[ebp], eax
  000cd	eb 08		 jmp	 SHORT $LN26@gzread
$LN25@gzread:
  000cf	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d4	89 55 ec	 mov	 DWORD PTR tv87[ebp], edx
$LN26@gzread:
  000d7	8b 45 ec	 mov	 eax, DWORD PTR tv87[ebp]
  000da	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 332  :             memcpy(buf, state->x.next, n);

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000e4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e7	50		 push	 eax
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _memcpy
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 333  :             state->x.next += n;

  000f4	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000f7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000fa	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000fd	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00100	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 334  :             state->x.have -= n;

  00103	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00106	8b 02		 mov	 eax, DWORD PTR [edx]
  00108	2b 45 fc	 sub	 eax, DWORD PTR _n$[ebp]
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0010e	89 01		 mov	 DWORD PTR [ecx], eax
  00110	e9 c2 00 00 00	 jmp	 $LN11@gzread
$LN12@gzread:

; 335  :         }
; 336  : 
; 337  :         /* output buffer empty -- return if we're at the end of the input */
; 338  :         else if (state->eof && strm->avail_in == 0) {

  00115	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00118	83 7a 40 00	 cmp	 DWORD PTR [edx+64], 0
  0011c	74 1d		 je	 SHORT $LN10@gzread
  0011e	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00121	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00125	75 14		 jne	 SHORT $LN10@gzread

; 339  :             state->past = 1;        /* tried to read past end */

  00127	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0012a	c7 41 44 01 00
	00 00		 mov	 DWORD PTR [ecx+68], 1
  00131	e9 df 00 00 00	 jmp	 $LN13@gzread

; 340  :             break;

  00136	e9 9c 00 00 00	 jmp	 $LN11@gzread
$LN10@gzread:

; 341  :         }
; 342  : 
; 343  :         /* need output data -- for small len or new stream load up our output
; 344  :            buffer */
; 345  :         else if (state->how == LOOK || len < (state->size << 1)) {

  0013b	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0013e	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00142	74 0d		 je	 SHORT $LN7@gzread
  00144	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00147	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0014a	d1 e1		 shl	 ecx, 1
  0014c	39 4d 10	 cmp	 DWORD PTR _len$[ebp], ecx
  0014f	73 20		 jae	 SHORT $LN8@gzread
$LN7@gzread:

; 346  :             /* get more output, looking for header if required */
; 347  :             if (gz_fetch(state) == -1)

  00151	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00154	52		 push	 edx
  00155	e8 00 00 00 00	 call	 _gz_fetch
  0015a	83 c4 04	 add	 esp, 4
  0015d	83 f8 ff	 cmp	 eax, -1
  00160	75 08		 jne	 SHORT $LN6@gzread

; 348  :                 return -1;

  00162	83 c8 ff	 or	 eax, -1
  00165	e9 ae 00 00 00	 jmp	 $LN23@gzread
$LN6@gzread:

; 349  :             continue;       /* no progress yet -- go back to copy above */

  0016a	e9 9c 00 00 00	 jmp	 $LN14@gzread
  0016f	eb 66		 jmp	 SHORT $LN11@gzread
$LN8@gzread:

; 350  :             /* the copy above assures that we will leave with space in the
; 351  :                output buffer, allowing at least one gzungetc() to succeed */
; 352  :         }
; 353  : 
; 354  :         /* large len -- read directly into user buffer */
; 355  :         else if (state->how == COPY) {      /* read directly */

  00171	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00174	83 78 30 01	 cmp	 DWORD PTR [eax+48], 1
  00178	75 24		 jne	 SHORT $LN4@gzread

; 356  :             if (gz_load(state, (unsigned char *)buf, len, &n) == -1)

  0017a	8d 4d fc	 lea	 ecx, DWORD PTR _n$[ebp]
  0017d	51		 push	 ecx
  0017e	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00181	52		 push	 edx
  00182	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00185	50		 push	 eax
  00186	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00189	51		 push	 ecx
  0018a	e8 00 00 00 00	 call	 _gz_load
  0018f	83 c4 10	 add	 esp, 16			; 00000010H
  00192	83 f8 ff	 cmp	 eax, -1
  00195	75 05		 jne	 SHORT $LN3@gzread

; 357  :                 return -1;

  00197	83 c8 ff	 or	 eax, -1
  0019a	eb 7c		 jmp	 SHORT $LN23@gzread
$LN3@gzread:

; 358  :         }
; 359  : 
; 360  :         /* large len -- decompress directly into user buffer */
; 361  :         else {  /* state->how == GZIP */

  0019c	eb 39		 jmp	 SHORT $LN11@gzread
$LN4@gzread:

; 362  :             strm->avail_out = len;

  0019e	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  001a1	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  001a4	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 363  :             strm->next_out = (unsigned char *)buf;

  001a7	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  001aa	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  001ad	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 364  :             if (gz_decomp(state) == -1)

  001b0	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 _gz_decomp
  001b9	83 c4 04	 add	 esp, 4
  001bc	83 f8 ff	 cmp	 eax, -1
  001bf	75 05		 jne	 SHORT $LN1@gzread

; 365  :                 return -1;

  001c1	83 c8 ff	 or	 eax, -1
  001c4	eb 52		 jmp	 SHORT $LN23@gzread
$LN1@gzread:

; 366  :             n = state->x.have;

  001c6	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001c9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001cb	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 367  :             state->x.have = 0;

  001ce	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001d1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN11@gzread:

; 368  :         }
; 369  : 
; 370  :         /* update progress */
; 371  :         len -= n;

  001d7	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  001da	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  001dd	89 4d 10	 mov	 DWORD PTR _len$[ebp], ecx

; 372  :         buf = (char *)buf + n;

  001e0	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  001e3	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  001e6	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 373  :         got += n;

  001e9	8b 45 f4	 mov	 eax, DWORD PTR _got$[ebp]
  001ec	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  001ef	89 45 f4	 mov	 DWORD PTR _got$[ebp], eax

; 374  :         state->x.pos += n;

  001f2	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  001f5	33 d2		 xor	 edx, edx
  001f7	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001fa	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  001fd	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00200	13 c2		 adc	 eax, edx
  00202	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00205	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00208	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN14@gzread:

; 375  :     } while (len);

  0020b	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  0020f	0f 85 a0 fe ff
	ff		 jne	 $LN15@gzread
$LN13@gzread:

; 376  : 
; 377  :     /* return number of bytes read into user buffer (will fit in int) */
; 378  :     return (int)got;

  00215	8b 45 f4	 mov	 eax, DWORD PTR _got$[ebp]
$LN23@gzread:

; 379  : }

  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c2 0c 00	 ret	 12			; 0000000cH
_gzread@12 ENDP
PUBLIC	_gzgetc@4
; Function compile flags: /Odtp
;	COMDAT _gzgetc@4
_TEXT	SEGMENT
tv90 = -20						; size = 4
tv82 = -13						; size = 1
_state$ = -12						; size = 4
_ret$ = -8						; size = 4
_buf$ = -1						; size = 1
_file$ = 8						; size = 4
_gzgetc@4 PROC						; COMDAT

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 390  :     int ret;
; 391  :     unsigned char buf[1];
; 392  :     gz_statep state;
; 393  : 
; 394  :     /* get internal structure */
; 395  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN4@gzgetc

; 396  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 a1 00 00 00	 jmp	 $LN5@gzgetc
$LN4@gzgetc:

; 397  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 398  : 
; 399  :     /* check that we're reading and that there's no (serious) error */
; 400  :     if (state->mode != GZ_READ ||
; 401  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00024	75 12		 jne	 SHORT $LN2@gzgetc
  00026	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00029	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0002d	74 0e		 je	 SHORT $LN3@gzgetc
  0002f	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00036	74 05		 je	 SHORT $LN3@gzgetc
$LN2@gzgetc:

; 402  :         return -1;

  00038	83 c8 ff	 or	 eax, -1
  0003b	eb 78		 jmp	 SHORT $LN5@gzgetc
$LN3@gzgetc:

; 403  : 
; 404  :     /* try output buffer (no need to check for skip request) */
; 405  :     if (state->x.have) {

  0003d	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00040	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00043	74 45		 je	 SHORT $LN1@gzgetc

; 406  :         state->x.have--;

  00045	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	83 e8 01	 sub	 eax, 1
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	89 01		 mov	 DWORD PTR [ecx], eax

; 407  :         state->x.pos++;

  00052	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00055	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00058	83 c0 01	 add	 eax, 1
  0005b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0005e	83 d1 00	 adc	 ecx, 0
  00061	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00064	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00067	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 408  :         return *(state->x.next)++;

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0006d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00070	8a 11		 mov	 dl, BYTE PTR [ecx]
  00072	88 55 f3	 mov	 BYTE PTR tv82[ebp], dl
  00075	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	83 c1 01	 add	 ecx, 1
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00081	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00084	0f b6 45 f3	 movzx	 eax, BYTE PTR tv82[ebp]
  00088	eb 2b		 jmp	 SHORT $LN5@gzgetc
$LN1@gzgetc:

; 409  :     }
; 410  : 
; 411  :     /* nothing there -- try gzread() */
; 412  :     ret = gzread(file, buf, 1);

  0008a	6a 01		 push	 1
  0008c	8d 45 ff	 lea	 eax, DWORD PTR _buf$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _gzread@12
  00099	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 413  :     return ret < 1 ? -1 : buf[0];

  0009c	83 7d f8 01	 cmp	 DWORD PTR _ret$[ebp], 1
  000a0	7d 09		 jge	 SHORT $LN7@gzgetc
  000a2	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv90[ebp], -1
  000a9	eb 07		 jmp	 SHORT $LN8@gzgetc
$LN7@gzgetc:
  000ab	0f b6 55 ff	 movzx	 edx, BYTE PTR _buf$[ebp]
  000af	89 55 ec	 mov	 DWORD PTR tv90[ebp], edx
$LN8@gzgetc:
  000b2	8b 45 ec	 mov	 eax, DWORD PTR tv90[ebp]
$LN5@gzgetc:

; 414  : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
_gzgetc@4 ENDP
_TEXT	ENDS
PUBLIC	_gzgetc_@4
; Function compile flags: /Odtp
;	COMDAT _gzgetc_@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzgetc_@4 PROC						; COMDAT

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 419  :     return gzgetc(file);

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _gzgetc@4

; 420  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
_gzgetc_@4 ENDP
_TEXT	ENDS
END
