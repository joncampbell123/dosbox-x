; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\dev\dosbox-x\vs2008\zlib\inftrees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_copyright
_inflate_copyright DB ' inflate 1.2.8 Copyright 1995-2013 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	048H
	DW	04eH
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
PUBLIC	_inflate_table
; Function compile flags: /Odtp
; File c:\dev\dosbox-x\vs2008\zlib\inftrees.c
;	COMDAT _inflate_table
_TEXT	SEGMENT
tv187 = -144						; size = 4
_max$ = -140						; size = 4
_used$ = -136						; size = 4
_low$ = -132						; size = 4
_sym$ = -128						; size = 4
_fill$ = -124						; size = 4
_offs$ = -120						; size = 32
_incr$ = -88						; size = 4
_end$ = -84						; size = 4
_len$ = -80						; size = 4
_left$ = -76						; size = 4
_next$ = -72						; size = 4
_root$ = -68						; size = 4
_curr$ = -64						; size = 4
_drop$ = -60						; size = 4
_mask$ = -56						; size = 4
_min$ = -52						; size = 4
_huff$ = -48						; size = 4
_base$ = -44						; size = 4
_extra$ = -40						; size = 4
_here$ = -36						; size = 4
_count$ = -32						; size = 32
_type$ = 8						; size = 4
_lens$ = 12						; size = 4
_codes$ = 16						; size = 4
_table$ = 20						; size = 4
_bits$ = 24						; size = 4
_work$ = 28						; size = 4
_inflate_table PROC					; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  00009	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN62@inflate_ta
$LN61@inflate_ta:
  00012	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 b0	 mov	 DWORD PTR _len$[ebp], eax
$LN62@inflate_ta:
  0001b	83 7d b0 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  0001f	77 0c		 ja	 SHORT $LN60@inflate_ta

; 108  :         count[len] = 0;

  00021	33 c9		 xor	 ecx, ecx
  00023	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  00026	66 89 4c 55 e0	 mov	 WORD PTR _count$[ebp+edx*2], cx
  0002b	eb e5		 jmp	 SHORT $LN61@inflate_ta
$LN60@inflate_ta:

; 109  :     for (sym = 0; sym < codes; sym++)

  0002d	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN59@inflate_ta
$LN58@inflate_ta:
  00036	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 80	 mov	 DWORD PTR _sym$[ebp], eax
$LN59@inflate_ta:
  0003f	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  00042	3b 4d 10	 cmp	 ecx, DWORD PTR _codes$[ebp]
  00045	73 24		 jae	 SHORT $LN57@inflate_ta

; 110  :         count[lens[sym]]++;

  00047	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  0004d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00051	66 8b 54 4d e0	 mov	 dx, WORD PTR _count$[ebp+ecx*2]
  00056	66 83 c2 01	 add	 dx, 1
  0005a	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  00060	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00064	66 89 54 45 e0	 mov	 WORD PTR _count$[ebp+eax*2], dx
  00069	eb cb		 jmp	 SHORT $LN58@inflate_ta
$LN57@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  0006b	8b 4d 18	 mov	 ecx, DWORD PTR _bits$[ebp]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	89 55 bc	 mov	 DWORD PTR _root$[ebp], edx

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00073	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _max$[ebp], 15 ; 0000000fH
  0007d	eb 0f		 jmp	 SHORT $LN56@inflate_ta
$LN55@inflate_ta:
  0007f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _max$[ebp]
  00085	83 e8 01	 sub	 eax, 1
  00088	89 85 74 ff ff
	ff		 mov	 DWORD PTR _max$[ebp], eax
$LN56@inflate_ta:
  0008e	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR _max$[ebp], 1
  00095	72 13		 jb	 SHORT $LN54@inflate_ta

; 115  :         if (count[max] != 0) break;

  00097	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _max$[ebp]
  0009d	0f b7 54 4d e0	 movzx	 edx, WORD PTR _count$[ebp+ecx*2]
  000a2	85 d2		 test	 edx, edx
  000a4	74 02		 je	 SHORT $LN53@inflate_ta
  000a6	eb 02		 jmp	 SHORT $LN54@inflate_ta
$LN53@inflate_ta:

; 116  :     if (root > max) root = max;

  000a8	eb d5		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:
  000aa	8b 45 bc	 mov	 eax, DWORD PTR _root$[ebp]
  000ad	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _max$[ebp]
  000b3	76 09		 jbe	 SHORT $LN52@inflate_ta
  000b5	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _max$[ebp]
  000bb	89 4d bc	 mov	 DWORD PTR _root$[ebp], ecx
$LN52@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000be	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _max$[ebp], 0
  000c5	75 4c		 jne	 SHORT $LN51@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */

  000c7	c6 45 dc 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H

; 119  :         here.bits = (unsigned char)1;

  000cb	c6 45 dd 01	 mov	 BYTE PTR _here$[ebp+1], 1

; 120  :         here.val = (unsigned short)0;

  000cf	33 d2		 xor	 edx, edx
  000d1	66 89 55 de	 mov	 WORD PTR _here$[ebp+2], dx

; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000d5	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	8b 55 dc	 mov	 edx, DWORD PTR _here$[ebp]
  000dd	89 11		 mov	 DWORD PTR [ecx], edx
  000df	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e4	83 c1 04	 add	 ecx, 4
  000e7	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  000ea	89 0a		 mov	 DWORD PTR [edx], ecx

; 122  :         *(*table)++ = here;

  000ec	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f1	8b 55 dc	 mov	 edx, DWORD PTR _here$[ebp]
  000f4	89 11		 mov	 DWORD PTR [ecx], edx
  000f6	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	83 c1 04	 add	 ecx, 4
  000fe	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00101	89 0a		 mov	 DWORD PTR [edx], ecx

; 123  :         *bits = 1;

  00103	8b 45 18	 mov	 eax, DWORD PTR _bits$[ebp]
  00106	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  0010c	33 c0		 xor	 eax, eax
  0010e	e9 d2 04 00 00	 jmp	 $LN63@inflate_ta
$LN51@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00113	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _min$[ebp], 1
  0011a	eb 09		 jmp	 SHORT $LN50@inflate_ta
$LN49@inflate_ta:
  0011c	8b 4d cc	 mov	 ecx, DWORD PTR _min$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d cc	 mov	 DWORD PTR _min$[ebp], ecx
$LN50@inflate_ta:
  00125	8b 55 cc	 mov	 edx, DWORD PTR _min$[ebp]
  00128	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _max$[ebp]
  0012e	73 10		 jae	 SHORT $LN48@inflate_ta

; 127  :         if (count[min] != 0) break;

  00130	8b 45 cc	 mov	 eax, DWORD PTR _min$[ebp]
  00133	0f b7 4c 45 e0	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  00138	85 c9		 test	 ecx, ecx
  0013a	74 02		 je	 SHORT $LN47@inflate_ta
  0013c	eb 02		 jmp	 SHORT $LN48@inflate_ta
$LN47@inflate_ta:

; 128  :     if (root < min) root = min;

  0013e	eb dc		 jmp	 SHORT $LN49@inflate_ta
$LN48@inflate_ta:
  00140	8b 55 bc	 mov	 edx, DWORD PTR _root$[ebp]
  00143	3b 55 cc	 cmp	 edx, DWORD PTR _min$[ebp]
  00146	73 06		 jae	 SHORT $LN46@inflate_ta
  00148	8b 45 cc	 mov	 eax, DWORD PTR _min$[ebp]
  0014b	89 45 bc	 mov	 DWORD PTR _root$[ebp], eax
$LN46@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  0014e	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _left$[ebp], 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00155	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  0015c	eb 09		 jmp	 SHORT $LN45@inflate_ta
$LN44@inflate_ta:
  0015e	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  00161	83 c1 01	 add	 ecx, 1
  00164	89 4d b0	 mov	 DWORD PTR _len$[ebp], ecx
$LN45@inflate_ta:
  00167	83 7d b0 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  0016b	77 24		 ja	 SHORT $LN43@inflate_ta

; 133  :         left <<= 1;

  0016d	8b 55 b4	 mov	 edx, DWORD PTR _left$[ebp]
  00170	d1 e2		 shl	 edx, 1
  00172	89 55 b4	 mov	 DWORD PTR _left$[ebp], edx

; 134  :         left -= count[len];

  00175	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  00178	0f b7 4c 45 e0	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  0017d	8b 55 b4	 mov	 edx, DWORD PTR _left$[ebp]
  00180	2b d1		 sub	 edx, ecx
  00182	89 55 b4	 mov	 DWORD PTR _left$[ebp], edx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00185	79 08		 jns	 SHORT $LN42@inflate_ta
  00187	83 c8 ff	 or	 eax, -1
  0018a	e9 56 04 00 00	 jmp	 $LN63@inflate_ta
$LN42@inflate_ta:

; 136  :     }

  0018f	eb cd		 jmp	 SHORT $LN44@inflate_ta
$LN43@inflate_ta:

; 137  :     if (left > 0 && (type == CODES || max != 1))

  00191	83 7d b4 00	 cmp	 DWORD PTR _left$[ebp], 0
  00195	7e 17		 jle	 SHORT $LN41@inflate_ta
  00197	83 7d 08 00	 cmp	 DWORD PTR _type$[ebp], 0
  0019b	74 09		 je	 SHORT $LN40@inflate_ta
  0019d	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR _max$[ebp], 1
  001a4	74 08		 je	 SHORT $LN41@inflate_ta
$LN40@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  001a6	83 c8 ff	 or	 eax, -1
  001a9	e9 37 04 00 00	 jmp	 $LN63@inflate_ta
$LN41@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  001ae	33 c0		 xor	 eax, eax
  001b0	66 89 45 8a	 mov	 WORD PTR _offs$[ebp+2], ax

; 142  :     for (len = 1; len < MAXBITS; len++)

  001b4	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  001bb	eb 09		 jmp	 SHORT $LN39@inflate_ta
$LN38@inflate_ta:
  001bd	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  001c0	83 c1 01	 add	 ecx, 1
  001c3	89 4d b0	 mov	 DWORD PTR _len$[ebp], ecx
$LN39@inflate_ta:
  001c6	83 7d b0 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  001ca	73 1c		 jae	 SHORT $LN37@inflate_ta

; 143  :         offs[len + 1] = offs[len] + count[len];

  001cc	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  001cf	0f b7 44 55 88	 movzx	 eax, WORD PTR _offs$[ebp+edx*2]
  001d4	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  001d7	0f b7 54 4d e0	 movzx	 edx, WORD PTR _count$[ebp+ecx*2]
  001dc	03 c2		 add	 eax, edx
  001de	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  001e1	66 89 44 4d 8a	 mov	 WORD PTR _offs$[ebp+ecx*2+2], ax
  001e6	eb d5		 jmp	 SHORT $LN38@inflate_ta
$LN37@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001e8	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  001ef	eb 09		 jmp	 SHORT $LN36@inflate_ta
$LN35@inflate_ta:
  001f1	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  001f4	83 c2 01	 add	 edx, 1
  001f7	89 55 80	 mov	 DWORD PTR _sym$[ebp], edx
$LN36@inflate_ta:
  001fa	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  001fd	3b 45 10	 cmp	 eax, DWORD PTR _codes$[ebp]
  00200	73 4c		 jae	 SHORT $LN34@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00202	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  00205	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  00208	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0020c	85 c0		 test	 eax, eax
  0020e	74 3c		 je	 SHORT $LN33@inflate_ta
  00210	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  00213	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  00216	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  0021a	0f b7 4c 45 88	 movzx	 ecx, WORD PTR _offs$[ebp+eax*2]
  0021f	8b 55 1c	 mov	 edx, DWORD PTR _work$[ebp]
  00222	66 8b 45 80	 mov	 ax, WORD PTR _sym$[ebp]
  00226	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0022a	8b 4d 80	 mov	 ecx, DWORD PTR _sym$[ebp]
  0022d	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  00230	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00234	66 8b 4c 45 88	 mov	 cx, WORD PTR _offs$[ebp+eax*2]
  00239	66 83 c1 01	 add	 cx, 1
  0023d	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  00240	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00243	0f b7 14 50	 movzx	 edx, WORD PTR [eax+edx*2]
  00247	66 89 4c 55 88	 mov	 WORD PTR _offs$[ebp+edx*2], cx
$LN33@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  0024c	eb a3		 jmp	 SHORT $LN35@inflate_ta
$LN34@inflate_ta:
  0024e	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  00251	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv187[ebp], eax
  00257	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv187[ebp], 0
  0025e	74 0b		 je	 SHORT $LN30@inflate_ta
  00260	83 bd 70 ff ff
	ff 01		 cmp	 DWORD PTR tv187[ebp], 1
  00267	74 17		 je	 SHORT $LN29@inflate_ta
  00269	eb 43		 jmp	 SHORT $LN28@inflate_ta
$LN30@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  0026b	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  0026e	89 4d d8	 mov	 DWORD PTR _extra$[ebp], ecx
  00271	8b 55 d8	 mov	 edx, DWORD PTR _extra$[ebp]
  00274	89 55 d4	 mov	 DWORD PTR _base$[ebp], edx

; 184  :         end = 19;

  00277	c7 45 ac 13 00
	00 00		 mov	 DWORD PTR _end$[ebp], 19 ; 00000013H

; 185  :         break;

  0027e	eb 43		 jmp	 SHORT $LN31@inflate_ta
$LN29@inflate_ta:

; 186  :     case LENS:
; 187  :         base = lbase;

  00280	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?lbase@?1??inflate_table@@9@9

; 188  :         base -= 257;

  00287	8b 45 d4	 mov	 eax, DWORD PTR _base$[ebp]
  0028a	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  0028f	89 45 d4	 mov	 DWORD PTR _base$[ebp], eax

; 189  :         extra = lext;

  00292	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?lext@?1??inflate_table@@9@9

; 190  :         extra -= 257;

  00299	8b 4d d8	 mov	 ecx, DWORD PTR _extra$[ebp]
  0029c	81 e9 02 02 00
	00		 sub	 ecx, 514		; 00000202H
  002a2	89 4d d8	 mov	 DWORD PTR _extra$[ebp], ecx

; 191  :         end = 256;

  002a5	c7 45 ac 00 01
	00 00		 mov	 DWORD PTR _end$[ebp], 256 ; 00000100H

; 192  :         break;

  002ac	eb 15		 jmp	 SHORT $LN31@inflate_ta
$LN28@inflate_ta:

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  002ae	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?dbase@?1??inflate_table@@9@9

; 195  :         extra = dext;

  002b5	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?dext@?1??inflate_table@@9@9

; 196  :         end = -1;

  002bc	c7 45 ac ff ff
	ff ff		 mov	 DWORD PTR _end$[ebp], -1
$LN31@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */

  002c3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0

; 201  :     sym = 0;                    /* starting code symbol */

  002ca	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0

; 202  :     len = min;                  /* starting code length */

  002d1	8b 55 cc	 mov	 edx, DWORD PTR _min$[ebp]
  002d4	89 55 b0	 mov	 DWORD PTR _len$[ebp], edx

; 203  :     next = *table;              /* current table to fill in */

  002d7	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  002da	8b 08		 mov	 ecx, DWORD PTR [eax]
  002dc	89 4d b8	 mov	 DWORD PTR _next$[ebp], ecx

; 204  :     curr = root;                /* current table index bits */

  002df	8b 55 bc	 mov	 edx, DWORD PTR _root$[ebp]
  002e2	89 55 c0	 mov	 DWORD PTR _curr$[ebp], edx

; 205  :     drop = 0;                   /* current bits to drop from code for index */

  002e5	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _drop$[ebp], 0

; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  002ec	c7 85 7c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _low$[ebp], -1

; 207  :     used = 1U << root;          /* use root table entries */

  002f6	b8 01 00 00 00	 mov	 eax, 1
  002fb	8b 4d bc	 mov	 ecx, DWORD PTR _root$[ebp]
  002fe	d3 e0		 shl	 eax, cl
  00300	89 85 78 ff ff
	ff		 mov	 DWORD PTR _used$[ebp], eax

; 208  :     mask = used - 1;            /* mask for comparing low */

  00306	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _used$[ebp]
  0030c	83 e9 01	 sub	 ecx, 1
  0030f	89 4d c8	 mov	 DWORD PTR _mask$[ebp], ecx

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used > ENOUGH_LENS) ||
; 212  :         (type == DISTS && used > ENOUGH_DISTS))

  00312	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  00316	75 0c		 jne	 SHORT $LN25@inflate_ta
  00318	81 bd 78 ff ff
	ff 54 03 00 00	 cmp	 DWORD PTR _used$[ebp], 852 ; 00000354H
  00322	77 12		 ja	 SHORT $LN26@inflate_ta
$LN25@inflate_ta:
  00324	83 7d 08 02	 cmp	 DWORD PTR _type$[ebp], 2
  00328	75 16		 jne	 SHORT $LN24@inflate_ta
  0032a	81 bd 78 ff ff
	ff 50 02 00 00	 cmp	 DWORD PTR _used$[ebp], 592 ; 00000250H
  00334	76 0a		 jbe	 SHORT $LN24@inflate_ta
$LN26@inflate_ta:

; 213  :         return 1;

  00336	b8 01 00 00 00	 mov	 eax, 1
  0033b	e9 a5 02 00 00	 jmp	 $LN63@inflate_ta
$LN24@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  00340	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  00343	2b 55 c4	 sub	 edx, DWORD PTR _drop$[ebp]
  00346	88 55 dd	 mov	 BYTE PTR _here$[ebp+1], dl

; 219  :         if ((int)(work[sym]) < end) {

  00349	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  0034c	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  0034f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00353	3b 55 ac	 cmp	 edx, DWORD PTR _end$[ebp]
  00356	7d 14		 jge	 SHORT $LN22@inflate_ta

; 220  :             here.op = (unsigned char)0;

  00358	c6 45 dc 00	 mov	 BYTE PTR _here$[ebp], 0

; 221  :             here.val = work[sym];

  0035c	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  0035f	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  00362	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00366	66 89 55 de	 mov	 WORD PTR _here$[ebp+2], dx
  0036a	eb 43		 jmp	 SHORT $LN21@inflate_ta
$LN22@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  0036c	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  0036f	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  00372	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00376	3b 55 ac	 cmp	 edx, DWORD PTR _end$[ebp]
  00379	7e 2a		 jle	 SHORT $LN20@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  0037b	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  0037e	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  00381	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00385	8b 45 d8	 mov	 eax, DWORD PTR _extra$[ebp]
  00388	8a 0c 50	 mov	 cl, BYTE PTR [eax+edx*2]
  0038b	88 4d dc	 mov	 BYTE PTR _here$[ebp], cl

; 225  :             here.val = base[work[sym]];

  0038e	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  00391	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00394	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00398	8b 55 d4	 mov	 edx, DWORD PTR _base$[ebp]
  0039b	66 8b 04 4a	 mov	 ax, WORD PTR [edx+ecx*2]
  0039f	66 89 45 de	 mov	 WORD PTR _here$[ebp+2], ax

; 226  :         }
; 227  :         else {

  003a3	eb 0a		 jmp	 SHORT $LN21@inflate_ta
$LN20@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  003a5	c6 45 dc 60	 mov	 BYTE PTR _here$[ebp], 96 ; 00000060H

; 229  :             here.val = 0;

  003a9	33 c9		 xor	 ecx, ecx
  003ab	66 89 4d de	 mov	 WORD PTR _here$[ebp+2], cx
$LN21@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  003af	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  003b2	2b 4d c4	 sub	 ecx, DWORD PTR _drop$[ebp]
  003b5	ba 01 00 00 00	 mov	 edx, 1
  003ba	d3 e2		 shl	 edx, cl
  003bc	89 55 a8	 mov	 DWORD PTR _incr$[ebp], edx

; 234  :         fill = 1U << curr;

  003bf	b8 01 00 00 00	 mov	 eax, 1
  003c4	8b 4d c0	 mov	 ecx, DWORD PTR _curr$[ebp]
  003c7	d3 e0		 shl	 eax, cl
  003c9	89 45 84	 mov	 DWORD PTR _fill$[ebp], eax

; 235  :         min = fill;                 /* save offset to next table */

  003cc	8b 4d 84	 mov	 ecx, DWORD PTR _fill$[ebp]
  003cf	89 4d cc	 mov	 DWORD PTR _min$[ebp], ecx
$LN18@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  003d2	8b 55 84	 mov	 edx, DWORD PTR _fill$[ebp]
  003d5	2b 55 a8	 sub	 edx, DWORD PTR _incr$[ebp]
  003d8	89 55 84	 mov	 DWORD PTR _fill$[ebp], edx

; 238  :             next[(huff >> drop) + fill] = here;

  003db	8b 45 d0	 mov	 eax, DWORD PTR _huff$[ebp]
  003de	8b 4d c4	 mov	 ecx, DWORD PTR _drop$[ebp]
  003e1	d3 e8		 shr	 eax, cl
  003e3	03 45 84	 add	 eax, DWORD PTR _fill$[ebp]
  003e6	8b 4d b8	 mov	 ecx, DWORD PTR _next$[ebp]
  003e9	8b 55 dc	 mov	 edx, DWORD PTR _here$[ebp]
  003ec	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 239  :         } while (fill != 0);

  003ef	83 7d 84 00	 cmp	 DWORD PTR _fill$[ebp], 0
  003f3	75 dd		 jne	 SHORT $LN18@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  003f5	8b 4d b0	 mov	 ecx, DWORD PTR _len$[ebp]
  003f8	83 e9 01	 sub	 ecx, 1
  003fb	b8 01 00 00 00	 mov	 eax, 1
  00400	d3 e0		 shl	 eax, cl
  00402	89 45 a8	 mov	 DWORD PTR _incr$[ebp], eax
$LN15@inflate_ta:

; 243  :         while (huff & incr)

  00405	8b 4d d0	 mov	 ecx, DWORD PTR _huff$[ebp]
  00408	23 4d a8	 and	 ecx, DWORD PTR _incr$[ebp]
  0040b	74 0a		 je	 SHORT $LN14@inflate_ta

; 244  :             incr >>= 1;

  0040d	8b 55 a8	 mov	 edx, DWORD PTR _incr$[ebp]
  00410	d1 ea		 shr	 edx, 1
  00412	89 55 a8	 mov	 DWORD PTR _incr$[ebp], edx
  00415	eb ee		 jmp	 SHORT $LN15@inflate_ta
$LN14@inflate_ta:

; 245  :         if (incr != 0) {

  00417	83 7d a8 00	 cmp	 DWORD PTR _incr$[ebp], 0
  0041b	74 17		 je	 SHORT $LN13@inflate_ta

; 246  :             huff &= incr - 1;

  0041d	8b 45 a8	 mov	 eax, DWORD PTR _incr$[ebp]
  00420	83 e8 01	 sub	 eax, 1
  00423	23 45 d0	 and	 eax, DWORD PTR _huff$[ebp]
  00426	89 45 d0	 mov	 DWORD PTR _huff$[ebp], eax

; 247  :             huff += incr;

  00429	8b 4d d0	 mov	 ecx, DWORD PTR _huff$[ebp]
  0042c	03 4d a8	 add	 ecx, DWORD PTR _incr$[ebp]
  0042f	89 4d d0	 mov	 DWORD PTR _huff$[ebp], ecx

; 248  :         }
; 249  :         else

  00432	eb 07		 jmp	 SHORT $LN12@inflate_ta
$LN13@inflate_ta:

; 250  :             huff = 0;

  00434	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0
$LN12@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  0043b	8b 55 80	 mov	 edx, DWORD PTR _sym$[ebp]
  0043e	83 c2 01	 add	 edx, 1
  00441	89 55 80	 mov	 DWORD PTR _sym$[ebp], edx

; 254  :         if (--(count[len]) == 0) {

  00444	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  00447	66 8b 4c 45 e0	 mov	 cx, WORD PTR _count$[ebp+eax*2]
  0044c	66 83 e9 01	 sub	 cx, 1
  00450	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  00453	66 89 4c 55 e0	 mov	 WORD PTR _count$[ebp+edx*2], cx
  00458	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  0045b	0f b7 4c 45 e0	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  00460	85 c9		 test	 ecx, ecx
  00462	75 24		 jne	 SHORT $LN11@inflate_ta

; 255  :             if (len == max) break;

  00464	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  00467	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _max$[ebp]
  0046d	75 05		 jne	 SHORT $LN10@inflate_ta
  0046f	e9 2f 01 00 00	 jmp	 $LN23@inflate_ta
$LN10@inflate_ta:

; 256  :             len = lens[work[sym]];

  00474	8b 45 80	 mov	 eax, DWORD PTR _sym$[ebp]
  00477	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  0047a	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0047e	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00481	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00485	89 4d b0	 mov	 DWORD PTR _len$[ebp], ecx
$LN11@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  00488	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  0048b	3b 55 bc	 cmp	 edx, DWORD PTR _root$[ebp]
  0048e	0f 86 0a 01 00
	00		 jbe	 $LN9@inflate_ta
  00494	8b 45 d0	 mov	 eax, DWORD PTR _huff$[ebp]
  00497	23 45 c8	 and	 eax, DWORD PTR _mask$[ebp]
  0049a	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _low$[ebp]
  004a0	0f 84 f8 00 00
	00		 je	 $LN9@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  004a6	83 7d c4 00	 cmp	 DWORD PTR _drop$[ebp], 0
  004aa	75 06		 jne	 SHORT $LN8@inflate_ta

; 263  :                 drop = root;

  004ac	8b 4d bc	 mov	 ecx, DWORD PTR _root$[ebp]
  004af	89 4d c4	 mov	 DWORD PTR _drop$[ebp], ecx
$LN8@inflate_ta:

; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  004b2	8b 55 cc	 mov	 edx, DWORD PTR _min$[ebp]
  004b5	8b 45 b8	 mov	 eax, DWORD PTR _next$[ebp]
  004b8	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  004bb	89 4d b8	 mov	 DWORD PTR _next$[ebp], ecx

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  004be	8b 55 b0	 mov	 edx, DWORD PTR _len$[ebp]
  004c1	2b 55 c4	 sub	 edx, DWORD PTR _drop$[ebp]
  004c4	89 55 c0	 mov	 DWORD PTR _curr$[ebp], edx

; 270  :             left = (int)(1 << curr);

  004c7	b8 01 00 00 00	 mov	 eax, 1
  004cc	8b 4d c0	 mov	 ecx, DWORD PTR _curr$[ebp]
  004cf	d3 e0		 shl	 eax, cl
  004d1	89 45 b4	 mov	 DWORD PTR _left$[ebp], eax
$LN7@inflate_ta:

; 271  :             while (curr + drop < max) {

  004d4	8b 4d c0	 mov	 ecx, DWORD PTR _curr$[ebp]
  004d7	03 4d c4	 add	 ecx, DWORD PTR _drop$[ebp]
  004da	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _max$[ebp]
  004e0	73 2e		 jae	 SHORT $LN6@inflate_ta

; 272  :                 left -= count[curr + drop];

  004e2	8b 55 c0	 mov	 edx, DWORD PTR _curr$[ebp]
  004e5	03 55 c4	 add	 edx, DWORD PTR _drop$[ebp]
  004e8	0f b7 44 55 e0	 movzx	 eax, WORD PTR _count$[ebp+edx*2]
  004ed	8b 4d b4	 mov	 ecx, DWORD PTR _left$[ebp]
  004f0	2b c8		 sub	 ecx, eax
  004f2	89 4d b4	 mov	 DWORD PTR _left$[ebp], ecx

; 273  :                 if (left <= 0) break;

  004f5	83 7d b4 00	 cmp	 DWORD PTR _left$[ebp], 0
  004f9	7f 02		 jg	 SHORT $LN5@inflate_ta
  004fb	eb 13		 jmp	 SHORT $LN6@inflate_ta
$LN5@inflate_ta:

; 274  :                 curr++;

  004fd	8b 55 c0	 mov	 edx, DWORD PTR _curr$[ebp]
  00500	83 c2 01	 add	 edx, 1
  00503	89 55 c0	 mov	 DWORD PTR _curr$[ebp], edx

; 275  :                 left <<= 1;

  00506	8b 45 b4	 mov	 eax, DWORD PTR _left$[ebp]
  00509	d1 e0		 shl	 eax, 1
  0050b	89 45 b4	 mov	 DWORD PTR _left$[ebp], eax

; 276  :             }

  0050e	eb c4		 jmp	 SHORT $LN7@inflate_ta
$LN6@inflate_ta:

; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  00510	ba 01 00 00 00	 mov	 edx, 1
  00515	8b 4d c0	 mov	 ecx, DWORD PTR _curr$[ebp]
  00518	d3 e2		 shl	 edx, cl
  0051a	03 95 78 ff ff
	ff		 add	 edx, DWORD PTR _used$[ebp]
  00520	89 95 78 ff ff
	ff		 mov	 DWORD PTR _used$[ebp], edx

; 280  :             if ((type == LENS && used > ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used > ENOUGH_DISTS))

  00526	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  0052a	75 0c		 jne	 SHORT $LN2@inflate_ta
  0052c	81 bd 78 ff ff
	ff 54 03 00 00	 cmp	 DWORD PTR _used$[ebp], 852 ; 00000354H
  00536	77 12		 ja	 SHORT $LN3@inflate_ta
$LN2@inflate_ta:
  00538	83 7d 08 02	 cmp	 DWORD PTR _type$[ebp], 2
  0053c	75 16		 jne	 SHORT $LN4@inflate_ta
  0053e	81 bd 78 ff ff
	ff 50 02 00 00	 cmp	 DWORD PTR _used$[ebp], 592 ; 00000250H
  00548	76 0a		 jbe	 SHORT $LN4@inflate_ta
$LN3@inflate_ta:

; 282  :                 return 1;

  0054a	b8 01 00 00 00	 mov	 eax, 1
  0054f	e9 91 00 00 00	 jmp	 $LN63@inflate_ta
$LN4@inflate_ta:

; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;

  00554	8b 45 d0	 mov	 eax, DWORD PTR _huff$[ebp]
  00557	23 45 c8	 and	 eax, DWORD PTR _mask$[ebp]
  0055a	89 85 7c ff ff
	ff		 mov	 DWORD PTR _low$[ebp], eax

; 286  :             (*table)[low].op = (unsigned char)curr;

  00560	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  00563	8b 11		 mov	 edx, DWORD PTR [ecx]
  00565	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _low$[ebp]
  0056b	8a 4d c0	 mov	 cl, BYTE PTR _curr$[ebp]
  0056e	88 0c 82	 mov	 BYTE PTR [edx+eax*4], cl

; 287  :             (*table)[low].bits = (unsigned char)root;

  00571	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00574	8b 02		 mov	 eax, DWORD PTR [edx]
  00576	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _low$[ebp]
  0057c	8a 55 bc	 mov	 dl, BYTE PTR _root$[ebp]
  0057f	88 54 88 01	 mov	 BYTE PTR [eax+ecx*4+1], dl

; 288  :             (*table)[low].val = (unsigned short)(next - *table);

  00583	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  00586	8b 4d b8	 mov	 ecx, DWORD PTR _next$[ebp]
  00589	2b 08		 sub	 ecx, DWORD PTR [eax]
  0058b	c1 f9 02	 sar	 ecx, 2
  0058e	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00591	8b 02		 mov	 eax, DWORD PTR [edx]
  00593	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _low$[ebp]
  00599	66 89 4c 90 02	 mov	 WORD PTR [eax+edx*4+2], cx
$LN9@inflate_ta:

; 289  :         }
; 290  :     }

  0059e	e9 9d fd ff ff	 jmp	 $LN24@inflate_ta
$LN23@inflate_ta:

; 291  : 
; 292  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 293  :        at most one remaining entry, since if the code is incomplete, the
; 294  :        maximum code length that was allowed to get this far is one bit) */
; 295  :     if (huff != 0) {

  005a3	83 7d d0 00	 cmp	 DWORD PTR _huff$[ebp], 0
  005a7	74 1f		 je	 SHORT $LN1@inflate_ta

; 296  :         here.op = (unsigned char)64;            /* invalid code marker */

  005a9	c6 45 dc 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H

; 297  :         here.bits = (unsigned char)(len - drop);

  005ad	8b 45 b0	 mov	 eax, DWORD PTR _len$[ebp]
  005b0	2b 45 c4	 sub	 eax, DWORD PTR _drop$[ebp]
  005b3	88 45 dd	 mov	 BYTE PTR _here$[ebp+1], al

; 298  :         here.val = (unsigned short)0;

  005b6	33 c9		 xor	 ecx, ecx
  005b8	66 89 4d de	 mov	 WORD PTR _here$[ebp+2], cx

; 299  :         next[huff] = here;

  005bc	8b 55 d0	 mov	 edx, DWORD PTR _huff$[ebp]
  005bf	8b 45 b8	 mov	 eax, DWORD PTR _next$[ebp]
  005c2	8b 4d dc	 mov	 ecx, DWORD PTR _here$[ebp]
  005c5	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
$LN1@inflate_ta:

; 300  :     }
; 301  : 
; 302  :     /* set return parameters */
; 303  :     *table += used;

  005c8	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  005cb	8b 02		 mov	 eax, DWORD PTR [edx]
  005cd	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _used$[ebp]
  005d3	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  005d6	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  005d9	89 10		 mov	 DWORD PTR [eax], edx

; 304  :     *bits = root;

  005db	8b 4d 18	 mov	 ecx, DWORD PTR _bits$[ebp]
  005de	8b 55 bc	 mov	 edx, DWORD PTR _root$[ebp]
  005e1	89 11		 mov	 DWORD PTR [ecx], edx

; 305  :     return 0;

  005e3	33 c0		 xor	 eax, eax
$LN63@inflate_ta:

; 306  : }

  005e5	8b e5		 mov	 esp, ebp
  005e7	5d		 pop	 ebp
  005e8	c3		 ret	 0
_inflate_table ENDP
END
