<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/dosbox.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/dosbox.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2020  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License along</span>
<a name="l00015"></a>00015 <span class="comment"> *  with this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00016"></a>00016 <span class="comment"> *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">/* NTS: Valgrind hunting shows memory leak from C++ new operator somewhere</span>
<a name="l00020"></a>00020 <span class="comment"> *      with the JACK library indirectly invoked by SDL audio. Can we resolve</span>
<a name="l00021"></a>00021 <span class="comment"> *      that too eventually? */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* NTS: Valgrind hunting also shows one of the section INIT functions (I can&#39;t</span>
<a name="l00024"></a>00024 <span class="comment"> *      yet tell which one because the stack trace doesn&#39;t show it) is allocating</span>
<a name="l00025"></a>00025 <span class="comment"> *      something and is not freeing it. */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/* NTS: Valgrind hunting has a moderate to high signal-to-noise ratio because</span>
<a name="l00028"></a>00028 <span class="comment"> *      of memory leaks (lazy memory allocation) from other libraries in the</span>
<a name="l00029"></a>00029 <span class="comment"> *      system, including:</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> *         ncurses</span>
<a name="l00032"></a>00032 <span class="comment"> *         libSDL</span>
<a name="l00033"></a>00033 <span class="comment"> *         libX11 and libXCB</span>
<a name="l00034"></a>00034 <span class="comment"> *         libasound (ALSA sound library)</span>
<a name="l00035"></a>00035 <span class="comment"> *         PulseAudio library calls</span>
<a name="l00036"></a>00036 <span class="comment"> *         JACK library calls</span>
<a name="l00037"></a>00037 <span class="comment"> *         libdl (the dlopen/dlclose functions allocate something and never free it)</span>
<a name="l00038"></a>00038 <span class="comment"> *         and a whole bunch of unidentified malloc calls without a matching free.</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> *      On my dev system, a reported leak of 450KB (77KB possibly lost + 384KB still reachable</span>
<a name="l00041"></a>00041 <span class="comment"> *      according to Valgrind) is normal.</span>
<a name="l00042"></a>00042 <span class="comment"> *</span>
<a name="l00043"></a>00043 <span class="comment"> *      Now you ask: why do I care so much about Valgrind, memory leaks, and cleaning</span>
<a name="l00044"></a>00044 <span class="comment"> *      up the code? The less spurious memory leaks, the easier it is to identify</span>
<a name="l00045"></a>00045 <span class="comment"> *      actual leaks among the noise and to patch them up. Thus, &quot;valgrind hunting&quot; --J.C. */</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;ctime&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;debug.h&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;video.h&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;ide.h&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;callback.h&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;mixer.h&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;timer.h&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;dos_inc.h&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;control.h&quot;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;cross.h&quot;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;programs.h&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &quot;support.h&quot;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &quot;mapper.h&quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &quot;ints/int10.h&quot;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &quot;menu.h&quot;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &quot;render.h&quot;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &quot;pci_bus.h&quot;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &quot;parport.h&quot;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &quot;clockdomain.h&quot;</span>
<a name="l00077"></a>00077 <span class="preprocessor">#include &quot;zip.h&quot;</span>
<a name="l00078"></a>00078 <span class="preprocessor">#include &quot;unzip.h&quot;</span>
<a name="l00079"></a>00079 <span class="preprocessor">#include &quot;ioapi.h&quot;</span>
<a name="l00080"></a>00080 <span class="preprocessor">#include &quot;shell.h&quot;</span>
<a name="l00081"></a>00081 <span class="preprocessor">#include &quot;build_timestamp.h&quot;</span>
<a name="l00082"></a>00082 <span class="preprocessor">#define MAXU32 0xffffffff</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#include &quot;vs2015/zlib/contrib/minizip/zip.c&quot;</span>
<a name="l00084"></a>00084 <span class="preprocessor">#include &quot;vs2015/zlib/contrib/minizip/unzip.c&quot;</span>
<a name="l00085"></a>00085 <span class="preprocessor">#include &quot;vs2015/zlib/contrib/minizip/ioapi.c&quot;</span>
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="preprocessor">#if C_EMSCRIPTEN</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="preprocessor"># include &lt;emscripten.h&gt;</span>
<a name="l00089"></a>00089 <span class="preprocessor">#endif</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span>
<a name="l00091"></a>00091 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#define WIN32_LEAN_AND_MEAN</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
<a name="l00094"></a>00094 <span class="preprocessor">#endif</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>
<a name="l00096"></a>00096 <span class="preprocessor">#if defined(unix) || defined(__APPLE__)</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor"># include &lt;utime.h&gt;</span>
<a name="l00098"></a>00098 <span class="preprocessor">#endif</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>
<a name="l00100"></a>00100 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">/*===================================TODO: Move to it&#39;s own file==============================*/</span>
<a name="l00103"></a>00103 <span class="preprocessor">#if defined(__SSE__) &amp;&amp; !(defined(_M_AMD64) || defined(__e2k__))</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="keywordtype">bool</span> sse2_available = <span class="keyword">false</span>;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="preprocessor"># ifdef __GNUC__</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#  define cpuid(func,ax,bx,cx,dx)\</span>
<a name="l00108"></a>00108 <span class="preprocessor">    __asm__ __volatile__ (&quot;cpuid&quot;:\</span>
<a name="l00109"></a>00109 <span class="preprocessor">    &quot;=a&quot; (ax), &quot;=b&quot; (bx), &quot;=c&quot; (cx), &quot;=d&quot; (dx) : &quot;a&quot; (func));</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="preprocessor"># endif </span><span class="comment">/* __GNUC__ */</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="preprocessor"># if defined(_MSC_VER)</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#  define cpuid(func,a,b,c,d)\</span>
<a name="l00114"></a>00114 <span class="preprocessor">    __asm mov eax, func\</span>
<a name="l00115"></a>00115 <span class="preprocessor">    __asm cpuid\</span>
<a name="l00116"></a>00116 <span class="preprocessor">    __asm mov a, eax\</span>
<a name="l00117"></a>00117 <span class="preprocessor">    __asm mov b, ebx\</span>
<a name="l00118"></a>00118 <span class="preprocessor">    __asm mov c, ecx\</span>
<a name="l00119"></a>00119 <span class="preprocessor">    __asm mov d, edx</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span><span class="preprocessor"># endif </span><span class="comment">/* _MSC_VER */</span>
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keywordtype">void</span> CheckSSESupport()
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124 <span class="preprocessor">#if (defined (__GNUC__) || (_MSC_VER)) &amp;&amp; !defined(EMSCRIPTEN)</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>    Bitu a, b, c, d;
<a name="l00126"></a>00126     cpuid(1, a, b, c, d);
<a name="l00127"></a>00127     sse2_available = ((d &gt;&gt; 26) &amp; 1)?<span class="keyword">true</span>:<span class="keyword">false</span>;
<a name="l00128"></a>00128 <span class="preprocessor">#endif</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>}
<a name="l00130"></a>00130 <span class="preprocessor">#endif</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span><span class="comment">/*=============================================================================*/</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="keyword">extern</span> <span class="keywordtype">void</span>         GFX_SetTitle(Bit32s cycles,Bits frameskip,Bits timing,<span class="keywordtype">bool</span> paused);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         force_nocachedir;
<a name="l00136"></a>00136 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         freesizecap;
<a name="l00137"></a>00137 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         wpcolon;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">extern</span> Bitu         frames;
<a name="l00140"></a>00140 <span class="keyword">extern</span> Bitu         cycle_count;
<a name="l00141"></a>00141 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         sse2_available;
<a name="l00142"></a>00142 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         dynamic_dos_kernel_alloc;
<a name="l00143"></a>00143 <span class="keyword">extern</span> Bitu         DOS_PRIVATE_SEGMENT_Size;
<a name="l00144"></a>00144 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         VGA_BIOS_dont_duplicate_CGA_first_half;
<a name="l00145"></a>00145 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         VIDEO_BIOS_always_carry_14_high_font;
<a name="l00146"></a>00146 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         VIDEO_BIOS_always_carry_16_high_font;
<a name="l00147"></a>00147 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         VIDEO_BIOS_enable_CGA_8x8_second_half;
<a name="l00148"></a>00148 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         allow_more_than_640kb;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 Bit32u              guest_msdos_LoL = 0;
<a name="l00151"></a>00151 Bit16u              guest_msdos_mcb_chain = 0;
<a name="l00152"></a>00152 <span class="keywordtype">int</span>                 boothax = BOOTHAX_NONE;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keywordtype">bool</span>                want_fm_towns = <span class="keyword">false</span>;
<a name="l00155"></a>00155 <span class="keywordtype">bool</span>                force_load_state = <span class="keyword">false</span>;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="keywordtype">bool</span>                dos_con_use_int16_to_detect_input = <span class="keyword">true</span>;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="keywordtype">bool</span>                dbg_zero_on_dos_allocmem = <span class="keyword">true</span>;
<a name="l00160"></a>00160 <span class="keywordtype">bool</span>                dbg_zero_on_xms_allocmem = <span class="keyword">true</span>;
<a name="l00161"></a>00161 <span class="keywordtype">bool</span>                dbg_zero_on_ems_allocmem = <span class="keyword">true</span>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">/* the exact frequency of the NTSC color subcarrier ~3.579545454...MHz or 315/88 */</span>
<a name="l00164"></a>00164 <span class="comment">/* see: http://en.wikipedia.org/wiki/Colorburst */</span>
<a name="l00165"></a>00165 <span class="preprocessor">#define             NTSC_COLOR_SUBCARRIER_NUM       (315000000ULL)</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor">#define             NTSC_COLOR_SUBCARRIER_DEN       (88ULL)</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span>
<a name="l00168"></a>00168 <span class="comment">/* PCI bus clock</span>
<a name="l00169"></a>00169 <span class="comment"> * Usual setting: 100MHz / 3 = 33.333MHz</span>
<a name="l00170"></a>00170 <span class="comment"> *                 90MHz / 3 = 30.000MHz */</span>
<a name="l00171"></a>00171 <a class="code" href="classClockDomain.html">ClockDomain</a>         clockdom_PCI_BCLK(100000000,3);     <span class="comment">/* MASTER 100MHz / 3 = 33.33333MHz */</span>
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="comment">/* ISA bus OSC clock (14.31818MHz), using a crystal that is 4x the NTSC subcarrier frequency 3.5795454..MHz */</span>
<a name="l00174"></a>00174 <a class="code" href="classClockDomain.html">ClockDomain</a>         clockdom_ISA_OSC(NTSC_COLOR_SUBCARRIER_NUM*4,NTSC_COLOR_SUBCARRIER_DEN);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">/* ISA bus clock (varies between 4.77MHz to 8.333MHz)</span>
<a name="l00177"></a>00177 <span class="comment"> * PC/XT: ISA oscillator clock (14.31818MHz / 3) = 4.77MHz</span>
<a name="l00178"></a>00178 <span class="comment"> * Some systems keep CPU synchronous to bus clock: 4.77MHz, 6MHz, 8MHz, 8.333MHz</span>
<a name="l00179"></a>00179 <span class="comment"> * Later systems: 25MHz / 3 = 8.333MHz</span>
<a name="l00180"></a>00180 <span class="comment"> *                33MHz / 4 = 8.333MHz</span>
<a name="l00181"></a>00181 <span class="comment"> * PCI bus systems: PCI bus clock 33MHz / 4 = 8.333MHz (especially Intel chipsets according to PIIX datasheets) */</span>
<a name="l00182"></a>00182 <a class="code" href="classClockDomain.html">ClockDomain</a>         clockdom_ISA_BCLK(25000000,3);      <span class="comment">/* MASTER 25000000Hz / 3 = 8.333333MHz */</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <a class="code" href="classConfig.html">Config</a>*             control;
<a name="l00185"></a>00185 MachineType         machine;
<a name="l00186"></a>00186 <span class="keywordtype">bool</span>                PS1AudioCard;       <span class="comment">// Perhaps have PS1 as a machine type...?</span>
<a name="l00187"></a>00187 SVGACards           svgaCard;
<a name="l00188"></a>00188 <span class="keywordtype">bool</span>                SDLNetInited;
<a name="l00189"></a>00189 Bit32s              ticksDone;
<a name="l00190"></a>00190 Bit32u              ticksScheduled;
<a name="l00191"></a>00191 <span class="keywordtype">bool</span>                ticksLocked;
<a name="l00192"></a>00192 <span class="keywordtype">bool</span>                mono_cga=<span class="keyword">false</span>;
<a name="l00193"></a>00193 <span class="keywordtype">bool</span>                ignore_opcode_63 = <span class="keyword">true</span>;
<a name="l00194"></a>00194 <span class="keywordtype">int</span>             dynamic_core_cache_block_size = 32;
<a name="l00195"></a>00195 Bitu                VGA_BIOS_Size_override = 0;
<a name="l00196"></a>00196 Bitu                VGA_BIOS_SEG = 0xC000;
<a name="l00197"></a>00197 Bitu                VGA_BIOS_SEG_END = 0xC800;
<a name="l00198"></a>00198 Bitu                VGA_BIOS_Size = 0x8000;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 Bit32u                  emulator_speed = 100;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="keyword">static</span> Bit32u           ticksRemain;
<a name="l00203"></a>00203 <span class="keyword">static</span> Bit32u           ticksRemainSpeedFrac;
<a name="l00204"></a>00204 <span class="keyword">static</span> Bit32u           ticksLast;
<a name="l00205"></a>00205 <span class="keyword">static</span> Bit32u           ticksLastFramecounter;
<a name="l00206"></a>00206 <span class="keyword">static</span> Bit32u           ticksLastRTcounter;
<a name="l00207"></a>00207 <span class="keyword">static</span> <span class="keywordtype">double</span>           ticksLastRTtime;
<a name="l00208"></a>00208 <span class="keyword">static</span> Bit32u           ticksAdded;
<a name="l00209"></a>00209 <span class="keyword">static</span> Bit32u           <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a> = 0;
<a name="l00210"></a>00210 <span class="keyword">extern</span> <span class="keywordtype">double</span>           rtdelta;
<a name="l00211"></a>00211 <span class="keyword">static</span> LoopHandler*     loop;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="keywordtype">void</span> increaseticks();
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="comment">/* The whole load of startups for all the subfunctions */</span>
<a name="l00216"></a>00216 <span class="keywordtype">void</span>                MEM_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00217"></a>00217 <span class="keywordtype">void</span>                ISAPNP_Cfg_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00218"></a>00218 <span class="keywordtype">void</span>                ROMBIOS_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00219"></a>00219 <span class="keywordtype">void</span>                CALLBACK_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00220"></a>00220 <span class="keywordtype">void</span>                PROGRAMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00221"></a>00221 <span class="keywordtype">void</span>                RENDER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00222"></a>00222 <span class="keywordtype">void</span>                VGA_VsyncInit(<a class="code" href="classSection.html">Section</a>*);
<a name="l00223"></a>00223 <span class="keywordtype">void</span>                VGA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00224"></a>00224 <span class="keywordtype">void</span>                DOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00225"></a>00225 <span class="keywordtype">void</span>                CPU_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00226"></a>00226 <span class="preprocessor">#if C_FPU</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span><span class="keywordtype">void</span>                FPU_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00228"></a>00228 <span class="preprocessor">#endif</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span><span class="keywordtype">void</span>                DMA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00230"></a>00230 <span class="keywordtype">void</span>                MIXER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00231"></a>00231 <span class="keywordtype">void</span>                MIDI_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00232"></a>00232 <span class="keywordtype">void</span>                HARDWARE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00233"></a>00233 <span class="keywordtype">void</span>                PCIBUS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00234"></a>00234 <span class="keywordtype">void</span>                PCI_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00235"></a>00235 <span class="keywordtype">void</span>                VOODOO_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="keywordtype">void</span>                IDE_Primary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00238"></a>00238 <span class="keywordtype">void</span>                IDE_Secondary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00239"></a>00239 <span class="keywordtype">void</span>                IDE_Tertiary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00240"></a>00240 <span class="keywordtype">void</span>                IDE_Quaternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00241"></a>00241 <span class="keywordtype">void</span>                IDE_Quinternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00242"></a>00242 <span class="keywordtype">void</span>                IDE_Sexternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00243"></a>00243 <span class="keywordtype">void</span>                IDE_Septernary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00244"></a>00244 <span class="keywordtype">void</span>                IDE_Octernary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="keywordtype">void</span>                FDC_Primary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="keywordtype">void</span>                KEYBOARD_Init(<a class="code" href="classSection.html">Section</a>*);    <span class="comment">//TODO This should setup INT 16 too but ok ;)</span>
<a name="l00249"></a>00249 <span class="keywordtype">void</span>                JOYSTICK_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00250"></a>00250 <span class="keywordtype">void</span>                MOUSE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00251"></a>00251 <span class="keywordtype">void</span>                SBLASTER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00252"></a>00252 <span class="keywordtype">void</span>                GUS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00253"></a>00253 <span class="keywordtype">void</span>                MPU401_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00254"></a>00254 <span class="keywordtype">void</span>                PCSPEAKER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00255"></a>00255 <span class="keywordtype">void</span>                TANDYSOUND_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00256"></a>00256 <span class="keywordtype">void</span>                DISNEY_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00257"></a>00257 <span class="keywordtype">void</span>                PS1SOUND_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00258"></a>00258 <span class="keywordtype">void</span>                INNOVA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00259"></a>00259 <span class="keywordtype">void</span>                SERIAL_Init(<a class="code" href="classSection.html">Section</a>*); 
<a name="l00260"></a>00260 <span class="keywordtype">void</span>                DONGLE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00261"></a>00261 <span class="preprocessor">#if C_IPX</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span><span class="keywordtype">void</span>                IPX_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00263"></a>00263 <span class="preprocessor">#endif</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span><span class="keywordtype">void</span>                PIC_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00265"></a>00265 <span class="keywordtype">void</span>                TIMER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00266"></a>00266 <span class="keywordtype">void</span>                BIOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00267"></a>00267 <span class="keywordtype">void</span>                DEBUG_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00268"></a>00268 <span class="keywordtype">void</span>                CMOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00269"></a>00269 <span class="keywordtype">void</span>                MSCDEX_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00270"></a>00270 <span class="keywordtype">void</span>                DRIVES_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00271"></a>00271 <span class="keywordtype">void</span>                CDROM_Image_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00272"></a>00272 <span class="keywordtype">void</span>                EMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00273"></a>00273 <span class="keywordtype">void</span>                XMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00274"></a>00274 <span class="keywordtype">void</span>                DOS_KeyboardLayout_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00275"></a>00275 <span class="keywordtype">void</span>                AUTOEXEC_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00276"></a>00276 <span class="keywordtype">void</span>                INT10_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00277"></a>00277 <span class="preprocessor">#if C_PRINTER</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span><span class="keywordtype">void</span>                PRINTER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00279"></a>00279 <span class="preprocessor">#endif</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span>
<a name="l00281"></a>00281 <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> time_to_clockdom(<span class="keyword">const</span> <a class="code" href="classClockDomain.html">ClockDomain</a> &amp;src,<span class="keywordtype">double</span> t) {
<a name="l00282"></a>00282     <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> lt = (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)t;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     lt *= (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)src.freq;
<a name="l00285"></a>00285     lt /= (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)src.freq_div;
<a name="l00286"></a>00286     <span class="keywordflow">return</span> lt;
<a name="l00287"></a>00287 }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> update_clockdom_from_now(<a class="code" href="classClockDomain.html">ClockDomain</a> &amp;dst) {
<a name="l00290"></a>00290     <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> s;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     <span class="comment">/* PIC_Ticks (if I read the code correctly) is millisecond ticks, units of 1/1000 seconds.</span>
<a name="l00293"></a>00293 <span class="comment">     * PIC_TickIndexND() units of submillisecond time in units of 1/CPU_CycleMax. */</span>
<a name="l00294"></a>00294     s  = (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)PIC_Ticks * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)dst.freq);
<a name="l00295"></a>00295     s += (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)PIC_TickIndexND() * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)dst.freq) / (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)CPU_CycleMax);
<a name="l00296"></a>00296     <span class="comment">/* convert down to frequency counts, not freq x 1000 */</span>
<a name="l00297"></a>00297     s /= (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)(1000ULL * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)dst.freq_div);
<a name="l00298"></a>00298 
<a name="l00299"></a>00299     <span class="comment">/* guard against time going backwards slightly (as PIC_TickIndexND() will do sometimes by tiny amounts) */</span>
<a name="l00300"></a>00300     <span class="keywordflow">if</span> (dst.counter &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)s) dst.counter = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)s;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     <span class="keywordflow">return</span> dst.counter;
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="preprocessor">#include &quot;paging.h&quot;</span>
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="keyword">extern</span> <span class="keywordtype">bool</span> rom_bios_vptable_enable;
<a name="l00308"></a>00308 <span class="keyword">extern</span> <span class="keywordtype">bool</span> rom_bios_8x8_cga_font;
<a name="l00309"></a>00309 <span class="keyword">extern</span> <span class="keywordtype">bool</span> allow_port_92_reset;
<a name="l00310"></a>00310 <span class="keyword">extern</span> <span class="keywordtype">bool</span> allow_keyb_reset;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="keyword">extern</span> <span class="keywordtype">bool</span> DOSBox_Paused();
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="comment">//#define DEBUG_CYCLE_OVERRUN_CALLBACK</span>
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">//For trying other delays</span>
<a name="l00317"></a>00317 <span class="preprocessor">#define wrap_delay(a) SDL_Delay(a)</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span>
<a name="l00319"></a>00319 <span class="keyword">static</span> Bitu Normal_Loop(<span class="keywordtype">void</span>) {
<a name="l00320"></a>00320     <span class="keywordtype">bool</span> saved_allow = dosbox_allow_nonrecursive_page_fault;
<a name="l00321"></a>00321     Bits ret;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323     <span class="keywordflow">if</span> (!menu.hidecycles || menu.showrt) { <span class="comment">/* sdlmain.cpp/render.cpp doesn&#39;t even maintain the frames count when hiding cycles! */</span>
<a name="l00324"></a>00324         Bit32u ticksNew = GetTicks();
<a name="l00325"></a>00325         <span class="keywordflow">if</span> (ticksNew &gt;= <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a>) {
<a name="l00326"></a>00326             Bit32u interval = ticksNew - ticksLastFramecounter;
<a name="l00327"></a>00327             <span class="keywordtype">double</span> rtnow = PIC_FullIndex();
<a name="l00328"></a>00328 
<a name="l00329"></a>00329             <span class="keywordflow">if</span> (interval == 0) interval = 1; <span class="comment">// avoid divide by zero</span>
<a name="l00330"></a>00330 
<a name="l00331"></a>00331             rtdelta = rtnow - ticksLastRTtime;
<a name="l00332"></a>00332             rtdelta = (rtdelta * 1000) / interval;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334             ticksLastRTtime = rtnow;
<a name="l00335"></a>00335             ticksLastFramecounter = <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a>;
<a name="l00336"></a>00336             <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a> = ticksNew + 500;     <span class="comment">// next update in 500ms</span>
<a name="l00337"></a>00337             frames = (frames * 1000) / interval; <span class="comment">// compensate for interval, be more exact (FIXME: so can we adjust for fractional frame rates)</span>
<a name="l00338"></a>00338             GFX_SetTitle((Bit32s)CPU_CycleMax,-1,-1,<span class="keyword">false</span>);
<a name="l00339"></a>00339             frames = 0;
<a name="l00340"></a>00340         }
<a name="l00341"></a>00341     }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     <span class="keywordflow">try</span> {
<a name="l00344"></a>00344         <span class="keywordflow">while</span> (1) {
<a name="l00345"></a>00345             <span class="keywordflow">if</span> (PIC_RunQueue()) {
<a name="l00346"></a>00346                 <span class="comment">/* now is the time to check for the NMI (Non-maskable interrupt) */</span>
<a name="l00347"></a>00347                 CPU_Check_NMI();
<a name="l00348"></a>00348 
<a name="l00349"></a>00349                 saved_allow = dosbox_allow_nonrecursive_page_fault;
<a name="l00350"></a>00350                 dosbox_allow_nonrecursive_page_fault = <span class="keyword">true</span>;
<a name="l00351"></a>00351                 ret = (*cpudecoder)();
<a name="l00352"></a>00352                 dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354                 <span class="keywordflow">if</span> (GCC_UNLIKELY(ret&lt;0))
<a name="l00355"></a>00355                     <span class="keywordflow">return</span> 1;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357                 <span class="keywordflow">if</span> (ret&gt;0) {
<a name="l00358"></a>00358                     <span class="keywordflow">if</span> (GCC_UNLIKELY((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)ret &gt;= CB_MAX))
<a name="l00359"></a>00359                         <span class="keywordflow">return</span> 0;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361                     <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_callback;
<a name="l00362"></a>00362                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_last_callback = last_callback;
<a name="l00363"></a>00363                     last_callback = (<span class="keywordtype">unsigned</span> int)ret;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365                     dosbox_allow_nonrecursive_page_fault = <span class="keyword">false</span>;
<a name="l00366"></a>00366                     Bitu blah = (*CallBack_Handlers[ret])();
<a name="l00367"></a>00367                     dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369                     last_callback = p_last_callback;
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="preprocessor">#ifdef DEBUG_CYCLE_OVERRUN_CALLBACK</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span>                    {
<a name="l00373"></a>00373                         <span class="keyword">extern</span> <span class="keywordtype">char</span>* CallBack_Description[CB_MAX];
<a name="l00374"></a>00374 
<a name="l00375"></a>00375                         <span class="comment">/* I/O delay can cause negative CPU_Cycles and PIC event / audio rendering issues */</span>
<a name="l00376"></a>00376                         cpu_cycles_count_t overrun = -std::min(CPU_Cycles,(cpu_cycles_count_t)0);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378                         <span class="keywordflow">if</span> (overrun &gt; (CPU_CycleMax/100))
<a name="l00379"></a>00379                             LOG_MSG(<span class="stringliteral">&quot;Normal loop: CPU cycles count overrun by %ld (%.3fms) after callback &#39;%s&#39;\n&quot;</span>,(<span class="keywordtype">signed</span> <span class="keywordtype">long</span>)overrun,(<span class="keywordtype">double</span>)overrun / CPU_CycleMax,CallBack_Description[ret]);
<a name="l00380"></a>00380                     }
<a name="l00381"></a>00381 <span class="preprocessor">#endif</span>
<a name="l00382"></a>00382 <span class="preprocessor"></span>
<a name="l00383"></a>00383                     <span class="keywordflow">if</span> (GCC_UNLIKELY(blah &gt; 0U))
<a name="l00384"></a>00384                         <span class="keywordflow">return</span> blah;
<a name="l00385"></a>00385                 }
<a name="l00386"></a>00386 <span class="preprocessor">#if C_DEBUG</span>
<a name="l00387"></a>00387 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (DEBUG_ExitLoop())
<a name="l00388"></a>00388                     <span class="keywordflow">return</span> 0;
<a name="l00389"></a>00389 <span class="preprocessor">#endif</span>
<a name="l00390"></a>00390 <span class="preprocessor"></span>            } <span class="keywordflow">else</span> {
<a name="l00391"></a>00391                 GFX_Events();
<a name="l00392"></a>00392                 <span class="keywordflow">if</span> (DOSBox_Paused() == <span class="keyword">false</span> &amp;&amp; ticksRemain &gt; 0) {
<a name="l00393"></a>00393                     TIMER_AddTick();
<a name="l00394"></a>00394                     ticksRemain--;
<a name="l00395"></a>00395                 } <span class="keywordflow">else</span> {
<a name="l00396"></a>00396                     increaseticks();
<a name="l00397"></a>00397                     <span class="keywordflow">return</span> 0;
<a name="l00398"></a>00398                 }
<a name="l00399"></a>00399             }
<a name="l00400"></a>00400         }
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402     <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classGuestPageFaultException.html">GuestPageFaultException</a>&amp; pf) {
<a name="l00403"></a>00403         Bitu FillFlags(<span class="keywordtype">void</span>);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         ret = 0;
<a name="l00406"></a>00406         FillFlags();
<a name="l00407"></a>00407         dosbox_allow_nonrecursive_page_fault = <span class="keyword">false</span>;
<a name="l00408"></a>00408         CPU_Exception(EXCEPTION_PF, pf.faultcode);
<a name="l00409"></a>00409         dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411     <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> x) {
<a name="l00412"></a>00412         dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00413"></a>00413         <span class="keywordflow">if</span> (x == 4<span class="comment">/*CMOS shutdown*/</span>) {
<a name="l00414"></a>00414             ret = 0;
<a name="l00415"></a>00415 <span class="comment">//          LOG_MSG(&quot;CMOS shutdown reset acknowledged&quot;);</span>
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417         <span class="keywordflow">else</span> {
<a name="l00418"></a>00418             <span class="keywordflow">throw</span>;
<a name="l00419"></a>00419         }
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421     <span class="keywordflow">return</span> 0;
<a name="l00422"></a>00422 }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 <span class="keywordtype">void</span> increaseticks() { <span class="comment">//Make it return ticksRemain and set it in the function above to remove the global variable.</span>
<a name="l00425"></a>00425     <span class="keyword">static</span> Bit32s lastsleepDone = -1;
<a name="l00426"></a>00426     <span class="keyword">static</span> Bitu sleep1count = 0;
<a name="l00427"></a>00427     <span class="keywordflow">if</span> (GCC_UNLIKELY(ticksLocked)) { <span class="comment">// For Fast Forward Mode</span>
<a name="l00428"></a>00428         ticksRemainSpeedFrac = 0;
<a name="l00429"></a>00429         ticksRemain = 5;
<a name="l00430"></a>00430         <span class="comment">/* Reset any auto cycle guessing for this frame */</span>
<a name="l00431"></a>00431         ticksLast = GetTicks();
<a name="l00432"></a>00432         ticksAdded = 0;
<a name="l00433"></a>00433         ticksDone = 0;
<a name="l00434"></a>00434         ticksScheduled = 0;
<a name="l00435"></a>00435         <span class="keywordflow">return</span>;
<a name="l00436"></a>00436     }
<a name="l00437"></a>00437     Bit32u ticksNew = GetTicks();
<a name="l00438"></a>00438     ticksScheduled += ticksAdded;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440     <span class="keywordflow">if</span> (ticksNew &lt;= ticksLast) { <span class="comment">//lower should not be possible, only equal.</span>
<a name="l00441"></a>00441         ticksAdded = 0;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443         <span class="keywordflow">if</span> (!CPU_CycleAutoAdjust || CPU_SkipCycleAutoAdjust || sleep1count &lt; 3) {
<a name="l00444"></a>00444             wrap_delay(1);
<a name="l00445"></a>00445         }
<a name="l00446"></a>00446         <span class="keywordflow">else</span> {
<a name="l00447"></a>00447             <span class="comment">/* Certain configurations always give an exact sleepingtime of 1, this causes problems due to the fact that</span>
<a name="l00448"></a>00448 <span class="comment">               DOSBox-X keeps track of full blocks.</span>
<a name="l00449"></a>00449 <span class="comment">               This code introduces some randomness to the time slept, which improves stability on those configurations</span>
<a name="l00450"></a>00450 <span class="comment">             */</span>
<a name="l00451"></a>00451             <span class="keyword">static</span> <span class="keyword">const</span> Bit32u sleeppattern[] = { 2, 2, 3, 2, 2, 4, 2 };
<a name="l00452"></a>00452             <span class="keyword">static</span> Bit32u sleepindex = 0;
<a name="l00453"></a>00453             <span class="keywordflow">if</span> (ticksDone != lastsleepDone) sleepindex = 0;
<a name="l00454"></a>00454             wrap_delay(sleeppattern[sleepindex++]);
<a name="l00455"></a>00455             sleepindex %= <span class="keyword">sizeof</span>(sleeppattern) / <span class="keyword">sizeof</span>(sleeppattern[0]);
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457         Bit32s timeslept = (Bit32s)(GetTicks() - ticksNew);
<a name="l00458"></a>00458         <span class="comment">// Count how many times in the current block (of 250 ms) the time slept was 1 ms</span>
<a name="l00459"></a>00459         <span class="keywordflow">if</span> (CPU_CycleAutoAdjust &amp;&amp; !CPU_SkipCycleAutoAdjust &amp;&amp; timeslept == 1) sleep1count++;
<a name="l00460"></a>00460         lastsleepDone = ticksDone;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462         <span class="comment">// Update ticksDone with the time spent sleeping</span>
<a name="l00463"></a>00463         ticksDone -= timeslept;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465         <span class="keywordflow">if</span> (ticksDone &lt; 0)
<a name="l00466"></a>00466             ticksDone = 0;
<a name="l00467"></a>00467         <span class="keywordflow">return</span>;
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="comment">//ticksNew &gt; ticksLast</span>
<a name="l00471"></a>00471     ticksRemain = ticksNew - ticksLast;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     <span class="keywordflow">if</span> (emulator_speed != 100u) {
<a name="l00474"></a>00474         ticksRemain *= emulator_speed;
<a name="l00475"></a>00475         ticksRemain += ticksRemainSpeedFrac;
<a name="l00476"></a>00476         ticksRemainSpeedFrac = ticksRemain % 100u;
<a name="l00477"></a>00477         ticksRemain /= 100u;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479     <span class="keywordflow">else</span> {
<a name="l00480"></a>00480         ticksRemainSpeedFrac = 0;
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483     ticksLast = ticksNew;
<a name="l00484"></a>00484     ticksDone += (Bit32s)ticksRemain;
<a name="l00485"></a>00485     <span class="keywordflow">if</span> (ticksRemain &gt; 20) {
<a name="l00486"></a>00486         ticksRemain = 20;
<a name="l00487"></a>00487     }
<a name="l00488"></a>00488     ticksAdded = ticksRemain;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <span class="comment">// Is the system in auto cycle mode guessing? If not just exit. (It can be temporarily disabled)</span>
<a name="l00491"></a>00491     <span class="keywordflow">if</span> (!CPU_CycleAutoAdjust || CPU_SkipCycleAutoAdjust)
<a name="l00492"></a>00492         <span class="keywordflow">return</span>;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494     <span class="keywordflow">if</span> (ticksScheduled &gt;= 250 || ticksDone &gt;= 250 || (ticksAdded &gt; 15 &amp;&amp; ticksScheduled &gt;= 5)) {
<a name="l00495"></a>00495         <span class="keywordflow">if</span> (ticksDone &lt; 1) ticksDone = 1; <span class="comment">// Protect against div by zero</span>
<a name="l00496"></a>00496         <span class="comment">/* ratio we are aiming for is around 90% usage*/</span>
<a name="l00497"></a>00497         Bit32s ratio = (Bit32s)((ticksScheduled * (CPU_CyclePercUsed * 90 * 1024 / 100 / 100)) / ticksDone);
<a name="l00498"></a>00498         Bit32s new_cmax = (Bit32s)CPU_CycleMax;
<a name="l00499"></a>00499         Bit64s cproc = (Bit64s)CPU_CycleMax * (Bit64s)ticksScheduled;
<a name="l00500"></a>00500         <span class="keywordflow">if</span> (cproc &gt; 0) {
<a name="l00501"></a>00501             <span class="comment">/* ignore the cycles added due to the IO delay code in order</span>
<a name="l00502"></a>00502 <span class="comment">               to have smoother auto cycle adjustments */</span>
<a name="l00503"></a>00503             <span class="keywordtype">double</span> ratioremoved = (double)CPU_IODelayRemoved / (<span class="keywordtype">double</span>)cproc;
<a name="l00504"></a>00504             <span class="keywordflow">if</span> (ratioremoved &lt; 1.0) {
<a name="l00505"></a>00505                 <span class="keywordtype">double</span> ratio_not_removed = 1 - ratioremoved;
<a name="l00506"></a>00506                 ratio = (Bit32s)((<span class="keywordtype">double</span>)ratio * ratio_not_removed);
<a name="l00507"></a>00507                 <span class="comment">/* Don&#39;t allow very high ratio which can cause us to lock as we don&#39;t scale down</span>
<a name="l00508"></a>00508 <span class="comment">                 * for very low ratios. High ratio might result because of timing resolution */</span>
<a name="l00509"></a>00509                 <span class="keywordflow">if</span> (ticksScheduled &gt;= 250 &amp;&amp; ticksDone &lt; 10 &amp;&amp; ratio &gt; 16384)
<a name="l00510"></a>00510                     ratio = 16384;
<a name="l00511"></a>00511 
<a name="l00512"></a>00512                 <span class="comment">// Limit the ratio even more when the cycles are already way above the realmode default.</span>
<a name="l00513"></a>00513                 <span class="keywordflow">if</span> (ticksScheduled &gt;= 250 &amp;&amp; ticksDone &lt; 10 &amp;&amp; ratio &gt; 5120 &amp;&amp; CPU_CycleMax &gt; 50000)
<a name="l00514"></a>00514                     ratio = 5120;
<a name="l00515"></a>00515 
<a name="l00516"></a>00516                 <span class="comment">// When downscaling multiple times in a row, ensure a minimum amount of downscaling</span>
<a name="l00517"></a>00517                 <span class="keywordflow">if</span> (ticksAdded &gt; 15 &amp;&amp; ticksScheduled &gt;= 5 &amp;&amp; ticksScheduled &lt;= 20 &amp;&amp; ratio &gt; 800)
<a name="l00518"></a>00518                     ratio = 800;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520                 <span class="keywordflow">if</span> (ratio &lt;= 1024) {
<a name="l00521"></a>00521                     <span class="comment">// ratio_not_removed = 1.0; //enabling this restores the old formula</span>
<a name="l00522"></a>00522                     <span class="keywordtype">double</span> r = (1.0 + ratio_not_removed) / (ratio_not_removed + 1024.0 / (static_cast&lt;double&gt;(ratio)));
<a name="l00523"></a>00523                     new_cmax = 1 + <span class="keyword">static_cast&lt;</span>Bit32s<span class="keyword">&gt;</span>(CPU_CycleMax * r);
<a name="l00524"></a>00524                 }
<a name="l00525"></a>00525                 <span class="keywordflow">else</span> {
<a name="l00526"></a>00526                     Bit64s ratio_with_removed = (Bit64s)((((<span class="keywordtype">double</span>)ratio - 1024.0) * ratio_not_removed) + 1024.0);
<a name="l00527"></a>00527                     Bit64s cmax_scaled = (Bit64s)CPU_CycleMax * ratio_with_removed;
<a name="l00528"></a>00528                     new_cmax = (Bit32s)(1 + (CPU_CycleMax &gt;&gt; 1) + cmax_scaled / (Bit64s)2048);
<a name="l00529"></a>00529                 }
<a name="l00530"></a>00530             }
<a name="l00531"></a>00531         }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533         <span class="keywordflow">if</span> (new_cmax &lt; CPU_CYCLES_LOWER_LIMIT)
<a name="l00534"></a>00534             new_cmax = CPU_CYCLES_LOWER_LIMIT;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="comment">/*</span>
<a name="l00537"></a>00537 <span class="comment">           LOG_MSG(&quot;cyclelog: current %6d   cmax %6d   ratio  %5d  done %3d   sched %3d&quot;,</span>
<a name="l00538"></a>00538 <span class="comment">           CPU_CycleMax,</span>
<a name="l00539"></a>00539 <span class="comment">           new_cmax,</span>
<a name="l00540"></a>00540 <span class="comment">           ratio,</span>
<a name="l00541"></a>00541 <span class="comment">           ticksDone,</span>
<a name="l00542"></a>00542 <span class="comment">           ticksScheduled);</span>
<a name="l00543"></a>00543 <span class="comment">           */</span>
<a name="l00544"></a>00544            <span class="comment">/* ratios below 1% are considered to be dropouts due to</span>
<a name="l00545"></a>00545 <span class="comment">              temporary load imbalance, the cycles adjusting is skipped */</span>
<a name="l00546"></a>00546         <span class="keywordflow">if</span> (ratio &gt; 10) {
<a name="l00547"></a>00547             <span class="comment">/* ratios below 12% along with a large time since the last update</span>
<a name="l00548"></a>00548 <span class="comment">               has taken place are most likely caused by heavy load through a</span>
<a name="l00549"></a>00549 <span class="comment">               different application, the cycles adjusting is skipped as well */</span>
<a name="l00550"></a>00550             <span class="keywordflow">if</span> ((ratio &gt; 120) || (ticksDone &lt; 700)) {
<a name="l00551"></a>00551                 CPU_CycleMax = new_cmax;
<a name="l00552"></a>00552                 <span class="keywordflow">if</span> (CPU_CycleLimit &gt; 0) {
<a name="l00553"></a>00553                     <span class="keywordflow">if</span> (CPU_CycleMax &gt; CPU_CycleLimit) CPU_CycleMax = CPU_CycleLimit;
<a name="l00554"></a>00554                 }
<a name="l00555"></a>00555                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CPU_CycleMax &gt; 2000000) CPU_CycleMax = 2000000; <span class="comment">//Hardcoded limit, if no limit was specified.</span>
<a name="l00556"></a>00556             }
<a name="l00557"></a>00557         }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559         <span class="comment">//Reset cycleguessing parameters.</span>
<a name="l00560"></a>00560         CPU_IODelayRemoved = 0;
<a name="l00561"></a>00561         ticksDone = 0;
<a name="l00562"></a>00562         ticksScheduled = 0;
<a name="l00563"></a>00563         lastsleepDone = -1;
<a name="l00564"></a>00564         sleep1count = 0;
<a name="l00565"></a>00565     }
<a name="l00566"></a>00566     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ticksAdded &gt; 15) {
<a name="l00567"></a>00567         <span class="comment">/* ticksAdded &gt; 15 but ticksScheduled &lt; 5, lower the cycles</span>
<a name="l00568"></a>00568 <span class="comment">           but do not reset the scheduled/done ticks to take them into</span>
<a name="l00569"></a>00569 <span class="comment">           account during the next auto cycle adjustment */</span>
<a name="l00570"></a>00570         CPU_CycleMax /= 3;
<a name="l00571"></a>00571         <span class="keywordflow">if</span> (CPU_CycleMax &lt; CPU_CYCLES_LOWER_LIMIT)
<a name="l00572"></a>00572             CPU_CycleMax = CPU_CYCLES_LOWER_LIMIT;
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574 }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576 LoopHandler *DOSBOX_GetLoop(<span class="keywordtype">void</span>) {
<a name="l00577"></a>00577     <span class="keywordflow">return</span> loop;
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 <span class="keywordtype">void</span> DOSBOX_SetLoop(LoopHandler * handler) {
<a name="l00581"></a>00581     loop=handler;
<a name="l00582"></a>00582 }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584 <span class="keywordtype">void</span> DOSBOX_SetNormalLoop() {
<a name="l00585"></a>00585     loop=Normal_Loop;
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="comment">//#define DEBUG_RECURSION</span>
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 <span class="preprocessor">#ifdef DEBUG_RECURSION</span>
<a name="l00591"></a>00591 <span class="preprocessor"></span><span class="keyword">volatile</span> <span class="keywordtype">int</span> runmachine_recursion = 0;
<a name="l00592"></a>00592 <span class="preprocessor">#endif</span>
<a name="l00593"></a>00593 <span class="preprocessor"></span>
<a name="l00594"></a>00594 <span class="keywordtype">void</span> DOSBOX_RunMachine(<span class="keywordtype">void</span>){
<a name="l00595"></a>00595     Bitu ret;
<a name="l00596"></a>00596 
<a name="l00597"></a>00597     <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_callback;
<a name="l00598"></a>00598     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_last_callback = last_callback;
<a name="l00599"></a>00599     last_callback = 0;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="preprocessor">#ifdef DEBUG_RECURSION</span>
<a name="l00602"></a>00602 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (runmachine_recursion++ != 0)
<a name="l00603"></a>00603         LOG_MSG(<span class="stringliteral">&quot;RunMachine recursion&quot;</span>);
<a name="l00604"></a>00604 <span class="preprocessor">#endif</span>
<a name="l00605"></a>00605 <span class="preprocessor"></span>
<a name="l00606"></a>00606     <span class="keywordflow">do</span> {
<a name="l00607"></a>00607         ret=(*loop)();
<a name="l00608"></a>00608     } <span class="keywordflow">while</span> (!ret);
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="preprocessor">#ifdef DEBUG_RECURSION</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (--runmachine_recursion &lt; 0)
<a name="l00612"></a>00612         LOG_MSG(<span class="stringliteral">&quot;RunMachine recursion leave error&quot;</span>);
<a name="l00613"></a>00613 <span class="preprocessor">#endif</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span>
<a name="l00615"></a>00615     last_callback = p_last_callback;
<a name="l00616"></a>00616 }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 <span class="keyword">static</span> <span class="keywordtype">void</span> DOSBOX_UnlockSpeed( <span class="keywordtype">bool</span> pressed ) {
<a name="l00619"></a>00619     <span class="keyword">static</span> <span class="keywordtype">bool</span> autoadjust = <span class="keyword">false</span>;
<a name="l00620"></a>00620     <span class="keywordflow">if</span> (pressed) {
<a name="l00621"></a>00621         LOG_MSG(<span class="stringliteral">&quot;Fast Forward ON&quot;</span>);
<a name="l00622"></a>00622         ticksLocked = <span class="keyword">true</span>;
<a name="l00623"></a>00623         <span class="keywordflow">if</span> (CPU_CycleAutoAdjust) {
<a name="l00624"></a>00624             autoadjust = <span class="keyword">true</span>;
<a name="l00625"></a>00625             CPU_CycleAutoAdjust = <span class="keyword">false</span>;
<a name="l00626"></a>00626             CPU_CycleMax /= 3;
<a name="l00627"></a>00627             <span class="keywordflow">if</span> (CPU_CycleMax&lt;1000) CPU_CycleMax=1000;
<a name="l00628"></a>00628         }
<a name="l00629"></a>00629     } <span class="keywordflow">else</span> {
<a name="l00630"></a>00630         LOG_MSG(<span class="stringliteral">&quot;Fast Forward OFF&quot;</span>);
<a name="l00631"></a>00631         ticksLocked = <span class="keyword">false</span>;
<a name="l00632"></a>00632         <span class="keywordflow">if</span> (autoadjust) {
<a name="l00633"></a>00633             autoadjust = <span class="keyword">false</span>;
<a name="l00634"></a>00634             CPU_CycleAutoAdjust = <span class="keyword">true</span>;
<a name="l00635"></a>00635         }
<a name="l00636"></a>00636     }
<a name="l00637"></a>00637     GFX_SetTitle(-1,-1,-1,<span class="keyword">false</span>);
<a name="l00638"></a>00638 }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="keywordtype">void</span> DOSBOX_UnlockSpeed2( <span class="keywordtype">bool</span> pressed ) {
<a name="l00641"></a>00641     <span class="keywordflow">if</span> (pressed) {
<a name="l00642"></a>00642         ticksLocked = !ticksLocked;
<a name="l00643"></a>00643         DOSBOX_UnlockSpeed(ticksLocked?<span class="keyword">true</span>:<span class="keyword">false</span>);
<a name="l00644"></a>00644 
<a name="l00645"></a>00645         <span class="comment">/* make sure the menu item keeps up with our state */</span>
<a name="l00646"></a>00646         mainMenu.get_item(<span class="stringliteral">&quot;mapper_speedlock2&quot;</span>).check(ticksLocked).refresh_item(mainMenu);
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650 <span class="keywordtype">void</span> DOSBOX_NormalSpeed( <span class="keywordtype">bool</span> pressed ) {
<a name="l00651"></a>00651     <span class="keywordflow">if</span> (pressed) {
<a name="l00652"></a>00652         <span class="comment">/* should also cancel turbo mode */</span>
<a name="l00653"></a>00653         <span class="keywordflow">if</span> (ticksLocked)
<a name="l00654"></a>00654             DOSBOX_UnlockSpeed2(<span class="keyword">true</span>);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656         LOG_MSG(<span class="stringliteral">&quot;Emulation speed restored to normal (100%%)&quot;</span>);
<a name="l00657"></a>00657 
<a name="l00658"></a>00658         emulator_speed = 100;
<a name="l00659"></a>00659         ticksRemainSpeedFrac = 0;
<a name="l00660"></a>00660     }
<a name="l00661"></a>00661 }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="keywordtype">void</span> DOSBOX_SpeedUp( <span class="keywordtype">bool</span> pressed ) {
<a name="l00664"></a>00664     <span class="keywordflow">if</span> (pressed) {
<a name="l00665"></a>00665         ticksRemainSpeedFrac = 0;
<a name="l00666"></a>00666         <span class="keywordflow">if</span> (emulator_speed &gt;= 5)
<a name="l00667"></a>00667             emulator_speed += 5;
<a name="l00668"></a>00668         <span class="keywordflow">else</span>
<a name="l00669"></a>00669             emulator_speed = 5;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         LOG_MSG(<span class="stringliteral">&quot;Emulation speed increased to (%u%%)&quot;</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)emulator_speed);
<a name="l00672"></a>00672     }
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="keywordtype">void</span> DOSBOX_SlowDown( <span class="keywordtype">bool</span> pressed ) {
<a name="l00676"></a>00676     <span class="keywordflow">if</span> (pressed) {
<a name="l00677"></a>00677         ticksRemainSpeedFrac = 0;
<a name="l00678"></a>00678         <span class="keywordflow">if</span> (emulator_speed  &gt; 5)
<a name="l00679"></a>00679             emulator_speed -= 5;
<a name="l00680"></a>00680         <span class="keywordflow">else</span>
<a name="l00681"></a>00681             emulator_speed = 1;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         LOG_MSG(<span class="stringliteral">&quot;Emulation speed decreased to (%u%%)&quot;</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)emulator_speed);
<a name="l00684"></a>00684     }
<a name="l00685"></a>00685 }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 <span class="keyword">namespace</span>
<a name="l00688"></a>00688 {
<a name="l00689"></a>00689 std::string getTime()
<a name="l00690"></a>00690 {
<a name="l00691"></a>00691     <span class="keyword">const</span> time_t current = time(NULL);
<a name="l00692"></a>00692     tm* timeinfo;
<a name="l00693"></a>00693     timeinfo = localtime(&amp;current); <span class="comment">//convert to local time</span>
<a name="l00694"></a>00694     <span class="keywordtype">char</span> buffer[50];
<a name="l00695"></a>00695     ::strftime(buffer, 50, <span class="stringliteral">&quot;%H:%M:%S&quot;</span>, timeinfo);
<a name="l00696"></a>00696     <span class="keywordflow">return</span> buffer;
<a name="l00697"></a>00697 }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 <span class="keyword">class </span>SlotPos
<a name="l00700"></a>00700 {
<a name="l00701"></a>00701 <span class="keyword">public</span>:
<a name="l00702"></a>00702     SlotPos() : slot(0) {}
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="keywordtype">void</span> next()
<a name="l00705"></a>00705     {
<a name="l00706"></a>00706         ++slot;
<a name="l00707"></a>00707         slot %= SaveState::SLOT_COUNT;
<a name="l00708"></a>00708     }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710     <span class="keywordtype">void</span> previous()
<a name="l00711"></a>00711     {
<a name="l00712"></a>00712         slot += SaveState::SLOT_COUNT - 1;
<a name="l00713"></a>00713         slot %= SaveState::SLOT_COUNT;
<a name="l00714"></a>00714     }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716     <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keywordtype">int</span> value)
<a name="l00717"></a>00717     {
<a name="l00718"></a>00718         slot = value;
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721     operator size_t()<span class="keyword"> const</span>
<a name="l00722"></a>00722 <span class="keyword">    </span>{
<a name="l00723"></a>00723         <span class="keywordflow">return</span> slot;
<a name="l00724"></a>00724     }
<a name="l00725"></a>00725 <span class="keyword">private</span>:
<a name="l00726"></a>00726     <span class="keywordtype">size_t</span> slot;
<a name="l00727"></a>00727 } currentSlot;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 <span class="keywordtype">void</span> notifyError(<span class="keyword">const</span> std::string&amp; message)
<a name="l00730"></a>00730 {
<a name="l00731"></a>00731 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00732"></a>00732 <span class="preprocessor"></span>    ::MessageBox(0, message.c_str(), <span class="stringliteral">&quot;Error&quot;</span>, 0);
<a name="l00733"></a>00733 <span class="preprocessor">#endif</span>
<a name="l00734"></a>00734 <span class="preprocessor"></span>    LOG_MSG(<span class="stringliteral">&quot;%s&quot;</span>,message.c_str());
<a name="l00735"></a>00735 }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 <span class="keywordtype">size_t</span> GetGameState(<span class="keywordtype">void</span>) {
<a name="l00738"></a>00738     <span class="keywordflow">return</span> currentSlot;
<a name="l00739"></a>00739 }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741 <span class="keywordtype">void</span> SetGameState(<span class="keywordtype">int</span> value) {
<a name="l00742"></a>00742         <span class="keywordtype">char</span> name[6]=<span class="stringliteral">&quot;slot0&quot;</span>;
<a name="l00743"></a>00743         name[4]=<span class="charliteral">&#39;0&#39;</span>+currentSlot;
<a name="l00744"></a>00744         mainMenu.get_item(name).check(<span class="keyword">false</span>).refresh_item(mainMenu);
<a name="l00745"></a>00745     currentSlot.set(value);
<a name="l00746"></a>00746         name[4]=<span class="charliteral">&#39;0&#39;</span>+currentSlot;
<a name="l00747"></a>00747         mainMenu.get_item(name).check(<span class="keyword">true</span>).refresh_item(mainMenu);
<a name="l00748"></a>00748         
<a name="l00749"></a>00749         <span class="keyword">const</span> <span class="keywordtype">bool</span> emptySlot = SaveState::instance().isEmpty(currentSlot);
<a name="l00750"></a>00750     LOG_MSG(<span class="stringliteral">&quot;Active save slot: %d %s&quot;</span>, (<span class="keywordtype">int</span>)currentSlot + 1,  emptySlot ? <span class="stringliteral">&quot;[Empty]&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00751"></a>00751 }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="keywordtype">void</span> SaveGameState(<span class="keywordtype">bool</span> pressed) {
<a name="l00754"></a>00754     <span class="keywordflow">if</span> (!pressed) <span class="keywordflow">return</span>;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756     <span class="keywordflow">try</span>
<a name="l00757"></a>00757     {
<a name="l00758"></a>00758         SaveState::instance().save(currentSlot);
<a name="l00759"></a>00759         LOG_MSG(<span class="stringliteral">&quot;[%s]: State %d saved!&quot;</span>, getTime().c_str(), (<span class="keywordtype">int</span>)currentSlot + 1);
<a name="l00760"></a>00760                 <span class="keywordtype">char</span> name[6]=<span class="stringliteral">&quot;slot0&quot;</span>;
<a name="l00761"></a>00761                 name[4]=<span class="charliteral">&#39;0&#39;</span>+currentSlot;
<a name="l00762"></a>00762                 std::string command=SaveState::instance().getName(currentSlot);
<a name="l00763"></a>00763                 std::string str=<span class="stringliteral">&quot;Slot &quot;</span>+(currentSlot&gt;=9?<span class="stringliteral">&quot;10&quot;</span>:std::string(1, <span class="charliteral">&#39;1&#39;</span>+currentSlot))+(command==<span class="stringliteral">&quot;[Empty]&quot;</span>?<span class="stringliteral">&quot; [Empty slot]&quot;</span>:(command==<span class="stringliteral">&quot;&quot;</span>?<span class="stringliteral">&quot;&quot;</span>:<span class="stringliteral">&quot; (Program: &quot;</span>+command+<span class="stringliteral">&quot;)&quot;</span>));
<a name="l00764"></a>00764                 mainMenu.get_item(name).set_text(str.c_str()).refresh_item(mainMenu);
<a name="l00765"></a>00765     }
<a name="l00766"></a>00766     <span class="keywordflow">catch</span> (<span class="keyword">const</span> SaveState::Error&amp; err)
<a name="l00767"></a>00767     {
<a name="l00768"></a>00768         notifyError(err);
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770 }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772 <span class="keywordtype">void</span> LoadGameState(<span class="keywordtype">bool</span> pressed) {
<a name="l00773"></a>00773     <span class="keywordflow">if</span> (!pressed) <span class="keywordflow">return</span>;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <span class="comment">//    if (SaveState::instance().isEmpty(currentSlot))</span>
<a name="l00776"></a>00776 <span class="comment">//    {</span>
<a name="l00777"></a>00777 <span class="comment">//        LOG_MSG(&quot;[%s]: State %d is empty!&quot;, getTime().c_str(), currentSlot + 1);</span>
<a name="l00778"></a>00778 <span class="comment">//        return;</span>
<a name="l00779"></a>00779 <span class="comment">//    }</span>
<a name="l00780"></a>00780     <span class="keywordflow">try</span>
<a name="l00781"></a>00781     {
<a name="l00782"></a>00782         SaveState::instance().load(currentSlot);
<a name="l00783"></a>00783         LOG_MSG(<span class="stringliteral">&quot;[%s]: State %d loaded!&quot;</span>, getTime().c_str(), (<span class="keywordtype">int</span>)currentSlot + 1);
<a name="l00784"></a>00784     }
<a name="l00785"></a>00785     <span class="keywordflow">catch</span> (<span class="keyword">const</span> SaveState::Error&amp; err)
<a name="l00786"></a>00786     {
<a name="l00787"></a>00787         notifyError(err);
<a name="l00788"></a>00788     }
<a name="l00789"></a>00789 }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 <span class="keywordtype">void</span> NextSaveSlot(<span class="keywordtype">bool</span> pressed) {
<a name="l00792"></a>00792     <span class="keywordflow">if</span> (!pressed) <span class="keywordflow">return</span>;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         <span class="keywordtype">char</span> name[6]=<span class="stringliteral">&quot;slot0&quot;</span>;
<a name="l00795"></a>00795         name[4]=<span class="charliteral">&#39;0&#39;</span>+currentSlot;
<a name="l00796"></a>00796         mainMenu.get_item(name).check(<span class="keyword">false</span>).refresh_item(mainMenu);
<a name="l00797"></a>00797     currentSlot.next();
<a name="l00798"></a>00798         name[4]=<span class="charliteral">&#39;0&#39;</span>+currentSlot;
<a name="l00799"></a>00799         mainMenu.get_item(name).check(<span class="keyword">true</span>).refresh_item(mainMenu);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801     <span class="keyword">const</span> <span class="keywordtype">bool</span> emptySlot = SaveState::instance().isEmpty(currentSlot);
<a name="l00802"></a>00802     LOG_MSG(<span class="stringliteral">&quot;Active save slot: %d %s&quot;</span>, (<span class="keywordtype">int</span>)currentSlot + 1, emptySlot ? <span class="stringliteral">&quot;[Empty]&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00803"></a>00803 }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="keywordtype">void</span> PreviousSaveSlot(<span class="keywordtype">bool</span> pressed) {
<a name="l00807"></a>00807     <span class="keywordflow">if</span> (!pressed) <span class="keywordflow">return</span>;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809         <span class="keywordtype">char</span> name[6]=<span class="stringliteral">&quot;slot0&quot;</span>;
<a name="l00810"></a>00810         name[4]=<span class="charliteral">&#39;0&#39;</span>+currentSlot;
<a name="l00811"></a>00811         mainMenu.get_item(name).check(<span class="keyword">false</span>).refresh_item(mainMenu);
<a name="l00812"></a>00812     currentSlot.previous();
<a name="l00813"></a>00813         name[4]=<span class="charliteral">&#39;0&#39;</span>+currentSlot;
<a name="l00814"></a>00814         mainMenu.get_item(name).check(<span class="keyword">true</span>).refresh_item(mainMenu);
<a name="l00815"></a>00815 
<a name="l00816"></a>00816     <span class="keyword">const</span> <span class="keywordtype">bool</span> emptySlot = SaveState::instance().isEmpty(currentSlot);
<a name="l00817"></a>00817     LOG_MSG(<span class="stringliteral">&quot;Active save slot: %d %s&quot;</span>, (<span class="keywordtype">int</span>)currentSlot + 1, emptySlot ? <span class="stringliteral">&quot;[Empty]&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 std::string GetPlatform(<span class="keywordtype">void</span>) {
<a name="l00822"></a>00822         <span class="keywordtype">char</span> platform[30];
<a name="l00823"></a>00823         strcpy(platform, 
<a name="l00824"></a>00824 #<span class="keywordflow">if</span> defined(WIN32)
<a name="l00825"></a>00825         <span class="stringliteral">&quot;Windows&quot;</span>
<a name="l00826"></a>00826 #elif defined(LINUX)
<a name="l00827"></a>00827         <span class="stringliteral">&quot;Linux&quot;</span>
<a name="l00828"></a>00828 #elif unix
<a name="l00829"></a>00829     <span class="stringliteral">&quot;Unix&quot;</span>
<a name="l00830"></a>00830 #elif defined(MACOSX)
<a name="l00831"></a>00831     <span class="stringliteral">&quot;macOS&quot;</span>
<a name="l00832"></a>00832 #<span class="keywordflow">else</span>
<a name="l00833"></a>00833     <span class="stringliteral">&quot;Other&quot;</span>
<a name="l00834"></a>00834 #endif
<a name="l00835"></a>00835 );
<a name="l00836"></a>00836 <span class="preprocessor">#if defined(_M_X64) || defined (_M_AMD64) || defined (_M_ARM64)</span>
<a name="l00837"></a>00837 <span class="preprocessor"></span>        strcat(platform, <span class="stringliteral">&quot; 64&quot;</span>);
<a name="l00838"></a>00838 <span class="preprocessor">#else</span>
<a name="l00839"></a>00839 <span class="preprocessor"></span>        strcat(platform, <span class="stringliteral">&quot; 32&quot;</span>);
<a name="l00840"></a>00840 <span class="preprocessor">#endif</span>
<a name="l00841"></a>00841 <span class="preprocessor"></span>        strcat(platform, <span class="stringliteral">&quot;-bit build&quot;</span>);
<a name="l00842"></a>00842         <span class="keywordflow">return</span> std::string(platform);
<a name="l00843"></a>00843 }
<a name="l00844"></a>00844 
<a name="l00845"></a>00845 <span class="keywordtype">size_t</span> GetGameState_Run(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> GetGameState(); }
<a name="l00846"></a>00846 <span class="keywordtype">void</span> SetGameState_Run(<span class="keywordtype">int</span> value) { SetGameState(value); }
<a name="l00847"></a>00847 <span class="keywordtype">void</span> SaveGameState_Run(<span class="keywordtype">void</span>) { SaveGameState(<span class="keyword">true</span>); }
<a name="l00848"></a>00848 <span class="keywordtype">void</span> LoadGameState_Run(<span class="keywordtype">void</span>) { LoadGameState(<span class="keyword">true</span>); }
<a name="l00849"></a>00849 <span class="keywordtype">void</span> NextSaveSlot_Run(<span class="keywordtype">void</span>) { NextSaveSlot(<span class="keyword">true</span>); }
<a name="l00850"></a>00850 <span class="keywordtype">void</span> PreviousSaveSlot_Run(<span class="keywordtype">void</span>) { PreviousSaveSlot(<span class="keyword">true</span>); }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852 <span class="comment">/* TODO: move to utility header */</span>
<a name="l00853"></a>00853 <span class="preprocessor">#ifdef _MSC_VER </span><span class="comment">/* Microsoft C++ does not have strtoull */</span>
<a name="l00854"></a>00854 <span class="preprocessor"># if _MSC_VER &lt; 1800 </span><span class="comment">/* But Visual Studio 2013 apparently does (http://www.vogons.org/viewtopic.php?f=41&amp;t=31881&amp;sid=49ff69ebc0459ed6523f5a250daa4d8c&amp;start=400#p355770) */</span>
<a name="l00855"></a>00855 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> strtoull(<span class="keyword">const</span> <span class="keywordtype">char</span> *s,<span class="keywordtype">char</span> **endptr,<span class="keywordtype">int</span> base) {
<a name="l00856"></a>00856     <span class="keywordflow">return</span> _strtoui64(s,endptr,base); <span class="comment">/* pfff... whatever Microsoft */</span>
<a name="l00857"></a>00857 }
<a name="l00858"></a>00858 <span class="preprocessor"># endif</span>
<a name="l00859"></a>00859 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span>
<a name="l00861"></a>00861 <span class="comment">/* utility function. rename as appropriate and move to utility collection */</span>
<a name="l00862"></a>00862 <span class="keywordtype">void</span> parse_busclk_setting_str(<a class="code" href="classClockDomain.html">ClockDomain</a> *cd,<span class="keyword">const</span> <span class="keywordtype">char</span> *s) {
<a name="l00863"></a>00863     <span class="keyword">const</span> <span class="keywordtype">char</span> *d;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865     <span class="comment">/* we&#39;re expecting an integer, a float, or an integer ratio */</span>
<a name="l00866"></a>00866     d = strchr(s,<span class="charliteral">&#39;/&#39;</span>);
<a name="l00867"></a>00867     <span class="keywordflow">if</span> (d != NULL) { <span class="comment">/* it has a slash therefore an integer ratio */</span>
<a name="l00868"></a>00868         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> num,den;
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         <span class="keywordflow">while</span> (*d == <span class="charliteral">&#39; &#39;</span> || *d == <span class="charliteral">&#39;/&#39;</span>) d++;
<a name="l00871"></a>00871         num = strtoull(s,NULL,0);
<a name="l00872"></a>00872         den = strtoull(d,NULL,0);
<a name="l00873"></a>00873         <span class="keywordflow">if</span> (num &gt;= 1ULL &amp;&amp; den &gt;= 1ULL) cd-&gt;set_frequency(num,den);
<a name="l00874"></a>00874     }
<a name="l00875"></a>00875     <span class="keywordflow">else</span> {
<a name="l00876"></a>00876         d = strchr(s,<span class="charliteral">&#39;.&#39;</span>);
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (d != NULL) { <span class="comment">/* it has a dot, floating point */</span>
<a name="l00878"></a>00878             <span class="keywordtype">double</span> f = atof(s);
<a name="l00879"></a>00879             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fi = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)floor((f*1000000)+0.5);
<a name="l00880"></a>00880             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> den = 1000000;
<a name="l00881"></a>00881 
<a name="l00882"></a>00882             <span class="keywordflow">while</span> (den &gt; 1ULL) {
<a name="l00883"></a>00883                 <span class="keywordflow">if</span> ((fi%10ULL) == 0) {
<a name="l00884"></a>00884                     den /= 10ULL;
<a name="l00885"></a>00885                     fi /= 10ULL;
<a name="l00886"></a>00886                 }
<a name="l00887"></a>00887                 <span class="keywordflow">else</span> {
<a name="l00888"></a>00888                     <span class="keywordflow">break</span>;
<a name="l00889"></a>00889                 }
<a name="l00890"></a>00890             }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892             <span class="keywordflow">if</span> (fi &gt;= 1ULL) cd-&gt;set_frequency(fi,den);
<a name="l00893"></a>00893         }
<a name="l00894"></a>00894         <span class="keywordflow">else</span> {
<a name="l00895"></a>00895             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> f = strtoull(s,NULL,10);
<a name="l00896"></a>00896             <span class="keywordflow">if</span> (f &gt;= 1ULL) cd-&gt;set_frequency(f,1);
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899 }
<a name="l00900"></a>00900 
<a name="l00901"></a>00901 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dosbox_shell_env_size = 0;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903 <span class="keywordtype">void</span> Null_Init(<a class="code" href="classSection.html">Section</a> *sec) {
<a name="l00904"></a>00904         (void)sec;
<a name="l00905"></a>00905 }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="keyword">extern</span> Bit8u cga_comp;
<a name="l00908"></a>00908 <span class="keyword">extern</span> <span class="keywordtype">bool</span> new_cga;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910 <span class="keywordtype">bool</span> dpi_aware_enable = <span class="keyword">true</span>;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912 std::string dosbox_title;
<a name="l00913"></a>00913 
<a name="l00914"></a>00914 <span class="keywordtype">void</span> DOSBOX_InitTickLoop() {
<a name="l00915"></a>00915     <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;Initializing tick loop management&quot;</span>);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     ticksRemain = 0;
<a name="l00918"></a>00918     ticksLocked = <span class="keyword">false</span>;
<a name="l00919"></a>00919     ticksLastRTtime = 0;
<a name="l00920"></a>00920     ticksLast = GetTicks();
<a name="l00921"></a>00921     ticksLastRTcounter = GetTicks();
<a name="l00922"></a>00922     ticksLastFramecounter = GetTicks();
<a name="l00923"></a>00923     DOSBOX_SetLoop(&amp;Normal_Loop);
<a name="l00924"></a>00924 }
<a name="l00925"></a>00925 
<a name="l00926"></a>00926 <span class="keywordtype">void</span> Init_VGABIOS() {
<a name="l00927"></a>00927     <a class="code" href="classSection__prop.html">Section_prop</a> *section = <span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00928"></a>00928     assert(section != NULL);
<a name="l00929"></a>00929 
<a name="l00930"></a>00930     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00931"></a>00931         <span class="comment">// There IS no VGA BIOS, this is PC-98 mode!</span>
<a name="l00932"></a>00932         VGA_BIOS_SEG = 0xC000;
<a name="l00933"></a>00933         VGA_BIOS_SEG_END = 0xC000; <span class="comment">// Important: DOS kernel uses this to determine where to place the private area!</span>
<a name="l00934"></a>00934         VGA_BIOS_Size = 0;
<a name="l00935"></a>00935         <span class="keywordflow">return</span>;
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938     <span class="comment">// log</span>
<a name="l00939"></a>00939     <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;Init_VGABIOS: Initializing VGA BIOS and parsing it&#39;s settings&quot;</span>);
<a name="l00940"></a>00940 
<a name="l00941"></a>00941     <span class="comment">// mem init must have already happened.</span>
<a name="l00942"></a>00942     <span class="comment">// We can remove this once the device callout system is in place.</span>
<a name="l00943"></a>00943     assert(MemBase != NULL);
<a name="l00944"></a>00944 
<a name="l00945"></a>00945     force_nocachedir = section-&gt;Get_bool(<span class="stringliteral">&quot;nocachedir&quot;</span>);
<a name="l00946"></a>00946         freesizecap = section-&gt;Get_bool(<span class="stringliteral">&quot;freesizecap&quot;</span>);
<a name="l00947"></a>00947     wpcolon = section-&gt;Get_bool(<span class="stringliteral">&quot;leading colon write protect image&quot;</span>);
<a name="l00948"></a>00948 
<a name="l00949"></a>00949     VGA_BIOS_Size_override = (Bitu)section-&gt;Get_int(<span class="stringliteral">&quot;vga bios size override&quot;</span>);
<a name="l00950"></a>00950     <span class="keywordflow">if</span> (VGA_BIOS_Size_override &gt; 0) VGA_BIOS_Size_override = (VGA_BIOS_Size_override+0x7FFU)&amp;(~0xFFFU);
<a name="l00951"></a>00951 
<a name="l00952"></a>00952     VGA_BIOS_dont_duplicate_CGA_first_half = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios dont duplicate cga first half rom font&quot;</span>);
<a name="l00953"></a>00953     VIDEO_BIOS_always_carry_14_high_font = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios always offer 14-pixel high rom font&quot;</span>);
<a name="l00954"></a>00954     VIDEO_BIOS_always_carry_16_high_font = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios always offer 16-pixel high rom font&quot;</span>);
<a name="l00955"></a>00955     VIDEO_BIOS_enable_CGA_8x8_second_half = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios enable cga second half rom font&quot;</span>);
<a name="l00956"></a>00956     <span class="comment">/* NTS: mainline compatible mapping demands the 8x8 CGA font */</span>
<a name="l00957"></a>00957     rom_bios_8x8_cga_font = section-&gt;Get_bool(<span class="stringliteral">&quot;rom bios 8x8 CGA font&quot;</span>);
<a name="l00958"></a>00958     rom_bios_vptable_enable = section-&gt;Get_bool(<span class="stringliteral">&quot;rom bios video parameter table&quot;</span>);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     <span class="comment">/* sanity check */</span>
<a name="l00961"></a>00961     <span class="keywordflow">if</span> (VGA_BIOS_dont_duplicate_CGA_first_half &amp;&amp; !rom_bios_8x8_cga_font) <span class="comment">/* can&#39;t point at the BIOS copy if it&#39;s not there */</span>
<a name="l00962"></a>00962         VGA_BIOS_dont_duplicate_CGA_first_half = <span class="keyword">false</span>;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     <span class="keywordflow">if</span> (VGA_BIOS_Size_override &gt;= 512 &amp;&amp; VGA_BIOS_Size_override &lt;= 65536)
<a name="l00965"></a>00965         VGA_BIOS_Size = (VGA_BIOS_Size_override + 0x7FFU) &amp; (~0xFFFU);
<a name="l00966"></a>00966     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_VGA_ARCH) {
<a name="l00967"></a>00967         <span class="keywordflow">if</span> (svgaCard == SVGA_S3Trio)
<a name="l00968"></a>00968             VGA_BIOS_Size = 0x4000;
<a name="l00969"></a>00969         <span class="keywordflow">else</span>
<a name="l00970"></a>00970             VGA_BIOS_Size = 0x4000; <span class="comment">// FIXME: Why does 0x3800 cause Windows 3.0 386 enhanced mode to hang?</span>
<a name="l00971"></a>00971     }
<a name="l00972"></a>00972     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (machine == MCH_EGA) {
<a name="l00973"></a>00973         <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font)
<a name="l00974"></a>00974             VGA_BIOS_Size = 0x3000;
<a name="l00975"></a>00975         <span class="keywordflow">else</span>
<a name="l00976"></a>00976             VGA_BIOS_Size = 0x2000;
<a name="l00977"></a>00977     }
<a name="l00978"></a>00978     <span class="keywordflow">else</span> {
<a name="l00979"></a>00979         <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font &amp;&amp; VIDEO_BIOS_always_carry_14_high_font)
<a name="l00980"></a>00980             VGA_BIOS_Size = 0x3000;
<a name="l00981"></a>00981         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font || VIDEO_BIOS_always_carry_14_high_font)
<a name="l00982"></a>00982             VGA_BIOS_Size = 0x2000;
<a name="l00983"></a>00983         <span class="keywordflow">else</span>
<a name="l00984"></a>00984             VGA_BIOS_Size = 0;
<a name="l00985"></a>00985     }
<a name="l00986"></a>00986     VGA_BIOS_SEG = 0xC000;
<a name="l00987"></a>00987     VGA_BIOS_SEG_END = (VGA_BIOS_SEG + (VGA_BIOS_Size &gt;&gt; 4));
<a name="l00988"></a>00988 
<a name="l00989"></a>00989     <span class="comment">/* clear for VGA BIOS (FIXME: Why does Project Angel like our BIOS when we memset() here, but don&#39;t like it if we memset() in the INT 10 ROM setup routine?) */</span>
<a name="l00990"></a>00990     <span class="keywordflow">if</span> (VGA_BIOS_Size != 0)
<a name="l00991"></a>00991         memset((<span class="keywordtype">char</span>*)MemBase+0xC0000,0x00,VGA_BIOS_Size);
<a name="l00992"></a>00992 }
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <span class="keywordtype">void</span> SetCyclesCount_mapper_shortcut(<span class="keywordtype">bool</span> pressed);
<a name="l00995"></a>00995 <span class="keywordtype">void</span> DOSBOX_RealInit() {
<a name="l00996"></a>00996     <a class="code" href="classDOSBoxMenu_1_1item.html">DOSBoxMenu::item</a> *item;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998     <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;DOSBOX_RealInit: loading settings and initializing&quot;</span>);
<a name="l00999"></a>00999 
<a name="l01000"></a>01000     MAPPER_AddHandler(DOSBOX_UnlockSpeed, MK_rightarrow, MMODHOST,<span class="stringliteral">&quot;speedlock&quot;</span>,<span class="stringliteral">&quot;Speedlock&quot;</span>);
<a name="l01001"></a>01001     {
<a name="l01002"></a>01002         MAPPER_AddHandler(DOSBOX_UnlockSpeed2, MK_nothing, 0, <span class="stringliteral">&quot;speedlock2&quot;</span>, <span class="stringliteral">&quot;Speedlock2&quot;</span>, &amp;item);
<a name="l01003"></a>01003         item-&gt;set_description(<span class="stringliteral">&quot;Toggle emulation speed, to allow running faster than realtime (fast forward)&quot;</span>);
<a name="l01004"></a>01004         item-&gt;set_text(<span class="stringliteral">&quot;Turbo (Fast Forward)&quot;</span>);
<a name="l01005"></a>01005     }
<a name="l01006"></a>01006     {
<a name="l01007"></a>01007         MAPPER_AddHandler(DOSBOX_NormalSpeed, MK_leftarrow, MMODHOST, <span class="stringliteral">&quot;speednorm&quot;</span>,<span class="stringliteral">&quot;SpeedNrm&quot;</span>, &amp;item);
<a name="l01008"></a>01008         item-&gt;set_description(<span class="stringliteral">&quot;Restore normal emulation speed&quot;</span>);
<a name="l01009"></a>01009         item-&gt;set_text(<span class="stringliteral">&quot;Normal speed&quot;</span>);
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011     {
<a name="l01012"></a>01012         MAPPER_AddHandler(DOSBOX_SpeedUp, MK_rbracket, MMODHOST, <span class="stringliteral">&quot;speedup&quot;</span>,<span class="stringliteral">&quot;SpeedUp&quot;</span>, &amp;item);
<a name="l01013"></a>01013         item-&gt;set_text(<span class="stringliteral">&quot;Speed up&quot;</span>);
<a name="l01014"></a>01014     }
<a name="l01015"></a>01015     {
<a name="l01016"></a>01016         MAPPER_AddHandler(DOSBOX_SlowDown, MK_lbracket, MMODHOST,<span class="stringliteral">&quot;slowdown&quot;</span>,<span class="stringliteral">&quot;SlowDn&quot;</span>, &amp;item);
<a name="l01017"></a>01017         item-&gt;set_text(<span class="stringliteral">&quot;Slow down&quot;</span>);
<a name="l01018"></a>01018     }
<a name="l01019"></a>01019         {
<a name="l01020"></a>01020                 MAPPER_AddHandler(&amp;SetCyclesCount_mapper_shortcut, MK_nothing, 0, <span class="stringliteral">&quot;editcycles&quot;</span>, <span class="stringliteral">&quot;EditCycles&quot;</span>, &amp;item);
<a name="l01021"></a>01021                 item-&gt;set_text(<span class="stringliteral">&quot;Edit cycles&quot;</span>);
<a name="l01022"></a>01022         }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         <span class="comment">//add support for loading/saving game states</span>
<a name="l01025"></a>01025         MAPPER_AddHandler(SaveGameState, MK_f9, MMOD1|MMOD2,<span class="stringliteral">&quot;savestate&quot;</span>,<span class="stringliteral">&quot;SaveState&quot;</span>, &amp;item);
<a name="l01026"></a>01026         item-&gt;set_text(<span class="stringliteral">&quot;Save state&quot;</span>);
<a name="l01027"></a>01027         MAPPER_AddHandler(LoadGameState, MK_f10, MMOD1|MMOD2,<span class="stringliteral">&quot;loadstate&quot;</span>,<span class="stringliteral">&quot;LoadState&quot;</span>, &amp;item);
<a name="l01028"></a>01028         item-&gt;set_text(<span class="stringliteral">&quot;Load state&quot;</span>);
<a name="l01029"></a>01029         MAPPER_AddHandler(PreviousSaveSlot, MK_f7, MMOD1|MMOD2,<span class="stringliteral">&quot;prevslot&quot;</span>,<span class="stringliteral">&quot;PrevSlot&quot;</span>, &amp;item);
<a name="l01030"></a>01030         item-&gt;set_text(<span class="stringliteral">&quot;Previous slot&quot;</span>);
<a name="l01031"></a>01031         MAPPER_AddHandler(NextSaveSlot, MK_f8, MMOD1|MMOD2,<span class="stringliteral">&quot;nextslot&quot;</span>,<span class="stringliteral">&quot;NextSlot&quot;</span>, &amp;item);
<a name="l01032"></a>01032         item-&gt;set_text(<span class="stringliteral">&quot;Next slot&quot;</span>);
<a name="l01033"></a>01033 
<a name="l01034"></a>01034     <a class="code" href="classSection__prop.html">Section_prop</a> *section = <span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l01035"></a>01035     assert(section != NULL);
<a name="l01036"></a>01036 
<a name="l01037"></a>01037     <span class="comment">// TODO: allow change at any time. in fact if it were possible for DOSBox-X configuration</span>
<a name="l01038"></a>01038     <span class="comment">//       schema code to attach event callbacks when a setting changes, we would set one</span>
<a name="l01039"></a>01039     <span class="comment">//       on the title= setting now to auto-update the titlebar when this changes.</span>
<a name="l01040"></a>01040     dosbox_title = section-&gt;Get_string(<span class="stringliteral">&quot;title&quot;</span>);
<a name="l01041"></a>01041 
<a name="l01042"></a>01042     <span class="comment">// TODO: these should be parsed by DOS kernel at startup</span>
<a name="l01043"></a>01043     dosbox_shell_env_size = (<span class="keywordtype">unsigned</span> int)section-&gt;Get_int(<span class="stringliteral">&quot;shell environment size&quot;</span>);
<a name="l01044"></a>01044 
<a name="l01045"></a>01045     <span class="comment">// TODO: a bit of a challenge: if we put it in the ROM area as mainline DOSBox does then the init</span>
<a name="l01046"></a>01046     <span class="comment">//       needs to read this from the BIOS where it can map the memory appropriately. if the allocation</span>
<a name="l01047"></a>01047     <span class="comment">//       is dynamic and the private area is down at the base of memory like real DOS, then the BIOS</span>
<a name="l01048"></a>01048     <span class="comment">//       should ignore it and the DOS kernel should parse it. If we&#39;re going to put it into upper</span>
<a name="l01049"></a>01049     <span class="comment">//       areas as well, then we should also consider making it look like adapter ROM at startup</span>
<a name="l01050"></a>01050     <span class="comment">//       so it can be enumerated properly by DOS programs scanning the ROM area.</span>
<a name="l01051"></a>01051     <span class="comment">/* private area size param in bytes. round up to nearest paragraph */</span>
<a name="l01052"></a>01052     DOS_PRIVATE_SEGMENT_Size = (Bitu)((section-&gt;Get_int(<span class="stringliteral">&quot;private area size&quot;</span>) + 8) / 16);
<a name="l01053"></a>01053 
<a name="l01054"></a>01054     <span class="comment">// TODO: these should be parsed by BIOS startup</span>
<a name="l01055"></a>01055     allow_more_than_640kb = section-&gt;Get_bool(<span class="stringliteral">&quot;allow more than 640kb base memory&quot;</span>);
<a name="l01056"></a>01056 
<a name="l01057"></a>01057     <span class="comment">// TODO: should be parsed by motherboard emulation</span>
<a name="l01058"></a>01058     allow_port_92_reset = section-&gt;Get_bool(<span class="stringliteral">&quot;allow port 92 reset&quot;</span>);
<a name="l01059"></a>01059 
<a name="l01060"></a>01060     <span class="comment">// CGA/EGA/VGA-specific</span>
<a name="l01061"></a>01061     <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> vga_p3da_undefined_bits;
<a name="l01062"></a>01062     vga_p3da_undefined_bits = (<span class="keywordtype">unsigned</span> char)section-&gt;Get_hex(<span class="stringliteral">&quot;vga 3da undefined bits&quot;</span>);
<a name="l01063"></a>01063 
<a name="l01064"></a>01064     <span class="comment">// TODO: should be parsed by motherboard emulation or lower level equiv..?</span>
<a name="l01065"></a>01065     std::string cmd_machine;
<a name="l01066"></a>01066     <span class="keywordflow">if</span> (control-&gt;cmdline-&gt;FindString(<span class="stringliteral">&quot;-machine&quot;</span>,cmd_machine,<span class="keyword">true</span>)){
<a name="l01067"></a>01067         <span class="comment">//update value in config (else no matching against suggested values</span>
<a name="l01068"></a>01068         section-&gt;HandleInputline(std::string(<span class="stringliteral">&quot;machine=&quot;</span>) + cmd_machine);
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071     <span class="comment">// TODO: should be parsed by...? perhaps at some point we support machine= for backwards compat</span>
<a name="l01072"></a>01072     <span class="comment">//       but translate it into two separate params that specify what machine vs what video hardware.</span>
<a name="l01073"></a>01073     <span class="comment">//       or better yet as envisioned, a possible dosbox-x.conf schema that allows a machine with no</span>
<a name="l01074"></a>01074     <span class="comment">//       base video of it&#39;s own, and then to specify an ISA or PCI card attached to the bus that</span>
<a name="l01075"></a>01075     <span class="comment">//       provides video.</span>
<a name="l01076"></a>01076     std::string mtype(section-&gt;Get_string(<span class="stringliteral">&quot;machine&quot;</span>));
<a name="l01077"></a>01077     svgaCard = SVGA_None;
<a name="l01078"></a>01078     machine = MCH_VGA;
<a name="l01079"></a>01079     int10.vesa_nolfb = <span class="keyword">false</span>;
<a name="l01080"></a>01080     int10.vesa_oldvbe = <span class="keyword">false</span>;
<a name="l01081"></a>01081     <span class="keywordflow">if</span>      (mtype == <span class="stringliteral">&quot;cga&quot;</span>)           { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; }
<a name="l01082"></a>01082     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_mono&quot;</span>)      { machine = MCH_CGA; mono_cga = <span class="keyword">true</span>; }
<a name="l01083"></a>01083     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_rgb&quot;</span>)       { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 2; }
<a name="l01084"></a>01084     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_composite&quot;</span>) { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 1; new_cga = <span class="keyword">false</span>; }
<a name="l01085"></a>01085     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_composite2&quot;</span>){ machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 1; new_cga = <span class="keyword">true</span>; }
<a name="l01086"></a>01086     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;mcga&quot;</span>)          { machine = MCH_MCGA; }
<a name="l01087"></a>01087     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;tandy&quot;</span>)         { machine = MCH_TANDY; }
<a name="l01088"></a>01088     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pcjr&quot;</span>)          { machine = MCH_PCJR; }
<a name="l01089"></a>01089     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;hercules&quot;</span>)      { machine = MCH_HERC; }
<a name="l01090"></a>01090     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;mda&quot;</span>)           { machine = MCH_MDA; }
<a name="l01091"></a>01091     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;ega&quot;</span>)           { machine = MCH_EGA; }
<a name="l01092"></a>01092     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_s3&quot;</span>)       { svgaCard = SVGA_S3Trio; }
<a name="l01093"></a>01093     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vesa_nolfb&quot;</span>)    { svgaCard = SVGA_S3Trio; int10.vesa_nolfb = <span class="keyword">true</span>;}
<a name="l01094"></a>01094     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vesa_oldvbe&quot;</span>)   { svgaCard = SVGA_S3Trio; int10.vesa_oldvbe = <span class="keyword">true</span>;}
<a name="l01095"></a>01095     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_et4000&quot;</span>)   { svgaCard = SVGA_TsengET4K; }
<a name="l01096"></a>01096     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_et3000&quot;</span>)   { svgaCard = SVGA_TsengET3K; }
<a name="l01097"></a>01097     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_paradise&quot;</span>) { svgaCard = SVGA_ParadisePVGA1A; }
<a name="l01098"></a>01098     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vgaonly&quot;</span>)       { svgaCard = SVGA_None; }
<a name="l01099"></a>01099     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;amstrad&quot;</span>)       { machine = MCH_AMSTRAD; }
<a name="l01100"></a>01100     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc98&quot;</span>)          { machine = MCH_PC98; }
<a name="l01101"></a>01101     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc9801&quot;</span>)        { machine = MCH_PC98; } <span class="comment">/* Future differentiation */</span>
<a name="l01102"></a>01102     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc9821&quot;</span>)        { machine = MCH_PC98; } <span class="comment">/* Future differentiation */</span>
<a name="l01103"></a>01103 
<a name="l01104"></a>01104     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;fm_towns&quot;</span>)      { machine = MCH_VGA; want_fm_towns = <span class="keyword">true</span>; <span class="comment">/*machine = MCH_FM_TOWNS;*/</span> }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     <span class="keywordflow">else</span> E_Exit(<span class="stringliteral">&quot;DOSBOX:Unknown machine type %s&quot;</span>,mtype.c_str());
<a name="l01107"></a>01107 
<a name="l01108"></a>01108     <span class="comment">// TODO: should be parsed by motherboard emulation</span>
<a name="l01109"></a>01109     <span class="comment">// FIXME: This re-uses the existing ISA bus delay code for C-BUS in PC-98 mode</span>
<a name="l01110"></a>01110     std::string isabclk;
<a name="l01111"></a>01111 
<a name="l01112"></a>01112     <span class="keywordflow">if</span> (IS_PC98_ARCH)
<a name="l01113"></a>01113         isabclk = section-&gt;Get_string(<span class="stringliteral">&quot;cbus bus clock&quot;</span>);
<a name="l01114"></a>01114     <span class="keywordflow">else</span>
<a name="l01115"></a>01115         isabclk = section-&gt;Get_string(<span class="stringliteral">&quot;isa bus clock&quot;</span>);
<a name="l01116"></a>01116 
<a name="l01117"></a>01117     <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std10&quot;</span>)
<a name="l01118"></a>01118         clockdom_ISA_BCLK.set_frequency(PIT_TICK_RATE_PC98_10MHZ * 4ul,1);          <span class="comment">/* 10Mhz (PC-98) */</span>
<a name="l01119"></a>01119     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std8.3&quot;</span>)
<a name="l01120"></a>01120         clockdom_ISA_BCLK.set_frequency(25000000,3);    <span class="comment">/* 25MHz / 3 = 8.333MHz, early 386 systems did this, became an industry standard &quot;norm&quot; afterwards */</span>
<a name="l01121"></a>01121     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std8&quot;</span>) {
<a name="l01122"></a>01122         <span class="keywordflow">if</span> (IS_PC98_ARCH)
<a name="l01123"></a>01123             clockdom_ISA_BCLK.set_frequency(PIT_TICK_RATE_PC98_8MHZ * 4ul,1);       <span class="comment">/* 8Mhz (PC-98) */</span>
<a name="l01124"></a>01124         <span class="keywordflow">else</span>
<a name="l01125"></a>01125             clockdom_ISA_BCLK.set_frequency(8000000,1);                             <span class="comment">/* 8Mhz (IBM PC) */</span>
<a name="l01126"></a>01126     }
<a name="l01127"></a>01127     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std6&quot;</span>)
<a name="l01128"></a>01128         clockdom_ISA_BCLK.set_frequency(6000000,1);     <span class="comment">/* 6MHz */</span>
<a name="l01129"></a>01129     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std5&quot;</span>)
<a name="l01130"></a>01130         clockdom_ISA_BCLK.set_frequency(PIT_TICK_RATE_PC98_10MHZ * 2ul,1);          <span class="comment">/* 5Mhz (PC-98) */</span>
<a name="l01131"></a>01131     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std4.77&quot;</span>)
<a name="l01132"></a>01132         clockdom_ISA_BCLK.set_frequency(clockdom_ISA_OSC.freq,clockdom_ISA_OSC.freq_div*3LL); <span class="comment">/* 14.31818MHz / 3 = 4.77MHz */</span>
<a name="l01133"></a>01133     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc10&quot;</span>)
<a name="l01134"></a>01134         clockdom_ISA_BCLK.set_frequency(10000000,1);    <span class="comment">/* 10MHz */</span>
<a name="l01135"></a>01135     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc12&quot;</span>)
<a name="l01136"></a>01136         clockdom_ISA_BCLK.set_frequency(12000000,1);    <span class="comment">/* 12MHz */</span>
<a name="l01137"></a>01137     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc15&quot;</span>)
<a name="l01138"></a>01138         clockdom_ISA_BCLK.set_frequency(15000000,1);    <span class="comment">/* 15MHz */</span>
<a name="l01139"></a>01139     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc16&quot;</span>)
<a name="l01140"></a>01140         clockdom_ISA_BCLK.set_frequency(16000000,1);    <span class="comment">/* 16MHz */</span>
<a name="l01141"></a>01141     <span class="keywordflow">else</span>
<a name="l01142"></a>01142         parse_busclk_setting_str(&amp;clockdom_ISA_BCLK,isabclk.c_str());
<a name="l01143"></a>01143 
<a name="l01144"></a>01144     std::string pcibclk = section-&gt;Get_string(<span class="stringliteral">&quot;pci bus clock&quot;</span>);
<a name="l01145"></a>01145     <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std33.3&quot;</span>)
<a name="l01146"></a>01146         clockdom_PCI_BCLK.set_frequency(100000000,3);   <span class="comment">/* 100MHz / 3 = 33.333MHz, VERY common PCI speed */</span>
<a name="l01147"></a>01147     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std30&quot;</span>)
<a name="l01148"></a>01148         clockdom_PCI_BCLK.set_frequency(30000000,1);    <span class="comment">/* 30Mhz */</span>
<a name="l01149"></a>01149     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std25&quot;</span>)
<a name="l01150"></a>01150         clockdom_PCI_BCLK.set_frequency(25000000,1);    <span class="comment">/* 25MHz */</span>
<a name="l01151"></a>01151     <span class="keywordflow">else</span>
<a name="l01152"></a>01152         parse_busclk_setting_str(&amp;clockdom_PCI_BCLK,pcibclk.c_str());
<a name="l01153"></a>01153 
<a name="l01154"></a>01154     LOG_MSG(<span class="stringliteral">&quot;%s BCLK: %.3fHz (%llu/%llu)&quot;</span>,
<a name="l01155"></a>01155         IS_PC98_ARCH ? <span class="stringliteral">&quot;C-BUS&quot;</span> : <span class="stringliteral">&quot;ISA&quot;</span>,
<a name="l01156"></a>01156         (<span class="keywordtype">double</span>)clockdom_ISA_BCLK.freq / clockdom_ISA_BCLK.freq_div,
<a name="l01157"></a>01157         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)clockdom_ISA_BCLK.freq,
<a name="l01158"></a>01158         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)clockdom_ISA_BCLK.freq_div);
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     clockdom_ISA_OSC.set_name(<span class="stringliteral">&quot;ISA OSC&quot;</span>);
<a name="l01161"></a>01161     clockdom_ISA_BCLK.set_name(<span class="stringliteral">&quot;ISA BCLK&quot;</span>);
<a name="l01162"></a>01162     clockdom_PCI_BCLK.set_name(<span class="stringliteral">&quot;PCI BCLK&quot;</span>);
<a name="l01163"></a>01163 
<a name="l01164"></a>01164     <span class="comment">// FM TOWNS is stub so far. According to sources like Wikipedia though,</span>
<a name="l01165"></a>01165     <span class="comment">// it boots from DOS in ROM that then loads bootcode from CD-ROM. So</span>
<a name="l01166"></a>01166     <span class="comment">// for now, allow booting into FM TOWNS mode with a warning. The</span>
<a name="l01167"></a>01167     <span class="comment">// switch to FM Towns will begin in the BOOT command with a flag to</span>
<a name="l01168"></a>01168     <span class="comment">// indicate the ISO is intended for FM TOwns.</span>
<a name="l01169"></a>01169     <span class="keywordflow">if</span> (IS_FM_TOWNS || want_fm_towns) LOG_MSG(<span class="stringliteral">&quot;FM Towns emulation not yet implemented. It&#39;s currently just a stub for future development.&quot;</span>);
<a name="l01170"></a>01170 }
<a name="l01171"></a>01171 
<a name="l01172"></a>01172 <span class="keywordtype">void</span> DOSBOX_SetupConfigSections(<span class="keywordtype">void</span>) {
<a name="l01173"></a>01173     <a class="code" href="classProp__int.html">Prop_int</a>* Pint;
<a name="l01174"></a>01174     <a class="code" href="classProp__hex.html">Prop_hex</a>* Phex;
<a name="l01175"></a>01175     <a class="code" href="classProp__bool.html">Prop_bool</a>* Pbool;
<a name="l01176"></a>01176     <a class="code" href="classProp__string.html">Prop_string</a>* Pstring;
<a name="l01177"></a>01177     <a class="code" href="classProp__double.html">Prop_double</a>* Pdouble;
<a name="l01178"></a>01178     <a class="code" href="classProp__multival.html">Prop_multival</a>* Pmulti;
<a name="l01179"></a>01179     <a class="code" href="classSection__prop.html">Section_prop</a> * secprop;
<a name="l01180"></a>01180     <a class="code" href="classProp__multival__remain.html">Prop_multival_remain</a>* Pmulti_remain;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182     <span class="comment">// Some frequently used option sets</span>
<a name="l01183"></a>01183     <span class="keyword">const</span> <span class="keywordtype">char</span>* vsyncrate[] = { <span class="stringliteral">&quot;%u&quot;</span>, 0 };
<a name="l01184"></a>01184     <span class="keyword">const</span> <span class="keywordtype">char</span>* force[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;forced&quot;</span>, 0 };
<a name="l01185"></a>01185     <span class="keyword">const</span> <span class="keywordtype">char</span>* cyclest[] = { <span class="stringliteral">&quot;auto&quot;</span>,<span class="stringliteral">&quot;fixed&quot;</span>,<span class="stringliteral">&quot;max&quot;</span>,<span class="stringliteral">&quot;%u&quot;</span>,0 };
<a name="l01186"></a>01186     <span class="keyword">const</span> <span class="keywordtype">char</span>* mputypes[] = { <span class="stringliteral">&quot;intelligent&quot;</span>, <span class="stringliteral">&quot;uart&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0 };
<a name="l01187"></a>01187     <span class="keyword">const</span> <span class="keywordtype">char</span>* vsyncmode[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span> ,<span class="stringliteral">&quot;force&quot;</span>, <span class="stringliteral">&quot;host&quot;</span>, 0 };
<a name="l01188"></a>01188     <span class="keyword">const</span> <span class="keywordtype">char</span>* captureformats[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;avi-zmbv&quot;</span>, <span class="stringliteral">&quot;mpegts-h264&quot;</span>, 0 };
<a name="l01189"></a>01189     <span class="keyword">const</span> <span class="keywordtype">char</span>* blocksizes[] = {<span class="stringliteral">&quot;1024&quot;</span>, <span class="stringliteral">&quot;2048&quot;</span>, <span class="stringliteral">&quot;4096&quot;</span>, <span class="stringliteral">&quot;8192&quot;</span>, <span class="stringliteral">&quot;512&quot;</span>, <span class="stringliteral">&quot;256&quot;</span>, 0};
<a name="l01190"></a>01190     <span class="keyword">const</span> <span class="keywordtype">char</span>* capturechromaformats[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;4:4:4&quot;</span>, <span class="stringliteral">&quot;4:2:2&quot;</span>, <span class="stringliteral">&quot;4:2:0&quot;</span>, 0};
<a name="l01191"></a>01191     <span class="keyword">const</span> <span class="keywordtype">char</span>* controllertypes[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;at&quot;</span>, <span class="stringliteral">&quot;xt&quot;</span>, <span class="stringliteral">&quot;pcjr&quot;</span>, <span class="stringliteral">&quot;pc98&quot;</span>, 0}; <span class="comment">// Future work: Tandy(?) and USB</span>
<a name="l01192"></a>01192     <span class="keyword">const</span> <span class="keywordtype">char</span>* auxdevices[] = {<span class="stringliteral">&quot;none&quot;</span>,<span class="stringliteral">&quot;2button&quot;</span>,<span class="stringliteral">&quot;3button&quot;</span>,<span class="stringliteral">&quot;intellimouse&quot;</span>,<span class="stringliteral">&quot;intellimouse45&quot;</span>,0};
<a name="l01193"></a>01193     <span class="keyword">const</span> <span class="keywordtype">char</span>* cputype_values[] = {<span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;8086&quot;</span>, <span class="stringliteral">&quot;8086_prefetch&quot;</span>, <span class="stringliteral">&quot;80186&quot;</span>, <span class="stringliteral">&quot;80186_prefetch&quot;</span>, <span class="stringliteral">&quot;286&quot;</span>, <span class="stringliteral">&quot;286_prefetch&quot;</span>, <span class="stringliteral">&quot;386&quot;</span>, <span class="stringliteral">&quot;386_prefetch&quot;</span>, <span class="stringliteral">&quot;486old&quot;</span>, <span class="stringliteral">&quot;486old_prefetch&quot;</span>, <span class="stringliteral">&quot;486&quot;</span>, <span class="stringliteral">&quot;486_prefetch&quot;</span>, <span class="stringliteral">&quot;pentium&quot;</span>, <span class="stringliteral">&quot;pentium_mmx&quot;</span>, <span class="stringliteral">&quot;ppro_slow&quot;</span>, 0};
<a name="l01194"></a>01194     <span class="keyword">const</span> <span class="keywordtype">char</span>* rates[] = {  <span class="stringliteral">&quot;44100&quot;</span>, <span class="stringliteral">&quot;48000&quot;</span>, <span class="stringliteral">&quot;32000&quot;</span>,<span class="stringliteral">&quot;22050&quot;</span>, <span class="stringliteral">&quot;16000&quot;</span>, <span class="stringliteral">&quot;11025&quot;</span>, <span class="stringliteral">&quot;8000&quot;</span>, <span class="stringliteral">&quot;49716&quot;</span>, 0 };
<a name="l01195"></a>01195     <span class="keyword">const</span> <span class="keywordtype">char</span>* oplrates[] = {   <span class="stringliteral">&quot;44100&quot;</span>, <span class="stringliteral">&quot;49716&quot;</span>, <span class="stringliteral">&quot;48000&quot;</span>, <span class="stringliteral">&quot;32000&quot;</span>,<span class="stringliteral">&quot;22050&quot;</span>, <span class="stringliteral">&quot;16000&quot;</span>, <span class="stringliteral">&quot;11025&quot;</span>, <span class="stringliteral">&quot;8000&quot;</span>, 0 };
<a name="l01196"></a>01196 <span class="preprocessor">#ifdef C_FLUIDSYNTH</span>
<a name="l01197"></a>01197 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">char</span>* devices[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;win32&quot;</span>, <span class="stringliteral">&quot;alsa&quot;</span>, <span class="stringliteral">&quot;oss&quot;</span>, <span class="stringliteral">&quot;coreaudio&quot;</span>, <span class="stringliteral">&quot;coremidi&quot;</span>, <span class="stringliteral">&quot;mt32&quot;</span>, <span class="stringliteral">&quot;synth&quot;</span>, <span class="stringliteral">&quot;fluidsynth&quot;</span>, <span class="stringliteral">&quot;timidity&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0};
<a name="l01198"></a>01198 <span class="preprocessor">#else</span>
<a name="l01199"></a>01199 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">char</span>* devices[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;win32&quot;</span>, <span class="stringliteral">&quot;alsa&quot;</span>, <span class="stringliteral">&quot;oss&quot;</span>, <span class="stringliteral">&quot;coreaudio&quot;</span>, <span class="stringliteral">&quot;coremidi&quot;</span>, <span class="stringliteral">&quot;mt32&quot;</span>, <span class="stringliteral">&quot;timidity&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0}; <span class="comment">// FIXME: add some way to offer the actually available choices.</span>
<a name="l01200"></a>01200 <span class="preprocessor">#endif</span>
<a name="l01201"></a>01201 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">char</span>* apmbiosversions[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;1.0&quot;</span>, <span class="stringliteral">&quot;1.1&quot;</span>, <span class="stringliteral">&quot;1.2&quot;</span>, 0 };
<a name="l01202"></a>01202     <span class="keyword">const</span> <span class="keywordtype">char</span>* driveletters[] = { <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;d&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;g&quot;</span>, <span class="stringliteral">&quot;h&quot;</span>, <span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;j&quot;</span>, <span class="stringliteral">&quot;k&quot;</span>, <span class="stringliteral">&quot;l&quot;</span>, <span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;n&quot;</span>, <span class="stringliteral">&quot;o&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;q&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>, <span class="stringliteral">&quot;s&quot;</span>, <span class="stringliteral">&quot;t&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;v&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot;y&quot;</span>, <span class="stringliteral">&quot;z&quot;</span>, 0};
<a name="l01203"></a>01203     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32log[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l01204"></a>01204     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32thread[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l01205"></a>01205     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32ReverseStereo[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l01206"></a>01206     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32DACModes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>,0};
<a name="l01207"></a>01207     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbModes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>,0};
<a name="l01208"></a>01208     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbTimes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>,0};
<a name="l01209"></a>01209     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbLevels[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>,0};
<a name="l01210"></a>01210     <span class="keyword">const</span> <span class="keywordtype">char</span>* gustypes[] = { <span class="stringliteral">&quot;classic&quot;</span>, <span class="stringliteral">&quot;classic37&quot;</span>, <span class="stringliteral">&quot;max&quot;</span>, <span class="stringliteral">&quot;interwave&quot;</span>, 0 };
<a name="l01211"></a>01211     <span class="keyword">const</span> <span class="keywordtype">char</span>* sbtypes[] = { <span class="stringliteral">&quot;sb1&quot;</span>, <span class="stringliteral">&quot;sb2&quot;</span>, <span class="stringliteral">&quot;sbpro1&quot;</span>, <span class="stringliteral">&quot;sbpro2&quot;</span>, <span class="stringliteral">&quot;sb16&quot;</span>, <span class="stringliteral">&quot;sb16vibra&quot;</span>, <span class="stringliteral">&quot;gb&quot;</span>, <span class="stringliteral">&quot;ess688&quot;</span>, <span class="stringliteral">&quot;reveal_sc400&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0 };
<a name="l01212"></a>01212     <span class="keyword">const</span> <span class="keywordtype">char</span>* oplmodes[]={ <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;cms&quot;</span>, <span class="stringliteral">&quot;opl2&quot;</span>, <span class="stringliteral">&quot;dualopl2&quot;</span>, <span class="stringliteral">&quot;opl3&quot;</span>, <span class="stringliteral">&quot;opl3gold&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, <span class="stringliteral">&quot;hardware&quot;</span>, <span class="stringliteral">&quot;hardwaregb&quot;</span>, 0};
<a name="l01213"></a>01213     <span class="keyword">const</span> <span class="keywordtype">char</span>* serials[] = { <span class="stringliteral">&quot;dummy&quot;</span>, <span class="stringliteral">&quot;disabled&quot;</span>, <span class="stringliteral">&quot;modem&quot;</span>, <span class="stringliteral">&quot;nullmodem&quot;</span>, <span class="stringliteral">&quot;serialmouse&quot;</span>, <span class="stringliteral">&quot;directserial&quot;</span>, <span class="stringliteral">&quot;log&quot;</span>, <span class="stringliteral">&quot;file&quot;</span>, 0 };
<a name="l01214"></a>01214     <span class="keyword">const</span> <span class="keywordtype">char</span>* acpi_rsd_ptr_settings[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;bios&quot;</span>, <span class="stringliteral">&quot;ebda&quot;</span>, 0 };
<a name="l01215"></a>01215     <span class="keyword">const</span> <span class="keywordtype">char</span>* cpm_compat_modes[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;msdos2&quot;</span>, <span class="stringliteral">&quot;msdos5&quot;</span>, <span class="stringliteral">&quot;direct&quot;</span>, 0 };
<a name="l01216"></a>01216     <span class="keyword">const</span> <span class="keywordtype">char</span>* dosv_settings[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;japanese&quot;</span>, <span class="stringliteral">&quot;chinese&quot;</span>, <span class="stringliteral">&quot;korean&quot;</span>, 0 };
<a name="l01217"></a>01217     <span class="keyword">const</span> <span class="keywordtype">char</span>* acpisettings[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;1.0&quot;</span>, <span class="stringliteral">&quot;1.0b&quot;</span>, <span class="stringliteral">&quot;2.0&quot;</span>, <span class="stringliteral">&quot;2.0a&quot;</span>, <span class="stringliteral">&quot;2.0b&quot;</span>, <span class="stringliteral">&quot;2.0c&quot;</span>, <span class="stringliteral">&quot;3.0&quot;</span>, <span class="stringliteral">&quot;3.0a&quot;</span>, <span class="stringliteral">&quot;3.0b&quot;</span>, <span class="stringliteral">&quot;4.0&quot;</span>, <span class="stringliteral">&quot;4.0a&quot;</span>, <span class="stringliteral">&quot;5.0&quot;</span>, <span class="stringliteral">&quot;5.0a&quot;</span>, <span class="stringliteral">&quot;6.0&quot;</span>, 0 };
<a name="l01218"></a>01218     <span class="keyword">const</span> <span class="keywordtype">char</span>* guspantables[] = { <span class="stringliteral">&quot;old&quot;</span>, <span class="stringliteral">&quot;accurate&quot;</span>, <span class="stringliteral">&quot;default&quot;</span>, 0 };
<a name="l01219"></a>01219     <span class="keyword">const</span> <span class="keywordtype">char</span> *sidbaseno[] = { <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>, <span class="stringliteral">&quot;300&quot;</span>, 0 };
<a name="l01220"></a>01220     <span class="keyword">const</span> <span class="keywordtype">char</span>* joytypes[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;2axis&quot;</span>, <span class="stringliteral">&quot;4axis&quot;</span>, <span class="stringliteral">&quot;4axis_2&quot;</span>, <span class="stringliteral">&quot;fcs&quot;</span>, <span class="stringliteral">&quot;ch&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>,0};
<a name="l01221"></a>01221 <span class="comment">//    const char* joydeadzone[] = { &quot;0.26&quot;, 0 };</span>
<a name="l01222"></a>01222 <span class="comment">//    const char* joyresponse[] = { &quot;1.0&quot;, 0 };</span>
<a name="l01223"></a>01223     <span class="keyword">const</span> <span class="keywordtype">char</span>* iosgus[] = { <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>, <span class="stringliteral">&quot;300&quot;</span>, <span class="stringliteral">&quot;210&quot;</span>, <span class="stringliteral">&quot;230&quot;</span>, <span class="stringliteral">&quot;250&quot;</span>, 0 };
<a name="l01224"></a>01224     <span class="keyword">const</span> <span class="keywordtype">char</span>* mpubases[] = {
<a name="l01225"></a>01225         <span class="stringliteral">&quot;0&quot;</span>,                                                                                    <span class="comment">/* Auto */</span>
<a name="l01226"></a>01226         <span class="stringliteral">&quot;300&quot;</span>, <span class="stringliteral">&quot;310&quot;</span>, <span class="stringliteral">&quot;320&quot;</span>, <span class="stringliteral">&quot;330&quot;</span>, <span class="stringliteral">&quot;332&quot;</span>, <span class="stringliteral">&quot;334&quot;</span>, <span class="stringliteral">&quot;336&quot;</span>, <span class="stringliteral">&quot;340&quot;</span>, <span class="stringliteral">&quot;360&quot;</span>,                          <span class="comment">/* IBM PC */</span>
<a name="l01227"></a>01227         <span class="stringliteral">&quot;c0d0&quot;</span>,<span class="stringliteral">&quot;c8d0&quot;</span>,<span class="stringliteral">&quot;d0d0&quot;</span>,<span class="stringliteral">&quot;d8d0&quot;</span>,<span class="stringliteral">&quot;e0d0&quot;</span>,<span class="stringliteral">&quot;e8d0&quot;</span>,<span class="stringliteral">&quot;f0d0&quot;</span>,<span class="stringliteral">&quot;f8d0&quot;</span>,                                <span class="comment">/* NEC PC-98 MPU98 */</span>
<a name="l01228"></a>01228         <span class="stringliteral">&quot;80d2&quot;</span>,<span class="stringliteral">&quot;80d4&quot;</span>,<span class="stringliteral">&quot;80d6&quot;</span>,<span class="stringliteral">&quot;80d8&quot;</span>,<span class="stringliteral">&quot;80da&quot;</span>,<span class="stringliteral">&quot;80dc&quot;</span>,<span class="stringliteral">&quot;80de&quot;</span>,                                       <span class="comment">/* NEC PC-98 SB16 */</span>
<a name="l01229"></a>01229         0 };
<a name="l01230"></a>01230     <span class="keyword">const</span> <span class="keywordtype">char</span>* ios[] = {
<a name="l01231"></a>01231         <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>,            <span class="comment">/* IBM PC      (base+port i.e. 220h base, 22Ch is DSP) */</span>
<a name="l01232"></a>01232         <span class="stringliteral">&quot;d2&quot;</span>,  <span class="stringliteral">&quot;d4&quot;</span>,  <span class="stringliteral">&quot;d6&quot;</span>,  <span class="stringliteral">&quot;d8&quot;</span>,  <span class="stringliteral">&quot;da&quot;</span>,  <span class="stringliteral">&quot;dc&quot;</span>,  <span class="stringliteral">&quot;de&quot;</span>,             <span class="comment">/* NEC PC-98   (base+(port &lt;&lt; 8) i.e. 00D2h base, 2CD2h is DSP) */</span>
<a name="l01233"></a>01233         0 };
<a name="l01234"></a>01234     <span class="keyword">const</span> <span class="keywordtype">char</span>* ems_settings[] = { <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;emsboard&quot;</span>, <span class="stringliteral">&quot;emm386&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, 0};
<a name="l01235"></a>01235     <span class="keyword">const</span> <span class="keywordtype">char</span>* lfn_settings[] = { <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;autostart&quot;</span>, 0};
<a name="l01236"></a>01236     <span class="keyword">const</span> <span class="keywordtype">char</span>* irqsgus[] = { <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;9&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>, <span class="stringliteral">&quot;11&quot;</span>, <span class="stringliteral">&quot;12&quot;</span>, 0 };
<a name="l01237"></a>01237     <span class="keyword">const</span> <span class="keywordtype">char</span>* irqssb[] = { <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;9&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>, <span class="stringliteral">&quot;11&quot;</span>, <span class="stringliteral">&quot;12&quot;</span>, 0 };
<a name="l01238"></a>01238     <span class="keyword">const</span> <span class="keywordtype">char</span>* dmasgus[] = { <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, 0 };
<a name="l01239"></a>01239     <span class="keyword">const</span> <span class="keywordtype">char</span>* dmassb[] = { <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, 0 };
<a name="l01240"></a>01240     <span class="keyword">const</span> <span class="keywordtype">char</span>* oplemus[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;compat&quot;</span>, <span class="stringliteral">&quot;fast&quot;</span>, <span class="stringliteral">&quot;nuked&quot;</span>, <span class="stringliteral">&quot;mame&quot;</span>, 0 };
<a name="l01241"></a>01241     <span class="keyword">const</span> <span class="keywordtype">char</span> *qualityno[] = { <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, 0 };
<a name="l01242"></a>01242     <span class="keyword">const</span> <span class="keywordtype">char</span>* tandys[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, 0};
<a name="l01243"></a>01243     <span class="keyword">const</span> <span class="keywordtype">char</span>* ps1opt[] = { <span class="stringliteral">&quot;on&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, 0};
<a name="l01244"></a>01244     <span class="keyword">const</span> <span class="keywordtype">char</span>* numopt[] = { <span class="stringliteral">&quot;on&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, 0};
<a name="l01245"></a>01245     <span class="keyword">const</span> <span class="keywordtype">char</span>* truefalseautoopt[] = { <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>, 0};
<a name="l01246"></a>01246     <span class="keyword">const</span> <span class="keywordtype">char</span>* pc98fmboards[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;board14&quot;</span>, <span class="stringliteral">&quot;board26k&quot;</span>, <span class="stringliteral">&quot;board86&quot;</span>, <span class="stringliteral">&quot;board86c&quot;</span>, 0};
<a name="l01247"></a>01247     <span class="keyword">const</span> <span class="keywordtype">char</span>* pc98videomodeopt[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;24khz&quot;</span>, <span class="stringliteral">&quot;31khz&quot;</span>, <span class="stringliteral">&quot;15khz&quot;</span>, 0};
<a name="l01248"></a>01248     <span class="keyword">const</span> <span class="keywordtype">char</span>* aspectmodes[] = { <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;yes&quot;</span>, <span class="stringliteral">&quot;no&quot;</span>, <span class="stringliteral">&quot;nearest&quot;</span>, <span class="stringliteral">&quot;bilinear&quot;</span>, 0};
<a name="l01249"></a>01249     <span class="keyword">const</span> <span class="keywordtype">char</span> *vga_ac_mapping_settings[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;4x4&quot;</span>, <span class="stringliteral">&quot;4low&quot;</span>, <span class="stringliteral">&quot;first16&quot;</span>, 0 };
<a name="l01250"></a>01250 
<a name="l01251"></a>01251     <span class="keyword">const</span> <span class="keywordtype">char</span>* irqhandler[] = {
<a name="l01252"></a>01252         <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;simple&quot;</span>, <span class="stringliteral">&quot;cooperative_2nd&quot;</span>, 0 };
<a name="l01253"></a>01253 
<a name="l01254"></a>01254     <span class="comment">/* Setup all the different modules making up DOSBox-X */</span>
<a name="l01255"></a>01255     <span class="keyword">const</span> <span class="keywordtype">char</span>* machines[] = {
<a name="l01256"></a>01256         <span class="stringliteral">&quot;hercules&quot;</span>, <span class="stringliteral">&quot;cga&quot;</span>, <span class="stringliteral">&quot;cga_mono&quot;</span>, <span class="stringliteral">&quot;cga_rgb&quot;</span>, <span class="stringliteral">&quot;cga_composite&quot;</span>, <span class="stringliteral">&quot;cga_composite2&quot;</span>, <span class="stringliteral">&quot;tandy&quot;</span>, <span class="stringliteral">&quot;pcjr&quot;</span>, <span class="stringliteral">&quot;ega&quot;</span>,
<a name="l01257"></a>01257         <span class="stringliteral">&quot;vgaonly&quot;</span>, <span class="stringliteral">&quot;svga_s3&quot;</span>, <span class="stringliteral">&quot;svga_et3000&quot;</span>, <span class="stringliteral">&quot;svga_et4000&quot;</span>,
<a name="l01258"></a>01258         <span class="stringliteral">&quot;svga_paradise&quot;</span>, <span class="stringliteral">&quot;vesa_nolfb&quot;</span>, <span class="stringliteral">&quot;vesa_oldvbe&quot;</span>, <span class="stringliteral">&quot;amstrad&quot;</span>, <span class="stringliteral">&quot;pc98&quot;</span>, <span class="stringliteral">&quot;pc9801&quot;</span>, <span class="stringliteral">&quot;pc9821&quot;</span>,
<a name="l01259"></a>01259 
<a name="l01260"></a>01260         <span class="stringliteral">&quot;fm_towns&quot;</span>, <span class="comment">// STUB</span>
<a name="l01261"></a>01261 
<a name="l01262"></a>01262         <span class="stringliteral">&quot;mcga&quot;</span>, <span class="stringliteral">&quot;mda&quot;</span>,
<a name="l01263"></a>01263 
<a name="l01264"></a>01264         0 };
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <span class="keyword">const</span> <span class="keywordtype">char</span>* scalers[] = { 
<a name="l01267"></a>01267         <span class="stringliteral">&quot;none&quot;</span>, <span class="stringliteral">&quot;normal2x&quot;</span>, <span class="stringliteral">&quot;normal3x&quot;</span>, <span class="stringliteral">&quot;normal4x&quot;</span>, <span class="stringliteral">&quot;normal5x&quot;</span>,
<a name="l01268"></a>01268 <span class="preprocessor">#if RENDER_USE_ADVANCED_SCALERS&gt;2</span>
<a name="l01269"></a>01269 <span class="preprocessor"></span>        <span class="stringliteral">&quot;advmame2x&quot;</span>, <span class="stringliteral">&quot;advmame3x&quot;</span>, <span class="stringliteral">&quot;advinterp2x&quot;</span>, <span class="stringliteral">&quot;advinterp3x&quot;</span>, <span class="stringliteral">&quot;hq2x&quot;</span>, <span class="stringliteral">&quot;hq3x&quot;</span>, <span class="stringliteral">&quot;2xsai&quot;</span>, <span class="stringliteral">&quot;super2xsai&quot;</span>, <span class="stringliteral">&quot;supereagle&quot;</span>,
<a name="l01270"></a>01270 <span class="preprocessor">#endif</span>
<a name="l01271"></a>01271 <span class="preprocessor"></span><span class="preprocessor">#if RENDER_USE_ADVANCED_SCALERS&gt;0</span>
<a name="l01272"></a>01272 <span class="preprocessor"></span>        <span class="stringliteral">&quot;tv2x&quot;</span>, <span class="stringliteral">&quot;tv3x&quot;</span>, <span class="stringliteral">&quot;rgb2x&quot;</span>, <span class="stringliteral">&quot;rgb3x&quot;</span>, <span class="stringliteral">&quot;scan2x&quot;</span>, <span class="stringliteral">&quot;scan3x&quot;</span>, <span class="stringliteral">&quot;gray&quot;</span>, <span class="stringliteral">&quot;gray2x&quot;</span>,
<a name="l01273"></a>01273 <span class="preprocessor">#endif</span>
<a name="l01274"></a>01274 <span class="preprocessor"></span>        <span class="stringliteral">&quot;hardware_none&quot;</span>, <span class="stringliteral">&quot;hardware2x&quot;</span>, <span class="stringliteral">&quot;hardware3x&quot;</span>, <span class="stringliteral">&quot;hardware4x&quot;</span>, <span class="stringliteral">&quot;hardware5x&quot;</span>,
<a name="l01275"></a>01275 <span class="preprocessor">#if C_XBRZ</span>
<a name="l01276"></a>01276 <span class="preprocessor"></span>        <span class="stringliteral">&quot;xbrz&quot;</span>, <span class="stringliteral">&quot;xbrz_bilinear&quot;</span>,
<a name="l01277"></a>01277 <span class="preprocessor">#endif</span>
<a name="l01278"></a>01278 <span class="preprocessor"></span>        0 };
<a name="l01279"></a>01279 
<a name="l01280"></a>01280     <span class="keyword">const</span> <span class="keywordtype">char</span>* cores[] = { <span class="stringliteral">&quot;auto&quot;</span>,
<a name="l01281"></a>01281 <span class="preprocessor">#if (C_DYNAMIC_X86) || (C_DYNREC)</span>
<a name="l01282"></a>01282 <span class="preprocessor"></span>        <span class="stringliteral">&quot;dynamic&quot;</span>,
<a name="l01283"></a>01283 <span class="preprocessor">#endif</span>
<a name="l01284"></a>01284 <span class="preprocessor"></span>        <span class="stringliteral">&quot;normal&quot;</span>, <span class="stringliteral">&quot;full&quot;</span>, <span class="stringliteral">&quot;simple&quot;</span>, 0 };
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     <span class="keyword">const</span> <span class="keywordtype">char</span>* voodoo_settings[] = {
<a name="l01287"></a>01287         <span class="stringliteral">&quot;false&quot;</span>,
<a name="l01288"></a>01288         <span class="stringliteral">&quot;software&quot;</span>,
<a name="l01289"></a>01289 <span class="preprocessor">#if C_OPENGL</span>
<a name="l01290"></a>01290 <span class="preprocessor"></span>        <span class="stringliteral">&quot;opengl&quot;</span>,
<a name="l01291"></a>01291 <span class="preprocessor">#endif</span>
<a name="l01292"></a>01292 <span class="preprocessor"></span>        <span class="stringliteral">&quot;auto&quot;</span>,
<a name="l01293"></a>01293         0
<a name="l01294"></a>01294     };
<a name="l01295"></a>01295 
<a name="l01296"></a>01296 <span class="preprocessor">#if defined(__SSE__) &amp;&amp; !(defined(_M_AMD64) || defined(__e2k__)) &amp;&amp; !defined(EMSCRIPTEN)</span>
<a name="l01297"></a>01297 <span class="preprocessor"></span>    CheckSSESupport();
<a name="l01298"></a>01298 <span class="preprocessor">#endif</span>
<a name="l01299"></a>01299 <span class="preprocessor"></span>    SDLNetInited = <span class="keyword">false</span>;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;dosbox&quot;</span>,&amp;Null_Init);
<a name="l01302"></a>01302     Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;language&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01303"></a>01303     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Select another language file.&quot;</span>);
<a name="l01304"></a>01304 
<a name="l01305"></a>01305     Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;title&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01306"></a>01306     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Additional text to place in the title bar of the window&quot;</span>);
<a name="l01307"></a>01307 
<a name="l01308"></a>01308     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable 8-bit dac&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01309"></a>01309     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow VESA BIOS calls in IBM PC mode to set DAC width. Has no effect in PC-98 mode.&quot;</span>);
<a name="l01310"></a>01310 
<a name="l01311"></a>01311     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dpi aware&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01312"></a>01312     Pstring-&gt;Set_values(truefalseautoopt);
<a name="l01313"></a>01313     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Set this option (auto by default) to indicate to your OS that DOSBox-X is DPI aware.\n&quot;</span>
<a name="l01314"></a>01314             <span class="stringliteral">&quot;If it is not set, Windows Vista/7/8/10 and higher may upscale the DOSBox-X window\n&quot;</span>
<a name="l01315"></a>01315             <span class="stringliteral">&quot;on higher resolution monitors which is probably not what you want.&quot;</span>);
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keyboard hook&quot;</span>, Property::Changeable::Always, <span class="keyword">false</span>);
<a name="l01318"></a>01318     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Use keyboard hook (currently only on Windows) to catch special keys and synchronize the keyboard LEDs with the host&quot;</span>);
<a name="l01319"></a>01319 
<a name="l01320"></a>01320     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01321"></a>01321     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;weitek&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01322"></a>01322     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the Weitek coprocessor. This option only has effect if cputype=386 or cputype=486.&quot;</span>);
<a name="l01323"></a>01323 
<a name="l01324"></a>01324     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;bochs debug port e9&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01325"></a>01325     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate Bochs debug port E9h. ASCII text written to this I/O port is assumed to be debug output, and logged.&quot;</span>);
<a name="l01326"></a>01326 
<a name="l01327"></a>01327     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;machine&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;svga_s3&quot;</span>);
<a name="l01328"></a>01328     Pstring-&gt;Set_values(machines);
<a name="l01329"></a>01329     Pstring-&gt;Set_help(<span class="stringliteral">&quot;The type of machine DOSBox-X tries to emulate.&quot;</span>);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;svga lfb base&quot;</span>, Property::Changeable::OnlyAtStart, 0);
<a name="l01332"></a>01332     Phex-&gt;Set_help(<span class="stringliteral">&quot;If nonzero, define the physical memory address of the linear framebuffer.&quot;</span>);
<a name="l01333"></a>01333 
<a name="l01334"></a>01334     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pci vga&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01335"></a>01335     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, SVGA is emulated as if a PCI device (when enable pci bus=true)&quot;</span>);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemdelay&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01338"></a>01338     Pint-&gt;SetMinMax(-1,100000);
<a name="l01339"></a>01339     Pint-&gt;Set_help( <span class="stringliteral">&quot;VGA Memory I/O delay in nanoseconds. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l01340"></a>01340             <span class="stringliteral">&quot;Default off. Enable this option (-1 or nonzero) if you are running a game or\n&quot;</span>
<a name="l01341"></a>01341             <span class="stringliteral">&quot;demo that needs slower VGA memory (like that of older ISA hardware) to work properly.\n&quot;</span>
<a name="l01342"></a>01342             <span class="stringliteral">&quot;If your game is not sensitive to VGA RAM I/O speed, then turning on this option\n&quot;</span>
<a name="l01343"></a>01343             <span class="stringliteral">&quot;will do nothing but cause a significant drop in frame rate which is probably not\n&quot;</span>
<a name="l01344"></a>01344             <span class="stringliteral">&quot;what you want. Recommended values -1, 0 to 2000.&quot;</span>);
<a name="l01345"></a>01345 
<a name="l01346"></a>01346     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemsize&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01347"></a>01347     Pint-&gt;SetMinMax(-1,16);
<a name="l01348"></a>01348     Pint-&gt;Set_help(
<a name="l01349"></a>01349         <span class="stringliteral">&quot;Amount of video memory in megabytes.\n&quot;</span>
<a name="l01350"></a>01350         <span class="stringliteral">&quot;  The maximum resolution and color depth the svga_s3 will be able to display\n&quot;</span>
<a name="l01351"></a>01351         <span class="stringliteral">&quot;  is determined by this value.\n &quot;</span>
<a name="l01352"></a>01352         <span class="stringliteral">&quot; -1: auto (vmemsizekb is ignored)\n&quot;</span>
<a name="l01353"></a>01353         <span class="stringliteral">&quot;  0: 512k (800x600  at 256 colors) if vmemsizekb=0\n&quot;</span>
<a name="l01354"></a>01354         <span class="stringliteral">&quot;  1: 1024x768  at 256 colors or 800x600  at 64k colors\n&quot;</span>
<a name="l01355"></a>01355         <span class="stringliteral">&quot;  2: 1600x1200 at 256 colors or 1024x768 at 64k colors or 640x480 at 16M colors\n&quot;</span>
<a name="l01356"></a>01356         <span class="stringliteral">&quot;  4: 1600x1200 at 64k colors or 1024x768 at 16M colors\n&quot;</span>
<a name="l01357"></a>01357         <span class="stringliteral">&quot;  8: up to 1600x1200 at 16M colors\n&quot;</span>
<a name="l01358"></a>01358         <span class="stringliteral">&quot;For build engine games, use more memory than in the list above so it can\n&quot;</span>
<a name="l01359"></a>01359         <span class="stringliteral">&quot;use triple buffering and thus won&#39;t flicker.\n&quot;</span>
<a name="l01360"></a>01360         );
<a name="l01361"></a>01361 
<a name="l01362"></a>01362     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemsizekb&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01363"></a>01363     Pint-&gt;SetMinMax(0,1024);
<a name="l01364"></a>01364     Pint-&gt;Set_help(
<a name="l01365"></a>01365         <span class="stringliteral">&quot;Amount of video memory in kilobytes, in addition to vmemsize&quot;</span>);
<a name="l01366"></a>01366 
<a name="l01367"></a>01367     Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;captures&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;capture&quot;</span>);
<a name="l01368"></a>01368     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Directory where things like wave, midi, screenshot get captured.&quot;</span>);
<a name="l01369"></a>01369 
<a name="l01370"></a>01370     <span class="comment">/* will change to default true unless this causes compatibility issues with other users or their editing software */</span>
<a name="l01371"></a>01371     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;skip encoding unchanged frames&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01372"></a>01372     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Unchanged frames will not be sent to the video codec as a possible performance and bandwidth optimization.&quot;</span>);
<a name="l01373"></a>01373 
<a name="l01374"></a>01374     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;capture chroma format&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01375"></a>01375     Pstring-&gt;Set_values(capturechromaformats);
<a name="l01376"></a>01376     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Chroma format to use when capturing to H.264. &#39;auto&#39; picks the best quality option.\n&quot;</span>
<a name="l01377"></a>01377             <span class="stringliteral">&quot;4:4:4       Chroma is at full resolution. This provides the best quality, however not widely supported by editing software.\n&quot;</span>
<a name="l01378"></a>01378             <span class="stringliteral">&quot;4:2:2       Chroma is at half horizontal resolution.\n&quot;</span>
<a name="l01379"></a>01379             <span class="stringliteral">&quot;4:2:0       Chroma is at quarter resolution, which may cause minor color smearing.\n&quot;</span>
<a name="l01380"></a>01380             <span class="stringliteral">&quot;            However, this chroma format is most likely to be compatible with video editing software.&quot;</span>);
<a name="l01381"></a>01381 
<a name="l01382"></a>01382     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;capture format&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l01383"></a>01383     Pstring-&gt;Set_values(captureformats);
<a name="l01384"></a>01384     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Capture format to use when capturing video. The availability of the format depends on how DOSBox-X was compiled.\n&quot;</span>
<a name="l01385"></a>01385             <span class="stringliteral">&quot;default                     Use compiled-in default (avi-zmbv)\n&quot;</span>
<a name="l01386"></a>01386             <span class="stringliteral">&quot;avi-zmbv                    Use DOSBox-style AVI + ZMBV codec with PCM audio\n&quot;</span>
<a name="l01387"></a>01387             <span class="stringliteral">&quot;mpegts-h264                 Use MPEG transport stream + H.264 + AAC audio. Resolution &amp; refresh rate changes can be contained\n&quot;</span>
<a name="l01388"></a>01388             <span class="stringliteral">&quot;                            within one file with this choice, however not all software can support mid-stream format changes.&quot;</span>);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;shell environment size&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l01391"></a>01391     Pint-&gt;SetMinMax(0,65280);
<a name="l01392"></a>01392     Pint-&gt;Set_help(<span class="stringliteral">&quot;Size of the initial DOSBox-X shell environment block, in bytes. This does not affect the environment block of sub-processes spawned from the shell.\n&quot;</span>
<a name="l01393"></a>01393             <span class="stringliteral">&quot;This option has no effect unless dynamic kernel allocation is enabled.&quot;</span>);
<a name="l01394"></a>01394 
<a name="l01395"></a>01395     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;private area size&quot;</span>,Property::Changeable::OnlyAtStart,32768); <span class="comment">// DOSBox mainline compatible 32KB region</span>
<a name="l01396"></a>01396     Pint-&gt;SetMinMax(16,128*1024);
<a name="l01397"></a>01397     Pint-&gt;Set_help(<span class="stringliteral">&quot;Set DOSBox-X private memory area size. This area contains private memory structures used by the DOS kernel.\n&quot;</span>
<a name="l01398"></a>01398             <span class="stringliteral">&quot;It is discarded when you boot into another OS. Mainline DOSBox uses 32KB. Testing shows that it is possible\n&quot;</span>
<a name="l01399"></a>01399             <span class="stringliteral">&quot;to run DOSBox with as little as 4KB. If DOSBox-X aborts with error \&quot;not enough memory for internal tables\&quot;\n&quot;</span>
<a name="l01400"></a>01400             <span class="stringliteral">&quot;then you need to increase this value.&quot;</span>);
<a name="l01401"></a>01401 
<a name="l01402"></a>01402     <span class="comment">// NOTE: This will be revised as I test the DOSLIB code against more VGA/SVGA hardware!</span>
<a name="l01403"></a>01403     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;vga attribute controller mapping&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01404"></a>01404     Pstring-&gt;Set_values(vga_ac_mapping_settings);
<a name="l01405"></a>01405     Pstring-&gt;Set_help(
<a name="l01406"></a>01406             <span class="stringliteral">&quot;This affects how the attribute controller maps colors, especially in 256-color mode.\n&quot;</span>
<a name="l01407"></a>01407             <span class="stringliteral">&quot;Some SVGA cards handle the attribute controller palette differently than most SVGA cards.\n&quot;</span>
<a name="l01408"></a>01408             <span class="stringliteral">&quot;  auto                         Automatically pick the mapping based on the SVGA chipset.\n&quot;</span>
<a name="l01409"></a>01409             <span class="stringliteral">&quot;  4x4                          Split into two 4-bit nibbles, map through AC, recombine. This is standard VGA behavior including clone SVGA cards.\n&quot;</span>
<a name="l01410"></a>01410             <span class="stringliteral">&quot;  4low                         Split into two 4-bit nibbles, remap only the low 4 bits, recombine. This is standard ET4000 behavior.\n&quot;</span>
<a name="l01411"></a>01411             <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01412"></a>01412             <span class="stringliteral">&quot;NOTES:\n&quot;</span>
<a name="l01413"></a>01413             <span class="stringliteral">&quot;  Demoscene executable &#39;COPPER.EXE&#39; requires the &#39;4low&#39; behavior in order to display line-fading effects\n&quot;</span>
<a name="l01414"></a>01414             <span class="stringliteral">&quot;  (including scrolling credits) correctly, else those parts of the demo show up as a blank screen.\n&quot;</span>
<a name="l01415"></a>01415             <span class="stringliteral">&quot;  \n&quot;</span>
<a name="l01416"></a>01416             <span class="stringliteral">&quot;  4low behavior is default for ET4000 emulation.&quot;</span>);
<a name="l01417"></a>01417 
<a name="l01418"></a>01418     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;a20&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;mask&quot;</span>);
<a name="l01419"></a>01419     Pstring-&gt;Set_help(<span class="stringliteral">&quot;A20 gate emulation mode.\n&quot;</span>
<a name="l01420"></a>01420               <span class="stringliteral">&quot;The on/off/on_fake/off_fake options are intended for testing and debugging DOS development,\n&quot;</span>
<a name="l01421"></a>01421               <span class="stringliteral">&quot;or to emulate obscure hardware, or to work around potential extended memory problems with DOS programs.\n&quot;</span>
<a name="l01422"></a>01422               <span class="stringliteral">&quot;on_fake/off_fake are intended to test whether a program carries out a memory test to ensure the A20\n&quot;</span>
<a name="l01423"></a>01423               <span class="stringliteral">&quot;gate is set as intended (as HIMEM.SYS does). If it goes by the gate bit alone, it WILL crash.\n&quot;</span>
<a name="l01424"></a>01424               <span class="stringliteral">&quot;This parameter is also changeable from the builtin A20GATE command.\n&quot;</span>
<a name="l01425"></a>01425               <span class="stringliteral">&quot;  fast                         Emulate A20 gating by remapping the first 64KB @ 1MB boundary (fast, mainline DOSBox behavior)\n&quot;</span>
<a name="l01426"></a>01426               <span class="stringliteral">&quot;  mask                         Emulate A20 gating by masking memory I/O address (accurate)\n&quot;</span>
<a name="l01427"></a>01427               <span class="stringliteral">&quot;  off                          Lock A20 gate off (Software/OS cannot enable A20)\n&quot;</span>
<a name="l01428"></a>01428               <span class="stringliteral">&quot;  on                           Lock A20 gate on (Software/OS cannot disable A20)\n&quot;</span>
<a name="l01429"></a>01429               <span class="stringliteral">&quot;  off_fake                     Lock A20 gate off but allow bit to toggle (hope your DOS game tests the HMA!)\n&quot;</span>
<a name="l01430"></a>01430               <span class="stringliteral">&quot;  on_fake                      Lock A20 gate on but allow bit to toggle&quot;</span>);
<a name="l01431"></a>01431 
<a name="l01432"></a>01432     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;turn off a20 gate on boot&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01433"></a>01433     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If enabled, A20 gate is switched off when booting a guest OS.\n&quot;</span>
<a name="l01434"></a>01434                     <span class="stringliteral">&quot;Enabled by default. Recommended for MS-DOS when HIMEM.SYS is not installed in the guest OS.\n&quot;</span>
<a name="l01435"></a>01435                     <span class="stringliteral">&quot;If disabled, and MS-DOS does not load HIMEM.SYS, programs and features that rely on the 1MB wraparound will fail.&quot;</span>);
<a name="l01436"></a>01436 
<a name="l01437"></a>01437     <span class="comment">/* Ref:</span>
<a name="l01438"></a>01438 <span class="comment">     *</span>
<a name="l01439"></a>01439 <span class="comment">     * &quot;Except the first generation, which C-Bus was synchronous with its 5MHz 8086, PC-98s</span>
<a name="l01440"></a>01440 <span class="comment">     *  before the age of SuperIO and PCI use either 10MHz (9.8304MHz) or 8MHz (7.9872MHz)</span>
<a name="l01441"></a>01441 <span class="comment">     *  for its C-Bus.</span>
<a name="l01442"></a>01442 <span class="comment">     * </span>
<a name="l01443"></a>01443 <span class="comment">     *  It&#39;s determined by the CPU clock base (2.4756Mhz or 1.9968MHz). For example, on a</span>
<a name="l01444"></a>01444 <span class="comment">     *  16MHz 386, C-Bus runs at 8MHz and on a 25MHz 386, C-Bus runs at 10MHz.</span>
<a name="l01445"></a>01445 <span class="comment">     *</span>
<a name="l01446"></a>01446 <span class="comment">     *  After NEC brought SuperIO and PCI to PC-98, C-Bus clock no longer ties to the CPU</span>
<a name="l01447"></a>01447 <span class="comment">     *  oscillator and got fixed to 10MHz.&quot; -Yksoft1</span>
<a name="l01448"></a>01448 <span class="comment">     *</span>
<a name="l01449"></a>01449 <span class="comment">     * Assuming this is true, the selection is given below */</span>
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cbus bus clock&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;std10&quot;</span>);
<a name="l01452"></a>01452     Pstring-&gt;Set_help(<span class="stringliteral">&quot;C-BUS BCLK frequency (PC-98), used to emulate I/O delay.\n&quot;</span>
<a name="l01453"></a>01453               <span class="stringliteral">&quot;WARNING: In future revisions, PCI/motherboard chipset emulation will allow the guest OS/program to alter this value at runtime.\n&quot;</span>
<a name="l01454"></a>01454               <span class="stringliteral">&quot;  std10                        10MHz (CPU speed multiple of 5MHz or PCI-based)\n&quot;</span>
<a name="l01455"></a>01455               <span class="stringliteral">&quot;  std8                         8MHz (CPU speed multiple of 4MHz)\n&quot;</span>
<a name="l01456"></a>01456               <span class="stringliteral">&quot;  std5                         5MHz (older PC-9801)\n&quot;</span>
<a name="l01457"></a>01457               <span class="stringliteral">&quot;  &lt;integer or float&gt;           Any integer or floating point value will be used as the clock frequency in Hz\n&quot;</span>
<a name="l01458"></a>01458               <span class="stringliteral">&quot;  &lt;integer/integer ratio&gt;      If a ratio is given (num/den), the ratio will be used as the clock frequency&quot;</span>);
<a name="l01459"></a>01459 
<a name="l01460"></a>01460     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;isa bus clock&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;std8.3&quot;</span>);
<a name="l01461"></a>01461     Pstring-&gt;Set_help(<span class="stringliteral">&quot;ISA BCLK frequency, used to emulate I/O delay.\n&quot;</span>
<a name="l01462"></a>01462               <span class="stringliteral">&quot;WARNING: In future revisions, PCI/motherboard chipset emulation will allow the guest OS/program to alter this value at runtime.\n&quot;</span>
<a name="l01463"></a>01463               <span class="stringliteral">&quot;  std8.3                       8.333MHz (typical 386-class or higher)\n&quot;</span>
<a name="l01464"></a>01464               <span class="stringliteral">&quot;  std8                         8MHz\n&quot;</span>
<a name="l01465"></a>01465               <span class="stringliteral">&quot;  std6                         6MHz\n&quot;</span>
<a name="l01466"></a>01466               <span class="stringliteral">&quot;  std4.77                      4.77MHz (precisely 1/3 x 14.31818MHz). Bus frequency of older PC/XT systems.\n&quot;</span>
<a name="l01467"></a>01467               <span class="stringliteral">&quot;  oc10                         10MHz\n&quot;</span>
<a name="l01468"></a>01468               <span class="stringliteral">&quot;  oc12                         12MHz\n&quot;</span>
<a name="l01469"></a>01469               <span class="stringliteral">&quot;  oc15                         15MHz\n&quot;</span>
<a name="l01470"></a>01470               <span class="stringliteral">&quot;  oc16                         16MHz\n&quot;</span>
<a name="l01471"></a>01471               <span class="stringliteral">&quot;  &lt;integer or float&gt;           Any integer or floating point value will be used as the clock frequency in Hz\n&quot;</span>
<a name="l01472"></a>01472               <span class="stringliteral">&quot;  &lt;integer/integer ratio&gt;      If a ratio is given (num/den), the ratio will be used as the clock frequency&quot;</span>);
<a name="l01473"></a>01473 
<a name="l01474"></a>01474     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pci bus clock&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;std33.3&quot;</span>);
<a name="l01475"></a>01475     Pstring-&gt;Set_help(<span class="stringliteral">&quot;PCI bus frequency, used to emulate I/O delay.\n&quot;</span>
<a name="l01476"></a>01476               <span class="stringliteral">&quot;WARNING: In future revisions, PCI/motherboard chipset emulation will allow the guest OS/program to alter this value at runtime.\n&quot;</span>
<a name="l01477"></a>01477               <span class="stringliteral">&quot;  std33.3                      33.333MHz (very common setting on motherboards)\n&quot;</span>
<a name="l01478"></a>01478               <span class="stringliteral">&quot;  std30                        30MHz (some older mid-1990&#39;s Pentium systems)\n&quot;</span>
<a name="l01479"></a>01479               <span class="stringliteral">&quot;  std25                        25MHz\n&quot;</span>
<a name="l01480"></a>01480               <span class="stringliteral">&quot;  &lt;integer or float&gt;           Any integer or floating point value will be used as the clock frequency in Hz\n&quot;</span>
<a name="l01481"></a>01481               <span class="stringliteral">&quot;  &lt;integer/integer ratio&gt;      If a ratio is given (num/den), the ratio will be used as the clock frequency&quot;</span>);
<a name="l01482"></a>01482 
<a name="l01483"></a>01483     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;call binary on reset&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01484"></a>01484     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, this is the path of a binary blob to load into the ROM BIOS area and execute immediately after CPU reset.\n&quot;</span>
<a name="l01485"></a>01485                       <span class="stringliteral">&quot;It will be executed before the BIOS POST routine, only ONCE. The binary blob is expected either to IRET or to\n&quot;</span>
<a name="l01486"></a>01486                       <span class="stringliteral">&quot;jump directly to F000:FFF0 to return control to the BIOS.\n&quot;</span>
<a name="l01487"></a>01487                       <span class="stringliteral">&quot;This can be used for x86 assembly language experiments and automated testing against the CPU emulation.&quot;</span>);
<a name="l01488"></a>01488 
<a name="l01489"></a>01489     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;unhandled irq handler&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01490"></a>01490     Pstring-&gt;Set_values(irqhandler);
<a name="l01491"></a>01491     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Determines how unhandled IRQs are handled. This may help some errant DOS applications.\n&quot;</span>
<a name="l01492"></a>01492                       <span class="stringliteral">&quot;Leave unset for default behavior (simple).\n&quot;</span>
<a name="l01493"></a>01493                       <span class="stringliteral">&quot;simple               Acknowledge the IRQ, and the master (if slave IRQ)\n&quot;</span>
<a name="l01494"></a>01494                       <span class="stringliteral">&quot;mask_isr             Acknowledge IRQs in service on master and slave and mask IRQs still in service, to deal with errant handlers (em-dosbox method)&quot;</span>);
<a name="l01495"></a>01495 
<a name="l01496"></a>01496     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;call binary on boot&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01497"></a>01497     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, this is the path of a binary blob to load into the ROM BIOS area and execute immediately before booting the DOS system.\n&quot;</span>
<a name="l01498"></a>01498                       <span class="stringliteral">&quot;This can be used for x86 assembly language experiments and automated testing against the CPU emulation.&quot;</span>);
<a name="l01499"></a>01499 
<a name="l01500"></a>01500     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rom bios allocation max&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l01501"></a>01501     Pint-&gt;SetMinMax(0,128);
<a name="l01502"></a>01502     Pint-&gt;Set_help(<span class="stringliteral">&quot;Maximum size (top down from 1MB) allowed for ROM BIOS dynamic allocation in KB&quot;</span>);
<a name="l01503"></a>01503 
<a name="l01504"></a>01504     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rom bios minimum size&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l01505"></a>01505     Pint-&gt;SetMinMax(0,128);
<a name="l01506"></a>01506     Pint-&gt;Set_help(<span class="stringliteral">&quot;Once ROM BIOS layout is finalized, trim total region down to a minimum amount in KB&quot;</span>);
<a name="l01507"></a>01507 
<a name="l01508"></a>01508     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq delay ns&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01509"></a>01509     Pint-&gt;SetMinMax(-1,100000);
<a name="l01510"></a>01510     Pint-&gt;Set_help( <span class="stringliteral">&quot;IRQ delay in nanoseconds. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l01511"></a>01511                     <span class="stringliteral">&quot;This is a more precise version of the irqdelay= setting.\n&quot;</span>
<a name="l01512"></a>01512                     <span class="stringliteral">&quot;There are some old DOS games and demos that have race conditions with IRQs that need a nonzero value here to work properly.&quot;</span>);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01515"></a>01515     Pint-&gt;SetMinMax(-1,100000);
<a name="l01516"></a>01516     Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay in nanoseconds for I/O port access. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l01517"></a>01517             <span class="stringliteral">&quot;A value of 1000 (1us) is recommended for ISA bus type delays. If your game\n&quot;</span>
<a name="l01518"></a>01518             <span class="stringliteral">&quot;or demo is not sensitive to I/O port and ISA bus timing, you can turn this option off\n&quot;</span>
<a name="l01519"></a>01519             <span class="stringliteral">&quot;(set to 0) to increase game performance.&quot;</span>);
<a name="l01520"></a>01520 
<a name="l01521"></a>01521     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay16&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01522"></a>01522     Pint-&gt;SetMinMax(-1,100000);
<a name="l01523"></a>01523     Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay for 16-bit transfers. -1 to use default, 0 to disable.&quot;</span>);
<a name="l01524"></a>01524 
<a name="l01525"></a>01525     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay32&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01526"></a>01526     Pint-&gt;SetMinMax(-1,100000);
<a name="l01527"></a>01527     Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay for 32-bit transfers. -1 to use default, 0 to disable.&quot;</span>);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01530"></a>01530     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;acpi&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l01531"></a>01531     Pstring-&gt;Set_values(acpisettings);
<a name="l01532"></a>01532     Pstring-&gt;Set_help(<span class="stringliteral">&quot;ACPI emulation, and what version of the specification to follow.\n&quot;</span>
<a name="l01533"></a>01533             <span class="stringliteral">&quot;WARNING: This option is very experimental at this time and should not be enabled unless you&#39;re willing to accept the consequences.\n&quot;</span>
<a name="l01534"></a>01534             <span class="stringliteral">&quot;         Intended for use with ACPI-aware OSes including Linux and Windows 98/ME. This option will also slightly reduce available\n&quot;</span>
<a name="l01535"></a>01535             <span class="stringliteral">&quot;         system memory to make room for the ACPI tables, just as real BIOSes do, and reserve an IRQ for ACPI functions.&quot;</span>);
<a name="l01536"></a>01536 
<a name="l01537"></a>01537     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01538"></a>01538     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;acpi rsd ptr location&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01539"></a>01539     Pstring-&gt;Set_values(acpi_rsd_ptr_settings);
<a name="l01540"></a>01540     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Where to store the Root System Description Pointer structure. You can have it stored in the ROM BIOS area, or the Extended Bios Data Area.&quot;</span>);
<a name="l01541"></a>01541 
<a name="l01542"></a>01542     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01543"></a>01543     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;acpi sci irq&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01544"></a>01544     Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ to assign as ACPI system control interrupt. set to -1 to automatically assign.&quot;</span>);
<a name="l01545"></a>01545 
<a name="l01546"></a>01546     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01547"></a>01547     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;acpi iobase&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l01548"></a>01548     Phex-&gt;Set_help(<span class="stringliteral">&quot;I/O port base for the ACPI device Power Management registers. Set to 0 for automatic assignment.&quot;</span>);
<a name="l01549"></a>01549 
<a name="l01550"></a>01550     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01551"></a>01551     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;acpi reserved size&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01552"></a>01552     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of memory at top to reserve for ACPI structures and tables. Set to 0 for automatic assignment.&quot;</span>);
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 <span class="preprocessor">#if defined(C_EMSCRIPTEN)</span>
<a name="l01555"></a>01555 <span class="preprocessor"></span>    Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memsize&quot;</span>, Property::Changeable::WhenIdle,4);
<a name="l01556"></a>01556 <span class="preprocessor">#else</span>
<a name="l01557"></a>01557 <span class="preprocessor"></span>    Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memsize&quot;</span>, Property::Changeable::WhenIdle,16);
<a name="l01558"></a>01558 <span class="preprocessor">#endif</span>
<a name="l01559"></a>01559 <span class="preprocessor"></span>    Pint-&gt;SetMinMax(1,3584); <span class="comment">// 3.5GB</span>
<a name="l01560"></a>01560     Pint-&gt;Set_help(
<a name="l01561"></a>01561         <span class="stringliteral">&quot;Amount of memory DOSBox-X has in megabytes.\n&quot;</span>
<a name="l01562"></a>01562         <span class="stringliteral">&quot;This value is best left at its default to avoid problems with some games,\n&quot;</span>
<a name="l01563"></a>01563         <span class="stringliteral">&quot;although other games and applications may require a higher value.\n&quot;</span>
<a name="l01564"></a>01564         <span class="stringliteral">&quot;Programs that use 286 protected mode like Windows 3.0 in Standard Mode may crash with more than 15MB.&quot;</span>);
<a name="l01565"></a>01565 
<a name="l01566"></a>01566     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memsizekb&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01567"></a>01567     Pint-&gt;SetMinMax(0,524288);
<a name="l01568"></a>01568     Pint-&gt;Set_help(
<a name="l01569"></a>01569         <span class="stringliteral">&quot;Amount of memory DOSBox-X has in kilobytes.\n&quot;</span>
<a name="l01570"></a>01570         <span class="stringliteral">&quot;This value should normally be set to 0.\n&quot;</span>
<a name="l01571"></a>01571         <span class="stringliteral">&quot;If nonzero, it is added to the memsize parameter.\n&quot;</span>
<a name="l01572"></a>01572         <span class="stringliteral">&quot;Finer grained control of total memory may be useful in\n&quot;</span>
<a name="l01573"></a>01573         <span class="stringliteral">&quot;emulating ancient DOS machines with less than 640KB of\n&quot;</span>
<a name="l01574"></a>01574         <span class="stringliteral">&quot;RAM or early 386 systems with odd extended memory sizes.&quot;</span>);
<a name="l01575"></a>01575 
<a name="l01576"></a>01576     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dos mem limit&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01577"></a>01577     Pint-&gt;SetMinMax(0,1023);
<a name="l01578"></a>01578     Pint-&gt;Set_help( <span class="stringliteral">&quot;Limit DOS conventional memory to this amount. Does not affect extended memory.\n&quot;</span>
<a name="l01579"></a>01579             <span class="stringliteral">&quot;Setting this option to a value in the range 636-639 can be used to simulate modern BIOSes\n&quot;</span>
<a name="l01580"></a>01580             <span class="stringliteral">&quot;that maintain an EBDA (Extended BIOS Data Area) at the top of conventional memory.\n&quot;</span>
<a name="l01581"></a>01581             <span class="stringliteral">&quot;You may also play with this option for diagnostic purposes or to stress test DOS programs in limited memory setups.\n&quot;</span>
<a name="l01582"></a>01582             <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01583"></a>01583             <span class="stringliteral">&quot;A few DOS games &amp; demos require this option to be set:\n&quot;</span>
<a name="l01584"></a>01584             <span class="stringliteral">&quot;     Majic 12 \&quot;Show\&quot;: If UMBs are enabled, set this option to 639 to avoid MCB chain corruption error.&quot;</span>);
<a name="l01585"></a>01585 
<a name="l01586"></a>01586     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;isa memory hole at 512kb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01587"></a>01587     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate an ISA memory hole at the 512KB to 640KB area (0x80000-0x9FFFF).&quot;</span>);
<a name="l01588"></a>01588 
<a name="l01589"></a>01589     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;reboot delay&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01590"></a>01590     Pint-&gt;SetMinMax(-1,10000);
<a name="l01591"></a>01591     Pint-&gt;Set_help(
<a name="l01592"></a>01592         <span class="stringliteral">&quot;Reboot delay. How long to pause at BIOS POST after reboot in milliseconds.\n&quot;</span>
<a name="l01593"></a>01593         <span class="stringliteral">&quot;This option is provided so that it is possible to see what the guest application\n&quot;</span>
<a name="l01594"></a>01594         <span class="stringliteral">&quot;or OS might have written to the screen before resetting the system. A value of\n&quot;</span>
<a name="l01595"></a>01595         <span class="stringliteral">&quot;-1 means to use a reasonable default.&quot;</span>);
<a name="l01596"></a>01596 
<a name="l01597"></a>01597     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memalias&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01598"></a>01598     Pint-&gt;SetMinMax(0,32);
<a name="l01599"></a>01599     Pint-&gt;Set_help(
<a name="l01600"></a>01600         <span class="stringliteral">&quot;Memory aliasing emulation, in number of valid address bits.\n&quot;</span>
<a name="l01601"></a>01601         <span class="stringliteral">&quot;Many 386/486 class motherboards and processors prior to 1995\n&quot;</span>
<a name="l01602"></a>01602         <span class="stringliteral">&quot;suffered from memory aliasing for various technical reasons. If the software you are\n&quot;</span>
<a name="l01603"></a>01603         <span class="stringliteral">&quot;trying to run assumes aliasing, or otherwise plays cheap tricks with paging,\n&quot;</span>
<a name="l01604"></a>01604         <span class="stringliteral">&quot;enabling this option can help. Note that enabling this option can cause slight performance degredation. Set to 0 to disable.\n&quot;</span>
<a name="l01605"></a>01605         <span class="stringliteral">&quot;Recommended values when enabled:\n&quot;</span>
<a name="l01606"></a>01606         <span class="stringliteral">&quot;    24: 16MB aliasing. Common on 386SX systems (CPU had 24 external address bits)\n&quot;</span>
<a name="l01607"></a>01607         <span class="stringliteral">&quot;        or 386DX and 486 systems where the CPU communicated directly with the ISA bus (A24-A31 tied off)\n&quot;</span>
<a name="l01608"></a>01608         <span class="stringliteral">&quot;    26: 64MB aliasing. Some 486s had only 26 external address bits, some motherboards tied off A26-A31&quot;</span>);
<a name="l01609"></a>01609 
<a name="l01610"></a>01610     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;nocachedir&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01611"></a>01611     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, MOUNT commands will mount with -nocachedir by default.&quot;</span>);
<a name="l01612"></a>01612 
<a name="l01613"></a>01613     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;freesizecap&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01614"></a>01614     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the value of MOUNT -freesize will be applied only if the actual free size is greater than the specified value.&quot;</span>);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;leading colon write protect image&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01617"></a>01617     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, BOOT and IMGMOUNT commands will put an image file name with a leading colon (:) in write-protect mode.&quot;</span>);
<a name="l01618"></a>01618 
<a name="l01619"></a>01619     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vga bios size override&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01620"></a>01620     Pint-&gt;SetMinMax(512,65536);
<a name="l01621"></a>01621     Pint-&gt;Set_help(<span class="stringliteral">&quot;VGA BIOS size override. Override the size of the VGA BIOS (normally 32KB in compatible or 12KB in non-compatible).&quot;</span>);
<a name="l01622"></a>01622 
<a name="l01623"></a>01623     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios dont duplicate cga first half rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01624"></a>01624     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, save 4KB of EGA/VGA ROM space by pointing to the copy in the ROM BIOS of the first 128 chars&quot;</span>);
<a name="l01625"></a>01625 
<a name="l01626"></a>01626     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios always offer 14-pixel high rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01627"></a>01627     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, video BIOS will always carry the 14-pixel ROM font. If clear, 14-pixel rom font will not be offered except for EGA/VGA emulation.&quot;</span>);
<a name="l01628"></a>01628 
<a name="l01629"></a>01629     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios always offer 16-pixel high rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01630"></a>01630     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, video BIOS will always carry the 16-pixel ROM font. If clear, 16-pixel rom font will not be offered except for VGA emulation.&quot;</span>);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios enable cga second half rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01633"></a>01633     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, and emulating CGA/PCjr/Tandy, automatically provide the second half of the 8x8 ROM font.\n&quot;</span>
<a name="l01634"></a>01634             <span class="stringliteral">&quot;This setting is ignored for EGA/VGA emulation. If not set, you will need a utility like GRAFTABL.COM to load the second half of the ROM font for graphics.\n&quot;</span>
<a name="l01635"></a>01635             <span class="stringliteral">&quot;NOTE: if you disable the 14 &amp; 16 pixel high font AND the second half when machine=cga, you will disable video bios completely.&quot;</span>);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;forcerate&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01638"></a>01638     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Force the VGA framerate to a specific value(ntsc, pal, or specific hz), no matter what&quot;</span>);
<a name="l01639"></a>01639 
<a name="l01640"></a>01640     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sierra ramdac&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01641"></a>01641     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Whether or not to emulate a Sierra or compatible RAMDAC at port 3C6h-3C9h.\n&quot;</span>
<a name="l01642"></a>01642             <span class="stringliteral">&quot;Some DOS games expect to access port 3C6h to enable highcolor/truecolor SVGA modes on older chipsets.\n&quot;</span>
<a name="l01643"></a>01643             <span class="stringliteral">&quot;Disable if you wish to emulate SVGA hardware that lacks a RAMDAC or (depending on the chipset) does\n&quot;</span>
<a name="l01644"></a>01644             <span class="stringliteral">&quot;not emulate a RAMDAC that is accessible through port 3C6h. This option has no effect for non-VGA video hardware.&quot;</span>);
<a name="l01645"></a>01645 
<a name="l01646"></a>01646     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sierra ramdac lock 565&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01647"></a>01647     Pbool-&gt;Set_help(<span class="stringliteral">&quot;When emulating High Sierra highcolor RAMDAC, assume 5:6:5 at all times if set. Else,\n&quot;</span>
<a name="l01648"></a>01648             <span class="stringliteral">&quot;bit 6 of the DAC command selects between 5:5:5 and 5:6:5. Set this option for demos or\n&quot;</span>
<a name="l01649"></a>01649             <span class="stringliteral">&quot;games that got the command byte wrong (MFX Transgrassion 2) or any other demo that is\n&quot;</span>
<a name="l01650"></a>01650             <span class="stringliteral">&quot;not rendering highcolor 16bpp correctly.&quot;</span>);
<a name="l01651"></a>01651 
<a name="l01652"></a>01652     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;page flip debug line&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01653"></a>01653     Pbool-&gt;Set_help(<span class="stringliteral">&quot;VGA debugging switch. If set, an inverse line will be drawn on the exact scanline that the CRTC display offset registers were written.\n&quot;</span>
<a name="l01654"></a>01654             <span class="stringliteral">&quot;This can be used to help diagnose whether or not the DOS game is page flipping properly according to vertical retrace if the display on-screen is flickering.&quot;</span>);
<a name="l01655"></a>01655 
<a name="l01656"></a>01656     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vertical retrace poll debug line&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01657"></a>01657     Pbool-&gt;Set_help(<span class="stringliteral">&quot;VGA debugging switch. If set, an inverse green dotted line will be drawn on the exact scanline that the CRTC status port (0x3DA) was read.\n&quot;</span>
<a name="l01658"></a>01658             <span class="stringliteral">&quot;This can be used to help diagnose whether the DOS game is propertly waiting for vertical retrace.&quot;</span>);
<a name="l01659"></a>01659 
<a name="l01660"></a>01660     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;cgasnow&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01661"></a>01661     Pbool-&gt;Set_help(<span class="stringliteral">&quot;When machine=cga, determines whether or not to emulate CGA snow in 80x25 text mode&quot;</span>);
<a name="l01662"></a>01662 
<a name="l01663"></a>01663     <span class="comment">/* Default changed to 0x04 for &quot;Blues Brothers&quot; at Allofich&#39;s request [https://github.com/joncampbell123/dosbox-x/issues/1273] */</span>
<a name="l01664"></a>01664     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;vga 3da undefined bits&quot;</span>,Property::Changeable::WhenIdle,0x04);
<a name="l01665"></a>01665     Phex-&gt;Set_help(<span class="stringliteral">&quot;VGA status port 3BA/3DAh only defines bits 0 and 3. This setting allows you to assign a bit pattern to the undefined bits.\n&quot;</span>
<a name="l01666"></a>01666                    <span class="stringliteral">&quot;The purpose of this hack is to deal with demos that read and handle port 3DAh in ways that might crash if all are zero.&quot;</span>);
<a name="l01667"></a>01667 
<a name="l01668"></a>01668     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask timer on int 10 setmode&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01669"></a>01669     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 10h will unmask IRQ 0 (timer) when setting video modes.&quot;</span>);
<a name="l01670"></a>01670 
<a name="l01671"></a>01671     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask keyboard on int 16 read&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01672"></a>01672     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 16h will unmask IRQ 1 (keyboard) when asked to read keyboard input.\n&quot;</span>
<a name="l01673"></a>01673                     <span class="stringliteral">&quot;It is strongly recommended that you set this option if running Windows 3.11 Windows for Workgroups in DOSBox-X.&quot;</span>);
<a name="l01674"></a>01674 
<a name="l01675"></a>01675     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int16 keyboard polling undocumented cf behavior&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01676"></a>01676     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 16h function AH=01h will also set/clear the carry flag depending on whether input was available.\n&quot;</span>
<a name="l01677"></a>01677                     <span class="stringliteral">&quot;There are some old DOS games and demos that rely on this behavior to sense keyboard input, and this behavior\n&quot;</span>
<a name="l01678"></a>01678                     <span class="stringliteral">&quot;has been verified to occur on some old (early 90s) BIOSes.&quot;</span>);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow port 92 reset&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01681"></a>01681     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allow the application to reset the CPU through port 92h&quot;</span>);
<a name="l01682"></a>01682 
<a name="l01683"></a>01683     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable port 92&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01684"></a>01684     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate port 92h (PS/2 system control port A). If you want to emulate a system that pre-dates the PS/2, set to 0.&quot;</span>);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable 1st dma controller&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01687"></a>01687     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate 1st (AT) DMA controller (default). Set to 0 if you wish to emulate a system that lacks DMA (PCjr and some Tandy systems)&quot;</span>);
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable 2nd dma controller&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01690"></a>01690     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate 2nd (AT) DMA controller (default). Set to 0 if you wish to emulate a PC/XT system without 16-bit DMA.\n&quot;</span>
<a name="l01691"></a>01691             <span class="stringliteral">&quot;Note: mainline DOSBox automatically disables 16-bit DMA when machine=cga or machine=hercules, while DOSBox-X does not.&quot;</span>);
<a name="l01692"></a>01692 
<a name="l01693"></a>01693     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow dma address decrement&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01694"></a>01694     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow increment &amp; decrement modes as specified in the 8237 datasheet.\n&quot;</span>
<a name="l01695"></a>01695             <span class="stringliteral">&quot;If clear, always increment the address (as if to emulate clone 8237 implementations that skipped the inc/dec bit).&quot;</span>);
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;enable 128k capable 16-bit dma&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01698"></a>01698     Pstring-&gt;Set_values(truefalseautoopt);
<a name="l01699"></a>01699     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If true, DMA controller emulation models ISA hardware that permits 16-bit DMA to span 128KB.\n&quot;</span>
<a name="l01700"></a>01700                     <span class="stringliteral">&quot;If false, DMA controller emulation models PCI hardware that limits 16-bit DMA to 64KB boundaries.\n&quot;</span>
<a name="l01701"></a>01701                     <span class="stringliteral">&quot;If auto, the choice is made according to other factors in hardware emulation&quot;</span>);
<a name="l01702"></a>01702 
<a name="l01703"></a>01703     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable dma extra page registers&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01704"></a>01704     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the extra page registers (I/O ports 0x80, 0x84-0x86, 0x88, 0x8C-0x8E), like actual hardware.\n&quot;</span>
<a name="l01705"></a>01705             <span class="stringliteral">&quot;Note that mainline DOSBox behavior is to NOT emulate these registers.&quot;</span>);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dma page registers write-only&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01708"></a>01708     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Normally (on AT hardware) the DMA page registers are read/write. Set this option if you want to emulate PC/XT hardware where the page registers are write-only.&quot;</span>);
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;cascade interrupt never in service&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01711"></a>01711     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, PIC emulation will never mark cascade interrupt as in service. This is OFF by default. It is a hack for troublesome games.&quot;</span>);
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     <span class="comment">// TODO: &quot;Special mode&quot; which apparently triggers this alternate behavior and used by default on PC-98, is configurable</span>
<a name="l01714"></a>01714     <span class="comment">//       by software through the PIC control words, and should control this setting if this is &quot;auto&quot;.</span>
<a name="l01715"></a>01715     <span class="comment">//       It&#39;s time for &quot;auto&quot; default setting to end once and for all the running gag that PC-98 games will not run</span>
<a name="l01716"></a>01716     <span class="comment">//       properly without having to add &quot;cascade interrupt ignore in service=true&quot; to your dosbox-x.conf all the time.</span>
<a name="l01717"></a>01717     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cascade interrupt ignore in service&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01718"></a>01718     Pstring-&gt;Set_values(truefalseautoopt);
<a name="l01719"></a>01719     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If true, PIC emulation will allow slave pic interrupts even if the cascade interrupt is still \&quot;in service\&quot; (common PC-98 behavior)\n&quot;</span>
<a name="l01720"></a>01720                     <span class="stringliteral">&quot;If false, PIC emulation will consider cascade in-service state when deciding which interrupt to signal (common IBM PC behavior)\n&quot;</span>
<a name="l01721"></a>01721                     <span class="stringliteral">&quot;If auto, setting is chosen based on machine type and other configuration.&quot;</span>);
<a name="l01722"></a>01722 
<a name="l01723"></a>01723     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable slave pic&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01724"></a>01724     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable slave PIC (IRQ 8-15). Set this to 0 if you want to emulate a PC/XT type arrangement with IRQ 0-7 and no IRQ 2 cascade.&quot;</span>);
<a name="l01725"></a>01725 
<a name="l01726"></a>01726     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pc nmi mask&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01727"></a>01727     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PC/XT style NMI mask register (0xA0). Note that this option conflicts with the secondary PIC and will be ignored if the slave PIC is enabled.&quot;</span>);
<a name="l01728"></a>01728 
<a name="l01729"></a>01729     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;rom bios 8x8 CGA font&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01730"></a>01730     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, or mainline DOSBox compatible BIOS mapping, a legacy 8x8 CGA font (first 128 characters) is stored at 0xF000:0xFA6E. DOS programs that do not use INT 10h to locate fonts might require that font to be located there.&quot;</span>);
<a name="l01731"></a>01731 
<a name="l01732"></a>01732     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;rom bios video parameter table&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01733"></a>01733     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, or mainline DOSBox compatible BIOS mapping, DOSBox-X will emulate the video parameter table and assign that to INT 1Dh. If clear, table will not be provided.&quot;</span>);
<a name="l01734"></a>01734 
<a name="l01735"></a>01735     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow more than 640kb base memory&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01736"></a>01736     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, and space is available, allow conventional memory to extend past 640KB.\n&quot;</span>
<a name="l01737"></a>01737             <span class="stringliteral">&quot;For example, if machine=cga, conventional memory can extend out to 0xB800 and provide up to 736KB of RAM.\n&quot;</span>
<a name="l01738"></a>01738             <span class="stringliteral">&quot;This allows you to emulate PC/XT style memory extensions.&quot;</span>);
<a name="l01739"></a>01739 
<a name="l01740"></a>01740     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int 10h points at vga bios&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01741"></a>01741     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 10h points at the VGA BIOS. If clear, INT 10h points into the system BIOS. This option only affects EGA/VGA/SVGA emulation.\n&quot;</span>
<a name="l01742"></a>01742                     <span class="stringliteral">&quot;This option is needed for some older DOS applications that make additional checks before detecting EGA/VGA hardware (SuperCalc).&quot;</span>);
<a name="l01743"></a>01743 
<a name="l01744"></a>01744     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa zero buffer on get information&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01745"></a>01745     Pbool-&gt;Set_help(<span class="stringliteral">&quot;This setting affects VESA BIOS function INT 10h AX=4F00h. If set, the VESA BIOS will zero the\n&quot;</span>
<a name="l01746"></a>01746                     <span class="stringliteral">&quot;256-byte buffer defined by the standard at ES:DI, then fill in the structure. If clear, only\n&quot;</span>
<a name="l01747"></a>01747                     <span class="stringliteral">&quot;the structure members will be filled in, and memory outside the initial 20-32 bytes will remain\n&quot;</span>
<a name="l01748"></a>01748                     <span class="stringliteral">&quot;unmodified. This setting is ON by default. Some very early 1990s DOS games that support VESA\n&quot;</span>
<a name="l01749"></a>01749                     <span class="stringliteral">&quot;BIOS standards may need this setting turned OFF if the programmer did not provide enough space\n&quot;</span>
<a name="l01750"></a>01750                     <span class="stringliteral">&quot;for the entire 256 byte structure and the game crashes if it detects VESA BIOS extensions.\n&quot;</span>
<a name="l01751"></a>01751                     <span class="stringliteral">&quot;Needed for:\n&quot;</span>
<a name="l01752"></a>01752                     <span class="stringliteral">&quot;  GETSADAM.EXE&quot;</span>);
<a name="l01753"></a>01753 
<a name="l01754"></a>01754     <span class="comment">/* should be set to zero unless for very specific demos:</span>
<a name="l01755"></a>01755 <span class="comment">     *  - &quot;Melvindale&quot; by MFX (1996): Set this to 2, the nightmarish visual rendering code appears to draw 2 scanlines</span>
<a name="l01756"></a>01756 <span class="comment">     *    upward from the VESA linear framebuffer base we return, causing DOSBox to emit warnings about illegal read/writes</span>
<a name="l01757"></a>01757 <span class="comment">     *    from 0xBFFFF000-0xBFFFFFFF (just before the base of the framebuffer at 0xC0000000). It also has the effect of</span>
<a name="l01758"></a>01758 <span class="comment">     *    properly centering the picture on the screen. I suppose it&#39;s a miracle the demo didn&#39;t crash people&#39;s computers</span>
<a name="l01759"></a>01759 <span class="comment">     *    writing to undefined areas like that. */</span>
<a name="l01760"></a>01760     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa lfb base scanline adjust&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l01761"></a>01761     Pint-&gt;Set_help(<span class="stringliteral">&quot;If non-zero, the VESA BIOS will report the linear framebuffer offset by this many scanlines.\n&quot;</span>
<a name="l01762"></a>01762             <span class="stringliteral">&quot;This does not affect the linear framebuffer&#39;s location. It only affects the linear framebuffer\n&quot;</span>
<a name="l01763"></a>01763             <span class="stringliteral">&quot;location reported by the VESA BIOS. Set to nonzero for DOS games with sloppy VESA graphics pointer management.\n&quot;</span>
<a name="l01764"></a>01764             <span class="stringliteral">&quot;    MFX \&quot;Melvindale\&quot; (1996): Set this option to 2 to center the picture properly.&quot;</span>);
<a name="l01765"></a>01765 
<a name="l01766"></a>01766     <span class="comment">/* If set, all VESA BIOS modes map 128KB of video RAM at A0000-BFFFF even though VESA BIOS emulation</span>
<a name="l01767"></a>01767 <span class="comment">     * reports a 64KB window. Some demos like the 1996 Wired report</span>
<a name="l01768"></a>01768 <span class="comment">     * (ftp.scene.org/pub/parties/1995/wired95/misc/e-w95rep.zip) assume they can write past the window</span>
<a name="l01769"></a>01769 <span class="comment">     * by spilling into B0000 without bank switching. */</span>
<a name="l01770"></a>01770     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa map non-lfb modes to 128kb region&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01771"></a>01771     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, VESA BIOS SVGA modes will be set to map 128KB of video memory to A0000-BFFFF instead of\n&quot;</span>
<a name="l01772"></a>01772                     <span class="stringliteral">&quot;64KB at A0000-AFFFF. This does not affect the SVGA window size or granularity.\n&quot;</span>
<a name="l01773"></a>01773                     <span class="stringliteral">&quot;Some games or demoscene productions assume that they can render into the next SVGA window/bank\n&quot;</span>
<a name="l01774"></a>01774                     <span class="stringliteral">&quot;by writing to video memory beyond the current SVGA window address and will not appear correctly\n&quot;</span>
<a name="l01775"></a>01775                     <span class="stringliteral">&quot;without this option.&quot;</span>);
<a name="l01776"></a>01776 
<a name="l01777"></a>01777     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow hpel effects&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01778"></a>01778     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow the DOS demo or program to change the horizontal pel (panning) register per scanline.\n&quot;</span>
<a name="l01779"></a>01779             <span class="stringliteral">&quot;Some early DOS demos use this to create waving or sinus effects on the picture. Not very many VGA\n&quot;</span>
<a name="l01780"></a>01780             <span class="stringliteral">&quot;chipsets allow this, so far, only ATI chipsets are known to support this effect. Disabled by default.&quot;</span>);
<a name="l01781"></a>01781 
<a name="l01782"></a>01782     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow hretrace effects&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01783"></a>01783     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow the DOS demo or program to make the picture wavy by playing with the &#39;start horizontal&quot;</span>
<a name="l01784"></a>01784             <span class="stringliteral">&quot;retrace&#39; register of the CRTC during the active picture. Some early DOS demos (Copper by Surprise!&quot;</span>
<a name="l01785"></a>01785             <span class="stringliteral">&quot;productions) need this option set for some demo effects to work. Disabled by default.&quot;</span>);
<a name="l01786"></a>01786 
<a name="l01787"></a>01787     Pdouble = secprop-&gt;Add_double(<span class="stringliteral">&quot;hretrace effect weight&quot;</span>,Property::Changeable::Always,4.0);
<a name="l01788"></a>01788     Pdouble-&gt;Set_help(<span class="stringliteral">&quot;If emulating hretrace effects, this parameter adds &#39;weight&#39; to the offset to smooth it out.\n&quot;</span>
<a name="l01789"></a>01789             <span class="stringliteral">&quot;the larger the number, the more averaging is applied. This is intended to emulate the inertia\n&quot;</span>
<a name="l01790"></a>01790             <span class="stringliteral">&quot;of the electron beam in a CRT monitor&quot;</span>);
<a name="l01791"></a>01791 
<a name="l01792"></a>01792     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist cap&quot;</span>,Property::Changeable::Always,0);
<a name="l01793"></a>01793     Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, the VESA modelist is capped so that it contains no more than the specified number of video modes.&quot;</span>);
<a name="l01794"></a>01794 
<a name="l01795"></a>01795     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist width limit&quot;</span>,Property::Changeable::Always,1280);
<a name="l01796"></a>01796     Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, VESA modes with horizontal resolution higher than the specified pixel count will not be listed.\n&quot;</span>
<a name="l01797"></a>01797             <span class="stringliteral">&quot;This is another way the modelist can be capped for DOS applications that have trouble with long modelists.&quot;</span>);
<a name="l01798"></a>01798 
<a name="l01799"></a>01799     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist height limit&quot;</span>,Property::Changeable::Always,1024);
<a name="l01800"></a>01800     Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, VESA modes with vertical resolution higher than the specified pixel count will not be listed.\n&quot;</span>
<a name="l01801"></a>01801             <span class="stringliteral">&quot;This is another way the modelist can be capped for DOS applications that have trouble with long modelists.&quot;</span>);
<a name="l01802"></a>01802 
<a name="l01803"></a>01803     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa vbe put modelist in vesa information&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01804"></a>01804     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the VESA modelist is placed in the VESA information structure itself when the DOS application\n&quot;</span>
<a name="l01805"></a>01805                     <span class="stringliteral">&quot;queries information on the VESA BIOS. Setting this option may help with some games, though it limits\n&quot;</span>
<a name="l01806"></a>01806                     <span class="stringliteral">&quot;the mode list reported to the DOS application.&quot;</span>);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa vbe 1.2 modes are 32bpp&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01809"></a>01809     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, truecolor (16M color) VESA BIOS modes in the 0x100-0x11F range are 32bpp. If clear, they are 24bpp.\n&quot;</span>
<a name="l01810"></a>01810             <span class="stringliteral">&quot;Some DOS games and demos assume one bit depth or the other and do not enumerate VESA BIOS modes, which is why this\n&quot;</span>
<a name="l01811"></a>01811             <span class="stringliteral">&quot;option exists.&quot;</span>);
<a name="l01812"></a>01812 
<a name="l01813"></a>01813     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow low resolution vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01814"></a>01814     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow low resolution VESA modes (320x200x16/24/32bpp and so on). You could set this to false to simulate\n&quot;</span>
<a name="l01815"></a>01815             <span class="stringliteral">&quot;SVGA hardware with a BIOS that does not support the lowres modes for testing purposes.&quot;</span>);
<a name="l01816"></a>01816 
<a name="l01817"></a>01817     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow explicit 24bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01818"></a>01818     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, additional 24bpp modes are listed in the modelist regardless whether modes 0x100-0x11F are\n&quot;</span>
<a name="l01819"></a>01819                     <span class="stringliteral">&quot;configured to be 24bpp or 32bpp. Setting this option can provide the best testing and development\n&quot;</span>
<a name="l01820"></a>01820                     <span class="stringliteral">&quot;environment for new retro DOS code. If clear, 24bpp will only be available in the 0x100-0x11F range\n&quot;</span>
<a name="l01821"></a>01821                     <span class="stringliteral">&quot;if the \&quot;vesa vbe 1.2 modes are 32bpp\&quot; is false. Setting to false helps to emulate typical SVGA\n&quot;</span>
<a name="l01822"></a>01822                     <span class="stringliteral">&quot;hardware in which either 24bpp is supported, or 32bpp is supported, but not both. Disabled by default.&quot;</span>);
<a name="l01823"></a>01823 
<a name="l01824"></a>01824     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow high definition vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01825"></a>01825     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, offer HD video modes in the VESA modelist (such as 1280x720 aka 720p or 1920x1080 aka 1080p).\n&quot;</span>
<a name="l01826"></a>01826                     <span class="stringliteral">&quot;This option also offers 4:3 versions (960x720 and 1440x1080) for DOS games that cannot properly handle\n&quot;</span>
<a name="l01827"></a>01827                     <span class="stringliteral">&quot;a 16:9 aspect ratio, and several other HD modes. The modes enabled by this option are still limited by the\n&quot;</span>
<a name="l01828"></a>01828                     <span class="stringliteral">&quot;width and height limits and available video memory.\n&quot;</span>
<a name="l01829"></a>01829                     <span class="stringliteral">&quot;This is unusual for VESA BIOSes to do and is disabled by default.&quot;</span>);
<a name="l01830"></a>01830 
<a name="l01831"></a>01831     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow unusual vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01832"></a>01832     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, unusual (uncommon) modes are added to the list. The modes reflect uncommon resolutions\n&quot;</span>
<a name="l01833"></a>01833                     <span class="stringliteral">&quot;added by external drivers (UNIVBE), some VESA BIOSes, some laptop and netbook displays, and\n&quot;</span>
<a name="l01834"></a>01834                     <span class="stringliteral">&quot;some added by DOSBox-X for additional fun. Disabled by default.&quot;</span>);
<a name="l01835"></a>01835 
<a name="l01836"></a>01836     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 32bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01837"></a>01837     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 32bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01838"></a>01838 
<a name="l01839"></a>01839     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 24bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01840"></a>01840     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 24bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01841"></a>01841 
<a name="l01842"></a>01842     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 16bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01843"></a>01843     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 16bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01844"></a>01844 
<a name="l01845"></a>01845     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 15bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01846"></a>01846     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 15bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01847"></a>01847 
<a name="l01848"></a>01848     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 8bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01849"></a>01849     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 8bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01850"></a>01850 
<a name="l01851"></a>01851     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 4bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01852"></a>01852     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 4bpp VESA modes, set to &#39;false&#39;.\n&quot;</span>
<a name="l01853"></a>01853                     <span class="stringliteral">&quot;These modes have the same 16-color planar memory layout as standard VGA, but\n&quot;</span>
<a name="l01854"></a>01854                     <span class="stringliteral">&quot;at SVGA resolution.&quot;</span>);
<a name="l01855"></a>01855 
<a name="l01856"></a>01856     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 4bpp packed vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01857"></a>01857     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 4bpp packed VESA modes, set to &#39;false&#39;.\n&quot;</span>
<a name="l01858"></a>01858                     <span class="stringliteral">&quot;4bpp (16-color) packed is an unusual novelty mode only seen on specific Chips &amp; Tech 65550\n&quot;</span>
<a name="l01859"></a>01859                     <span class="stringliteral">&quot;VESA BIOSes such as the one in a Toshiba Libretto laptop. Disabled by default.&quot;</span>);
<a name="l01860"></a>01860 
<a name="l01861"></a>01861     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow tty vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01862"></a>01862     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with text VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01863"></a>01863 
<a name="l01864"></a>01864     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;double-buffered line compare&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01865"></a>01865     Pbool-&gt;Set_help(<span class="stringliteral">&quot;This setting affects the VGA Line Compare register. Set to false (default value) to emulate most VGA behavior\n&quot;</span>
<a name="l01866"></a>01866             <span class="stringliteral">&quot;Set to true for the value to latch once at the start of the frame.&quot;</span>);
<a name="l01867"></a>01867 
<a name="l01868"></a>01868     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore vblank wraparound&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01869"></a>01869     Pbool-&gt;Set_help(<span class="stringliteral">&quot;DOSBox-X can handle active display properly if games or demos reprogram vertical blanking to end in the active picture area.\n&quot;</span>
<a name="l01870"></a>01870             <span class="stringliteral">&quot;If the wraparound handling prevents the game from displaying properly, set this to false. Out of bounds vblank values will be ignored.\n&quot;</span>);
<a name="l01871"></a>01871 
<a name="l01872"></a>01872     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable vga resize delay&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01873"></a>01873     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game you are running relies on certain VGA raster tricks that affect active display area, enable this option.\n&quot;</span>
<a name="l01874"></a>01874             <span class="stringliteral">&quot;This adds a delay between VGA mode changes and window updates. It also means that if you are capturing a demo or game,\n&quot;</span>
<a name="l01875"></a>01875             <span class="stringliteral">&quot;that your capture will also show a few garbled frames at any point mode changes occur, which is why this option is disabled\n&quot;</span>
<a name="l01876"></a>01876             <span class="stringliteral">&quot;by default. If you intend to run certain DOS games and demos like DoWhackaDo, enable this option.&quot;</span>);
<a name="l01877"></a>01877 
<a name="l01878"></a>01878     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;resize only on vga active display width increase&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01879"></a>01879     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, changes to the Display End register of the CRTC do not trigger DOSBox-X to resize its window\n&quot;</span>
<a name="l01880"></a>01880             <span class="stringliteral">&quot;IF the value written is less than the current value. Some demos like DoWhackaDo need this option set\n&quot;</span>
<a name="l01881"></a>01881             <span class="stringliteral">&quot;because of the way its raster effects work. If the DOSBox-X window rapidly changes size during a demo\n&quot;</span>
<a name="l01882"></a>01882             <span class="stringliteral">&quot;try setting this option. Else, leave it turned off. Changes to other VGA CRTC registers will trigger\n&quot;</span>
<a name="l01883"></a>01883             <span class="stringliteral">&quot;a DOSBox-X mode change as normal regardless of this setting.&quot;</span>);
<a name="l01884"></a>01884 
<a name="l01885"></a>01885     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pci bus&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01886"></a>01886     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PCI bus emulation&quot;</span>);
<a name="l01887"></a>01887 
<a name="l01888"></a>01888     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vga palette update on full load&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01889"></a>01889     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, all three bytes of the palette entry must be loaded before taking the color,\n&quot;</span>
<a name="l01890"></a>01890                     <span class="stringliteral">&quot;which is fairly typical SVGA behavior. If not set, partial changes are allowed.&quot;</span>);
<a name="l01891"></a>01891 
<a name="l01892"></a>01892     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore odd-even mode in non-cga modes&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01893"></a>01893     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Some demoscene productions use VGA Mode X but accidentally enable odd/even mode.\n&quot;</span>
<a name="l01894"></a>01894                     <span class="stringliteral">&quot;Setting this option can correct for that and render the demo properly.\n&quot;</span>
<a name="l01895"></a>01895                     <span class="stringliteral">&quot;This option forces VGA emulation to ignore odd/even mode except in text and CGA modes.&quot;</span>);
<a name="l01896"></a>01896                                         
<a name="l01897"></a>01897     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;pc98&quot;</span>,&amp;Null_Init);
<a name="l01898"></a>01898         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 BIOS copyright string&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01899"></a>01899     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the PC-98 BIOS copyright string is placed at E800:0000. Enable this for software that detects PC-98 vs Epson.&quot;</span>);
<a name="l01900"></a>01900 
<a name="l01901"></a>01901     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 int 1b fdc timer wait&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01902"></a>01902     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 1Bh floppy access will wait for the timer to count down before returning.\n&quot;</span>
<a name="l01903"></a>01903                     <span class="stringliteral">&quot;This is needed for Ys II to run without crashing.&quot;</span>);
<a name="l01904"></a>01904 
<a name="l01905"></a>01905     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 pic init to read isr&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01906"></a>01906     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the programmable interrupt controllers are initialized by default (if PC-98 mode)\n&quot;</span>
<a name="l01907"></a>01907                     <span class="stringliteral">&quot;so that the in-service interrupt status can be read immediately. There seems to be a common\n&quot;</span>
<a name="l01908"></a>01908                     <span class="stringliteral">&quot;convention in PC-98 games to program and/or assume this mode for cooperative interrupt handling.\n&quot;</span>
<a name="l01909"></a>01909                     <span class="stringliteral">&quot;This option is enabled by default for best compatibility with PC-98 games.&quot;</span>);
<a name="l01910"></a>01910 
<a name="l01911"></a>01911     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pc-98 fm board&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01912"></a>01912     Pstring-&gt;Set_values(pc98fmboards);
<a name="l01913"></a>01913     Pstring-&gt;Set_help(<span class="stringliteral">&quot;In PC-98 mode, selects the FM music board to emulate.&quot;</span>);
<a name="l01914"></a>01914 
<a name="l01915"></a>01915     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 fm board irq&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01916"></a>01916     Pint-&gt;Set_help(<span class="stringliteral">&quot;If set, helps to determine the IRQ of the FM board. A setting of zero means to auto-determine the IRQ.&quot;</span>);
<a name="l01917"></a>01917 
<a name="l01918"></a>01918     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;pc-98 fm board io port&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01919"></a>01919     Phex-&gt;Set_help(<span class="stringliteral">&quot;If set, helps to determine the base I/O port of the FM board. A setting of zero means to auto-determine the port number.&quot;</span>);
<a name="l01920"></a>01920 
<a name="l01921"></a>01921     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 sound bios&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01922"></a>01922     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set Sound BIOS enabled bit in MEMSW 4 for some games that require it.\n&quot;</span>
<a name="l01923"></a>01923                     <span class="stringliteral">&quot;TODO: Real emulation of PC-9801-26K/86 Sound BIOS&quot;</span>);
<a name="l01924"></a>01924 
<a name="l01925"></a>01925     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 load sound bios rom file&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01926"></a>01926     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, load SOUND.ROM if available and prsent that to the guest instead of trying to emulate directly.\n&quot;</span>
<a name="l01927"></a>01927                     <span class="stringliteral">&quot;This is strongly recommended, and is default enabled.\n&quot;</span>
<a name="l01928"></a>01928                     <span class="stringliteral">&quot;SOUND.ROM is a snapshot of the FM board BIOS taken from real PC-98 hardware.&quot;</span>);
<a name="l01929"></a>01929 
<a name="l01930"></a>01930     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 buffer page flip&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01931"></a>01931     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the game&#39;s request to page flip will be delayed to vertical retrace, which can eliminate tearline artifacts.\n&quot;</span>
<a name="l01932"></a>01932                     <span class="stringliteral">&quot;Note that this is NOT the behavior of actual hardware. This option is provided for the user&#39;s preference.&quot;</span>);
<a name="l01933"></a>01933 
<a name="l01934"></a>01934     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 256-color planar&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01935"></a>01935     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 256-color planar graphics mode if set, disable if not set.\n&quot;</span>
<a name="l01936"></a>01936                     <span class="stringliteral">&quot;This is a form of memory access in 256-color mode that existed for a short\n&quot;</span>
<a name="l01937"></a>01937                     <span class="stringliteral">&quot;time before later PC-9821 models removed it. This option must be enabled\n&quot;</span>
<a name="l01938"></a>01938                     <span class="stringliteral">&quot;to use DOSBox-X with Windows 3.1 and it&#39;s built-in 256-color driver.&quot;</span>);
<a name="l01939"></a>01939 
<a name="l01940"></a>01940     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 256-color&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01941"></a>01941     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 256-color graphics mode if set, disable if not set&quot;</span>);
<a name="l01942"></a>01942 
<a name="l01943"></a>01943     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 16-color&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01944"></a>01944     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 16-color graphics mode if set, disable if not set&quot;</span>);
<a name="l01945"></a>01945 
<a name="l01946"></a>01946     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable grcg&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01947"></a>01947     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow GRCG graphics functions if set, disable if not set&quot;</span>);
<a name="l01948"></a>01948 
<a name="l01949"></a>01949     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable egc&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01950"></a>01950     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow EGC graphics functions if set, disable if not set&quot;</span>);
<a name="l01951"></a>01951 
<a name="l01952"></a>01952     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 188 user cg&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01953"></a>01953     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 188+ user-defined CG cells if set&quot;</span>);
<a name="l01954"></a>01954 
<a name="l01955"></a>01955     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 start gdc at 5mhz&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01956"></a>01956     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start GDC at 5MHz if set, 2.5MHz if clear. May be required for some games.&quot;</span>);
<a name="l01957"></a>01957 
<a name="l01958"></a>01958     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 allow scanline effect&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01959"></a>01959     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, PC-98 emulation will allow the DOS application to enable the &#39;scanline effect&#39;\n&quot;</span>
<a name="l01960"></a>01960                     <span class="stringliteral">&quot;in 200-line graphics modes upconverted to 400-line raster display. When enabled, odd\n&quot;</span>
<a name="l01961"></a>01961                     <span class="stringliteral">&quot;numbered scanlines are blanked instead of doubled&quot;</span>);
<a name="l01962"></a>01962 
<a name="l01963"></a>01963     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 bus mouse&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01964"></a>01964     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PC-98 bus mouse emulation. Disabling this option does not disable INT 33h emulation.&quot;</span>);
<a name="l01965"></a>01965 
<a name="l01966"></a>01966     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pc-98 video mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01967"></a>01967     Pstring-&gt;Set_values(pc98videomodeopt);
<a name="l01968"></a>01968     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specify the preferred PC-98 video mode.\n&quot;</span>
<a name="l01969"></a>01969                       <span class="stringliteral">&quot;Valid values are 15, 24, or 31 for each specific horizontal refresh rate on the platform.\n&quot;</span>
<a name="l01970"></a>01970                       <span class="stringliteral">&quot;24khz is default and best supported at this time.\n&quot;</span>
<a name="l01971"></a>01971                       <span class="stringliteral">&quot;15khz is not implemented at this time.\n&quot;</span>
<a name="l01972"></a>01972                       <span class="stringliteral">&quot;31khz is experimental at this time.&quot;</span>);
<a name="l01973"></a>01973 
<a name="l01974"></a>01974     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pc-98 timer always cycles&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01975"></a>01975     Pstring-&gt;Set_values(truefalseautoopt);
<a name="l01976"></a>01976     Pstring-&gt;Set_help(<span class="stringliteral">&quot;This controls PIT 1 PC speaker behavior related to turning the output on and off.\n&quot;</span>
<a name="l01977"></a>01977                       <span class="stringliteral">&quot;Default setting is &#39;auto&#39; to let the emulator choose for you.\n&quot;</span>
<a name="l01978"></a>01978                       <span class="stringliteral">&quot;true:  PIT 1 will always cycle whether or not the speaker is on (PC-9801 behavior).\n&quot;</span>
<a name="l01979"></a>01979                       <span class="stringliteral">&quot;false: PIT 1 will only cycle when the speaker is on (PC-9821 behavior).\n&quot;</span>
<a name="l01980"></a>01980                       <span class="stringliteral">&quot;Some older games will require the PC-9801 behavior to function properly.&quot;</span>);
<a name="l01981"></a>01981 
<a name="l01982"></a>01982     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 timer master frequency&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01983"></a>01983     Pint-&gt;SetMinMax(0,2457600);
<a name="l01984"></a>01984     Pint-&gt;Set_help(<span class="stringliteral">&quot;8254 timer clock frequency (NEC PC-98). Depending on the CPU frequency the clock frequency is one of two common values.\n&quot;</span>
<a name="l01985"></a>01985                    <span class="stringliteral">&quot;If your setting is neither of the below the closest appropriate value will be chosen.\n&quot;</span>
<a name="l01986"></a>01986                    <span class="stringliteral">&quot;This setting affects the master clock rate that DOS applications must divide down from to program the timer\n&quot;</span>
<a name="l01987"></a>01987                    <span class="stringliteral">&quot;at the correct rate, which affects timer interrupt, PC speaker, and the COM1 RS-232C serial port baud rate.\n&quot;</span>
<a name="l01988"></a>01988                    <span class="stringliteral">&quot;8MHz is treated as an alias for 4MHz and 10MHz is treated as an alias for 5MHz.\n&quot;</span>
<a name="l01989"></a>01989                    <span class="stringliteral">&quot;    0: Use default (auto)\n&quot;</span>
<a name="l01990"></a>01990                    <span class="stringliteral">&quot;    4: 1.996MHz (as if 4MHz or multiple thereof CPU clock)\n&quot;</span>
<a name="l01991"></a>01991                    <span class="stringliteral">&quot;    5: 2.457MHz (as if 5MHz or multiple thereof CPU clock)&quot;</span>);
<a name="l01992"></a>01992 
<a name="l01993"></a>01993     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 allow 4 display partition graphics&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01994"></a>01994     Pint-&gt;SetMinMax(-1,1);
<a name="l01995"></a>01995     Pint-&gt;Set_help(<span class="stringliteral">&quot;According to NEC graphics controller documentation, graphics mode is supposed to support only\n&quot;</span>
<a name="l01996"></a>01996                    <span class="stringliteral">&quot;2 display partitions. Some games rely on hardware flaws that allowed 4 partitions.\n&quot;</span>
<a name="l01997"></a>01997                    <span class="stringliteral">&quot;   -1: Default (choose automatically)\n&quot;</span>
<a name="l01998"></a>01998                    <span class="stringliteral">&quot;    0: Disable\n&quot;</span>
<a name="l01999"></a>01999                    <span class="stringliteral">&quot;    1: Enable&quot;</span>);
<a name="l02000"></a>02000 
<a name="l02001"></a>02001     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 force ibm keyboard layout&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02002"></a>02002     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Force to use a default keyboard layout like IBM US-English for PC-98 emulation.\n&quot;</span>
<a name="l02003"></a>02003                     <span class="stringliteral">&quot;Will only work with apps and games using BIOS for keyboard.&quot;</span>);
<a name="l02004"></a>02004 
<a name="l02005"></a>02005     <span class="comment">/* Explanation: NEC&#39;s mouse driver MOUSE.COM enables the graphics layer on startup and when INT 33h AX=0 is called.</span>
<a name="l02006"></a>02006 <span class="comment">     *              Some games by &quot;Orange House&quot; assume this behavior and do not make any effort on their</span>
<a name="l02007"></a>02007 <span class="comment">     *              own to show and enable graphics. Without this option, those games will not show any</span>
<a name="l02008"></a>02008 <span class="comment">     *              graphics. PC-98 systems have been confirmed to boot up with the graphics layer disabled</span>
<a name="l02009"></a>02009 <span class="comment">     *              and set to 640x200 8-color planar mode. This has been confirmed on real hardware.</span>
<a name="l02010"></a>02010 <span class="comment">     *              See also [https://github.com/joncampbell123/dosbox-x/issues/1305] */</span>
<a name="l02011"></a>02011     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 show graphics layer on initialize&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02012"></a>02012     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If PC-98 mode and INT 33h emulation is enabled, the graphics layer will be automatically enabled\n&quot;</span>
<a name="l02013"></a>02013                     <span class="stringliteral">&quot;at driver startup AND when INT 33h AX=0 is called. This is NEC MOUSE.COM behavior and default\n&quot;</span>
<a name="l02014"></a>02014                     <span class="stringliteral">&quot;enabled. To emulate other drivers like QMOUSE that do not follow this behavior, set to false.&quot;</span>);
<a name="l02015"></a>02015 
<a name="l02016"></a>02016     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;render&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02017"></a>02017     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;frameskip&quot;</span>,Property::Changeable::Always,0);
<a name="l02018"></a>02018     Pint-&gt;SetMinMax(0,10);
<a name="l02019"></a>02019     Pint-&gt;Set_help(<span class="stringliteral">&quot;How many frames DOSBox-X skips before drawing one.&quot;</span>);
<a name="l02020"></a>02020 
<a name="l02021"></a>02021     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;alt render&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l02022"></a>02022     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, use a new experimental rendering engine&quot;</span>);
<a name="l02023"></a>02023 
<a name="l02024"></a>02024     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;aspect&quot;</span>, Property::Changeable::Always, <span class="stringliteral">&quot;false&quot;</span>);
<a name="l02025"></a>02025     Pstring-&gt;Set_values(aspectmodes);
<a name="l02026"></a>02026     Pstring-&gt;Set_help(
<a name="l02027"></a>02027         <span class="stringliteral">&quot;Aspect ratio correction mode. Can be set to the following values:\n&quot;</span>
<a name="l02028"></a>02028         <span class="stringliteral">&quot;  &#39;false&#39; (default):\n&quot;</span>
<a name="l02029"></a>02029         <span class="stringliteral">&quot;      &#39;direct3d&#39;/opengl outputs: image is simply scaled to full window/fullscreen size, possibly resulting in disproportional image\n&quot;</span>
<a name="l02030"></a>02030         <span class="stringliteral">&quot;      &#39;surface&#39; output: it does no aspect ratio correction (default), resulting in disproportional images if VGA mode pixel ratio is not 4:3\n&quot;</span>
<a name="l02031"></a>02031         <span class="stringliteral">&quot;  &#39;true&#39;:\n&quot;</span>
<a name="l02032"></a>02032         <span class="stringliteral">&quot;      &#39;direct3d&#39;/opengl outputs: uses output driver functions to scale / pad image with black bars, correcting output to proportional 4:3 image\n&quot;</span>
<a name="l02033"></a>02033         <span class="stringliteral">&quot;          In most cases image degradation should not be noticeable (it all depends on the video adapter and how much the image is upscaled).\n&quot;</span>
<a name="l02034"></a>02034         <span class="stringliteral">&quot;          Should have none to negligible impact on performance, mostly being done in hardware\n&quot;</span>
<a name="l02035"></a>02035         <span class="stringliteral">&quot;      &#39;surface&#39; output: inherits old DOSBox aspect ratio correction method (adjusting rendered image line count to correct output to 4:3 ratio)\n&quot;</span>
<a name="l02036"></a>02036         <span class="stringliteral">&quot;          Due to source image manipulation this mode does not mix well with scalers, i.e. multiline scalers like hq2x/hq3x will work poorly\n&quot;</span>
<a name="l02037"></a>02037         <span class="stringliteral">&quot;          Slightly degrades visual image quality. Has a tiny impact on performance&quot;</span>
<a name="l02038"></a>02038 #<span class="keywordflow">if</span> C_XBRZ
<a name="l02039"></a>02039         <span class="stringliteral">&quot;\n&quot;</span>
<a name="l02040"></a>02040         <span class="stringliteral">&quot;          When using xBRZ scaler with &#39;surface&#39; output, aspect ratio correction is done by the scaler itself, so none of the above apply&quot;</span>
<a name="l02041"></a>02041 #endif
<a name="l02042"></a>02042 #<span class="keywordflow">if</span> C_SURFACE_POSTRENDER_ASPECT
<a name="l02043"></a>02043         <span class="stringliteral">&quot;\n&quot;</span>
<a name="l02044"></a>02044         <span class="stringliteral">&quot;  &#39;nearest&#39;:\n&quot;</span>
<a name="l02045"></a>02045         <span class="stringliteral">&quot;      &#39;direct3d&#39;/opengl outputs: not available, fallbacks to &#39;true&#39; mode automatically\n&quot;</span>
<a name="l02046"></a>02046         <span class="stringliteral">&quot;      &#39;surface&#39; output: scaler friendly aspect ratio correction, works by rescaling rendered image using nearest neighbor scaler\n&quot;</span>
<a name="l02047"></a>02047         <span class="stringliteral">&quot;          Complex scalers work. Image quality is on par with &#39;true&#39; mode (and better with scalers). More CPU intensive than &#39;true&#39; mode\n&quot;</span>
<a name="l02048"></a>02048 #<span class="keywordflow">if</span> C_XBRZ
<a name="l02049"></a>02049         <span class="stringliteral">&quot;          When using xBRZ scaler with &#39;surface&#39; output, aspect ratio correction is done by the scaler itself, so it fallbacks to &#39;true&#39; mode\n&quot;</span>
<a name="l02050"></a>02050 #endif
<a name="l02051"></a>02051         <span class="stringliteral">&quot;  &#39;bilinear&#39;:\n&quot;</span>
<a name="l02052"></a>02052         <span class="stringliteral">&quot;      &#39;direct3d&#39;/opengl outputs: not available, fallbacks to &#39;true&#39; mode automatically\n&quot;</span>
<a name="l02053"></a>02053         <span class="stringliteral">&quot;      &#39;surface&#39; output: scaler friendly aspect ratio correction, works by rescaling rendered image using bilinear scaler\n&quot;</span>
<a name="l02054"></a>02054         <span class="stringliteral">&quot;          Complex scalers work. Image quality is much better, should be on par with using &#39;direct3d&#39; output + &#39;true&#39; mode\n&quot;</span>
<a name="l02055"></a>02055         <span class="stringliteral">&quot;          Very CPU intensive, high end CPU may be required&quot;</span>
<a name="l02056"></a>02056 #<span class="keywordflow">if</span> C_XBRZ
<a name="l02057"></a>02057         <span class="stringliteral">&quot;\n&quot;</span>
<a name="l02058"></a>02058         <span class="stringliteral">&quot;          When using xBRZ scaler with &#39;surface&#39; output, aspect ratio correction is done by the scaler itself, so it fallbacks to &#39;true&#39; mode&quot;</span>
<a name="l02059"></a>02059 #endif
<a name="l02060"></a>02060 #endif
<a name="l02061"></a>02061     );
<a name="l02062"></a>02062 
<a name="l02063"></a>02063     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;char9&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02064"></a>02064     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 9-pixel wide text mode fonts.&quot;</span>);
<a name="l02065"></a>02065 
<a name="l02066"></a>02066     <span class="comment">/* NTS: In the original code borrowed from yhkong, this was named &quot;multiscan&quot;. All it really does is disable</span>
<a name="l02067"></a>02067 <span class="comment">     *      the doublescan down-rezzing DOSBox normally does with 320x240 graphics so that you get the full rendition of what a VGA output would emit. */</span>
<a name="l02068"></a>02068     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;doublescan&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02069"></a>02069     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, doublescanned output emits two scanlines for each source line, in the\n&quot;</span>
<a name="l02070"></a>02070             <span class="stringliteral">&quot;same manner as the actual VGA output (320x200 is rendered as 640x400 for example).\n&quot;</span>
<a name="l02071"></a>02071             <span class="stringliteral">&quot;If clear, doublescanned output is rendered at the native source resolution (320x200 as 320x200).\n&quot;</span>
<a name="l02072"></a>02072             <span class="stringliteral">&quot;This affects the raster PRIOR to the software or hardware scalers. Choose wisely.\n&quot;</span>);
<a name="l02073"></a>02073 
<a name="l02074"></a>02074     Pmulti = secprop-&gt;Add_multi(<span class="stringliteral">&quot;scaler&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02075"></a>02075     Pmulti-&gt;SetValue(<span class="stringliteral">&quot;normal2x&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02076"></a>02076     Pmulti-&gt;Set_help(<span class="stringliteral">&quot;Scaler used to enlarge/enhance low resolution modes. If &#39;forced&#39; is appended,\n&quot;</span>
<a name="l02077"></a>02077                      <span class="stringliteral">&quot;then the scaler will be used even if the result might not be desired.\n&quot;</span>
<a name="l02078"></a>02078                      <span class="stringliteral">&quot;To fit a scaler in the resolution used at full screen may require a border or side bars.\n&quot;</span>
<a name="l02079"></a>02079                      <span class="stringliteral">&quot;To fill the screen entirely, depending on your hardware, a different scaler/fullresolution might work.&quot;</span>);
<a name="l02080"></a>02080     Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;normal2x&quot;</span>);
<a name="l02081"></a>02081     Pstring-&gt;Set_values(scalers);
<a name="l02082"></a>02082 
<a name="l02083"></a>02083     Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;force&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02084"></a>02084     Pstring-&gt;Set_values(force);
<a name="l02085"></a>02085 
<a name="l02086"></a>02086 <span class="preprocessor">#if C_XBRZ</span>
<a name="l02087"></a>02087 <span class="preprocessor"></span>    Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;xbrz slice&quot;</span>,Property::Changeable::OnlyAtStart,16);
<a name="l02088"></a>02088     Pint-&gt;SetMinMax(1,1024);
<a name="l02089"></a>02089     Pint-&gt;Set_help(<span class="stringliteral">&quot;Number of screen lines to process in single xBRZ scaler taskset task, affects xBRZ performance, 16 is the default&quot;</span>);
<a name="l02090"></a>02090 
<a name="l02091"></a>02091     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;xbrz fixed scale factor&quot;</span>,Property::Changeable::OnlyAtStart, 0);
<a name="l02092"></a>02092     Pint-&gt;SetMinMax(0,6);
<a name="l02093"></a>02093     Pint-&gt;Set_help(<span class="stringliteral">&quot;To use fixed xBRZ scale factor (i.e. to attune performance), set it to 2-6, 0 - use automatic calculation (default)&quot;</span>);
<a name="l02094"></a>02094 
<a name="l02095"></a>02095     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;xbrz max scale factor&quot;</span>,Property::Changeable::OnlyAtStart, 0);
<a name="l02096"></a>02096     Pint-&gt;SetMinMax(0,6);
<a name="l02097"></a>02097     Pint-&gt;Set_help(<span class="stringliteral">&quot;To cap maximum xBRZ scale factor used (i.e. to attune performance), set it to 2-6, 0 - use scaler allowed maximum (default)&quot;</span>);
<a name="l02098"></a>02098 <span class="preprocessor">#endif</span>
<a name="l02099"></a>02099 <span class="preprocessor"></span>
<a name="l02100"></a>02100     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autofit&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02101"></a>02101     Pbool-&gt;Set_help(
<a name="l02102"></a>02102         <span class="stringliteral">&quot;Best fits image to window\n&quot;</span>
<a name="l02103"></a>02103         <span class="stringliteral">&quot;- Intended for output=direct3d, fullresolution=original, aspect=true&quot;</span>);
<a name="l02104"></a>02104 
<a name="l02105"></a>02105     Pmulti = secprop-&gt;Add_multi(<span class="stringliteral">&quot;monochrome_pal&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02106"></a>02106     Pmulti-&gt;SetValue(<span class="stringliteral">&quot;green&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02107"></a>02107     Pmulti-&gt;Set_help(<span class="stringliteral">&quot;Specify the color of monochrome display.\n&quot;</span>
<a name="l02108"></a>02108         <span class="stringliteral">&quot;Possible values: green, amber, gray, white\n&quot;</span>
<a name="l02109"></a>02109         <span class="stringliteral">&quot;Append &#39;bright&#39; for a brighter look.&quot;</span>);
<a name="l02110"></a>02110     Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;color&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;green&quot;</span>);
<a name="l02111"></a>02111     <span class="keyword">const</span> <span class="keywordtype">char</span>* monochrome_pal_colors[]={
<a name="l02112"></a>02112       <span class="stringliteral">&quot;green&quot;</span>,<span class="stringliteral">&quot;amber&quot;</span>,<span class="stringliteral">&quot;gray&quot;</span>,<span class="stringliteral">&quot;white&quot;</span>,0
<a name="l02113"></a>02113     };
<a name="l02114"></a>02114     Pstring-&gt;Set_values(monochrome_pal_colors);
<a name="l02115"></a>02115     Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;bright&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02116"></a>02116     <span class="keyword">const</span> <span class="keywordtype">char</span>* bright[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;bright&quot;</span>, 0 };
<a name="l02117"></a>02117     Pstring-&gt;Set_values(bright);
<a name="l02118"></a>02118 
<a name="l02119"></a>02119     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;vsync&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02120"></a>02120 
<a name="l02121"></a>02121     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;vsyncmode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02122"></a>02122     Pstring-&gt;Set_values(vsyncmode);
<a name="l02123"></a>02123     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Synchronize vsync timing to the host display. Requires calibration within DOSBox-X.&quot;</span>);
<a name="l02124"></a>02124     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;vsyncrate&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;75&quot;</span>);
<a name="l02125"></a>02125     Pstring-&gt;Set_values(vsyncrate);
<a name="l02126"></a>02126     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Vsync rate used if vsync is enabled. Ignored if vsyncmode is set to host (win32).&quot;</span>);
<a name="l02127"></a>02127 
<a name="l02128"></a>02128     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;cpu&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02129"></a>02129     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;core&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02130"></a>02130     Pstring-&gt;Set_values(cores);
<a name="l02131"></a>02131     Pstring-&gt;Set_help(<span class="stringliteral">&quot;CPU Core used in emulation. auto will switch to dynamic if available and appropriate.\n&quot;</span>
<a name="l02132"></a>02132             <span class="stringliteral">&quot;WARNING: Do not use dynamic or auto setting core with Windows 95 or other preemptive\n&quot;</span>
<a name="l02133"></a>02133             <span class="stringliteral">&quot;multitasking OSes with protected mode paging, you should use the normal core instead.&quot;</span>);
<a name="l02134"></a>02134 
<a name="l02135"></a>02135     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;fpu&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02136"></a>02136     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable FPU emulation&quot;</span>);
<a name="l02137"></a>02137 
<a name="l02138"></a>02138     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;segment limits&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02139"></a>02139     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enforce segment limits&quot;</span>);
<a name="l02140"></a>02140 
<a name="l02141"></a>02141     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;double fault&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02142"></a>02142     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate double fault exception&quot;</span>);
<a name="l02143"></a>02143 
<a name="l02144"></a>02144     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;reset on triple fault&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02145"></a>02145     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Reset CPU on triple fault condition (failure to handle double fault)&quot;</span>);
<a name="l02146"></a>02146 
<a name="l02147"></a>02147     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;always report double fault&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l02148"></a>02148     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always report (to log file) double faults if set. Else, a double fault is reported only once. Set this option for debugging purposes.&quot;</span>);
<a name="l02149"></a>02149 
<a name="l02150"></a>02150     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;always report triple fault&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l02151"></a>02151     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always report (to log file) triple faults if set. Else, a triple fault is reported only once. Set this option for debugging purposes.&quot;</span>);
<a name="l02152"></a>02152 
<a name="l02153"></a>02153     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable msr&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02154"></a>02154     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow RDMSR/WRMSR instructions. This option is only meaningful when cputype=pentium.\n&quot;</span>
<a name="l02155"></a>02155             <span class="stringliteral">&quot;WARNING: Leaving this option enabled while installing Windows 95/98/ME can cause crashes.&quot;</span>);
<a name="l02156"></a>02156 
<a name="l02157"></a>02157     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable cmpxchg8b&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02158"></a>02158     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Pentium CMPXCHG8B instruction. Enable this explicitly if using software that uses this instruction.\n&quot;</span>
<a name="l02159"></a>02159             <span class="stringliteral">&quot;You must enable this option to run Windows ME because portions of the kernel rely on this instruction.&quot;</span>);
<a name="l02160"></a>02160 
<a name="l02161"></a>02161     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore undefined msr&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l02162"></a>02162     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Ignore RDMSR/WRMSR on undefined registers. Normally the CPU will fire an Invalid Opcode exception in that case.\n&quot;</span>
<a name="l02163"></a>02163             <span class="stringliteral">&quot;This option is off by default, enable if using software or drivers that assumes the presence of\n&quot;</span>
<a name="l02164"></a>02164             <span class="stringliteral">&quot;certain MSR registers without checking. If you are using certain versions of the 3Dfx glide drivers for MS-DOS\n&quot;</span>
<a name="l02165"></a>02165             <span class="stringliteral">&quot;you will need to set this to TRUE as 3Dfx appears to have coded GLIDE2.OVL to assume the presence\n&quot;</span>
<a name="l02166"></a>02166             <span class="stringliteral">&quot;of Pentium Pro/Pentium II MTRR registers.\n&quot;</span>
<a name="l02167"></a>02167             <span class="stringliteral">&quot;WARNING: Leaving this option enabled while installing Windows 95/98/ME can cause crashes.&quot;</span>);
<a name="l02168"></a>02168 
<a name="l02169"></a>02169     <span class="comment">/* NTS: This setting is honored by all cpu cores except dynamic core */</span>
<a name="l02170"></a>02170     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;interruptible rep string op&quot;</span>,Property::Changeable::Always,-1);
<a name="l02171"></a>02171     Pint-&gt;SetMinMax(-1,65536);
<a name="l02172"></a>02172     Pint-&gt;Set_help(<span class="stringliteral">&quot;if nonzero, REP string instructions (LODS/MOVS/STOS/INS/OUTS) are interruptible (by interrupts or other events).\n&quot;</span>
<a name="l02173"></a>02173             <span class="stringliteral">&quot;if zero, REP string instructions are carried out in full before processing events and interrupts.\n&quot;</span>
<a name="l02174"></a>02174             <span class="stringliteral">&quot;Set to -1 for a reasonable default setting based on cpu type and other configuration.\n&quot;</span>
<a name="l02175"></a>02175             <span class="stringliteral">&quot;A setting of 0 can improve emulation speed at the expense of emulation accuracy.\n&quot;</span>
<a name="l02176"></a>02176             <span class="stringliteral">&quot;A nonzero setting (1-8) may be needed for DOS games and demos that use the IRQ 0 interrupt to play digitized samples\n&quot;</span>
<a name="l02177"></a>02177             <span class="stringliteral">&quot;while doing VGA palette animation at the same time (use case of REP OUTS), where the non-interruptible version\n&quot;</span>
<a name="l02178"></a>02178             <span class="stringliteral">&quot;would cause an audible drop in audio pitch.&quot;</span>);
<a name="l02179"></a>02179 
<a name="l02180"></a>02180     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dynamic core cache block size&quot;</span>,Property::Changeable::Always,32);
<a name="l02181"></a>02181     Pint-&gt;SetMinMax(1,65536);
<a name="l02182"></a>02182     Pint-&gt;Set_help(<span class="stringliteral">&quot;dynamic core cache block size. default value is 32. change this value carefully.\n&quot;</span>
<a name="l02183"></a>02183             <span class="stringliteral">&quot;according to forum discussion, setting this to 1 can aid debugging, however doing so\n&quot;</span>
<a name="l02184"></a>02184             <span class="stringliteral">&quot;also causes problems with 32-bit protected mode DOS games and reduces the performance\n&quot;</span>
<a name="l02185"></a>02185             <span class="stringliteral">&quot;of the dynamic core.\n&quot;</span>);
<a name="l02186"></a>02186 
<a name="l02187"></a>02187     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cputype&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02188"></a>02188     Pstring-&gt;Set_values(cputype_values);
<a name="l02189"></a>02189     Pstring-&gt;Set_help(<span class="stringliteral">&quot;CPU Type used in emulation. auto emulates a 486 which tolerates Pentium instructions.&quot;</span>);
<a name="l02190"></a>02190 
<a name="l02191"></a>02191     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;cycles&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02192"></a>02192     Pmulti_remain-&gt;Set_help(
<a name="l02193"></a>02193         <span class="stringliteral">&quot;Amount of instructions DOSBox-X tries to emulate each millisecond.\n&quot;</span>
<a name="l02194"></a>02194         <span class="stringliteral">&quot;Setting this value too high results in sound dropouts and lags.\n&quot;</span>
<a name="l02195"></a>02195         <span class="stringliteral">&quot;Cycles can be set in 3 ways:\n&quot;</span>
<a name="l02196"></a>02196         <span class="stringliteral">&quot;  &#39;auto&#39;          tries to guess what a game needs.\n&quot;</span>
<a name="l02197"></a>02197         <span class="stringliteral">&quot;                  It usually works, but can fail for certain games.\n&quot;</span>
<a name="l02198"></a>02198         <span class="stringliteral">&quot;  &#39;fixed #number&#39; will set a fixed amount of cycles. This is what you usually\n&quot;</span>
<a name="l02199"></a>02199         <span class="stringliteral">&quot;                  need if &#39;auto&#39; fails (Example: fixed 4000).\n&quot;</span>
<a name="l02200"></a>02200         <span class="stringliteral">&quot;  &#39;max&#39;           will allocate as much cycles as your computer is able to\n&quot;</span>
<a name="l02201"></a>02201         <span class="stringliteral">&quot;                  handle.&quot;</span>);
<a name="l02202"></a>02202 
<a name="l02203"></a>02203     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02204"></a>02204     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;auto&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02205"></a>02205     Pstring-&gt;Set_values(cyclest);
<a name="l02206"></a>02206 
<a name="l02207"></a>02207     Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02208"></a>02208 
<a name="l02209"></a>02209     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cycleup&quot;</span>,Property::Changeable::Always,10);
<a name="l02210"></a>02210     Pint-&gt;SetMinMax(1,1000000);
<a name="l02211"></a>02211     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of cycles to decrease/increase with keycombos.(CTRL-F11/CTRL-F12)&quot;</span>);
<a name="l02212"></a>02212 
<a name="l02213"></a>02213     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cycledown&quot;</span>,Property::Changeable::Always,20);
<a name="l02214"></a>02214     Pint-&gt;SetMinMax(1,1000000);
<a name="l02215"></a>02215     Pint-&gt;Set_help(<span class="stringliteral">&quot;Setting it lower than 100 will be a percentage.&quot;</span>);
<a name="l02216"></a>02216 
<a name="l02217"></a>02217     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;use dynamic core with paging on&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02218"></a>02218     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow dynamic core with 386 paging enabled. This is generally OK for DOS games and Windows 3.1.\n&quot;</span>
<a name="l02219"></a>02219                     <span class="stringliteral">&quot;If the game becomes unstable, turn off this option.\n&quot;</span>
<a name="l02220"></a>02220                     <span class="stringliteral">&quot;WARNING: Do NOT use this option with preemptive multitasking OSes including Windows 95 and Windows NT.&quot;</span>);
<a name="l02221"></a>02221             
<a name="l02222"></a>02222     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore opcode 63&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l02223"></a>02223     Pbool-&gt;Set_help(<span class="stringliteral">&quot;When debugging, do not report illegal opcode 0x63.\n&quot;</span>
<a name="l02224"></a>02224             <span class="stringliteral">&quot;Enable this option to ignore spurious errors while debugging from within Windows 3.1/9x/ME&quot;</span>);
<a name="l02225"></a>02225 
<a name="l02226"></a>02226     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02227"></a>02227     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate Advanced Power Management BIOS calls&quot;</span>);
<a name="l02228"></a>02228 
<a name="l02229"></a>02229     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios pnp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02230"></a>02230     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If emulating ISA PnP BIOS, announce APM BIOS in PnP enumeration.\n&quot;</span>
<a name="l02231"></a>02231             <span class="stringliteral">&quot;Warning: this can cause Windows 95 OSR2 and later to enumerate the APM BIOS twice and cause problems.&quot;</span>);
<a name="l02232"></a>02232 
<a name="l02233"></a>02233     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;apmbios version&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02234"></a>02234     Pstring-&gt;Set_values(apmbiosversions);
<a name="l02235"></a>02235     Pstring-&gt;Set_help(<span class="stringliteral">&quot;What version of the APM BIOS specification to emulate.\n&quot;</span>
<a name="l02236"></a>02236             <span class="stringliteral">&quot;You will need at least APM BIOS v1.1 for emulation to work with Windows 95/98/ME&quot;</span>);
<a name="l02237"></a>02237 
<a name="l02238"></a>02238     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow realmode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02239"></a>02239     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from real mode.&quot;</span>);
<a name="l02240"></a>02240 
<a name="l02241"></a>02241     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow 16-bit protected mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02242"></a>02242     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from 16-bit protected mode.&quot;</span>);
<a name="l02243"></a>02243 
<a name="l02244"></a>02244     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow 32-bit protected mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02245"></a>02245     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from 32-bit protected mode.\n&quot;</span>
<a name="l02246"></a>02246             <span class="stringliteral">&quot;If you want power management in Windows 95/98/ME (beyond using the APM to shutdown the computer) you MUST enable this option.\n&quot;</span>
<a name="l02247"></a>02247             <span class="stringliteral">&quot;Windows 95/98/ME does not support the 16-bit real and protected mode APM BIOS entry points.\n&quot;</span>
<a name="l02248"></a>02248             <span class="stringliteral">&quot;Please note at this time that 32-bit APM is unstable under Windows ME&quot;</span>);
<a name="l02249"></a>02249 
<a name="l02250"></a>02250     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;integration device&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02251"></a>02251     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable DOSBox-X integration I/O device. This can be used by the guest OS to match mouse pointer position, for example. EXPERIMENTAL!&quot;</span>);
<a name="l02252"></a>02252 
<a name="l02253"></a>02253     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;integration device pnp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02254"></a>02254     Pbool-&gt;Set_help(<span class="stringliteral">&quot;List DOSBox-X integration I/O device as part of ISA PnP enumeration. This has no purpose yet.&quot;</span>);
<a name="l02255"></a>02255 
<a name="l02256"></a>02256     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;isapnpbios&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02257"></a>02257     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate ISA Plug &amp; Play BIOS. Enable if using DOSBox-X to run a PnP aware DOS program or if booting Windows 9x.\n&quot;</span>
<a name="l02258"></a>02258             <span class="stringliteral">&quot;Do not disable if Windows 9x is configured around PnP devices, you will likely confuse it.&quot;</span>);
<a name="l02259"></a>02259 
<a name="l02260"></a>02260     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;realbig16&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02261"></a>02261     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow the B (big) bit in real mode. If set, allow the DOS program to set the B bit,\n&quot;</span>
<a name="l02262"></a>02262         <span class="stringliteral">&quot;then jump to realmode with B still set (aka Huge Unreal mode). Needed for Project Angel.&quot;</span>);
<a name="l02263"></a>02263 
<a name="l02264"></a>02264     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;keyboard&quot;</span>,&amp;Null_Init);
<a name="l02265"></a>02265     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;aux&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02266"></a>02266     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable emulation of the 8042 auxiliary port. PS/2 mouse emulation requires this to be enabled.\n&quot;</span>
<a name="l02267"></a>02267             <span class="stringliteral">&quot;You should enable this if you will be running Windows ME or any other OS that does not use the BIOS to receive mouse events.&quot;</span>);
<a name="l02268"></a>02268 
<a name="l02269"></a>02269     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow output port reset&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02270"></a>02270     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allow the application to reset the CPU through the keyboard controller.\n&quot;</span>
<a name="l02271"></a>02271             <span class="stringliteral">&quot;This option is required to allow Windows ME to reboot properly, whereas Windows 9x and earlier\n&quot;</span>
<a name="l02272"></a>02272             <span class="stringliteral">&quot;will reboot without this option using INT 19h&quot;</span>);
<a name="l02273"></a>02273 
<a name="l02274"></a>02274     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;controllertype&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02275"></a>02275     Pstring-&gt;Set_values(controllertypes);
<a name="l02276"></a>02276     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of keyboard controller (and keyboard) attached.\n&quot;</span>
<a name="l02277"></a>02277                       <span class="stringliteral">&quot;auto     Automatically pick according to machine type\n&quot;</span>
<a name="l02278"></a>02278                       <span class="stringliteral">&quot;at       AT (PS/2) type keyboard\n&quot;</span>
<a name="l02279"></a>02279                       <span class="stringliteral">&quot;xt       IBM PC/XT type keyboard\n&quot;</span>
<a name="l02280"></a>02280                       <span class="stringliteral">&quot;pcjr     IBM PCjr type keyboard (only if machine=pcjr)\n&quot;</span>
<a name="l02281"></a>02281                       <span class="stringliteral">&quot;pc98     PC-98 keyboard emulation (only if machine=pc98)&quot;</span>);
<a name="l02282"></a>02282 
<a name="l02283"></a>02283     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;auxdevice&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;intellimouse&quot;</span>);
<a name="l02284"></a>02284     Pstring-&gt;Set_values(auxdevices);
<a name="l02285"></a>02285     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of PS/2 mouse attached to the AUX port&quot;</span>);
<a name="l02286"></a>02286 
<a name="l02287"></a>02287     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;pci&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>); <span class="comment">//PCI bus</span>
<a name="l02288"></a>02288 
<a name="l02289"></a>02289     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;voodoo&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02290"></a>02290     Pstring-&gt;Set_values(voodoo_settings);
<a name="l02291"></a>02291     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable VOODOO support.&quot;</span>);
<a name="l02292"></a>02292 
<a name="l02293"></a>02293     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;mixer&quot;</span>,&amp;Null_Init);
<a name="l02294"></a>02294     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;nosound&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02295"></a>02295     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable silent mode, sound is still emulated though.&quot;</span>);
<a name="l02296"></a>02296 
<a name="l02297"></a>02297     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sample accurate&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02298"></a>02298     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable sample accurate mixing, at the expense of some emulation performance. Enable this option for DOS games and demos that\n&quot;</span>
<a name="l02299"></a>02299             <span class="stringliteral">&quot;require such accuracy for correct Tandy/OPL output including digitized speech. This option can also help eliminate minor\n&quot;</span>
<a name="l02300"></a>02300             <span class="stringliteral">&quot;errors in Gravis Ultrasound emulation that result in random echo/attenuation effects.&quot;</span>);
<a name="l02301"></a>02301 
<a name="l02302"></a>02302     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;swapstereo&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>); 
<a name="l02303"></a>02303     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Swaps the left and right stereo channels.&quot;</span>); 
<a name="l02304"></a>02304 
<a name="l02305"></a>02305     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rate&quot;</span>,Property::Changeable::OnlyAtStart,44100);
<a name="l02306"></a>02306     Pint-&gt;SetMinMax(8000,192000);
<a name="l02307"></a>02307     Pint-&gt;Set_help(<span class="stringliteral">&quot;Mixer sample rate, setting any device&#39;s rate higher than this will probably lower their sound quality.&quot;</span>);
<a name="l02308"></a>02308 
<a name="l02309"></a>02309     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;blocksize&quot;</span>,Property::Changeable::OnlyAtStart,1024);
<a name="l02310"></a>02310     Pint-&gt;Set_values(blocksizes);
<a name="l02311"></a>02311     Pint-&gt;Set_help(<span class="stringliteral">&quot;Mixer block size, larger blocks might help sound stuttering but sound will also be more lagged.&quot;</span>);
<a name="l02312"></a>02312 
<a name="l02313"></a>02313     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;prebuffer&quot;</span>,Property::Changeable::OnlyAtStart,25);
<a name="l02314"></a>02314     Pint-&gt;SetMinMax(0,100);
<a name="l02315"></a>02315     Pint-&gt;Set_help(<span class="stringliteral">&quot;How many milliseconds of data to keep on top of the blocksize.&quot;</span>);
<a name="l02316"></a>02316 
<a name="l02317"></a>02317     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;midi&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02318"></a>02318 
<a name="l02319"></a>02319     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mpu401&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;intelligent&quot;</span>);
<a name="l02320"></a>02320     Pstring-&gt;Set_values(mputypes);
<a name="l02321"></a>02321     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of MPU-401 to emulate.&quot;</span>);
<a name="l02322"></a>02322 
<a name="l02323"></a>02323     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;mpubase&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*default*/</span>);
<a name="l02324"></a>02324     Phex-&gt;Set_values(mpubases);
<a name="l02325"></a>02325     Phex-&gt;Set_help(<span class="stringliteral">&quot;The IO address of the MPU-401.\n&quot;</span>
<a name="l02326"></a>02326                    <span class="stringliteral">&quot;Set to 0 to use a default I/O address.\n&quot;</span>
<a name="l02327"></a>02327                    <span class="stringliteral">&quot;300h to 330h are for use with IBM PC mode.\n&quot;</span>
<a name="l02328"></a>02328                    <span class="stringliteral">&quot;C0D0h to F8D0h (in steps of 800h) are for use with NEC PC-98 mode (MPU98).\n&quot;</span>
<a name="l02329"></a>02329                    <span class="stringliteral">&quot;80D2h through 80DEh are for use with NEC PC-98 Sound Blaster 16 MPU-401 emulation.\n&quot;</span>
<a name="l02330"></a>02330                    <span class="stringliteral">&quot;If not assigned (0), 330h is the default for IBM PC and E0D0h is the default for PC-98.&quot;</span>);
<a name="l02331"></a>02331 
<a name="l02332"></a>02332     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mididevice&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02333"></a>02333     Pstring-&gt;Set_values(devices);
<a name="l02334"></a>02334     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Device that will receive the MIDI data from MPU-401.&quot;</span>);
<a name="l02335"></a>02335 
<a name="l02336"></a>02336     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;midiconfig&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02337"></a>02337     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Special configuration options for the device driver. This is usually the id or part of the name of the device you want to use (find the id/name with mixer/listmidi).\n&quot;</span>
<a name="l02338"></a>02338                       <span class="stringliteral">&quot;Or in the case of coreaudio or synth, you can specify a soundfont here.\n&quot;</span>
<a name="l02339"></a>02339                       <span class="stringliteral">&quot;When using a Roland MT-32 rev. 0 as midi output device, some games may require a delay in order to prevent &#39;buffer overflow&#39; issues.\n&quot;</span>
<a name="l02340"></a>02340                       <span class="stringliteral">&quot;In that case, add &#39;delaysysex&#39;, for example: midiconfig=2 delaysysex\n&quot;</span>
<a name="l02341"></a>02341                       <span class="stringliteral">&quot;See the README/Manual for more details.&quot;</span>);
<a name="l02342"></a>02342 
<a name="l02343"></a>02343     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;samplerate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02344"></a>02344     Pint-&gt;Set_values(rates);
<a name="l02345"></a>02345     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate for MIDI synthesizer, if applicable.&quot;</span>);
<a name="l02346"></a>02346     
<a name="l02347"></a>02347     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mpuirq&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02348"></a>02348     Pint-&gt;SetMinMax(-1,15);
<a name="l02349"></a>02349     Pint-&gt;Set_help(<span class="stringliteral">&quot;MPU-401 IRQ. -1 to automatically choose.&quot;</span>);
<a name="l02350"></a>02350 
<a name="l02351"></a>02351     <span class="comment">/* mt32.romdir added from DOSBox ECE by request. This romdir code taken from DOSBox ECE */</span>
<a name="l02352"></a>02352     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.romdir&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02353"></a>02353     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Name of the directory where MT-32 Control and PCM ROM files can be found. Emulation requires these files to work.\n&quot;</span>
<a name="l02354"></a>02354             <span class="stringliteral">&quot;  Accepted file names are as follows:\n&quot;</span>
<a name="l02355"></a>02355             <span class="stringliteral">&quot;    MT32_CONTROL.ROM or CM32L_CONTROL.ROM - control ROM file.\n&quot;</span>
<a name="l02356"></a>02356             <span class="stringliteral">&quot;    MT32_PCM.ROM or CM32L_PCM.ROM - PCM ROM file.&quot;</span>);
<a name="l02357"></a>02357 
<a name="l02358"></a>02358     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.reverse.stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02359"></a>02359     Pstring-&gt;Set_values(mt32ReverseStereo);
<a name="l02360"></a>02360     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Reverse stereo channels for MT-32 output&quot;</span>);
<a name="l02361"></a>02361 
<a name="l02362"></a>02362     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.verbose&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02363"></a>02363     Pstring-&gt;Set_values(mt32log);
<a name="l02364"></a>02364     Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 debug logging&quot;</span>);
<a name="l02365"></a>02365 
<a name="l02366"></a>02366     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.thread&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02367"></a>02367     Pstring-&gt;Set_values(mt32thread);
<a name="l02368"></a>02368     Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 rendering in separate thread&quot;</span>);
<a name="l02369"></a>02369 
<a name="l02370"></a>02370     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.dac&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02371"></a>02371     Pstring-&gt;Set_values(mt32DACModes);
<a name="l02372"></a>02372     Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 DAC input emulation mode\n&quot;</span>
<a name="l02373"></a>02373         <span class="stringliteral">&quot;Nice = 0 - default\n&quot;</span>
<a name="l02374"></a>02374         <span class="stringliteral">&quot;Produces samples at double the volume, without tricks.\n&quot;</span>
<a name="l02375"></a>02375         <span class="stringliteral">&quot;Higher quality than the real devices\n\n&quot;</span>
<a name="l02376"></a>02376 
<a name="l02377"></a>02377         <span class="stringliteral">&quot;Pure = 1\n&quot;</span>
<a name="l02378"></a>02378         <span class="stringliteral">&quot;Produces samples that exactly match the bits output from the emulated LA32.\n&quot;</span>
<a name="l02379"></a>02379         <span class="stringliteral">&quot;Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)\n&quot;</span>
<a name="l02380"></a>02380         <span class="stringliteral">&quot;Much less likely to overdrive than any other mode.\n&quot;</span>
<a name="l02381"></a>02381         <span class="stringliteral">&quot;Half the volume of any of the other modes, meaning its volume relative to the reverb\n&quot;</span>
<a name="l02382"></a>02382         <span class="stringliteral">&quot;output when mixed together directly will sound wrong. So, reverb level must be lowered.\n&quot;</span>
<a name="l02383"></a>02383         <span class="stringliteral">&quot;Perfect for developers while debugging :)\n\n&quot;</span>
<a name="l02384"></a>02384 
<a name="l02385"></a>02385         <span class="stringliteral">&quot;GENERATION1 = 2\n&quot;</span>
<a name="l02386"></a>02386         <span class="stringliteral">&quot;Re-orders the LA32 output bits as in early generation MT-32s (according to Wikipedia).\n&quot;</span>
<a name="l02387"></a>02387         <span class="stringliteral">&quot;Bit order at DAC (where each number represents the original LA32 output bit number, and XX means the bit is always low):\n&quot;</span>
<a name="l02388"></a>02388         <span class="stringliteral">&quot;15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 XX\n\n&quot;</span>
<a name="l02389"></a>02389 
<a name="l02390"></a>02390         <span class="stringliteral">&quot;GENERATION2 = 3\n&quot;</span>
<a name="l02391"></a>02391         <span class="stringliteral">&quot;Re-orders the LA32 output bits as in later geneerations (personally confirmed on my CM-32L - KG).\n&quot;</span>
<a name="l02392"></a>02392         <span class="stringliteral">&quot;Bit order at DAC (where each number represents the original LA32 output bit number):\n&quot;</span>
<a name="l02393"></a>02393         <span class="stringliteral">&quot;15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 14\n&quot;</span>);
<a name="l02394"></a>02394 
<a name="l02395"></a>02395     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.reverb.mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02396"></a>02396     Pstring-&gt;Set_values(mt32reverbModes);
<a name="l02397"></a>02397     Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb mode&quot;</span>);
<a name="l02398"></a>02398 
<a name="l02399"></a>02399     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.reverb.time&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l02400"></a>02400     Pint-&gt;Set_values(mt32reverbTimes);
<a name="l02401"></a>02401     Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb decaying time&quot;</span>); 
<a name="l02402"></a>02402 
<a name="l02403"></a>02403     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.reverb.level&quot;</span>,Property::Changeable::WhenIdle,3);
<a name="l02404"></a>02404     Pint-&gt;Set_values(mt32reverbLevels);
<a name="l02405"></a>02405     Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb level&quot;</span>);
<a name="l02406"></a>02406 
<a name="l02407"></a>02407     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.partials&quot;</span>,Property::Changeable::WhenIdle,32);
<a name="l02408"></a>02408     Pint-&gt;SetMinMax(0,256);
<a name="l02409"></a>02409     Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 max partials allowed (0-256)&quot;</span>);
<a name="l02410"></a>02410 
<a name="l02411"></a>02411 <span class="preprocessor">#ifdef C_FLUIDSYNTH</span>
<a name="l02412"></a>02412 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">char</span> *fluiddrivers[] = {<span class="stringliteral">&quot;pulseaudio&quot;</span>, <span class="stringliteral">&quot;alsa&quot;</span>, <span class="stringliteral">&quot;oss&quot;</span>, <span class="stringliteral">&quot;coreaudio&quot;</span>, <span class="stringliteral">&quot;dsound&quot;</span>, <span class="stringliteral">&quot;portaudio&quot;</span>, <span class="stringliteral">&quot;sndman&quot;</span>, <span class="stringliteral">&quot;jack&quot;</span>, <span class="stringliteral">&quot;file&quot;</span>, <span class="stringliteral">&quot;default&quot;</span>,0};
<a name="l02413"></a>02413         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.driver&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02414"></a>02414         Pstring-&gt;Set_values(fluiddrivers);
<a name="l02415"></a>02415         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Driver to use with Fluidsynth, not needed under Windows. Available drivers depend on what Fluidsynth was compiled with.&quot;</span>);
<a name="l02416"></a>02416 
<a name="l02417"></a>02417         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.soundfont&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02418"></a>02418         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Soundfont to use with Fluidsynth. One must be specified.&quot;</span>);
<a name="l02419"></a>02419 
<a name="l02420"></a>02420         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.samplerate&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;48000&quot;</span>);
<a name="l02421"></a>02421         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Sample rate to use with Fluidsynth.&quot;</span>);
<a name="l02422"></a>02422 
<a name="l02423"></a>02423         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.gain&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;.6&quot;</span>);
<a name="l02424"></a>02424         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth gain.&quot;</span>);
<a name="l02425"></a>02425 
<a name="l02426"></a>02426         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;fluid.polyphony&quot;</span>,Property::Changeable::WhenIdle,256);
<a name="l02427"></a>02427         Pint-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth polyphony.&quot;</span>);
<a name="l02428"></a>02428 
<a name="l02429"></a>02429         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.cores&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02430"></a>02430         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth CPU cores to use, or default.&quot;</span>);
<a name="l02431"></a>02431 
<a name="l02432"></a>02432         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.periods&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02433"></a>02433         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth periods, or default.&quot;</span>);
<a name="l02434"></a>02434 
<a name="l02435"></a>02435         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.periodsize&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02436"></a>02436         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth period size, or default.&quot;</span>);
<a name="l02437"></a>02437 
<a name="l02438"></a>02438         <span class="keyword">const</span> <span class="keywordtype">char</span> *fluidreverb[] = {<span class="stringliteral">&quot;no&quot;</span>, <span class="stringliteral">&quot;yes&quot;</span>,0};
<a name="l02439"></a>02439         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.reverb&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;yes&quot;</span>);     
<a name="l02440"></a>02440         Pstring-&gt;Set_values(fluidreverb);
<a name="l02441"></a>02441         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth use reverb.&quot;</span>);
<a name="l02442"></a>02442 
<a name="l02443"></a>02443         <span class="keyword">const</span> <span class="keywordtype">char</span> *fluidchorus[] = {<span class="stringliteral">&quot;no&quot;</span>, <span class="stringliteral">&quot;yes&quot;</span>,0};
<a name="l02444"></a>02444         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.chorus&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;yes&quot;</span>);     
<a name="l02445"></a>02445         Pstring-&gt;Set_values(fluidchorus);
<a name="l02446"></a>02446         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth use chorus.&quot;</span>);
<a name="l02447"></a>02447 
<a name="l02448"></a>02448         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.reverb.roomsize&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;.61&quot;</span>);
<a name="l02449"></a>02449         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth reverb room size.&quot;</span>);
<a name="l02450"></a>02450 
<a name="l02451"></a>02451         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.reverb.damping&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;.23&quot;</span>);
<a name="l02452"></a>02452         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth reverb damping.&quot;</span>);
<a name="l02453"></a>02453 
<a name="l02454"></a>02454         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.reverb.width&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;.76&quot;</span>);
<a name="l02455"></a>02455         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth reverb width.&quot;</span>);
<a name="l02456"></a>02456 
<a name="l02457"></a>02457         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.reverb.level&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;.57&quot;</span>);
<a name="l02458"></a>02458         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth reverb level.&quot;</span>);
<a name="l02459"></a>02459 
<a name="l02460"></a>02460         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;fluid.chorus.number&quot;</span>,Property::Changeable::WhenIdle,3);        
<a name="l02461"></a>02461         Pint-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth chorus voices&quot;</span>);
<a name="l02462"></a>02462 
<a name="l02463"></a>02463         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.chorus.level&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;1.2&quot;</span>);
<a name="l02464"></a>02464         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth chorus level.&quot;</span>);
<a name="l02465"></a>02465 
<a name="l02466"></a>02466         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.chorus.speed&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;.3&quot;</span>);
<a name="l02467"></a>02467         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth chorus speed.&quot;</span>);
<a name="l02468"></a>02468 
<a name="l02469"></a>02469         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;fluid.chorus.depth&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;8.0&quot;</span>);
<a name="l02470"></a>02470         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth chorus depth.&quot;</span>);
<a name="l02471"></a>02471 
<a name="l02472"></a>02472         <span class="keyword">const</span> <span class="keywordtype">char</span> *fluidchorustypes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>,0};
<a name="l02473"></a>02473         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;fluid.chorus.type&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02474"></a>02474         Pint-&gt;Set_values(fluidchorustypes);
<a name="l02475"></a>02475         Pint-&gt;Set_help(<span class="stringliteral">&quot;Fluidsynth chorus type. 0 is sine wave, 1 is triangle wave.&quot;</span>);
<a name="l02476"></a>02476 <span class="preprocessor">#endif</span>
<a name="l02477"></a>02477 <span class="preprocessor"></span>
<a name="l02478"></a>02478     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;sblaster&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02479"></a>02479     
<a name="l02480"></a>02480     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;sbtype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;sb16&quot;</span>);
<a name="l02481"></a>02481     Pstring-&gt;Set_values(sbtypes);
<a name="l02482"></a>02482     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of Sound Blaster to emulate. &#39;gb&#39; is Game Blaster.&quot;</span>);
<a name="l02483"></a>02483 
<a name="l02484"></a>02484     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;sbbase&quot;</span>,Property::Changeable::WhenIdle,0x220);
<a name="l02485"></a>02485     Phex-&gt;Set_values(ios);
<a name="l02486"></a>02486     Phex-&gt;Set_help(<span class="stringliteral">&quot;The IO address of the Sound Blaster.\n&quot;</span>
<a name="l02487"></a>02487                    <span class="stringliteral">&quot;220h to 2E0h are for use with IBM PC Sound Blaster emulation.\n&quot;</span>
<a name="l02488"></a>02488                    <span class="stringliteral">&quot;D2h to DEh are for use with NEC PC-98 Sound Blaster 16 emulation.&quot;</span>);
<a name="l02489"></a>02489 
<a name="l02490"></a>02490     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,7);
<a name="l02491"></a>02491     Pint-&gt;Set_values(irqssb);
<a name="l02492"></a>02492     Pint-&gt;Set_help(<span class="stringliteral">&quot;The IRQ number of the Sound Blaster. Set to -1 to start DOSBox-X with the IRQ unassigned&quot;</span>);
<a name="l02493"></a>02493 
<a name="l02494"></a>02494     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mindma&quot;</span>,Property::Changeable::OnlyAtStart,-1);
<a name="l02495"></a>02495     Pint-&gt;Set_help( <span class="stringliteral">&quot;Minimum DMA transfer left to increase attention across DSP blocks, in milliseconds. Set to -1 for default.\n&quot;</span>
<a name="l02496"></a>02496             <span class="stringliteral">&quot;There are some DOS games/demos that use single-cycle DSP playback in their music tracker and they micromanage\n&quot;</span>
<a name="l02497"></a>02497             <span class="stringliteral">&quot;the DMA transfer per block poorly in a way that causes popping and artifacts. Setting this option to 0 for\n&quot;</span>
<a name="l02498"></a>02498             <span class="stringliteral">&quot;such DOS applications may reduce audible popping and artifacts.&quot;</span>);
<a name="l02499"></a>02499 
<a name="l02500"></a>02500     <span class="comment">/* Sound Blaster IRQ hacks.</span>
<a name="l02501"></a>02501 <span class="comment">     *</span>
<a name="l02502"></a>02502 <span class="comment">     * These hacks reduce emulation accuracy but can be set to work around bugs or mistakes in some old</span>
<a name="l02503"></a>02503 <span class="comment">     * games and demos related to handling the Sound Blaster IRQ.</span>
<a name="l02504"></a>02504 <span class="comment">     *</span>
<a name="l02505"></a>02505 <span class="comment">     * - Saga by Dust (1993):</span>
<a name="l02506"></a>02506 <span class="comment">     *     Sound Blaster support has a fatal flaw in that the Sound Blaster interrupt handler it installs assumes</span>
<a name="l02507"></a>02507 <span class="comment">     *     DS == CS. It uses the DS register to read local variables needed to manage the Sound Blaster card but</span>
<a name="l02508"></a>02508 <span class="comment">     *     it makes no attempt to push DS and then load the DS segment value it needs. While the demo may seem to</span>
<a name="l02509"></a>02509 <span class="comment">     *     run normally at first, eventually the interrupt is fired at just the right time to catch the demo in</span>
<a name="l02510"></a>02510 <span class="comment">     *     the middle of it&#39;s graphics routines (DS=A000). Since the ISR uses DS to load the Sound Blaster DSP</span>
<a name="l02511"></a>02511 <span class="comment">     *     I/O port, it reads some random value from *video RAM* and then hangs in a loop waiting for that I/O</span>
<a name="l02512"></a>02512 <span class="comment">     *     port to clear bit 7! Setting &#39;cs_equ_ds&#39; works around that bug by instructing PIC emulation not to</span>
<a name="l02513"></a>02513 <span class="comment">     *     fire the interrupt unless segment registers CS and DS match. */</span>
<a name="l02514"></a>02514     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;irq hack&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;none&quot;</span>);
<a name="l02515"></a>02515     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specify a hack related to the Sound Blaster IRQ to avoid crashes in a handful of games and demos.\n&quot;</span>
<a name="l02516"></a>02516             <span class="stringliteral">&quot;    none                   Emulate IRQs normally\n&quot;</span>
<a name="l02517"></a>02517             <span class="stringliteral">&quot;    cs_equ_ds              Do not fire IRQ unless two CPU segment registers match: CS == DS. Read Dosbox-X Wiki or source code for details.&quot;</span>);
<a name="l02518"></a>02518 
<a name="l02519"></a>02519     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dma&quot;</span>,Property::Changeable::WhenIdle,1);
<a name="l02520"></a>02520     Pint-&gt;Set_values(dmassb);
<a name="l02521"></a>02521     Pint-&gt;Set_help(<span class="stringliteral">&quot;The DMA number of the Sound Blaster. Set to -1 to start DOSBox-X with the DMA unassigned&quot;</span>);
<a name="l02522"></a>02522 
<a name="l02523"></a>02523     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hdma&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l02524"></a>02524     Pint-&gt;Set_values(dmassb);
<a name="l02525"></a>02525     Pint-&gt;Set_help(<span class="stringliteral">&quot;The High DMA number of the Sound Blaster. Set to -1 to start DOSBox-X with the High DMA unassigned&quot;</span>);
<a name="l02526"></a>02526 
<a name="l02527"></a>02527     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pic unmask irq&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02528"></a>02528     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the Sound Blaster IRQ already unmasked at the PIC.\n&quot;</span>
<a name="l02529"></a>02529             <span class="stringliteral">&quot;Some early DOS games/demos that support Sound Blaster expect the IRQ to fire but make\n&quot;</span>
<a name="l02530"></a>02530             <span class="stringliteral">&quot;no attempt to unmask the IRQ. If audio cuts out no matter what IRQ you try, then try\n&quot;</span>
<a name="l02531"></a>02531             <span class="stringliteral">&quot;setting this option.\n&quot;</span>
<a name="l02532"></a>02532             <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l02533"></a>02533             <span class="stringliteral">&quot;   Public NMI \&quot;jump\&quot; demo (1992)&quot;</span>);
<a name="l02534"></a>02534 
<a name="l02535"></a>02535     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable speaker&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02536"></a>02536     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the Sound Blaster speaker enabled.\n&quot;</span>
<a name="l02537"></a>02537                     <span class="stringliteral">&quot;Sound Blaster Pro and older cards have a speaker disable/enable command.\n&quot;</span>
<a name="l02538"></a>02538                     <span class="stringliteral">&quot;Normally the card boots up with the speaker disabled. If a DOS game or demo\n&quot;</span>
<a name="l02539"></a>02539                     <span class="stringliteral">&quot;attempts to play without enabling the speaker, set this option to true to\n&quot;</span>
<a name="l02540"></a>02540                     <span class="stringliteral">&quot;compensate. This setting has no meaning if emulating a Sound Blaster 16 card.&quot;</span>);
<a name="l02541"></a>02541 
<a name="l02542"></a>02542     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable asp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02543"></a>02543     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the presence of the Sound Blaster 16 Advanced Sound Processor/Creative Sound Processor chip.\n&quot;</span>
<a name="l02544"></a>02544             <span class="stringliteral">&quot;NOTE: This only emulates it&#39;s presence and the basic DSP commands to communicate with it. Actual ASP/CSP functions are not yet implemented.&quot;</span>);
<a name="l02545"></a>02545 
<a name="l02546"></a>02546     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;disable filtering&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02547"></a>02547     Pbool-&gt;Set_help(<span class="stringliteral">&quot;By default DOSBox-X filters Sound Blaster output to emulate lowpass filters and analog output limitations.\n&quot;</span>
<a name="l02548"></a>02548             <span class="stringliteral">&quot;Set this option to true to disable filtering. Note that doing so disables emulation of the Sound Blaster Pro\n&quot;</span>
<a name="l02549"></a>02549             <span class="stringliteral">&quot;output filter and ESS AudioDrive lowpass filter.&quot;</span>);
<a name="l02550"></a>02550 
<a name="l02551"></a>02551     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dsp write buffer status must return 0x7f or 0xff&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02552"></a>02552     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, force port 22Ch (DSP write buffer status) to return 0x7F or 0xFF. If not set, the port\n&quot;</span>
<a name="l02553"></a>02553             <span class="stringliteral">&quot;may return 0x7F or 0xFF depending on what type of Sound Blaster is being emulated.\n&quot;</span>
<a name="l02554"></a>02554             <span class="stringliteral">&quot;Set this option for some early DOS demos that make that assumption about port 22Ch.\n&quot;</span>
<a name="l02555"></a>02555             <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l02556"></a>02556             <span class="stringliteral">&quot;   Overload by Hysteria (1992) - Audio will crackle/saturate (8-bit overflow) except when sbtype=sb16&quot;</span>);
<a name="l02557"></a>02557 
<a name="l02558"></a>02558     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pre-set sbpro stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02559"></a>02559     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the Sound Blaster Pro stereo bit set (in the mixer).\n&quot;</span>
<a name="l02560"></a>02560             <span class="stringliteral">&quot;A few demos support Sound Blaster Pro but forget to set this bit.\n&quot;</span>
<a name="l02561"></a>02561             <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l02562"></a>02562             <span class="stringliteral">&quot;   Inconexia by Iguana (1993)&quot;</span>);
<a name="l02563"></a>02563 
<a name="l02564"></a>02564     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sbmixer&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02565"></a>02565     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow the Sound Blaster mixer to modify the DOSBox-X mixer.&quot;</span>);
<a name="l02566"></a>02566 
<a name="l02567"></a>02567     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;oplmode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02568"></a>02568     Pstring-&gt;Set_values(oplmodes);
<a name="l02569"></a>02569     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of OPL emulation. On &#39;auto&#39; the mode is determined by the &#39;sbtype&#39; setting.\n&quot;</span>
<a name="l02570"></a>02570                         <span class="stringliteral">&quot;All OPL modes are AdLib-compatible, except for &#39;cms&#39; (set &#39;sbtype=none&#39; with &#39;cms&#39; for a Game Blaster).&quot;</span>);
<a name="l02571"></a>02571 
<a name="l02572"></a>02572     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;adlib force timer overflow on detect&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02573"></a>02573     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Adlib/OPL emulation will signal &#39;overflow&#39; on timers after 50 I/O reads.\n&quot;</span>
<a name="l02574"></a>02574             <span class="stringliteral">&quot;This is a temporary hack to work around timing bugs noted in DOSBox-X. Certain\n&quot;</span>
<a name="l02575"></a>02575             <span class="stringliteral">&quot;games (Wolfenstein 3D) poll the Adlib status port a fixed number of times assuming\n&quot;</span>
<a name="l02576"></a>02576             <span class="stringliteral">&quot;that the poll loop takes long enough for the Adlib timer to run out. If the game\n&quot;</span>
<a name="l02577"></a>02577             <span class="stringliteral">&quot;cannot reliably detect Adlib at higher cycles counts, but can reliably detect at\n&quot;</span>
<a name="l02578"></a>02578             <span class="stringliteral">&quot;lower cycles counts, set this option.\n&quot;</span>
<a name="l02579"></a>02579             <span class="stringliteral">&quot;NOTE: Technically this decreases emulation accuracy, however it also reflects the\n&quot;</span>
<a name="l02580"></a>02580             <span class="stringliteral">&quot;      fact that DOSBox-X&#39;s I/O timing code needs some work to better match the\n&quot;</span>
<a name="l02581"></a>02581             <span class="stringliteral">&quot;      slowness of the ISA bus per I/O read in consideration of DOS games. So this\n&quot;</span>
<a name="l02582"></a>02582             <span class="stringliteral">&quot;      option is ON by default.&quot;</span>);
<a name="l02583"></a>02583     <span class="comment">/* NTS: The reason I mention Wolfenstein 3D is that it seems coded not to probe for Sound Blaster unless it</span>
<a name="l02584"></a>02584 <span class="comment">     *      first detects the Adlib at port 0x388. No Adlib, no Sound Blaster. */</span>
<a name="l02585"></a>02585     <span class="comment">/* ^ NTS: To see what I mean, download Wolf3d source code, look at ID_SD.C line 1585 (Adlib detection routine).</span>
<a name="l02586"></a>02586 <span class="comment">     *        Note it sets Timer 1, then reads port 388h 100 times before reading status to detect whether the</span>
<a name="l02587"></a>02587 <span class="comment">     *        timer &quot;overflowed&quot; (fairly typical Adlib detection code).</span>
<a name="l02588"></a>02588 <span class="comment">     *        Some quick math: 8333333Hz ISA BCLK / 6 cycles per read (3 wait states) = 1388888 reads/second possible</span>
<a name="l02589"></a>02589 <span class="comment">     *                         100 I/O reads * (1 / 1388888) = 72us */</span> 
<a name="l02590"></a>02590 
<a name="l02591"></a>02591     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;oplemu&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02592"></a>02592     Pstring-&gt;Set_values(oplemus);
<a name="l02593"></a>02593     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Provider for the OPL emulation. &#39;compat&#39; might provide better quality.\n&quot;</span>
<a name="l02594"></a>02594                 <span class="stringliteral">&quot;&#39;nuked&#39; is the most accurate (but the most CPU-intensive). See oplrate as well.&quot;</span>);
<a name="l02595"></a>02595 
<a name="l02596"></a>02596     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;oplrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02597"></a>02597     Pint-&gt;Set_values(oplrates);
<a name="l02598"></a>02598     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of OPL music emulation. Use 49716 for highest quality (set the mixer rate accordingly).&quot;</span>);
<a name="l02599"></a>02599 
<a name="l02600"></a>02600     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;hardwarebase&quot;</span>,Property::Changeable::WhenIdle,0x220);
<a name="l02601"></a>02601     Phex-&gt;Set_help(<span class="stringliteral">&quot;base address of the real hardware Sound Blaster:\n&quot;</span>\
<a name="l02602"></a>02602         <span class="stringliteral">&quot;210,220,230,240,250,260,280&quot;</span>);
<a name="l02603"></a>02603 
<a name="l02604"></a>02604     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force dsp auto-init&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02605"></a>02605     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Treat all single-cycle DSP commands as auto-init to keep playback going.\n&quot;</span>
<a name="l02606"></a>02606             <span class="stringliteral">&quot;This option is a workaround for DOS games or demos that use single-cycle DSP playback commands and\n&quot;</span>
<a name="l02607"></a>02607             <span class="stringliteral">&quot;have problems with missing the Sound Blaster IRQ under load. Do not enable unless you need this workaround.\n&quot;</span>
<a name="l02608"></a>02608             <span class="stringliteral">&quot;Needed for:\n&quot;</span>
<a name="l02609"></a>02609             <span class="stringliteral">&quot;  - Extreme \&quot;lunatic\&quot; demo (1993)&quot;</span>);
<a name="l02610"></a>02610 
<a name="l02611"></a>02611     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force goldplay&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02612"></a>02612     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always render Sound Blaster output sample-at-a-time. Testing option. You probably don&#39;t want to enable this.&quot;</span>);
<a name="l02613"></a>02613 
<a name="l02614"></a>02614     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;goldplay&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02615"></a>02615     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable goldplay emulation.&quot;</span>);
<a name="l02616"></a>02616 
<a name="l02617"></a>02617     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;goldplay stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02618"></a>02618     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable workaround for goldplay stereo playback. Many DOS demos using this technique\n&quot;</span>
<a name="l02619"></a>02619             <span class="stringliteral">&quot;don&#39;t seem to know they need to double the frequency when programming the DSP time constant for Pro stereo output.\n&quot;</span>
<a name="l02620"></a>02620             <span class="stringliteral">&quot;If stereo playback seems to have artifacts consider enabling this option. For accurate emulation of Sound Blaster\n&quot;</span>
<a name="l02621"></a>02621             <span class="stringliteral">&quot;hardware, disable this option.&quot;</span>);
<a name="l02622"></a>02622 
<a name="l02623"></a>02623     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dsp require interrupt acknowledge&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02624"></a>02624     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, the DSP will halt DMA playback until IRQ acknowledgement occurs even in auto-init mode (SB16 behavior).\n&quot;</span>
<a name="l02625"></a>02625             <span class="stringliteral">&quot;If clear, IRQ acknowledgement will have no effect on auto-init playback (SB Pro and earlier &amp; clone behavior)\n&quot;</span>
<a name="l02626"></a>02626             <span class="stringliteral">&quot;If set to &#39;auto&#39; then behavior is determined by sbtype= setting.\n&quot;</span>
<a name="l02627"></a>02627             <span class="stringliteral">&quot;This is a setting for hardware accuracy in emulation. If audio briefly plays then stops then your DOS game\n&quot;</span>
<a name="l02628"></a>02628             <span class="stringliteral">&quot;and it&#39;s not using IRQ (but using DMA), try setting this option to &#39;false&#39;&quot;</span>);
<a name="l02629"></a>02629 
<a name="l02630"></a>02630     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp write busy delay&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02631"></a>02631     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of time in nanoseconds the DSP chip signals &#39;busy&#39; after writing to the DSP (port 2xCh). Set to -1 to use card-specific defaults.\n&quot;</span>
<a name="l02632"></a>02632             <span class="stringliteral">&quot;WARNING: Setting the value too high (above 20000ns) may have detrimental effects to DOS games that use IRQ 0 and DSP command 0x10 to play audio.\n&quot;</span>
<a name="l02633"></a>02633             <span class="stringliteral">&quot;         Setting the value way too high (above 1000000ns) can cause significant lag in DOS games.&quot;</span>);
<a name="l02634"></a>02634 
<a name="l02635"></a>02635     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;blaster environment variable&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02636"></a>02636     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Whether or not to set the BLASTER environment variable automatically at startup&quot;</span>);
<a name="l02637"></a>02637 
<a name="l02638"></a>02638     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sample rate limits&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02639"></a>02639     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), limit DSP sample rate to what real hardware is limited to&quot;</span>);
<a name="l02640"></a>02640 
<a name="l02641"></a>02641     <span class="comment">/* recommended for:</span>
<a name="l02642"></a>02642 <span class="comment">     *   1992 demo &quot;overload&quot; (if set, Sound Blaster support can run at 24KHz without causing demo to hang in the IRQ 0 timer)</span>
<a name="l02643"></a>02643 <span class="comment">     *   1993 demo &quot;xmas 93&quot; (superiority complex) because the demo&#39;s Sound Blaster mode writes at the timer interrupt rate without polling the DSP to check busy state */</span>
<a name="l02644"></a>02644     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;instant direct dac&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02645"></a>02645     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, direct DAC output commands are instantaneous. This option is intended as a quick fix for\n&quot;</span>
<a name="l02646"></a>02646             <span class="stringliteral">&quot;games or demos that play direct DAC music/sound from the IRQ 0 timer who a) write the DSP command\n&quot;</span>
<a name="l02647"></a>02647             <span class="stringliteral">&quot;and data without polling the DSP to ensure it&#39;s ready or b) can get locked into the IRQ 0 handler\n&quot;</span>
<a name="l02648"></a>02648             <span class="stringliteral">&quot;waiting for DSP status when instructed to play at or beyond the DSP&#39;s maximum direct DAC sample rate.\n&quot;</span>
<a name="l02649"></a>02649             <span class="stringliteral">&quot;This fix allows broken Sound Blaster code to work and should not be enabled unless necessary.&quot;</span>);
<a name="l02650"></a>02650 
<a name="l02651"></a>02651     <span class="comment">/* accuracy emulation: SB16 does not honor SBPro stereo bit in the mixer */</span>
<a name="l02652"></a>02652     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;stereo control with sbpro only&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02653"></a>02653     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Default on. If set, Sound Blaster Pro stereo is not available when emulating sb16 or sb16vibra.\n&quot;</span>
<a name="l02654"></a>02654             <span class="stringliteral">&quot;If clear, sb16 emulation will honor the sbpro stereo bit. Note that Creative SB16 cards do not\n&quot;</span>
<a name="l02655"></a>02655             <span class="stringliteral">&quot;honor the stereo bit, and this option allows DOSBox-X emulate that fact. Accuracy setting.&quot;</span>);
<a name="l02656"></a>02656 
<a name="l02657"></a>02657     <span class="comment">/* NTS: It turns out (SB16 at least) the DSP will periodically set bit 7 (busy) by itself at some</span>
<a name="l02658"></a>02658 <span class="comment">     *      clock rate even if it&#39;s idle. Casual testing on an old Pentium system with a ViBRA shows</span>
<a name="l02659"></a>02659 <span class="comment">     *      it&#39;s possible to see both 0x7F and 0xFF come back if you repeatedly type &quot;i 22c&quot; in DOS</span>
<a name="l02660"></a>02660 <span class="comment">     *      DEBUG.EXE.  FIXME: At what clock rate and duty cycle does this happen? */</span>
<a name="l02661"></a>02661     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle rate&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l02662"></a>02662     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sound Blaster 16 DSP chips appear to go busy periodically at some high clock rate\n&quot;</span>
<a name="l02663"></a>02663             <span class="stringliteral">&quot;whether the DSP is actually doing anything for the system or not. This is an accuracy\n&quot;</span>
<a name="l02664"></a>02664             <span class="stringliteral">&quot;option for Sound Blaster emulation. If this option is nonzero, it will be interpreted\n&quot;</span>
<a name="l02665"></a>02665             <span class="stringliteral">&quot;as the busy cycle rate in Hz. If zero, busy cycle will not be emulated. If -1, sound\n&quot;</span>
<a name="l02666"></a>02666             <span class="stringliteral">&quot;blaster emulation will automatically choose a setting based on the sbtype= setting&quot;</span>);
<a name="l02667"></a>02667 
<a name="l02668"></a>02668     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle always&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l02669"></a>02669     Pint-&gt;Set_help(<span class="stringliteral">&quot;If set, the DSP busy cycle always happens. If clear, DSP busy cycle only happens when\n&quot;</span>
<a name="l02670"></a>02670             <span class="stringliteral">&quot;audio playback is running. Default setting is to pick according to the sound card.&quot;</span>);
<a name="l02671"></a>02671 
<a name="l02672"></a>02672     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle duty&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l02673"></a>02673     Pint-&gt;Set_help(<span class="stringliteral">&quot;If emulating SB16 busy cycle, this value (0 to 100) controls the duty cycle of the busy cycle.\n&quot;</span>
<a name="l02674"></a>02674             <span class="stringliteral">&quot;If this option is set to -1, Sound Blaster emulation will choose a value automatically according\n&quot;</span>
<a name="l02675"></a>02675             <span class="stringliteral">&quot;to sbtype=. If 0, busy cycle emulation is disabled.&quot;</span>);
<a name="l02676"></a>02676 
<a name="l02677"></a>02677     <span class="comment">/* NTS: Confirmed: My Sound Blaster 2.0 (at least) mirrors the DSP on port 22Ch and 22Dh. This option</span>
<a name="l02678"></a>02678 <span class="comment">     *      will only take effect with sbtype sb1 and sb2, so make it enabled by default. Accuracy setting. */</span>
<a name="l02679"></a>02679     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;io port aliasing&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02680"></a>02680     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Sound Blaster ports alias by not decoding the LSB of the I/O port.\n&quot;</span>
<a name="l02681"></a>02681             <span class="stringliteral">&quot;This option only applies when sbtype is set to sb1 or sb2 (not SBPro or SB16).\n&quot;</span>
<a name="l02682"></a>02682             <span class="stringliteral">&quot;This is a hack for the Electromotive Force &#39;Internal Damage&#39; demo which apparently\n&quot;</span>
<a name="l02683"></a>02683             <span class="stringliteral">&quot;relies on this behavior for Sound Blaster output and should be enabled for accuracy in emulation.&quot;</span>);
<a name="l02684"></a>02684 
<a name="l02685"></a>02685     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;gus&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>); <span class="comment">//done</span>
<a name="l02686"></a>02686     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;gus&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);  
<a name="l02687"></a>02687     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable the Gravis Ultrasound emulation.&quot;</span>);
<a name="l02688"></a>02688 
<a name="l02689"></a>02689     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autoamp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02690"></a>02690     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, GF1 output will reduce in volume automatically if the sum of all channels exceeds full volume.\n&quot;</span>
<a name="l02691"></a>02691                     <span class="stringliteral">&quot;If not set, then loud music will clip to full volume just as it would on real hardware.\n&quot;</span>
<a name="l02692"></a>02692                     <span class="stringliteral">&quot;Enable this option for loud music if you want a more pleasing rendition without saturation and distortion.&quot;</span>);
<a name="l02693"></a>02693 
<a name="l02694"></a>02694     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask dma&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02695"></a>02695     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the DMA channel already unmasked at the controller.\n&quot;</span>
<a name="l02696"></a>02696             <span class="stringliteral">&quot;Use this for DOS applications that expect to operate the GUS but forget to unmask the DMA channel.&quot;</span>);
<a name="l02697"></a>02697 
<a name="l02698"></a>02698     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore channel count while active&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02699"></a>02699     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Ignore writes to the active channel count register when the DAC is enabled (bit 1 of GUS reset)\n&quot;</span>
<a name="l02700"></a>02700                     <span class="stringliteral">&quot;This is a HACK for demoscene prod &#39;Ice Fever&#39; without which the music sounds wrong.\n&quot;</span>
<a name="l02701"></a>02701                     <span class="stringliteral">&quot;According to current testing real hardware does not behave this way.&quot;</span>);
<a name="l02702"></a>02702 
<a name="l02703"></a>02703     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pic unmask irq&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02704"></a>02704     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the GUS IRQ already unmasked at the PIC.&quot;</span>);
<a name="l02705"></a>02705 
<a name="l02706"></a>02706     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;startup initialized&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02707"></a>02707     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, start the GF1 in a fully initialized state (as if ULTRINIT had been run).\n&quot;</span>
<a name="l02708"></a>02708                     <span class="stringliteral">&quot;If clear, leave the card in an uninitialized state (as if cold boot).\n&quot;</span>
<a name="l02709"></a>02709                     <span class="stringliteral">&quot;Some DOS games or demoscene productions will hang or fail to use the Ultrasound hardware\n&quot;</span>
<a name="l02710"></a>02710                     <span class="stringliteral">&quot;because they assume the card is initialized and their hardware detect does not fully initialize the card.&quot;</span>);
<a name="l02711"></a>02711 
<a name="l02712"></a>02712     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dma enable on dma control polling&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02713"></a>02713     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, automatically enable GUS DMA transfer bit in specific cases when the DMA control register is being polled.\n&quot;</span>
<a name="l02714"></a>02714                     <span class="stringliteral">&quot;THIS IS A HACK. Some games and demoscene productions need this hack to avoid hanging while uploading sample data\n&quot;</span>
<a name="l02715"></a>02715                     <span class="stringliteral">&quot;to the Gravis Ultrasound due to bugs in their implementation.&quot;</span>);
<a name="l02716"></a>02716 
<a name="l02717"></a>02717     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;clear dma tc irq if excess polling&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02718"></a>02718     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS application is seen polling the IRQ status register rapidly, automatically clear the DMA TC IRQ status.\n&quot;</span>
<a name="l02719"></a>02719             <span class="stringliteral">&quot;This is a hack that should only be used with DOS applications that need it to avoid bugs in their GUS support code.\n&quot;</span>
<a name="l02720"></a>02720             <span class="stringliteral">&quot;Needed for:\n&quot;</span>
<a name="l02721"></a>02721             <span class="stringliteral">&quot;  Warcraft II by Blizzard ............. if using GUS for music and sound, set this option to prevent the game from\n&quot;</span>
<a name="l02722"></a>02722             <span class="stringliteral">&quot;                                        hanging when you click on the buttons in the main menu.&quot;</span>);
<a name="l02723"></a>02723 
<a name="l02724"></a>02724     <span class="comment">/* some DOS demos, especially where the programmers wrote their own tracker, forget to set &quot;master IRQ enable&quot; on the GUS,</span>
<a name="l02725"></a>02725 <span class="comment">     * and then wonder why music isn&#39;t playing. prior to some GUS bugfixes they happend to work anyway because DOSBox also</span>
<a name="l02726"></a>02726 <span class="comment">     * ignored master IRQ enable. you can restore that buggy behavior here.</span>
<a name="l02727"></a>02727 <span class="comment">     *</span>
<a name="l02728"></a>02728 <span class="comment">     * DOS games &amp; demos that need this:</span>
<a name="l02729"></a>02729 <span class="comment">     *   - &quot;Juice&quot; by Psychic Link (writes 0x300 to GUS reset which only enables DAC and takes card out of reset, does not enable IRQ) */</span>
<a name="l02730"></a>02730     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force master irq enable&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02731"></a>02731     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set this option if a DOS game or demo initializes the GUS but is unable to play any music.\n&quot;</span>
<a name="l02732"></a>02732             <span class="stringliteral">&quot;Usually the cause is buggy GUS support that resets the GUS but fails to set the Master IRQ enable bit.&quot;</span>);
<a name="l02733"></a>02733 
<a name="l02734"></a>02734     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;gus panning table&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02735"></a>02735     Pstring-&gt;Set_values(guspantables);
<a name="l02736"></a>02736     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Controls which table or equation is used for the Gravis Ultrasound panning emulation.\n&quot;</span>
<a name="l02737"></a>02737             <span class="stringliteral">&quot;accurate emulation attempts to better reflect how the actual hardware handles panning,\n&quot;</span>
<a name="l02738"></a>02738             <span class="stringliteral">&quot;while the old emulation uses a simpler idealistic mapping.&quot;</span>);
<a name="l02739"></a>02739 
<a name="l02740"></a>02740     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02741"></a>02741     Pint-&gt;Set_values(rates);
<a name="l02742"></a>02742     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of Ultrasound emulation.&quot;</span>);
<a name="l02743"></a>02743 
<a name="l02744"></a>02744     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;gus fixed render rate&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02745"></a>02745     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Gravis Ultrasound audio output is rendered at a fixed sample rate specified by &#39;gusrate&#39;. This can provide better quality than real hardware,\n&quot;</span>
<a name="l02746"></a>02746             <span class="stringliteral">&quot;if desired. Else, Gravis Ultrasound emulation will change the sample rate of it&#39;s output according to the number of active channels, just like real hardware.\n&quot;</span>
<a name="l02747"></a>02747             <span class="stringliteral">&quot;Note: DOSBox-X defaults to &#39;false&#39;, while mainline DOSBox SVN is currently hardcoded to render as if this setting is &#39;true&#39;.&quot;</span>);
<a name="l02748"></a>02748 
<a name="l02749"></a>02749     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusmemsize&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02750"></a>02750     Pint-&gt;SetMinMax(-1,1024);
<a name="l02751"></a>02751     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of RAM on the Gravis Ultrasound in KB. Set to -1 for default.&quot;</span>);
<a name="l02752"></a>02752 
<a name="l02753"></a>02753     Pdouble = secprop-&gt;Add_double(<span class="stringliteral">&quot;gus master volume&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02754"></a>02754     Pdouble-&gt;SetMinMax(-120.0,6.0);
<a name="l02755"></a>02755     Pdouble-&gt;Set_help(<span class="stringliteral">&quot;Master Gravis Ultrasound GF1 volume, in decibels. Reducing the master volume can help with games or demoscene productions where the music is too loud and clipping&quot;</span>);
<a name="l02756"></a>02756 
<a name="l02757"></a>02757     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;gusbase&quot;</span>,Property::Changeable::WhenIdle,0x240);
<a name="l02758"></a>02758     Phex-&gt;Set_values(iosgus);
<a name="l02759"></a>02759     Phex-&gt;Set_help(<span class="stringliteral">&quot;The IO base address of the Gravis Ultrasound.&quot;</span>);
<a name="l02760"></a>02760 
<a name="l02761"></a>02761     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusirq&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l02762"></a>02762     Pint-&gt;Set_values(irqsgus);
<a name="l02763"></a>02763     Pint-&gt;Set_help(<span class="stringliteral">&quot;The IRQ number of the Gravis Ultrasound.&quot;</span>);
<a name="l02764"></a>02764 
<a name="l02765"></a>02765     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusdma&quot;</span>,Property::Changeable::WhenIdle,3);
<a name="l02766"></a>02766     Pint-&gt;Set_values(dmasgus);
<a name="l02767"></a>02767     Pint-&gt;Set_help(<span class="stringliteral">&quot;The DMA channel of the Gravis Ultrasound.&quot;</span>);
<a name="l02768"></a>02768  
<a name="l02769"></a>02769     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;irq hack&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;none&quot;</span>);
<a name="l02770"></a>02770     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specify a hack related to the Gravis Ultrasound IRQ to avoid crashes in a handful of games and demos.\n&quot;</span>
<a name="l02771"></a>02771             <span class="stringliteral">&quot;    none                   Emulate IRQs normally\n&quot;</span>
<a name="l02772"></a>02772             <span class="stringliteral">&quot;    cs_equ_ds              Do not fire IRQ unless two CPU segment registers match: CS == DS. Read Dosbox-X Wiki or source code for details.&quot;</span>);
<a name="l02773"></a>02773 
<a name="l02774"></a>02774     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;gustype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;classic&quot;</span>);
<a name="l02775"></a>02775     Pstring-&gt;Set_values(gustypes);
<a name="l02776"></a>02776     Pstring-&gt;Set_help(  <span class="stringliteral">&quot;Type of Gravis Ultrasound to emulate.\n&quot;</span>
<a name="l02777"></a>02777                 <span class="stringliteral">&quot;classic             Original Gravis Ultrasound chipset\n&quot;</span>
<a name="l02778"></a>02778                 <span class="stringliteral">&quot;classic37           Original Gravis Ultrasound with ICS Mixer (rev 3.7)\n&quot;</span>
<a name="l02779"></a>02779                 <span class="stringliteral">&quot;max                 Gravis Ultrasound MAX emulation (with CS4231 codec)\n&quot;</span>
<a name="l02780"></a>02780                 <span class="stringliteral">&quot;interwave           Gravis Ultrasound Plug &amp; Play (interwave)&quot;</span>);
<a name="l02781"></a>02781 
<a name="l02782"></a>02782     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ultradir&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;C:\\ULTRASND&quot;</span>);
<a name="l02783"></a>02783     Pstring-&gt;Set_help(
<a name="l02784"></a>02784         <span class="stringliteral">&quot;Path to Ultrasound directory. In this directory\n&quot;</span>
<a name="l02785"></a>02785         <span class="stringliteral">&quot;there should be a MIDI directory that contains\n&quot;</span>
<a name="l02786"></a>02786         <span class="stringliteral">&quot;the patch files for GUS playback. Patch sets used\n&quot;</span>
<a name="l02787"></a>02787         <span class="stringliteral">&quot;with Timidity should work fine.&quot;</span>);
<a name="l02788"></a>02788 
<a name="l02789"></a>02789     secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;innova&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02790"></a>02790     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;innova&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02791"></a>02791     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable the Innovation SSI-2001 emulation.&quot;</span>);
<a name="l02792"></a>02792     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;samplerate&quot;</span>,Property::Changeable::WhenIdle,22050);
<a name="l02793"></a>02793     Pint-&gt;Set_values(rates);
<a name="l02794"></a>02794     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of Innovation SSI-2001 emulation&quot;</span>);
<a name="l02795"></a>02795     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;sidbase&quot;</span>,Property::Changeable::WhenIdle,0x280);
<a name="l02796"></a>02796     Phex-&gt;Set_values(sidbaseno);
<a name="l02797"></a>02797     Phex-&gt;Set_help(<span class="stringliteral">&quot;SID base port (typically 280h).&quot;</span>);
<a name="l02798"></a>02798     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;quality&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02799"></a>02799     Pint-&gt;Set_values(qualityno);
<a name="l02800"></a>02800     Pint-&gt;Set_help(<span class="stringliteral">&quot;Set SID emulation quality level (0 to 3).&quot;</span>);
<a name="l02801"></a>02801 
<a name="l02802"></a>02802     secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;speaker&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02803"></a>02803     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pcspeaker&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02804"></a>02804     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PC-Speaker emulation.&quot;</span>);
<a name="l02805"></a>02805 
<a name="l02806"></a>02806     <span class="comment">/* added for &quot;baoxiao-sanguozhi&quot; which for some reason uses both port 61h bit 4 (DRAM refresh) and PIT timer 2 (PC speaker)</span>
<a name="l02807"></a>02807 <span class="comment">     * for game timing IN ADDITION TO the BIOS timer counter in the BIOS data area. Game does not set bit 0 itself, so if the</span>
<a name="l02808"></a>02808 <span class="comment">     * bit wasn&#39;t set, the game will hang when asking for a password. Setting this option to &quot;true&quot; tells the BIOS to start the</span>
<a name="l02809"></a>02809 <span class="comment">     * system with that bit set so games like that can run. [https://github.com/joncampbell123/dosbox-x/issues/1274].</span>
<a name="l02810"></a>02810 <span class="comment">     *</span>
<a name="l02811"></a>02811 <span class="comment">     * Note that setting clock gate enable will not make audible sound through the PC speaker unless bit 1 (output gate enable)</span>
<a name="l02812"></a>02812 <span class="comment">     * is also set. Setting bits [1:0] = to 01 is a way to cycle PIT timer 2 without making audible noise. */</span>
<a name="l02813"></a>02813     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pcspeaker clock gate enable at startup&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02814"></a>02814     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start system with the clock gate (bit 0 of port 61h) on. Needed for some games that use the PC speaker for timing on IBM compatible systems.\n&quot;</span>
<a name="l02815"></a>02815                     <span class="stringliteral">&quot;This option has no effect in PC-98 mode.&quot;</span>);
<a name="l02816"></a>02816 
<a name="l02817"></a>02817     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;initial frequency&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02818"></a>02818     Pint-&gt;Set_help(<span class="stringliteral">&quot;PC speaker PIT timer is programmed to this frequency on startup. If the DOS game\n&quot;</span>
<a name="l02819"></a>02819             <span class="stringliteral">&quot;or demo causes a long audible beep at startup (leaving the gate open) try setting\n&quot;</span>
<a name="l02820"></a>02820             <span class="stringliteral">&quot;this option to 0 to silence the PC speaker until reprogrammed by the demo.\n&quot;</span>
<a name="l02821"></a>02821             <span class="stringliteral">&quot;Set to 0 for some early Abaddon demos including \&quot;Torso\&quot; and \&quot;Cycling\&quot;.&quot;</span>);
<a name="l02822"></a>02822 
<a name="l02823"></a>02823     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pcrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02824"></a>02824     Pint-&gt;Set_values(rates);
<a name="l02825"></a>02825     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the PC-Speaker sound generation.&quot;</span>);
<a name="l02826"></a>02826 
<a name="l02827"></a>02827     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;tandy&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02828"></a>02828     Pstring-&gt;Set_values(tandys);
<a name="l02829"></a>02829     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable Tandy Sound System emulation. For &#39;auto&#39;, emulation is present only if machine is set to &#39;tandy&#39;.&quot;</span>);
<a name="l02830"></a>02830 
<a name="l02831"></a>02831     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;tandyrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02832"></a>02832     Pint-&gt;Set_values(rates);
<a name="l02833"></a>02833     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the Tandy 3-Voice generation.&quot;</span>);
<a name="l02834"></a>02834 
<a name="l02835"></a>02835     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;disney&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02836"></a>02836     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Disney Sound Source emulation. (Covox Voice Master and Speech Thing compatible).&quot;</span>);
<a name="l02837"></a>02837     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ps1audio&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02838"></a>02838     Pstring-&gt;Set_values(ps1opt);
<a name="l02839"></a>02839     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable PS1 audio emulation.&quot;</span>);
<a name="l02840"></a>02840     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;ps1audiorate&quot;</span>,Property::Changeable::OnlyAtStart,22050);
<a name="l02841"></a>02841     Pint-&gt;Set_values(rates);
<a name="l02842"></a>02842     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the PS1 audio emulation.&quot;</span>);
<a name="l02843"></a>02843 
<a name="l02844"></a>02844     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;joystick&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l02845"></a>02845     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;joysticktype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02846"></a>02846     Pstring-&gt;Set_values(joytypes);
<a name="l02847"></a>02847     Pstring-&gt;Set_help(
<a name="l02848"></a>02848         <span class="stringliteral">&quot;Type of joystick to emulate: auto (default), none,\n&quot;</span>
<a name="l02849"></a>02849         <span class="stringliteral">&quot;2axis (supports two joysticks),\n&quot;</span>
<a name="l02850"></a>02850         <span class="stringliteral">&quot;4axis (supports one joystick, first joystick used),\n&quot;</span>
<a name="l02851"></a>02851         <span class="stringliteral">&quot;4axis_2 (supports one joystick, second joystick used),\n&quot;</span>
<a name="l02852"></a>02852         <span class="stringliteral">&quot;fcs (Thrustmaster), ch (CH Flightstick).\n&quot;</span>
<a name="l02853"></a>02853         <span class="stringliteral">&quot;none disables joystick emulation.\n&quot;</span>
<a name="l02854"></a>02854         <span class="stringliteral">&quot;auto chooses emulation depending on real joystick(s).\n&quot;</span>
<a name="l02855"></a>02855         <span class="stringliteral">&quot;(Remember to reset dosbox&#39;s mapperfile if you saved it earlier)&quot;</span>);
<a name="l02856"></a>02856 
<a name="l02857"></a>02857     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;timed&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02858"></a>02858     Pbool-&gt;Set_help(<span class="stringliteral">&quot;enable timed intervals for axis. Experiment with this option, if your joystick drifts (away).&quot;</span>);
<a name="l02859"></a>02859 
<a name="l02860"></a>02860     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autofire&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02861"></a>02861     Pbool-&gt;Set_help(<span class="stringliteral">&quot;continuously fires as long as you keep the button pressed.&quot;</span>);
<a name="l02862"></a>02862 
<a name="l02863"></a>02863     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;swap34&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02864"></a>02864     Pbool-&gt;Set_help(<span class="stringliteral">&quot;swap the 3rd and the 4th axis. can be useful for certain joysticks.&quot;</span>);
<a name="l02865"></a>02865 
<a name="l02866"></a>02866     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;buttonwrap&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02867"></a>02867     Pbool-&gt;Set_help(<span class="stringliteral">&quot;enable button wrapping at the number of emulated buttons.&quot;</span>);
<a name="l02868"></a>02868 
<a name="l02869"></a>02869         <span class="comment">/*improved joystick</span>
<a name="l02870"></a>02870 <span class="comment">         * each axis has its own deadzone and response</span>
<a name="l02871"></a>02871 <span class="comment">         * each axis index can be remapped, e.g. fix poor driver mappings</span>
<a name="l02872"></a>02872 <span class="comment">         */</span>
<a name="l02873"></a>02873 
<a name="l02874"></a>02874         <span class="comment">/* logical axes settings*/</span>
<a name="l02875"></a>02875         std::vector&lt;int&gt; sticks = { 2, 1 };
<a name="l02876"></a>02876         <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0u; i &lt; sticks.size(); i++)
<a name="l02877"></a>02877         {
<a name="l02878"></a>02878                 <span class="keyword">const</span> <span class="keyword">auto</span> count = sticks[i];
<a name="l02879"></a>02879                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; count; j++)
<a name="l02880"></a>02880                 {
<a name="l02881"></a>02881                         <span class="keyword">const</span> <span class="keyword">auto</span> joy = std::to_string(i + 1);
<a name="l02882"></a>02882                         <span class="keyword">const</span> <span class="keyword">auto</span> stick = std::to_string(j + 1);
<a name="l02883"></a>02883                         <span class="keyword">const</span> <span class="keyword">auto</span> name = <span class="stringliteral">&quot;joy&quot;</span> + joy + <span class="stringliteral">&quot;deadzone&quot;</span> + stick;
<a name="l02884"></a>02884                         <span class="keyword">const</span> <span class="keyword">auto</span> help = <span class="stringliteral">&quot;deadzone for joystick &quot;</span> + joy + <span class="stringliteral">&quot; thumbstick &quot;</span> + stick + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02885"></a>02885                         Pdouble = secprop-&gt;Add_double(name, Property::Changeable::WhenIdle, 0.25);
<a name="l02886"></a>02886                         Pdouble-&gt;SetMinMax(0.0, 1.0);
<a name="l02887"></a>02887                         Pdouble-&gt;Set_help(help);
<a name="l02888"></a>02888                 }
<a name="l02889"></a>02889         }
<a name="l02890"></a>02890         <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0u; i &lt; sticks.size(); i++)
<a name="l02891"></a>02891         {
<a name="l02892"></a>02892                 <span class="keyword">const</span> <span class="keyword">auto</span> count = sticks[i];
<a name="l02893"></a>02893                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; count; j++)
<a name="l02894"></a>02894                 {
<a name="l02895"></a>02895                         <span class="keyword">const</span> <span class="keyword">auto</span> joy = std::to_string(i + 1);
<a name="l02896"></a>02896                         <span class="keyword">const</span> <span class="keyword">auto</span> stick = std::to_string(j + 1);
<a name="l02897"></a>02897                         <span class="keyword">const</span> <span class="keyword">auto</span> name = <span class="stringliteral">&quot;joy&quot;</span> + joy + <span class="stringliteral">&quot;response&quot;</span> + stick;
<a name="l02898"></a>02898                         <span class="keyword">const</span> <span class="keyword">auto</span> help = <span class="stringliteral">&quot;response for joystick &quot;</span> + joy + <span class="stringliteral">&quot; thumbstick &quot;</span> + stick + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02899"></a>02899                         Pdouble = secprop-&gt;Add_double(name, Property::Changeable::WhenIdle, 1.0);
<a name="l02900"></a>02900                         Pdouble-&gt;SetMinMax(-5.0, 5.0);
<a name="l02901"></a>02901                         Pdouble-&gt;Set_help(help);
<a name="l02902"></a>02902                 }
<a name="l02903"></a>02903         }
<a name="l02904"></a>02904 
<a name="l02905"></a>02905         <span class="keyword">const</span> <span class="keyword">auto</span> joysticks = 2;
<a name="l02906"></a>02906         <span class="keyword">const</span> <span class="keyword">auto</span> axes = 8;
<a name="l02907"></a>02907         <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; joysticks; i++)
<a name="l02908"></a>02908         {
<a name="l02909"></a>02909                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; axes; j++)
<a name="l02910"></a>02910                 {
<a name="l02911"></a>02911                         <span class="keyword">const</span> <span class="keyword">auto</span> joy = std::to_string(i + 1);
<a name="l02912"></a>02912                         <span class="keyword">const</span> <span class="keyword">auto</span> axis = std::to_string(j);
<a name="l02913"></a>02913                         <span class="keyword">const</span> <span class="keyword">auto</span> propname = <span class="stringliteral">&quot;joy&quot;</span> + joy + <span class="stringliteral">&quot;axis&quot;</span> + axis;
<a name="l02914"></a>02914                         Pint = secprop-&gt;Add_int(propname, Property::Changeable::WhenIdle, j);
<a name="l02915"></a>02915                         Pint-&gt;SetMinMax(0, axes - 1);
<a name="l02916"></a>02916                         <span class="keyword">const</span> <span class="keyword">auto</span> help = <span class="stringliteral">&quot;axis for joystick &quot;</span> + joy + <span class="stringliteral">&quot; axis &quot;</span> + axis + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02917"></a>02917                         Pint-&gt;Set_help(help);
<a name="l02918"></a>02918                 }
<a name="l02919"></a>02919         }
<a name="l02920"></a>02920         <span class="comment">/*physical axes settings*/</span>
<a name="l02921"></a>02921         secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;mapper&quot;</span>, &amp;Null_Init, <span class="keyword">true</span>);
<a name="l02922"></a>02922 
<a name="l02923"></a>02923         <span class="keyword">const</span> <span class="keyword">auto</span> directions = 2;
<a name="l02924"></a>02924         <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; joysticks; i++)
<a name="l02925"></a>02925         {
<a name="l02926"></a>02926                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; axes; j++)
<a name="l02927"></a>02927                 {
<a name="l02928"></a>02928                         <span class="keywordflow">for</span> (<span class="keyword">auto</span> k = 0; k &lt; directions; k++)
<a name="l02929"></a>02929                         {
<a name="l02930"></a>02930                                 <span class="keyword">const</span> <span class="keyword">auto</span> joy = std::to_string(i + 1);
<a name="l02931"></a>02931                                 <span class="keyword">const</span> <span class="keyword">auto</span> axis = std::to_string(j);
<a name="l02932"></a>02932                                 <span class="keyword">const</span> <span class="keyword">auto</span> dir = k == 0 ? <span class="stringliteral">&quot;-&quot;</span> : <span class="stringliteral">&quot;+&quot;</span>;
<a name="l02933"></a>02933                                 <span class="keyword">const</span> <span class="keyword">auto</span> name = <span class="stringliteral">&quot;joy&quot;</span> + joy + <span class="stringliteral">&quot;deadzone&quot;</span> + axis + dir;
<a name="l02934"></a>02934                                 Pdouble = secprop-&gt;Add_double(name, Property::Changeable::WhenIdle, 0.6);
<a name="l02935"></a>02935                                 Pdouble-&gt;SetMinMax(0.0, 1.0);
<a name="l02936"></a>02936                                 <span class="keyword">const</span> <span class="keyword">auto</span> help = <span class="stringliteral">&quot;deadzone for joystick &quot;</span> + joy + <span class="stringliteral">&quot; axis &quot;</span> + axis + dir;
<a name="l02937"></a>02937                                 Pdouble-&gt;Set_help(help);
<a name="l02938"></a>02938                         }
<a name="l02939"></a>02939                 }
<a name="l02940"></a>02940         }
<a name="l02941"></a>02941 
<a name="l02942"></a>02942 
<a name="l02943"></a>02943     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;serial&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02944"></a>02944 
<a name="l02945"></a>02945     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial1&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02946"></a>02946     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;dummy&quot;</span>);
<a name="l02947"></a>02947     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;dummy&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02948"></a>02948     Pstring-&gt;Set_values(serials);
<a name="l02949"></a>02949     Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02950"></a>02950     Pmulti_remain-&gt;Set_help(
<a name="l02951"></a>02951         <span class="stringliteral">&quot;set type of device connected to com port.\n&quot;</span>
<a name="l02952"></a>02952         <span class="stringliteral">&quot;Can be disabled, dummy, modem, nullmodem, directserial.\n&quot;</span>
<a name="l02953"></a>02953         <span class="stringliteral">&quot;Additional parameters must be in the same line in the form of\n&quot;</span>
<a name="l02954"></a>02954         <span class="stringliteral">&quot;parameter:value. Parameter for all types is irq (optional).\n&quot;</span>
<a name="l02955"></a>02955         <span class="stringliteral">&quot;for directserial: realport (required), rxdelay (optional).\n&quot;</span>
<a name="l02956"></a>02956         <span class="stringliteral">&quot;                 (realport:COM1 realport:ttyS0).\n&quot;</span>
<a name="l02957"></a>02957         <span class="stringliteral">&quot;for modem: listenport (optional).\n&quot;</span>
<a name="l02958"></a>02958         <span class="stringliteral">&quot;for nullmodem: server, rxdelay, txdelay, telnet, usedtr,\n&quot;</span>
<a name="l02959"></a>02959         <span class="stringliteral">&quot;               transparent, port, inhsocket, nonlocal (all optional).\n&quot;</span>
<a name="l02960"></a>02960         <span class="stringliteral">&quot;               connections are limited to localhost unless you specify nonlocal:1\n&quot;</span>
<a name="l02961"></a>02961         <span class="stringliteral">&quot;Example: serial1=modem listenport:5000&quot;</span>);
<a name="l02962"></a>02962 
<a name="l02963"></a>02963     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial2&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02964"></a>02964     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;dummy&quot;</span>);
<a name="l02965"></a>02965     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;dummy&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02966"></a>02966     Pstring-&gt;Set_values(serials);
<a name="l02967"></a>02967     Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02968"></a>02968     Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02969"></a>02969 
<a name="l02970"></a>02970     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial3&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02971"></a>02971     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02972"></a>02972     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;disabled&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02973"></a>02973     Pstring-&gt;Set_values(serials);
<a name="l02974"></a>02974     Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02975"></a>02975     Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02976"></a>02976 
<a name="l02977"></a>02977     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial4&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02978"></a>02978     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02979"></a>02979     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;disabled&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02980"></a>02980     Pstring-&gt;Set_values(serials);
<a name="l02981"></a>02981     Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02982"></a>02982     Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02983"></a>02983 
<a name="l02984"></a>02984     Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;phonebookfile&quot;</span>, Property::Changeable::OnlyAtStart, <span class="stringliteral">&quot;phonebook-&quot;</span> VERSION <span class="stringliteral">&quot;.txt&quot;</span>);
<a name="l02985"></a>02985     Pstring-&gt;Set_help(<span class="stringliteral">&quot;File used to map fake phone numbers to addresses.&quot;</span>);
<a name="l02986"></a>02986 
<a name="l02987"></a>02987     <span class="comment">// printer redirection parameters</span>
<a name="l02988"></a>02988     secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;printer&quot;</span>, &amp;Null_Init);
<a name="l02989"></a>02989     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;printer&quot;</span>, Property::Changeable::WhenIdle, <span class="keyword">true</span>);
<a name="l02990"></a>02990     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable printer emulation.&quot;</span>);
<a name="l02991"></a>02991     <span class="comment">//secprop-&gt;Add_string(&quot;fontpath&quot;,&quot;%%windir%%\\fonts&quot;);</span>
<a name="l02992"></a>02992     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dpi&quot;</span>, Property::Changeable::WhenIdle, 360);
<a name="l02993"></a>02993     Pint-&gt;Set_help(<span class="stringliteral">&quot;Resolution of printer (default 360).&quot;</span>);
<a name="l02994"></a>02994     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;width&quot;</span>, Property::Changeable::WhenIdle, 85);
<a name="l02995"></a>02995     Pint-&gt;Set_help(<span class="stringliteral">&quot;Width of paper in 1/10 inch (default 85 = 8.5&#39;&#39;).&quot;</span>);
<a name="l02996"></a>02996     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;height&quot;</span>, Property::Changeable::WhenIdle, 110);
<a name="l02997"></a>02997     Pint-&gt;Set_help(<span class="stringliteral">&quot;Height of paper in 1/10 inch (default 110 = 11.0&#39;&#39;).&quot;</span>);
<a name="l02998"></a>02998 <span class="preprocessor">#ifdef C_LIBPNG</span>
<a name="l02999"></a>02999 <span class="preprocessor"></span>    Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;printoutput&quot;</span>, Property::Changeable::WhenIdle, <span class="stringliteral">&quot;png&quot;</span>);
<a name="l03000"></a>03000 <span class="preprocessor">#else</span>
<a name="l03001"></a>03001 <span class="preprocessor"></span>    Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;printoutput&quot;</span>, Property::Changeable::WhenIdle, <span class="stringliteral">&quot;ps&quot;</span>);
<a name="l03002"></a>03002 <span class="preprocessor">#endif</span>
<a name="l03003"></a>03003 <span class="preprocessor"></span>    Pstring-&gt;Set_help(<span class="stringliteral">&quot;Output method for finished pages: \n&quot;</span>
<a name="l03004"></a>03004 #ifdef C_LIBPNG
<a name="l03005"></a>03005         <span class="stringliteral">&quot;  png     : Creates PNG images (default)\n&quot;</span>
<a name="l03006"></a>03006 #endif
<a name="l03007"></a>03007         <span class="stringliteral">&quot;  ps      : Creates PostScript\n&quot;</span>
<a name="l03008"></a>03008         <span class="stringliteral">&quot;  bmp     : Creates BMP images (very huge files, not recommended)\n&quot;</span>
<a name="l03009"></a>03009 #<span class="keywordflow">if</span> defined (WIN32)
<a name="l03010"></a>03010         <span class="stringliteral">&quot;  printer : Send to an actual printer (Print dialog will appear)&quot;</span>
<a name="l03011"></a>03011 #endif
<a name="l03012"></a>03012     );
<a name="l03013"></a>03013 
<a name="l03014"></a>03014     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;multipage&quot;</span>, Property::Changeable::WhenIdle, <span class="keyword">false</span>);
<a name="l03015"></a>03015     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Adds all pages to one PostScript file or printer job until CTRL-F2 is pressed.&quot;</span>);
<a name="l03016"></a>03016 
<a name="l03017"></a>03017     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;docpath&quot;</span>, Property::Changeable::WhenIdle, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l03018"></a>03018     Pstring-&gt;Set_help(<span class="stringliteral">&quot;The path where the output files are stored.&quot;</span>);
<a name="l03019"></a>03019 
<a name="l03020"></a>03020     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;timeout&quot;</span>, Property::Changeable::WhenIdle, 0);
<a name="l03021"></a>03021     Pint-&gt;Set_help(<span class="stringliteral">&quot;(in milliseconds) if nonzero: the time the page will be ejected automatically after when no more data arrives at the printer.&quot;</span>);
<a name="l03022"></a>03022 
<a name="l03023"></a>03023     <span class="comment">// parallel ports</span>
<a name="l03024"></a>03024     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;parallel&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l03025"></a>03025     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel1&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l03026"></a>03026     Pstring-&gt;Set_help(
<a name="l03027"></a>03027             <span class="stringliteral">&quot;parallel1-3 -- set type of device connected to lpt port.\n&quot;</span>
<a name="l03028"></a>03028             <span class="stringliteral">&quot;Can be:\n&quot;</span>
<a name="l03029"></a>03029             <span class="stringliteral">&quot;   reallpt (direct parallel port passthrough),\n&quot;</span>
<a name="l03030"></a>03030             <span class="stringliteral">&quot;   file (records data to a file or passes it to a device),\n&quot;</span>
<a name="l03031"></a>03031             <span class="stringliteral">&quot;   printer (virtual dot-matrix printer, see [printer] section)\n&quot;</span>
<a name="l03032"></a>03032             <span class="stringliteral">&quot;       disney (attach Disney Sound Source emulation to this port)\n&quot;</span>
<a name="l03033"></a>03033             <span class="stringliteral">&quot;Additional parameters must be in the same line in the form of\n&quot;</span>
<a name="l03034"></a>03034             <span class="stringliteral">&quot;parameter:value.\n&quot;</span>
<a name="l03035"></a>03035             <span class="stringliteral">&quot;  for reallpt:\n&quot;</span>
<a name="l03036"></a>03036             <span class="stringliteral">&quot;  Windows:\n&quot;</span>
<a name="l03037"></a>03037             <span class="stringliteral">&quot;    realbase (the base address of your real parallel port).\n&quot;</span>
<a name="l03038"></a>03038             <span class="stringliteral">&quot;      Default: 378\n&quot;</span>
<a name="l03039"></a>03039             <span class="stringliteral">&quot;    ecpbase (base address of the ECP registers, optional).\n&quot;</span>
<a name="l03040"></a>03040             <span class="stringliteral">&quot;  Linux: realport (the parallel port device i.e. /dev/parport0).\n&quot;</span>
<a name="l03041"></a>03041             <span class="stringliteral">&quot;  for file: \n&quot;</span>
<a name="l03042"></a>03042             <span class="stringliteral">&quot;    dev:&lt;devname&gt; (i.e. dev:lpt1) to forward data to a device,\n&quot;</span>
<a name="l03043"></a>03043             <span class="stringliteral">&quot;    or append:&lt;file&gt; appends data to the specified file.\n&quot;</span>
<a name="l03044"></a>03044             <span class="stringliteral">&quot;    Without the above parameters data is written to files in the capture dir.\n&quot;</span>
<a name="l03045"></a>03045             <span class="stringliteral">&quot;    Additional parameters: timeout:&lt;milliseconds&gt; = how long to wait before\n&quot;</span>
<a name="l03046"></a>03046             <span class="stringliteral">&quot;    closing the file on inactivity (default:500), addFF to add a formfeed when\n&quot;</span>
<a name="l03047"></a>03047             <span class="stringliteral">&quot;    closing, addLF to add a linefeed if the app doesn&#39;t, cp:&lt;codepage number&gt;\n&quot;</span>
<a name="l03048"></a>03048             <span class="stringliteral">&quot;    to perform codepage translation, i.e. cp:437\n&quot;</span>
<a name="l03049"></a>03049             <span class="stringliteral">&quot;  for printer:\n&quot;</span>
<a name="l03050"></a>03050             <span class="stringliteral">&quot;    printer still has it&#39;s own configuration section above.&quot;</span>
<a name="l03051"></a>03051     );
<a name="l03052"></a>03052     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel2&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l03053"></a>03053     Pstring-&gt;Set_help(<span class="stringliteral">&quot;see parallel1&quot;</span>);
<a name="l03054"></a>03054     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel3&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l03055"></a>03055     Pstring-&gt;Set_help(<span class="stringliteral">&quot;see parallel1&quot;</span>);
<a name="l03056"></a>03056 
<a name="l03057"></a>03057     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dongle&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03058"></a>03058     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable dongle&quot;</span>);
<a name="l03059"></a>03059 
<a name="l03060"></a>03060     <span class="comment">/* All the DOS Related stuff, which will eventually start up in the shell */</span>
<a name="l03061"></a>03061     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;dos&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l03062"></a>03062     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;xms&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03063"></a>03063     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable XMS support.&quot;</span>);
<a name="l03064"></a>03064 
<a name="l03065"></a>03065     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;xms handles&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l03066"></a>03066     Pint-&gt;Set_help(<span class="stringliteral">&quot;Number of XMS handles available for the DOS environment, or 0 to use a reasonable default&quot;</span>);
<a name="l03067"></a>03067 
<a name="l03068"></a>03068     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;shell configuration as commands&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03069"></a>03069     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow entering dosbox-x.conf configuration parameters as shell commands to get and set settings.\n&quot;</span>
<a name="l03070"></a>03070                     <span class="stringliteral">&quot;This is disabled by default to avoid conflicts between commands and executables.\n&quot;</span>
<a name="l03071"></a>03071                     <span class="stringliteral">&quot;It is recommended to get and set dosbox-x.conf settings using the CONFIG command instead.\n&quot;</span>
<a name="l03072"></a>03072                     <span class="stringliteral">&quot;Compatibility with DOSBox SVN can be improved by enabling this option.&quot;</span>);
<a name="l03073"></a>03073 
<a name="l03074"></a>03074     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;hma&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03075"></a>03075     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Report through XMS that HMA exists (not necessarily available)&quot;</span>);
<a name="l03076"></a>03076 
<a name="l03077"></a>03077     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;hma allow reservation&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03078"></a>03078     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow TSR and application (anything other than the DOS kernel) to request control of the HMA.\n&quot;</span>
<a name="l03079"></a>03079             <span class="stringliteral">&quot;They will not be able to request control however if the DOS kernel is configured to occupy the HMA (DOS=HIGH)&quot;</span>);
<a name="l03080"></a>03080 
<a name="l03081"></a>03081     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hard drive data rate limit&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l03082"></a>03082     Pint-&gt;Set_help(<span class="stringliteral">&quot;Slow down (limit) hard disk throughput. This setting controls the limit in bytes/second.\n&quot;</span>
<a name="l03083"></a>03083                    <span class="stringliteral">&quot;Set to 0 to disable the limit, or -1 to use a reasonable default.&quot;</span>);
<a name="l03084"></a>03084 
<a name="l03085"></a>03085     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;drive z is remote&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l03086"></a>03086     Pstring-&gt;Set_values(truefalseautoopt);
<a name="l03087"></a>03087     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, DOS will report drive Z as remote. If not set, DOS will report drive Z as local.\n&quot;</span>
<a name="l03088"></a>03088                       <span class="stringliteral">&quot;If auto (default), DOS will report drive Z as remote or local depending on the program.\n&quot;</span>
<a name="l03089"></a>03089                       <span class="stringliteral">&quot;Set this option to true to prevent SCANDISK.EXE from attempting scan and repair drive Z:\n&quot;</span>
<a name="l03090"></a>03090                       <span class="stringliteral">&quot;which is impossible since Z: is a virtual drive not backed by a disk filesystem.&quot;</span>);
<a name="l03091"></a>03091 
<a name="l03092"></a>03092     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hma minimum allocation&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l03093"></a>03093     Pint-&gt;Set_help(<span class="stringliteral">&quot;Minimum allocation size for HMA in bytes (equivalent to /HMAMIN= parameter).&quot;</span>);
<a name="l03094"></a>03094 
<a name="l03095"></a>03095     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ansi.sys&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03096"></a>03096     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (by default), ANSI.SYS emulation is on. If clear, ANSI.SYS is not emulated and will not appear to be installed.\n&quot;</span>
<a name="l03097"></a>03097                     <span class="stringliteral">&quot;NOTE: This option has no effect in PC-98 mode where MS-DOS systems integrate ANSI.SYS into the DOS kernel.&quot;</span>);
<a name="l03098"></a>03098 
<a name="l03099"></a>03099     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;log console&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03100"></a>03100     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, log DOS CON output to the log file.&quot;</span>);
<a name="l03101"></a>03101 
<a name="l03102"></a>03102     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dos sda size&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l03103"></a>03103     Pint-&gt;Set_help(<span class="stringliteral">&quot;SDA (swappable data area) size, in bytes. Set to 0 to use a reasonable default.&quot;</span>);
<a name="l03104"></a>03104 
<a name="l03105"></a>03105     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hma free space&quot;</span>,Property::Changeable::WhenIdle,34*1024); <span class="comment">/* default 34KB (TODO: How much does MS-DOS 5.0 usually occupy?) */</span>
<a name="l03106"></a>03106     Pint-&gt;Set_help(<span class="stringliteral">&quot;Controls the amount of free space available in HMA. This setting is not meaningful unless the\n&quot;</span>
<a name="l03107"></a>03107             <span class="stringliteral">&quot;DOS kernel occupies HMA and the emulated DOS version is at least 5.0.&quot;</span>);
<a name="l03108"></a>03108 
<a name="l03109"></a>03109     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cpm compatibility mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l03110"></a>03110     Pstring-&gt;Set_values(cpm_compat_modes);
<a name="l03111"></a>03111     Pstring-&gt;Set_help(
<a name="l03112"></a>03112             <span class="stringliteral">&quot;This controls how the DOS kernel sets up the CP/M compatibility code in the PSP segment.\n&quot;</span>
<a name="l03113"></a>03113             <span class="stringliteral">&quot;Several options are provided to emulate one of several undocumented behaviors related to the CP/M entry point.\n&quot;</span>
<a name="l03114"></a>03114             <span class="stringliteral">&quot;If set to auto, DOSBox-X will pick the best option to allow it to work properly.\n&quot;</span>
<a name="l03115"></a>03115             <span class="stringliteral">&quot;Unless set to &#39;off&#39;, this option will require the DOS kernel to occupy the first 256 bytes of the HMA memory area\n&quot;</span>
<a name="l03116"></a>03116             <span class="stringliteral">&quot;to prevent crashes when the A20 gate is switched on.\n&quot;</span>
<a name="l03117"></a>03117             <span class="stringliteral">&quot;   auto      Pick the best option\n&quot;</span>
<a name="l03118"></a>03118             <span class="stringliteral">&quot;   off       Turn off the CP/M entry point (program will abort if called)\n&quot;</span>
<a name="l03119"></a>03119             <span class="stringliteral">&quot;   msdos2    MS-DOS 2.x behavior, offset field also doubles as data segment size\n&quot;</span>
<a name="l03120"></a>03120             <span class="stringliteral">&quot;   msdos5    MS-DOS 5.x behavior, entry point becomes one of two fixed addresses\n&quot;</span>
<a name="l03121"></a>03121             <span class="stringliteral">&quot;   direct    Non-standard behavior, encode the CALL FAR directly to the entry point rather than indirectly&quot;</span>);
<a name="l03122"></a>03122 
<a name="l03123"></a>03123     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;share&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03124"></a>03124     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Report SHARE.EXE as resident. Does not actually emulate SHARE functions.&quot;</span>);
<a name="l03125"></a>03125 
<a name="l03126"></a>03126     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum dos initial private segment&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l03127"></a>03127     Phex-&gt;Set_help(<span class="stringliteral">&quot;In non-mainline mapping mode, where DOS structures are allocated from base memory, this sets the\n&quot;</span>
<a name="l03128"></a>03128             <span class="stringliteral">&quot;minimum segment value. Recommended value is 0x70. You may reduce the value down to 0x50 if freeing\n&quot;</span>
<a name="l03129"></a>03129             <span class="stringliteral">&quot;up more memory is important. Set to 0 for default.&quot;</span>);
<a name="l03130"></a>03130 
<a name="l03131"></a>03131     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum mcb segment&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l03132"></a>03132     Phex-&gt;Set_help(<span class="stringliteral">&quot;Minimum segment value to begin memory allocation from, in hexadecimal. Set to 0 for default.\n&quot;</span>
<a name="l03133"></a>03133             <span class="stringliteral">&quot;You can increase available DOS memory by reducing this value down to as low as 0x51, however\n&quot;</span>
<a name="l03134"></a>03134             <span class="stringliteral">&quot;setting it to low can cause some DOS programs to crash or run erratically, and some DOS games\n&quot;</span>
<a name="l03135"></a>03135             <span class="stringliteral">&quot;and demos to cause intermittent static noises when using Sound Blaster output. DOS programs\n&quot;</span>
<a name="l03136"></a>03136             <span class="stringliteral">&quot;compressed with Microsoft EXEPACK will not run if the minimum MCB segment is below 64KB.&quot;</span>);
<a name="l03137"></a>03137 
<a name="l03138"></a>03138     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum mcb free&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l03139"></a>03139     Phex-&gt;Set_help(<span class="stringliteral">&quot;Minimum free segment value to leave free. At startup, the DOS kernel will allocate memory\n&quot;</span>
<a name="l03140"></a>03140                    <span class="stringliteral">&quot;up to this point. This can be used to deal with EXEPACK issues or DOS programs that cannot\n&quot;</span>
<a name="l03141"></a>03141                    <span class="stringliteral">&quot;be loaded too low in memory. This differs from &#39;minimum mcb segment&#39; in that this affects\n&quot;</span>
<a name="l03142"></a>03142                    <span class="stringliteral">&quot;the lowest free block instead of the starting point of the mcb chain.&quot;</span>);
<a name="l03143"></a>03143 
<a name="l03144"></a>03144     <span class="comment">// TODO: Enable by default WHEN the &#39;SD&#39; signature becomes valid, and a valid device list within</span>
<a name="l03145"></a>03145     <span class="comment">//       is emulated properly.</span>
<a name="l03146"></a>03146     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable dummy device mcb&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03147"></a>03147     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allocate a fake device MCB at the base of conventional memory.\n&quot;</span>
<a name="l03148"></a>03148             <span class="stringliteral">&quot;Clearing this option can reclaim a small amount of conventional memory at the expense of\n&quot;</span>
<a name="l03149"></a>03149             <span class="stringliteral">&quot;some minor DOS compatibility.&quot;</span>);
<a name="l03150"></a>03150 
<a name="l03151"></a>03151     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;maximum environment block size on exec&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l03152"></a>03152     Pint-&gt;SetMinMax(-1,65535);
<a name="l03153"></a>03153     Pint-&gt;Set_help(<span class="stringliteral">&quot;Maximum environment block size to copy for child processes. Set to -1 for default.&quot;</span>);
<a name="l03154"></a>03154 
<a name="l03155"></a>03155     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;additional environment block size on exec&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l03156"></a>03156     Pint-&gt;SetMinMax(-1,65535);
<a name="l03157"></a>03157     Pint-&gt;Set_help(<span class="stringliteral">&quot;When executing a program, compute the size of the parent block then add this amount to allow for a few additional variables.\n&quot;</span>
<a name="l03158"></a>03158             <span class="stringliteral">&quot;If the subprocesses will never add/modify the environment block, you can free up a few additional bytes by setting this to 0.\n&quot;</span>
<a name="l03159"></a>03159             <span class="stringliteral">&quot;Set to -1 for default setting.&quot;</span>);
<a name="l03160"></a>03160 
<a name="l03161"></a>03161     <span class="comment">// DEPRECATED, REMOVE</span>
<a name="l03162"></a>03162     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable a20 on windows init&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03163"></a>03163     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, DOSBox-X will enable the A20 gate when Windows 3.1/9x broadcasts the INIT message\n&quot;</span>
<a name="l03164"></a>03164             <span class="stringliteral">&quot;at startup. Windows 3.1 appears to make assumptions at some key points on startup about\n&quot;</span>
<a name="l03165"></a>03165             <span class="stringliteral">&quot;A20 that don&#39;t quite hold up and cause Windows 3.1 to crash when you set A20 emulation\n&quot;</span>
<a name="l03166"></a>03166             <span class="stringliteral">&quot;to a20=mask as opposed to a20=fast. This option is enabled by default.&quot;</span>);
<a name="l03167"></a>03167 
<a name="l03168"></a>03168     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on xms memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03169"></a>03169     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by XMS allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l03170"></a>03170             <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l03171"></a>03171             <span class="stringliteral">&quot;related to uninitialized variables in extended memory. When enabled this option may\n&quot;</span>
<a name="l03172"></a>03172             <span class="stringliteral">&quot;incur a slight to moderate performance penalty.&quot;</span>);
<a name="l03173"></a>03173 
<a name="l03174"></a>03174     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dosv&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l03175"></a>03175     Pstring-&gt;Set_values(dosv_settings);
<a name="l03176"></a>03176     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable DOS/V emulation and specify which version to emulate. This option is intended for\n&quot;</span>
<a name="l03177"></a>03177             <span class="stringliteral">&quot;use with games or software originating from Asia that use the double byte character set\n&quot;</span>
<a name="l03178"></a>03178             <span class="stringliteral">&quot;encodings and the DOS/V extensions to display Japanese, Chinese, or Korean text.\n&quot;</span>
<a name="l03179"></a>03179             <span class="stringliteral">&quot;Note that enabling DOS/V replaces 80x25 text mode (INT 10h mode 3) with a EGA/VGA graphics\n&quot;</span>
<a name="l03180"></a>03180             <span class="stringliteral">&quot;mode that emulates text mode to display the characters and may be incompatible with non-Asian\n&quot;</span>
<a name="l03181"></a>03181             <span class="stringliteral">&quot;software that assumes direct access to the text mode via segment 0xB800.\n&quot;</span>
<a name="l03182"></a>03182             <span class="stringliteral">&quot;WARNING: This option is very experimental at this time.&quot;</span>);
<a name="l03183"></a>03183 
<a name="l03184"></a>03184     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ems&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;true&quot;</span>);
<a name="l03185"></a>03185     Pstring-&gt;Set_values(ems_settings);
<a name="l03186"></a>03186     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable EMS support. The default (=true) provides the best\n&quot;</span>
<a name="l03187"></a>03187         <span class="stringliteral">&quot;compatibility but certain applications may run better with\n&quot;</span>
<a name="l03188"></a>03188         <span class="stringliteral">&quot;other choices, or require EMS support to be disabled (=false)\n&quot;</span>
<a name="l03189"></a>03189         <span class="stringliteral">&quot;to work at all.&quot;</span>);
<a name="l03190"></a>03190 
<a name="l03191"></a>03191     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vcpi&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03192"></a>03192     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set and expanded memory is enabled, also emulate VCPI.&quot;</span>);
<a name="l03193"></a>03193 
<a name="l03194"></a>03194     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask timer on disk io&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03195"></a>03195     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 21h emulation will unmask IRQ 0 (timer interrupt) when the application opens/closes/reads/writes files.&quot;</span>);
<a name="l03196"></a>03196 
<a name="l03197"></a>03197     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero int 67h if no ems&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03198"></a>03198     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If ems=false, leave interrupt vector 67h zeroed out (default true).\n&quot;</span>
<a name="l03199"></a>03199             <span class="stringliteral">&quot;This is a workaround for games or demos that try to detect EMS by whether or not INT 67h is 0000:0000 rather than a proper test.\n&quot;</span>
<a name="l03200"></a>03200             <span class="stringliteral">&quot;This option also affects whether INT 67h is zeroed when booting a guest OS&quot;</span>);
<a name="l03201"></a>03201 
<a name="l03202"></a>03202     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero unused int 68h&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03203"></a>03203     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Leave INT 68h zero at startup.\n&quot;</span>
<a name="l03204"></a>03204             <span class="stringliteral">&quot;Set this to true for certain games that use INT 68h in unusual ways that require a zero value.\n&quot;</span>
<a name="l03205"></a>03205             <span class="stringliteral">&quot;Note that the vector is left at zero anyway when machine=cga.\n&quot;</span>
<a name="l03206"></a>03206             <span class="stringliteral">&quot;This is needed to properly run 1988 game &#39;PopCorn&#39;.&quot;</span>);
<a name="l03207"></a>03207 
<a name="l03208"></a>03208     <span class="comment">/* FIXME: The vm86 monitor in src/ints/ems.cpp is not very stable! Option is default OFF until stabilized! */</span>
<a name="l03209"></a>03209     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;emm386 startup active&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03210"></a>03210     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set and expanded memory is set to emulate emm386, start the DOS machine with EMM386.EXE active\n&quot;</span>
<a name="l03211"></a>03211             <span class="stringliteral">&quot;(running the 16-bit DOS environment from within Virtual 8086 mode). If you will be running anything\n&quot;</span>
<a name="l03212"></a>03212             <span class="stringliteral">&quot;that involves a DOS extender you will also need to enable the VCPI interface as well.&quot;</span>);
<a name="l03213"></a>03213 
<a name="l03214"></a>03214     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on ems memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03215"></a>03215     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by EMS allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l03216"></a>03216             <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l03217"></a>03217             <span class="stringliteral">&quot;related to uninitialized variables in expanded memory. When enabled this option may\n&quot;</span>
<a name="l03218"></a>03218             <span class="stringliteral">&quot;incur a slight to moderate performance penalty.&quot;</span>);
<a name="l03219"></a>03219 
<a name="l03220"></a>03220     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;ems system handle memory size&quot;</span>,Property::Changeable::WhenIdle,384);
<a name="l03221"></a>03221     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of memory associated with system handle, in KB&quot;</span>);
<a name="l03222"></a>03222 
<a name="l03223"></a>03223     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ems system handle on even megabyte&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03224"></a>03224     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, try to allocate the EMM system handle on an even megabyte.\n&quot;</span>
<a name="l03225"></a>03225             <span class="stringliteral">&quot;If the DOS game or demo fiddles with the A20 gate while using EMM386.EXE emulation in virtual 8086 mode, setting this option may help prevent crashes.\n&quot;</span>
<a name="l03226"></a>03226             <span class="stringliteral">&quot;However, forcing allocation on an even megabyte will also cause some extended memory fragmentation and reduce the\n&quot;</span>
<a name="l03227"></a>03227             <span class="stringliteral">&quot;overall amount of extended memory available to the DOS game depending on whether it expects large contiguous chunks\n&quot;</span>
<a name="l03228"></a>03228             <span class="stringliteral">&quot;of extended memory.&quot;</span>);
<a name="l03229"></a>03229 
<a name="l03230"></a>03230     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;umb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03231"></a>03231     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable UMB support.&quot;</span>);
<a name="l03232"></a>03232 
<a name="l03233"></a>03233     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;umb start&quot;</span>,Property::Changeable::OnlyAtStart,0); <span class="comment">/* &lt;- (0=auto) 0xD000 is mainline DOSBox compatible behavior */</span>
<a name="l03234"></a>03234     Phex-&gt;Set_help(<span class="stringliteral">&quot;UMB region starting segment&quot;</span>);
<a name="l03235"></a>03235 
<a name="l03236"></a>03236     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;umb end&quot;</span>,Property::Changeable::OnlyAtStart,0); <span class="comment">/* &lt;- (0=auto) 0xEFFF is mainline DOSBox compatible (where base=0xD000 and size=0x2000) */</span>
<a name="l03237"></a>03237     Phex-&gt;Set_help(<span class="stringliteral">&quot;UMB region last segment&quot;</span>);
<a name="l03238"></a>03238 
<a name="l03239"></a>03239     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;kernel allocation in umb&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03240"></a>03240     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, dynamic kernel allocation=1, and private area in umb=1, all kernel structures will be allocated from the private area in UMB.\n&quot;</span>
<a name="l03241"></a>03241             <span class="stringliteral">&quot;If you intend to run Windows 3.1 in DOSBox-X, you must set this option to false else Windows 3.1 will not start.&quot;</span>);
<a name="l03242"></a>03242 
<a name="l03243"></a>03243     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keep umb on boot&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03244"></a>03244     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If emulating UMBs, keep the UMB around after boot (Mainline DOSBox behavior). If clear, UMB is unmapped when you boot an operating system.&quot;</span>);
<a name="l03245"></a>03245 
<a name="l03246"></a>03246     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keep private area on boot&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03247"></a>03247     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, keep the DOSBox-X private area around after boot (Mainline DOSBox behavior). If clear, unmap and discard the private area when you boot an operating system.&quot;</span>);
<a name="l03248"></a>03248 
<a name="l03249"></a>03249     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;private area in umb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03250"></a>03250     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, keep private DOS segment in upper memory block, usually segment 0xC800 (Mainline DOSBox behavior)\n&quot;</span>
<a name="l03251"></a>03251             <span class="stringliteral">&quot;If clear, place private DOS segment at the base of system memory (just below the MCB)&quot;</span>);
<a name="l03252"></a>03252 
<a name="l03253"></a>03253     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ver&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l03254"></a>03254     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Set DOS version. Specify as major.minor format. A single number is treated as the major version (compatible with LFN support). Common settings are:\n&quot;</span>
<a name="l03255"></a>03255             <span class="stringliteral">&quot;auto (or unset)                  Pick a DOS kernel version automatically\n&quot;</span>
<a name="l03256"></a>03256             <span class="stringliteral">&quot;3.3                              MS-DOS 3.3 emulation (not tested!)\n&quot;</span>
<a name="l03257"></a>03257             <span class="stringliteral">&quot;5.0                              MS-DOS 5.0 emulation (recommended for DOS gaming)\n&quot;</span>
<a name="l03258"></a>03258             <span class="stringliteral">&quot;6.22                             MS-DOS 6.22 emulation\n&quot;</span>
<a name="l03259"></a>03259             <span class="stringliteral">&quot;7.0                              MS-DOS 7.0 (or Windows 95 pure DOS mode) emulation\n&quot;</span>
<a name="l03260"></a>03260             <span class="stringliteral">&quot;7.1                              MS-DOS 7.1 (or Windows 98 pure DOS mode) emulation\n&quot;</span>
<a name="l03261"></a>03261             <span class="stringliteral">&quot;Long filename (LFN) support will be enabled with a reported DOS version of 7.0 or higher with \&quot;lfn=auto\&quot; (default).\n&quot;</span>
<a name="l03262"></a>03262                         <span class="stringliteral">&quot;Similarly, FAT32 disk images will be supported with a reported DOS version of 7.1 or higher.\n&quot;</span>);
<a name="l03263"></a>03263 
<a name="l03264"></a>03264     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;lfn&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l03265"></a>03265     Pstring-&gt;Set_values(lfn_settings);
<a name="l03266"></a>03266     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable long filename support. If set to auto (default), it is enabled if the reported DOS version is at least 7.0.\n&quot;</span>
<a name="l03267"></a>03267                       <span class="stringliteral">&quot;If set to autostart, the builtin VER command won&#39;t activate/disactivate LFN support according to the reported DOS version.&quot;</span>);
<a name="l03268"></a>03268 
<a name="l03269"></a>03269     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;automount&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03270"></a>03270     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable automatic drive mounting in Windows.&quot;</span>);
<a name="l03271"></a>03271 
<a name="l03272"></a>03272     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;automountall&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03273"></a>03273     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Automatically mount all available Windows drives at start.&quot;</span>);
<a name="l03274"></a>03274 
<a name="l03275"></a>03275     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03276"></a>03276     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable INT 33H (mouse) support.&quot;</span>);
<a name="l03277"></a>03277 
<a name="l03278"></a>03278     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33 hide host cursor if interrupt subroutine&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03279"></a>03279     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the cursor on the host will be hidden if the DOS application provides it&#39;s own\n&quot;</span>
<a name="l03280"></a>03280                     <span class="stringliteral">&quot;interrupt subroutine for the mouse driver to call, which is usually an indication that\n&quot;</span>
<a name="l03281"></a>03281                     <span class="stringliteral">&quot;the DOS game wishes to draw the cursor with it&#39;s own support routines (DeluxePaint II).&quot;</span>);
<a name="l03282"></a>03282 
<a name="l03283"></a>03283     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33 hide host cursor when polling&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03284"></a>03284     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the cursor on the host will be hidden even if the DOS application has also\n&quot;</span>
<a name="l03285"></a>03285                     <span class="stringliteral">&quot;hidden the cursor in the guest, as long as the DOS application is polling position\n&quot;</span>
<a name="l03286"></a>03286                     <span class="stringliteral">&quot;and button status. This can be useful for DOS programs that draw the cursor on their\n&quot;</span>
<a name="l03287"></a>03287                     <span class="stringliteral">&quot;own instead of using the mouse driver, including most games and DeluxePaint II.&quot;</span>);
<a name="l03288"></a>03288 
<a name="l03289"></a>03289     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33 disable cell granularity&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03290"></a>03290     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the mouse pointer position is reported at full precision (as if 640x200 coordinates) in all modes.\n&quot;</span>
<a name="l03291"></a>03291                     <span class="stringliteral">&quot;If not set, the mouse pointer position is rounded to the top-left corner of a character cell in text modes.\n&quot;</span>
<a name="l03292"></a>03292                     <span class="stringliteral">&quot;This option is OFF by default.&quot;</span>);
<a name="l03293"></a>03293 
<a name="l03294"></a>03294     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int 13 extensions&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03295"></a>03295     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable INT 13h extensions (functions 0x40-0x48). You will need this enabled if the virtual hard drive image is 8.4GB or larger.&quot;</span>);
<a name="l03296"></a>03296 
<a name="l03297"></a>03297     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;biosps2&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03298"></a>03298     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate BIOS INT 15h PS/2 mouse services\n&quot;</span>
<a name="l03299"></a>03299         <span class="stringliteral">&quot;Note that some OS&#39;s like Microsoft Windows neither use INT 33h nor\n&quot;</span>
<a name="l03300"></a>03300         <span class="stringliteral">&quot;probe the AUX port directly and depend on this BIOS interface exclusively\n&quot;</span>
<a name="l03301"></a>03301         <span class="stringliteral">&quot;for PS/2 mouse support. In other cases there is no harm in leaving this enabled&quot;</span>);
<a name="l03302"></a>03302 
<a name="l03303"></a>03303     <span class="comment">/* bugfix for Yodel &quot;mayday&quot; demo */</span>
<a name="l03304"></a>03304     <span class="comment">/* TODO: Set this option to default to &quot;true&quot; if it turns out most BIOSes unmask the IRQ during INT 15h AH=86 WAIT */</span>
<a name="l03305"></a>03305     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int15 wait force unmask irq&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03306"></a>03306     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Some demos or games mistakingly use INT 15h AH=0x86 (WAIT) while leaving the IRQs needed for it masked.\n&quot;</span>
<a name="l03307"></a>03307             <span class="stringliteral">&quot;If this option is set (by default), the necessary IRQs will be unmasked when INT 15 AH=0x86 is used so that the game or demo does not hang.&quot;</span>);
<a name="l03308"></a>03308 
<a name="l03309"></a>03309     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int15 mouse callback does not preserve registers&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03310"></a>03310     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set to true if the guest OS or DOS program assigns an INT 15h mouse callback,\n&quot;</span>
<a name="l03311"></a>03311             <span class="stringliteral">&quot;but does not properly preserve CPU registers. Diagnostic function only (default off).&quot;</span>);
<a name="l03312"></a>03312 
<a name="l03313"></a>03313     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;keyboardlayout&quot;</span>,Property::Changeable::WhenIdle, <span class="stringliteral">&quot;auto&quot;</span>);
<a name="l03314"></a>03314     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Language code of the keyboard layout (or none).&quot;</span>);
<a name="l03315"></a>03315 
<a name="l03316"></a>03316     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dbcs&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03317"></a>03317     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable DBCS table.\n&quot;</span>
<a name="l03318"></a>03318             <span class="stringliteral">&quot;CAUTION: Some software will crash without the DBCS table, including the Open Watcom installer.\n&quot;</span>);
<a name="l03319"></a>03319 
<a name="l03320"></a>03320     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;filenamechar&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03321"></a>03321     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable filename char table&quot;</span>);
<a name="l03322"></a>03322 
<a name="l03323"></a>03323     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;collating and uppercase&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03324"></a>03324     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable collating and uppercase table&quot;</span>);
<a name="l03325"></a>03325 
<a name="l03326"></a>03326     <span class="comment">// DEPRECATED, REMOVE</span>
<a name="l03327"></a>03327     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;con device use int 16h to detect keyboard input&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03328"></a>03328     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, use INT 16h to detect keyboard input (MS-DOS 6.22 behavior). If clear, detect keyboard input by\n&quot;</span>
<a name="l03329"></a>03329             <span class="stringliteral">&quot;peeking into the BIOS keyboard buffer (Mainline DOSBox behavior). You will need to set this\n&quot;</span>
<a name="l03330"></a>03330             <span class="stringliteral">&quot;option for programs that hook INT 16h to handle keyboard input ahead of the DOS console.\n&quot;</span>
<a name="l03331"></a>03331             <span class="stringliteral">&quot;Microsoft Scandisk needs this option to respond to keyboard input correctly.&quot;</span>);
<a name="l03332"></a>03332 
<a name="l03333"></a>03333     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on int 21h memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03334"></a>03334     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by the INT 21h allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l03335"></a>03335             <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l03336"></a>03336             <span class="stringliteral">&quot;related to uninitialized variables in the data or stack segment. If you intend to run a\n&quot;</span>
<a name="l03337"></a>03337             <span class="stringliteral">&quot;game or demo known to have this problem (Second Unreal, for example), set to true, else\n&quot;</span>
<a name="l03338"></a>03338             <span class="stringliteral">&quot;set to false. When enabled this option may incur a slight to moderate performance penalty.&quot;</span>);
<a name="l03339"></a>03339 
<a name="l03340"></a>03340     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dos clipboard device enable&quot;</span>,Property::Changeable::WhenIdle, <span class="stringliteral">&quot;false&quot;</span>);
<a name="l03341"></a>03341     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If enabled, a DOS device will be added for bidirectional communications with the Windows clipboard.\n&quot;</span>
<a name="l03342"></a>03342                         <span class="stringliteral">&quot;Setting to \&quot;read\&quot; will only allow read access, and setting to \&quot;write\&quot; will only allow write access.\n&quot;</span>
<a name="l03343"></a>03343                         <span class="stringliteral">&quot;Setting to \&quot;full\&quot; or \&quot;true\&quot; enables both; setting to \&quot;dummy\&quot; or \&quot;false\&quot; disables the access or device.\n&quot;</span>
<a name="l03344"></a>03344             <span class="stringliteral">&quot;The default device name is CLIP$, but can be changed with the \&quot;dos clipboard device name\&quot; setting below.&quot;</span>);
<a name="l03345"></a>03345 
<a name="l03346"></a>03346     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dos clipboard device name&quot;</span>,Property::Changeable::WhenIdle, <span class="stringliteral">&quot;CLIP$&quot;</span>);
<a name="l03347"></a>03347     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Set DOS device name (up to 8 characters) for bidirectional communications with the Windows clipboard.\n&quot;</span>
<a name="l03348"></a>03348             <span class="stringliteral">&quot;If unset or invalid, the default name CLIP$ will be used (e.g. \&quot;TYPE CLIP$\&quot; shows the clipboard contents).\n&quot;</span>
<a name="l03349"></a>03349                         <span class="stringliteral">&quot;It has no effect if \&quot;dos clipboard device enable\&quot; is false, and it is deactivated if the secure mode is enabled.&quot;</span>);
<a name="l03350"></a>03350 
<a name="l03351"></a>03351     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;ipx&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l03352"></a>03352     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ipx&quot;</span>,Property::Changeable::WhenIdle, <span class="keyword">false</span>);
<a name="l03353"></a>03353     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable ipx over UDP/IP emulation.&quot;</span>);
<a name="l03354"></a>03354 
<a name="l03355"></a>03355     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;ne2000&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l03356"></a>03356     MSG_Add(<span class="stringliteral">&quot;NE2000_CONFIGFILE_HELP&quot;</span>,
<a name="l03357"></a>03357         <span class="stringliteral">&quot;macaddr -- The physical address the emulator will use on your network.\n&quot;</span>
<a name="l03358"></a>03358         <span class="stringliteral">&quot;           If you have multiple DOSBoxes running on your network,\n&quot;</span>
<a name="l03359"></a>03359         <span class="stringliteral">&quot;           this has to be changed. Modify the last three number blocks.\n&quot;</span>
<a name="l03360"></a>03360         <span class="stringliteral">&quot;           I.e. AC:DE:48:88:99:AB.\n&quot;</span>
<a name="l03361"></a>03361         <span class="stringliteral">&quot;realnic -- Specifies which of your network interfaces is used.\n&quot;</span>
<a name="l03362"></a>03362         <span class="stringliteral">&quot;           Write \&#39;list\&#39; here to see the list of devices in the\n&quot;</span>
<a name="l03363"></a>03363         <span class="stringliteral">&quot;           Status Window. Then make your choice and put either the\n&quot;</span>
<a name="l03364"></a>03364         <span class="stringliteral">&quot;           interface number (2 or something) or a part of your adapters\n&quot;</span>
<a name="l03365"></a>03365         <span class="stringliteral">&quot;           name, e.g. VIA here.\n&quot;</span>
<a name="l03366"></a>03366 
<a name="l03367"></a>03367     );
<a name="l03368"></a>03368 
<a name="l03369"></a>03369     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ne2000&quot;</span>, Property::Changeable::WhenIdle, <span class="keyword">false</span>);
<a name="l03370"></a>03370     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Ethernet passthrough. Requires [Win]Pcap.&quot;</span>);
<a name="l03371"></a>03371 
<a name="l03372"></a>03372     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;nicbase&quot;</span>, Property::Changeable::WhenIdle, 0x300);
<a name="l03373"></a>03373     Phex-&gt;Set_help(<span class="stringliteral">&quot;The base address of the NE2000 board.&quot;</span>);
<a name="l03374"></a>03374 
<a name="l03375"></a>03375     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;nicirq&quot;</span>, Property::Changeable::WhenIdle, 3);
<a name="l03376"></a>03376     Pint-&gt;Set_help(<span class="stringliteral">&quot;The interrupt it uses. Note serial2 uses IRQ3 as default.&quot;</span>);
<a name="l03377"></a>03377 
<a name="l03378"></a>03378     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;macaddr&quot;</span>, Property::Changeable::WhenIdle,<span class="stringliteral">&quot;AC:DE:48:88:99:AA&quot;</span>);
<a name="l03379"></a>03379     Pstring-&gt;Set_help(<span class="stringliteral">&quot;The physical address the emulator will use on your network.\n&quot;</span>
<a name="l03380"></a>03380         <span class="stringliteral">&quot;If you have multiple DOSBoxes running on your network,\n&quot;</span>
<a name="l03381"></a>03381         <span class="stringliteral">&quot;this has to be changed for each. AC:DE:48 is an address range reserved for\n&quot;</span>
<a name="l03382"></a>03382         <span class="stringliteral">&quot;private use, so modify the last three number blocks.\n&quot;</span>
<a name="l03383"></a>03383         <span class="stringliteral">&quot;I.e. AC:DE:48:88:99:AB.&quot;</span>);
<a name="l03384"></a>03384 
<a name="l03385"></a>03385     <span class="comment">/* TODO: Change default to &quot;nat&quot; and then begin implementing support for emulating</span>
<a name="l03386"></a>03386 <span class="comment">     *       an ethernet connection with DOSBox-X as a NAT/firewall between the guest</span>
<a name="l03387"></a>03387 <span class="comment">     *       and the OS. Sort of like &quot;NAT&quot; mode in VirtualBox. When that works, we</span>
<a name="l03388"></a>03388 <span class="comment">     *       can then compile NE2000 support with and without libpcap/winpcap support. */</span>
<a name="l03389"></a>03389     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;realnic&quot;</span>, Property::Changeable::WhenIdle,<span class="stringliteral">&quot;list&quot;</span>);
<a name="l03390"></a>03390     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specifies which of your network interfaces is used.\n&quot;</span>
<a name="l03391"></a>03391         <span class="stringliteral">&quot;Write \&#39;list\&#39; here to see the list of devices in the\n&quot;</span>
<a name="l03392"></a>03392         <span class="stringliteral">&quot;Status Window. Then make your choice and put either the\n&quot;</span>
<a name="l03393"></a>03393         <span class="stringliteral">&quot;interface number (2 or something) or a part of your adapters\n&quot;</span>
<a name="l03394"></a>03394         <span class="stringliteral">&quot;name, e.g. VIA here.&quot;</span>);
<a name="l03395"></a>03395 
<a name="l03396"></a>03396     <span class="comment">/* floppy controller emulation options and setup */</span>
<a name="l03397"></a>03397     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;fdc, primary&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);
<a name="l03398"></a>03398 
<a name="l03399"></a>03399     <span class="comment">/* Primary FDC on by default, secondary is not. Most PCs have only one floppy controller. */</span>
<a name="l03400"></a>03400     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03401"></a>03401     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable floppy controller interface&quot;</span>);
<a name="l03402"></a>03402 
<a name="l03403"></a>03403     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pnp&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03404"></a>03404     Pbool-&gt;Set_help(<span class="stringliteral">&quot;List floppy controller in ISA PnP BIOS enumeration&quot;</span>);
<a name="l03405"></a>03405 
<a name="l03406"></a>03406     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use FDC default*/</span>);
<a name="l03407"></a>03407     Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ used by floppy controller. Set to 0 for default.\n&quot;</span>
<a name="l03408"></a>03408         <span class="stringliteral">&quot;WARNING: Setting the IRQ to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the floppy controller.\n&quot;</span>
<a name="l03409"></a>03409         <span class="stringliteral">&quot;         Setting the IRQ to one already occupied by another device or IDE controller will trigger \&quot;resource conflict\&quot; errors in Windows 95.\n&quot;</span>
<a name="l03410"></a>03410         <span class="stringliteral">&quot;         Normally, floppy controllers use IRQ 6.&quot;</span>);
<a name="l03411"></a>03411 
<a name="l03412"></a>03412     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;io&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use FDC default*/</span>);
<a name="l03413"></a>03413     Phex-&gt;Set_help(<span class="stringliteral">&quot;Base I/O port for floppy controller. Set to 0 for default.\n&quot;</span>
<a name="l03414"></a>03414         <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03415"></a>03415         <span class="stringliteral">&quot;         Standard I/O ports are 3F0 and 370.&quot;</span>);
<a name="l03416"></a>03416 
<a name="l03417"></a>03417     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dma&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*use FDC default*/</span>);
<a name="l03418"></a>03418     Pint-&gt;Set_help(<span class="stringliteral">&quot;DMA channel for floppy controller. Set to -1 for default.\n&quot;</span>
<a name="l03419"></a>03419         <span class="stringliteral">&quot;WARNING: Setting the DMA channel to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03420"></a>03420         <span class="stringliteral">&quot;         Standard DMA channel is 2.&quot;</span>);
<a name="l03421"></a>03421 
<a name="l03422"></a>03422     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakev86io&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03423"></a>03423     Pbool-&gt;Set_help(
<a name="l03424"></a>03424         <span class="stringliteral">&quot;If set, certain INT 13h commands will cause floppy emulation to issue fake CPU I/O\n&quot;</span>
<a name="l03425"></a>03425         <span class="stringliteral">&quot;traps (GPF) in virtual 8086 mode and a fake IRQ signal. You must enable this\n&quot;</span>
<a name="l03426"></a>03426         <span class="stringliteral">&quot;option if you want 32-bit floppy access in Windows 95 to work with DOSBox-X.&quot;</span>);
<a name="l03427"></a>03427 
<a name="l03428"></a>03428     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;instant mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03429"></a>03429     Pbool-&gt;Set_help(
<a name="l03430"></a>03430         <span class="stringliteral">&quot;If set, all floppy operations are &#39;instantaneous&#39;, they are carried\n&quot;</span>
<a name="l03431"></a>03431         <span class="stringliteral">&quot;out without any delay. Real hardware of course has motor, command\n&quot;</span>
<a name="l03432"></a>03432         <span class="stringliteral">&quot;and data I/O delays and so this option is off by default for realistic\n&quot;</span>
<a name="l03433"></a>03433         <span class="stringliteral">&quot;emulation.&quot;</span>);
<a name="l03434"></a>03434 
<a name="l03435"></a>03435     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;auto-attach to int 13h&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03436"></a>03436     Pbool-&gt;Set_help(
<a name="l03437"></a>03437         <span class="stringliteral">&quot;If set, DOSBox-X will automatically attach a disk image as being\n&quot;</span>
<a name="l03438"></a>03438         <span class="stringliteral">&quot;inserted into a floppy drive attached to the controller when imgmount is used\n&quot;</span>
<a name="l03439"></a>03439         <span class="stringliteral">&quot;to mount a disk image to drive 0/1 or A/B. If not set, you must specify\n&quot;</span>
<a name="l03440"></a>03440         <span class="stringliteral">&quot;the -fdc option to imgmount to attach drive A/B to the floppy controller\n&quot;</span>
<a name="l03441"></a>03441         <span class="stringliteral">&quot;manually. You must use the -fdc option regardless if loading floppies into\n&quot;</span>
<a name="l03442"></a>03442         <span class="stringliteral">&quot;drives attached to any other FDC than the primary controller&quot;</span>);
<a name="l03443"></a>03443 
<a name="l03444"></a>03444     <span class="comment">/* FIXME: From http://wiki.osdev.org/Floppy_Disk_Controller#Configure</span>
<a name="l03445"></a>03445 <span class="comment">     *</span>
<a name="l03446"></a>03446 <span class="comment">     *    &quot;The three modes are PC-AT mode, PS/2 mode, and Model 30 mode. The most likely mode ... is model 30 mode.</span>
<a name="l03447"></a>03447 <span class="comment">     *    You may find some pre-1996 Pentium machines using PS/2 mode. You can ignore PC-AT mode.&quot;</span>
<a name="l03448"></a>03448 <span class="comment">     *</span>
<a name="l03449"></a>03449 <span class="comment">     *    What? What the fuck are you talking about?</span>
<a name="l03450"></a>03450 <span class="comment">     *</span>
<a name="l03451"></a>03451 <span class="comment">     *    &quot;AT mode&quot; seems to imply the presense of port 3F7. PS/2 mode seems to imply the presense of 3F0-3F1 and 3F7.</span>
<a name="l03452"></a>03452 <span class="comment">     *    A Toshiba laptop (Satellite Pro 465CDX) has port 3F7 but not 3F0-3F1. By other documentation I&#39;ve found, that</span>
<a name="l03453"></a>03453 <span class="comment">     *    means this laptop (which came out late 1997) is running in AT mode! There&#39;s plenty of hardware running in both</span>
<a name="l03454"></a>03454 <span class="comment">     *    PS/2 and AT mode, even some very old stuff in my pile of junk dating back to 1990!</span>
<a name="l03455"></a>03455 <span class="comment">     *</span>
<a name="l03456"></a>03456 <span class="comment">     *    Somehow I think this information is as correct as their ATAPI programming docs on how to read CD-ROM</span>
<a name="l03457"></a>03457 <span class="comment">     *    sectors: it&#39;s a start but it&#39;s mostly wrong. Hopefully DOSLIB will shed light on what the real differences</span>
<a name="l03458"></a>03458 <span class="comment">     *    are and what is most common. --J.C. */</span>
<a name="l03459"></a>03459     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;ps2&quot;</span>);
<a name="l03460"></a>03460     Pstring-&gt;Set_help(
<a name="l03461"></a>03461         <span class="stringliteral">&quot;Floppy controller mode. What the controller acts like.\n&quot;</span>
<a name="l03462"></a>03462         <span class="stringliteral">&quot;  ps2                          PS/2 mode (most common)\n&quot;</span>
<a name="l03463"></a>03463         <span class="stringliteral">&quot;  ps2_model30                  PS/2 model 30\n&quot;</span>
<a name="l03464"></a>03464         <span class="stringliteral">&quot;  at                           AT mode\n&quot;</span>
<a name="l03465"></a>03465         <span class="stringliteral">&quot;  xt                           PC/XT mode&quot;</span>);
<a name="l03466"></a>03466 
<a name="l03467"></a>03467     <span class="comment">/* FIXME: Not yet implemented. Future plans */</span>
<a name="l03468"></a>03468     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;chip&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;82077aa&quot;</span>);
<a name="l03469"></a>03469     Pstring-&gt;Set_help(
<a name="l03470"></a>03470         <span class="stringliteral">&quot;Floppy controller chipset\n&quot;</span>
<a name="l03471"></a>03471         <span class="stringliteral">&quot;  82077aa                      Intel 82077AA chipset\n&quot;</span>
<a name="l03472"></a>03472         <span class="stringliteral">&quot;  82072                        Intel 82072 chipset\n&quot;</span>
<a name="l03473"></a>03473         <span class="stringliteral">&quot;  nec_uPD765                   NEC uPD765 chipset\n&quot;</span>
<a name="l03474"></a>03474         <span class="stringliteral">&quot;  none                         No chipset (For PC/XT mode)&quot;</span>);
<a name="l03475"></a>03475 
<a name="l03476"></a>03476     <span class="comment">/* IDE emulation options and setup */</span>
<a name="l03477"></a>03477     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; MAX_IDE_CONTROLLERS;i++) {
<a name="l03478"></a>03478         secprop=control-&gt;AddSection_prop(ide_names[i],&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l03479"></a>03479 
<a name="l03480"></a>03480         <span class="comment">/* Primary and Secondary are on by default, Teritary and Quaternary are off by default.</span>
<a name="l03481"></a>03481 <span class="comment">         * Throughout the life of the IDE interface it was far more common for a PC to have just</span>
<a name="l03482"></a>03482 <span class="comment">         * a Primary and Secondary interface */</span>
<a name="l03483"></a>03483         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable&quot;</span>,Property::Changeable::OnlyAtStart,(i &lt; 2) ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l03484"></a>03484         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable IDE interface&quot;</span>);
<a name="l03485"></a>03485 
<a name="l03486"></a>03486         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pnp&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03487"></a>03487         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(<span class="stringliteral">&quot;List IDE device in ISA PnP BIOS enumeration&quot;</span>);
<a name="l03488"></a>03488 
<a name="l03489"></a>03489         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l03490"></a>03490         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ used by IDE controller. Set to 0 for default.\n&quot;</span>
<a name="l03491"></a>03491                 <span class="stringliteral">&quot;WARNING: Setting the IRQ to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03492"></a>03492                 <span class="stringliteral">&quot;         Setting the IRQ to one already occupied by another device or IDE controller will trigger \&quot;resource conflict\&quot; errors in Windows 95.\n&quot;</span>
<a name="l03493"></a>03493                 <span class="stringliteral">&quot;         Using IRQ 9, 12, 13, or IRQ 2-7 may cause problems with MS-DOS CD-ROM drivers.&quot;</span>);
<a name="l03494"></a>03494 
<a name="l03495"></a>03495         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;io&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l03496"></a>03496         <span class="keywordflow">if</span> (i == 0) Phex-&gt;Set_help(<span class="stringliteral">&quot;Base I/O port for IDE controller. Set to 0 for default.\n&quot;</span>
<a name="l03497"></a>03497                 <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03498"></a>03498                 <span class="stringliteral">&quot;         Using any port other than 1F0, 170, 1E8 or 168 can prevent MS-DOS CD-ROM drivers from detecting the IDE controller.&quot;</span>);
<a name="l03499"></a>03499 
<a name="l03500"></a>03500         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;altio&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l03501"></a>03501         <span class="keywordflow">if</span> (i == 0) Phex-&gt;Set_help(<span class="stringliteral">&quot;Alternate I/O port for IDE controller (alt status, etc). Set to 0 for default.\n&quot;</span>
<a name="l03502"></a>03502                 <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03503"></a>03503                 <span class="stringliteral">&quot;         For best compatability set this value to io+0x206, for example, io=1F0 altio=3F6.\n&quot;</span>
<a name="l03504"></a>03504                 <span class="stringliteral">&quot;         The primary IDE controller will not claim port 3F7 if the primary floppy controller is enabled due to I/O port overlap in the 3F0-3F7 range.&quot;</span>);
<a name="l03505"></a>03505 
<a name="l03506"></a>03506         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakeio&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03507"></a>03507         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l03508"></a>03508                 <span class="stringliteral">&quot;If set, force IDE state change on certain INT 13h commands.\n&quot;</span>
<a name="l03509"></a>03509                 <span class="stringliteral">&quot;IDE registers will be changed as if BIOS had carried out the action.\n&quot;</span>
<a name="l03510"></a>03510                 <span class="stringliteral">&quot;If you are running Windows 3.11 or Windows 3.11 Windows for Workgroups\n&quot;</span>
<a name="l03511"></a>03511                 <span class="stringliteral">&quot;you must enable this option (and use -reservecyl 1) if you want 32-bit\n&quot;</span>
<a name="l03512"></a>03512                 <span class="stringliteral">&quot;disk access to work correctly in DOSBox-X.&quot;</span>);
<a name="l03513"></a>03513 
<a name="l03514"></a>03514         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakev86io&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03515"></a>03515         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l03516"></a>03516                 <span class="stringliteral">&quot;If set, and int13fakeio is set, certain INT 13h commands will cause IDE emulation to\n&quot;</span>
<a name="l03517"></a>03517                 <span class="stringliteral">&quot;issue fake CPU I/O traps (GPF) in virtual 8086 mode and a fake IRQ signal. You must\n&quot;</span>
<a name="l03518"></a>03518                 <span class="stringliteral">&quot;enable this option if you want 32-bit disk access in Windows 95 to work with DOSBox-X.&quot;</span>);
<a name="l03519"></a>03519 
<a name="l03520"></a>03520         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pio32&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03521"></a>03521         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l03522"></a>03522                 <span class="stringliteral">&quot;If set, 32-bit I/O reads and writes are handled directly (much like PCI IDE implementations)\n&quot;</span>
<a name="l03523"></a>03523                 <span class="stringliteral">&quot;If clear, 32-bit I/O will be handled as if two 16-bit I/O (much like ISA IDE implementations)&quot;</span>);
<a name="l03524"></a>03524 
<a name="l03525"></a>03525         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore pio32&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03526"></a>03526         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l03527"></a>03527                 <span class="stringliteral">&quot;If 32-bit I/O is enabled, attempts to read/write 32-bit I/O will be ignored entirely.\n&quot;</span>
<a name="l03528"></a>03528                 <span class="stringliteral">&quot;In this way, you can have DOSBox-X emulate one of the strange quirks of 1995-1997 era\n&quot;</span>
<a name="l03529"></a>03529                 <span class="stringliteral">&quot;laptop hardware&quot;</span>);
<a name="l03530"></a>03530 
<a name="l03531"></a>03531         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom spinup time&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l03532"></a>03532         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms to spin up if CD is stationary.\n&quot;</span>
<a name="l03533"></a>03533                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l03534"></a>03534 
<a name="l03535"></a>03535         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom spindown timeout&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l03536"></a>03536         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms that drive will spin down automatically when not in use\n&quot;</span>
<a name="l03537"></a>03537                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l03538"></a>03538 
<a name="l03539"></a>03539         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom insertion delay&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l03540"></a>03540         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms that drive will report \&quot;medium not present\&quot;\n&quot;</span>
<a name="l03541"></a>03541                 <span class="stringliteral">&quot;to emulate the time it takes for someone to take out a CD and insert a new one when\n&quot;</span>
<a name="l03542"></a>03542                 <span class="stringliteral">&quot;DOSBox-X is instructed to swap or change CDs.\n&quot;</span>
<a name="l03543"></a>03543                 <span class="stringliteral">&quot;When running Windows 95 or higher a delay of 4000ms is recommended to ensure that\n&quot;</span>
<a name="l03544"></a>03544                 <span class="stringliteral">&quot;auto-insert notification triggers properly.\n&quot;</span>
<a name="l03545"></a>03545                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l03546"></a>03546     }
<a name="l03547"></a>03547 
<a name="l03548"></a>03548     <span class="comment">/* CONFIG.SYS options (stub) */</span>
<a name="l03549"></a>03549     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;config&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);
<a name="l03550"></a>03550 
<a name="l03551"></a>03551     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;rem&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;This section is DOS&#39;s CONFIG.SYS file, not all CONFIG.SYS options supported&quot;</span>);
<a name="l03552"></a>03552         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Records comments (remarks).&quot;</span>);
<a name="l03553"></a>03553     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;break&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l03554"></a>03554         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Sets or clears extended CTRL+C checking.&quot;</span>);
<a name="l03555"></a>03555     Pstring-&gt;Set_values(ps1opt);
<a name="l03556"></a>03556     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;numlock&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;&quot;</span>);
<a name="l03557"></a>03557         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Sets the initial state of the NumLock key.&quot;</span>);
<a name="l03558"></a>03558     Pstring-&gt;Set_values(numopt);
<a name="l03559"></a>03559     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dos&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;high, umb&quot;</span>);
<a name="l03560"></a>03560         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Reports whether DOS occupies HMA and allocates UMB memory (if available).&quot;</span>);
<a name="l03561"></a>03561     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;fcbs&quot;</span>,Property::Changeable::OnlyAtStart,100);
<a name="l03562"></a>03562     Pint-&gt;Set_help(<span class="stringliteral">&quot;Number of FCB handles available to DOS programs (1-255).&quot;</span>);
<a name="l03563"></a>03563     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;files&quot;</span>,Property::Changeable::OnlyAtStart,127);
<a name="l03564"></a>03564     Pint-&gt;Set_help(<span class="stringliteral">&quot;Number of file handles available to DOS programs (8-255).&quot;</span>);
<a name="l03565"></a>03565     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;country&quot;</span>,Property::Changeable::OnlyAtStart,1);
<a name="l03566"></a>03566     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sets the country code for country-specific date/time formats.&quot;</span>);
<a name="l03567"></a>03567     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;lastdrive&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;a&quot;</span>);
<a name="l03568"></a>03568         Pstring-&gt;Set_help(<span class="stringliteral">&quot;The maximum drive letter that can be accessed by programs.&quot;</span>);
<a name="l03569"></a>03569     Pstring-&gt;Set_values(driveletters);
<a name="l03570"></a>03570 
<a name="l03571"></a>03571     <span class="comment">//TODO ?</span>
<a name="l03572"></a>03572     control-&gt;AddSection_line(<span class="stringliteral">&quot;autoexec&quot;</span>,&amp;Null_Init);
<a name="l03573"></a>03573     MSG_Add(<span class="stringliteral">&quot;AUTOEXEC_CONFIGFILE_HELP&quot;</span>,
<a name="l03574"></a>03574         <span class="stringliteral">&quot;Lines in this section will be run at startup.\n&quot;</span>
<a name="l03575"></a>03575         <span class="stringliteral">&quot;You can put your MOUNT lines here.\n&quot;</span>
<a name="l03576"></a>03576     );
<a name="l03577"></a>03577     MSG_Add(<span class="stringliteral">&quot;CONFIGFILE_INTRO&quot;</span>,
<a name="l03578"></a>03578             <span class="stringliteral">&quot;# This is the configuration file for DOSBox-X %s. (Please use the latest version of DOSBox-X)\n&quot;</span>
<a name="l03579"></a>03579             <span class="stringliteral">&quot;# Lines starting with a # are comment lines and are ignored by DOSBox-X.\n&quot;</span>
<a name="l03580"></a>03580             <span class="stringliteral">&quot;# They are used to (briefly) document the effect of each option.\n&quot;</span>
<a name="l03581"></a>03581         <span class="stringliteral">&quot;# To write out ALL options, use command &#39;config -all&#39; with -wc or -writeconf options.\n&quot;</span>);
<a name="l03582"></a>03582     MSG_Add(<span class="stringliteral">&quot;CONFIG_SUGGESTED_VALUES&quot;</span>, <span class="stringliteral">&quot;Possible values&quot;</span>);
<a name="l03583"></a>03583 }
<a name="l03584"></a>03584 
<a name="l03585"></a>03585 <span class="keywordtype">int</span> utf8_encode(<span class="keywordtype">char</span> **ptr, <span class="keyword">const</span> <span class="keywordtype">char</span> *fence, uint32_t code) {
<a name="l03586"></a>03586     <span class="keywordtype">int</span> uchar_size=1;
<a name="l03587"></a>03587     <span class="keywordtype">char</span> *p = *ptr;
<a name="l03588"></a>03588 
<a name="l03589"></a>03589     <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03590"></a>03590     <span class="keywordflow">if</span> (code &gt;= (uint32_t)0x80000000UL) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03591"></a>03591     <span class="keywordflow">if</span> (p &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03592"></a>03592 
<a name="l03593"></a>03593     <span class="keywordflow">if</span> (code &gt;= 0x4000000) uchar_size = 6;
<a name="l03594"></a>03594     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x200000) uchar_size = 5;
<a name="l03595"></a>03595     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x10000) uchar_size = 4;
<a name="l03596"></a>03596     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x800) uchar_size = 3;
<a name="l03597"></a>03597     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x80) uchar_size = 2;
<a name="l03598"></a>03598 
<a name="l03599"></a>03599     <span class="keywordflow">if</span> ((p+uchar_size) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03600"></a>03600 
<a name="l03601"></a>03601     <span class="keywordflow">switch</span> (uchar_size) {
<a name="l03602"></a>03602         <span class="keywordflow">case</span> 1: *p++ = (char)code;
<a name="l03603"></a>03603             <span class="keywordflow">break</span>;
<a name="l03604"></a>03604         <span class="keywordflow">case</span> 2: *p++ = (char)(0xC0 | (code &gt;&gt; 6));
<a name="l03605"></a>03605             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03606"></a>03606             <span class="keywordflow">break</span>;
<a name="l03607"></a>03607         <span class="keywordflow">case</span> 3: *p++ = (char)(0xE0 | (code &gt;&gt; 12));
<a name="l03608"></a>03608             *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l03609"></a>03609             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03610"></a>03610             <span class="keywordflow">break</span>;
<a name="l03611"></a>03611         <span class="keywordflow">case</span> 4: *p++ = (char)(0xF0 | (code &gt;&gt; 18));
<a name="l03612"></a>03612             *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l03613"></a>03613             *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l03614"></a>03614             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03615"></a>03615             <span class="keywordflow">break</span>;
<a name="l03616"></a>03616         <span class="keywordflow">case</span> 5: *p++ = (char)(0xF8 | (code &gt;&gt; 24));
<a name="l03617"></a>03617             *p++ = (char)(0x80 | ((code &gt;&gt; 18) &amp; 0x3F));
<a name="l03618"></a>03618             *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l03619"></a>03619             *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l03620"></a>03620             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03621"></a>03621             <span class="keywordflow">break</span>;
<a name="l03622"></a>03622         <span class="keywordflow">case</span> 6: *p++ = (char)(0xFC | (code &gt;&gt; 30));
<a name="l03623"></a>03623             *p++ = (char)(0x80 | ((code &gt;&gt; 24) &amp; 0x3F));
<a name="l03624"></a>03624             *p++ = (char)(0x80 | ((code &gt;&gt; 18) &amp; 0x3F));
<a name="l03625"></a>03625             *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l03626"></a>03626             *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l03627"></a>03627             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03628"></a>03628             <span class="keywordflow">break</span>;
<a name="l03629"></a>03629     }
<a name="l03630"></a>03630 
<a name="l03631"></a>03631     *ptr = p;
<a name="l03632"></a>03632     <span class="keywordflow">return</span> 0;
<a name="l03633"></a>03633 }
<a name="l03634"></a>03634 
<a name="l03635"></a>03635 <span class="keywordtype">int</span> utf8_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> **ptr,<span class="keyword">const</span> <span class="keywordtype">char</span> *fence) {
<a name="l03636"></a>03636     <span class="keyword">const</span> <span class="keywordtype">char</span> *p = *ptr;
<a name="l03637"></a>03637     <span class="keywordtype">int</span> uchar_size=1;
<a name="l03638"></a>03638     <span class="keywordtype">int</span> ret = 0,c;
<a name="l03639"></a>03639 
<a name="l03640"></a>03640     <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03641"></a>03641     <span class="keywordflow">if</span> (p &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03642"></a>03642 
<a name="l03643"></a>03643     ret = (<span class="keywordtype">unsigned</span> char)(*p);
<a name="l03644"></a>03644     <span class="keywordflow">if</span> (ret &gt;= 0xFE) { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l03645"></a>03645     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xFC) uchar_size=6;
<a name="l03646"></a>03646     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xF8) uchar_size=5;
<a name="l03647"></a>03647     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xF0) uchar_size=4;
<a name="l03648"></a>03648     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xE0) uchar_size=3;
<a name="l03649"></a>03649     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xC0) uchar_size=2;
<a name="l03650"></a>03650     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0x80) { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l03651"></a>03651 
<a name="l03652"></a>03652     <span class="keywordflow">if</span> ((p+uchar_size) &gt; fence)
<a name="l03653"></a>03653         <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03654"></a>03654 
<a name="l03655"></a>03655     <span class="keywordflow">switch</span> (uchar_size) {
<a name="l03656"></a>03656         <span class="keywordflow">case</span> 1: p++;
<a name="l03657"></a>03657             <span class="keywordflow">break</span>;
<a name="l03658"></a>03658         <span class="keywordflow">case</span> 2: ret = (ret&amp;0x1F)&lt;&lt;6; p++;
<a name="l03659"></a>03659             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03660"></a>03660             ret |= c&amp;0x3F;
<a name="l03661"></a>03661             <span class="keywordflow">break</span>;
<a name="l03662"></a>03662         <span class="keywordflow">case</span> 3: ret = (ret&amp;0xF)&lt;&lt;12; p++;
<a name="l03663"></a>03663             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03664"></a>03664             ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l03665"></a>03665             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03666"></a>03666             ret |= c&amp;0x3F;
<a name="l03667"></a>03667             <span class="keywordflow">break</span>;
<a name="l03668"></a>03668         <span class="keywordflow">case</span> 4: ret = (ret&amp;0x7)&lt;&lt;18; p++;
<a name="l03669"></a>03669             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03670"></a>03670             ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l03671"></a>03671             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03672"></a>03672             ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l03673"></a>03673             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03674"></a>03674             ret |= c&amp;0x3F;
<a name="l03675"></a>03675             <span class="keywordflow">break</span>;
<a name="l03676"></a>03676         <span class="keywordflow">case</span> 5: ret = (ret&amp;0x3)&lt;&lt;24; p++;
<a name="l03677"></a>03677             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03678"></a>03678             ret |= (c&amp;0x3F)&lt;&lt;18;
<a name="l03679"></a>03679             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03680"></a>03680             ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l03681"></a>03681             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03682"></a>03682             ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l03683"></a>03683             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03684"></a>03684             ret |= c&amp;0x3F;
<a name="l03685"></a>03685             <span class="keywordflow">break</span>;
<a name="l03686"></a>03686         <span class="keywordflow">case</span> 6: ret = (ret&amp;0x1)&lt;&lt;30; p++;
<a name="l03687"></a>03687             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03688"></a>03688             ret |= (c&amp;0x3F)&lt;&lt;24;
<a name="l03689"></a>03689             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03690"></a>03690             ret |= (c&amp;0x3F)&lt;&lt;18;
<a name="l03691"></a>03691             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03692"></a>03692             ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l03693"></a>03693             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03694"></a>03694             ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l03695"></a>03695             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03696"></a>03696             ret |= c&amp;0x3F;
<a name="l03697"></a>03697             <span class="keywordflow">break</span>;
<a name="l03698"></a>03698     }
<a name="l03699"></a>03699 
<a name="l03700"></a>03700     *ptr = p;
<a name="l03701"></a>03701     <span class="keywordflow">return</span> ret;
<a name="l03702"></a>03702 }
<a name="l03703"></a>03703 
<a name="l03704"></a>03704 <span class="keywordtype">int</span> utf16le_encode(<span class="keywordtype">char</span> **ptr, <span class="keyword">const</span> <span class="keywordtype">char</span> *fence, uint32_t code) {
<a name="l03705"></a>03705     <span class="keywordtype">char</span> *p = *ptr;
<a name="l03706"></a>03706 
<a name="l03707"></a>03707     <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03708"></a>03708     <span class="keywordflow">if</span> (code &gt; 0x10FFFF) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03709"></a>03709     <span class="keywordflow">if</span> (code &gt; 0xFFFF) { <span class="comment">/* UTF-16 surrogate pair */</span>
<a name="l03710"></a>03710         uint32_t lo = (code - 0x10000) &amp; 0x3FF;
<a name="l03711"></a>03711         uint32_t hi = ((code - 0x10000) &gt;&gt; 10) &amp; 0x3FF;
<a name="l03712"></a>03712         <span class="keywordflow">if</span> ((p+2+2) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03713"></a>03713         *p++ = (char)( (hi+0xD800)       &amp; 0xFF);
<a name="l03714"></a>03714         *p++ = (char)(((hi+0xD800) &gt;&gt; 8) &amp; 0xFF);
<a name="l03715"></a>03715         *p++ = (char)( (lo+0xDC00)       &amp; 0xFF);
<a name="l03716"></a>03716         *p++ = (char)(((lo+0xDC00) &gt;&gt; 8) &amp; 0xFF);
<a name="l03717"></a>03717     }
<a name="l03718"></a>03718     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((code&amp;0xF800) == 0xD800) { <span class="comment">/* do not allow accidental surrogate pairs (0xD800-0xDFFF) */</span>
<a name="l03719"></a>03719         <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03720"></a>03720     }
<a name="l03721"></a>03721     <span class="keywordflow">else</span> {
<a name="l03722"></a>03722         <span class="keywordflow">if</span> ((p+2) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03723"></a>03723         *p++ = (char)( code       &amp; 0xFF);
<a name="l03724"></a>03724         *p++ = (char)((code &gt;&gt; 8) &amp; 0xFF);
<a name="l03725"></a>03725     }
<a name="l03726"></a>03726 
<a name="l03727"></a>03727     *ptr = p;
<a name="l03728"></a>03728     <span class="keywordflow">return</span> 0;
<a name="l03729"></a>03729 }
<a name="l03730"></a>03730 
<a name="l03731"></a>03731 <span class="keywordtype">int</span> utf16le_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> **ptr,<span class="keyword">const</span> <span class="keywordtype">char</span> *fence) {
<a name="l03732"></a>03732     <span class="keyword">const</span> <span class="keywordtype">char</span> *p = *ptr;
<a name="l03733"></a>03733     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ret,b=2;
<a name="l03734"></a>03734 
<a name="l03735"></a>03735     <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03736"></a>03736     <span class="keywordflow">if</span> ((p+1) &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03737"></a>03737 
<a name="l03738"></a>03738     ret = (<span class="keywordtype">unsigned</span> char)p[0];
<a name="l03739"></a>03739     ret |= ((<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)p[1])) &lt;&lt; 8;
<a name="l03740"></a>03740     <span class="keywordflow">if</span> (ret &gt;= 0xD800U &amp;&amp; ret &lt;= 0xDBFFU)
<a name="l03741"></a>03741         b=4;
<a name="l03742"></a>03742     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xDC00U &amp;&amp; ret &lt;= 0xDFFFU)
<a name="l03743"></a>03743         { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l03744"></a>03744 
<a name="l03745"></a>03745     <span class="keywordflow">if</span> ((p+b) &gt; fence)
<a name="l03746"></a>03746         <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03747"></a>03747 
<a name="l03748"></a>03748     p += 2;
<a name="l03749"></a>03749     <span class="keywordflow">if</span> (ret &gt;= 0xD800U &amp;&amp; ret &lt;= 0xDBFFU) {
<a name="l03750"></a>03750         <span class="comment">/* decode surrogate pair */</span>
<a name="l03751"></a>03751         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hi = ret &amp; 0x3FFU;
<a name="l03752"></a>03752         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lo = (<span class="keywordtype">unsigned</span> char)p[0];
<a name="l03753"></a>03753         lo |= ((<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)p[1])) &lt;&lt; 8;
<a name="l03754"></a>03754         p += 2;
<a name="l03755"></a>03755         <span class="keywordflow">if</span> (lo &lt; 0xDC00U || lo &gt; 0xDFFFU) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03756"></a>03756         lo &amp;= 0x3FFU;
<a name="l03757"></a>03757         ret = ((hi &lt;&lt; 10U) | lo) + 0x10000U;
<a name="l03758"></a>03758     }
<a name="l03759"></a>03759 
<a name="l03760"></a>03760     *ptr = p;
<a name="l03761"></a>03761     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)ret;
<a name="l03762"></a>03762 }
<a name="l03763"></a>03763 
<a name="l03764"></a>03764 <span class="keyword">extern</span> <span class="keywordtype">void</span> POD_Save_Sdlmain( std::ostream&amp; stream );
<a name="l03765"></a>03765 <span class="keyword">extern</span> <span class="keywordtype">void</span> POD_Load_Sdlmain( std::istream&amp; stream );
<a name="l03766"></a>03766 
<a name="l03767"></a>03767 <span class="comment">// save state support</span>
<a name="l03768"></a>03768 
<a name="l03769"></a>03769 <span class="keyword">namespace</span>
<a name="l03770"></a>03770 {
<a name="l03771"></a>03771 <span class="keyword">class </span>SerializeDosbox : <span class="keyword">public</span> SerializeGlobalPOD
<a name="l03772"></a>03772 {
<a name="l03773"></a>03773 <span class="keyword">public</span>:
<a name="l03774"></a>03774         SerializeDosbox() : SerializeGlobalPOD(<span class="stringliteral">&quot;Dosbox-x&quot;</span>)
<a name="l03775"></a>03775         {}
<a name="l03776"></a>03776 
<a name="l03777"></a>03777 <span class="keyword">private</span>:
<a name="l03778"></a>03778         <span class="keyword">virtual</span> <span class="keywordtype">void</span> getBytes(std::ostream&amp; stream)
<a name="l03779"></a>03779         {
<a name="l03780"></a>03780 
<a name="l03781"></a>03781                 <span class="comment">//******************************************</span>
<a name="l03782"></a>03782                 <span class="comment">//******************************************</span>
<a name="l03783"></a>03783                 <span class="comment">//******************************************</span>
<a name="l03784"></a>03784 
<a name="l03785"></a>03785                 SerializeGlobalPOD::getBytes(stream);
<a name="l03786"></a>03786 
<a name="l03787"></a>03787                 <span class="comment">//******************************************</span>
<a name="l03788"></a>03788                 <span class="comment">//******************************************</span>
<a name="l03789"></a>03789                 <span class="comment">//******************************************</span>
<a name="l03790"></a>03790 
<a name="l03791"></a>03791                 POD_Save_Sdlmain(stream);
<a name="l03792"></a>03792         }
<a name="l03793"></a>03793 
<a name="l03794"></a>03794         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setBytes(std::istream&amp; stream)
<a name="l03795"></a>03795         {
<a name="l03796"></a>03796 
<a name="l03797"></a>03797                 <span class="comment">//******************************************</span>
<a name="l03798"></a>03798                 <span class="comment">//******************************************</span>
<a name="l03799"></a>03799                 <span class="comment">//******************************************</span>
<a name="l03800"></a>03800 
<a name="l03801"></a>03801                 SerializeGlobalPOD::setBytes(stream);
<a name="l03802"></a>03802 
<a name="l03803"></a>03803                 <span class="comment">//******************************************</span>
<a name="l03804"></a>03804                 <span class="comment">//******************************************</span>
<a name="l03805"></a>03805                 <span class="comment">//******************************************</span>
<a name="l03806"></a>03806 
<a name="l03807"></a>03807                 POD_Load_Sdlmain(stream);
<a name="l03808"></a>03808 
<a name="l03809"></a>03809                 <span class="comment">//*******************************************</span>
<a name="l03810"></a>03810                 <span class="comment">//*******************************************</span>
<a name="l03811"></a>03811                 <span class="comment">//*******************************************</span>
<a name="l03812"></a>03812 
<a name="l03813"></a>03813                 <span class="comment">// Reset any auto cycle guessing for this frame</span>
<a name="l03814"></a>03814                 ticksRemain=5;
<a name="l03815"></a>03815                 ticksLast = GetTicks();
<a name="l03816"></a>03816                 ticksAdded = 0;
<a name="l03817"></a>03817                 ticksDone = 0;
<a name="l03818"></a>03818                 ticksScheduled = 0;
<a name="l03819"></a>03819         }
<a name="l03820"></a>03820 } dummy;
<a name="l03821"></a>03821 }
<a name="l03822"></a>03822 
<a name="l03823"></a>03823 <span class="preprocessor">#include &quot;zlib.h&quot;</span>
<a name="l03824"></a>03824 <span class="preprocessor">#ifdef WIN32</span>
<a name="l03825"></a>03825 <span class="preprocessor"></span><span class="preprocessor">#include &quot;direct.h&quot;</span>
<a name="l03826"></a>03826 <span class="preprocessor">#endif</span>
<a name="l03827"></a>03827 <span class="preprocessor"></span><span class="preprocessor">#include &quot;cross.h&quot;</span>
<a name="l03828"></a>03828 <span class="preprocessor">#include &quot;logging.h&quot;</span>
<a name="l03829"></a>03829 <span class="preprocessor">#if defined (__APPLE__)</span>
<a name="l03830"></a>03830 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l03831"></a>03831 <span class="preprocessor"></span><span class="preprocessor">#include &lt;malloc.h&gt;</span>
<a name="l03832"></a>03832 <span class="preprocessor">#endif</span>
<a name="l03833"></a>03833 <span class="preprocessor"></span><span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l03834"></a>03834 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l03835"></a>03835 
<a name="l03836"></a>03836 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l03837"></a>03837 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
<a name="l03838"></a>03838 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l03839"></a>03839 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l03840"></a>03840 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l03841"></a>03841 <span class="preprocessor">#include &quot;SDL.h&quot;</span>
<a name="l03842"></a>03842 
<a name="l03843"></a>03843 <span class="preprocessor">#ifndef WIN32</span>
<a name="l03844"></a>03844 <span class="preprocessor"></span><span class="keywordtype">char</span>* itoa(<span class="keywordtype">int</span> value, <span class="keywordtype">char</span>* str, <span class="keywordtype">int</span> radix) {
<a name="l03850"></a>03850                 <span class="comment">// check that the radix if valid</span>
<a name="l03851"></a>03851                 <span class="keywordflow">if</span> (radix &lt; 2 || radix &gt; 36) { *str = <span class="charliteral">&#39;\0&#39;</span>; <span class="keywordflow">return</span> str; }
<a name="l03852"></a>03852 
<a name="l03853"></a>03853                 <span class="keywordtype">char</span>* ptr = str, *ptr1 = str, tmp_char;
<a name="l03854"></a>03854                 <span class="keywordtype">int</span> tmp_value;
<a name="l03855"></a>03855 
<a name="l03856"></a>03856                 <span class="keywordflow">do</span> {
<a name="l03857"></a>03857                         tmp_value = value;
<a name="l03858"></a>03858                         value /= radix;
<a name="l03859"></a>03859                         *ptr++ = <span class="stringliteral">&quot;zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz&quot;</span> [35 + (tmp_value - value * radix)];
<a name="l03860"></a>03860                 } <span class="keywordflow">while</span> ( value );
<a name="l03861"></a>03861 
<a name="l03862"></a>03862                 <span class="comment">// Apply negative sign</span>
<a name="l03863"></a>03863                 <span class="keywordflow">if</span> (tmp_value &lt; 0) *ptr++ = <span class="charliteral">&#39;-&#39;</span>;
<a name="l03864"></a>03864                 *ptr-- = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03865"></a>03865                 <span class="keywordflow">while</span>(ptr1 &lt; ptr) {
<a name="l03866"></a>03866                         tmp_char = *ptr;
<a name="l03867"></a>03867                         *ptr--= *ptr1;
<a name="l03868"></a>03868                         *ptr1++ = tmp_char;
<a name="l03869"></a>03869                 }
<a name="l03870"></a>03870                 <span class="keywordflow">return</span> str;
<a name="l03871"></a>03871 }
<a name="l03872"></a>03872 <span class="preprocessor">#endif</span>
<a name="l03873"></a>03873 <span class="preprocessor"></span>
<a name="l03874"></a>03874 SaveState&amp; SaveState::instance() {
<a name="l03875"></a>03875     <span class="keyword">static</span> SaveState singleton;
<a name="l03876"></a>03876     <span class="keywordflow">return</span> singleton;
<a name="l03877"></a>03877 }
<a name="l03878"></a>03878 
<a name="l03879"></a>03879 <span class="keywordtype">void</span> SaveState::registerComponent(<span class="keyword">const</span> std::string&amp; uniqueName, Component&amp; comp) {
<a name="l03880"></a>03880     components.insert(std::make_pair(uniqueName, CompData(comp)));
<a name="l03881"></a>03881 }
<a name="l03882"></a>03882 
<a name="l03883"></a>03883 <span class="keyword">namespace </span>Util {
<a name="l03884"></a>03884 std::string compress(<span class="keyword">const</span> std::string&amp; input) { <span class="comment">//throw (SaveState::Error)</span>
<a name="l03885"></a>03885         <span class="keywordflow">if</span> (input.empty())
<a name="l03886"></a>03886                 <span class="keywordflow">return</span> input;
<a name="l03887"></a>03887 
<a name="l03888"></a>03888         <span class="keyword">const</span> uLong bufferSize = ::compressBound(input.size());
<a name="l03889"></a>03889 
<a name="l03890"></a>03890         std::string output;
<a name="l03891"></a>03891         output.resize(bufferSize);
<a name="l03892"></a>03892 
<a name="l03893"></a>03893         uLongf actualSize = bufferSize;
<a name="l03894"></a>03894         <span class="keywordflow">if</span> (::compress2(reinterpret_cast&lt;Bytef*&gt;(&amp;output[0]), &amp;actualSize,
<a name="l03895"></a>03895                                         reinterpret_cast&lt;const Bytef*&gt;(input.c_str()), input.size(), Z_BEST_SPEED) != Z_OK)
<a name="l03896"></a>03896                 <span class="keywordflow">throw</span> SaveState::Error(<span class="stringliteral">&quot;Compression failed!&quot;</span>);
<a name="l03897"></a>03897 
<a name="l03898"></a>03898         output.resize(actualSize);
<a name="l03899"></a>03899 
<a name="l03900"></a>03900         <span class="comment">//save size of uncompressed data</span>
<a name="l03901"></a>03901         <span class="keyword">const</span> <span class="keywordtype">size_t</span> uncompressedSize = input.size(); <span class="comment">//save size of uncompressed data</span>
<a name="l03902"></a>03902         output.resize(output.size() + <span class="keyword">sizeof</span>(uncompressedSize)); <span class="comment">//won&#39;t trigger a reallocation</span>
<a name="l03903"></a>03903         ::memcpy(&amp;output[0] + output.size() - <span class="keyword">sizeof</span>(uncompressedSize), &amp;uncompressedSize, <span class="keyword">sizeof</span>(uncompressedSize));
<a name="l03904"></a>03904 
<a name="l03905"></a>03905         <span class="keywordflow">return</span> std::string(&amp;output[0], output.size()); <span class="comment">//strip reserved space</span>
<a name="l03906"></a>03906 }
<a name="l03907"></a>03907 
<a name="l03908"></a>03908 std::string decompress(<span class="keyword">const</span> std::string&amp; input) { <span class="comment">//throw (SaveState::Error)</span>
<a name="l03909"></a>03909         <span class="keywordflow">if</span> (input.empty())
<a name="l03910"></a>03910                 <span class="keywordflow">return</span> input;
<a name="l03911"></a>03911 
<a name="l03912"></a>03912         <span class="comment">//retrieve size of uncompressed data</span>
<a name="l03913"></a>03913         <span class="keywordtype">size_t</span> uncompressedSize = 0;
<a name="l03914"></a>03914         ::memcpy(&amp;uncompressedSize, &amp;input[0] + input.size() - <span class="keyword">sizeof</span>(uncompressedSize), <span class="keyword">sizeof</span>(uncompressedSize));
<a name="l03915"></a>03915 
<a name="l03916"></a>03916         std::string output;
<a name="l03917"></a>03917         output.resize(uncompressedSize);
<a name="l03918"></a>03918 
<a name="l03919"></a>03919         uLongf actualSize = uncompressedSize;
<a name="l03920"></a>03920         <span class="keywordflow">if</span> (::uncompress(reinterpret_cast&lt;Bytef*&gt;(&amp;output[0]), &amp;actualSize,
<a name="l03921"></a>03921                                          reinterpret_cast&lt;const Bytef*&gt;(input.c_str()), input.size() - <span class="keyword">sizeof</span>(uncompressedSize)) != Z_OK)
<a name="l03922"></a>03922                 <span class="keywordflow">throw</span> SaveState::Error(<span class="stringliteral">&quot;Decompression failed!&quot;</span>);
<a name="l03923"></a>03923 
<a name="l03924"></a>03924         output.resize(actualSize); <span class="comment">//should be superfluous!</span>
<a name="l03925"></a>03925 
<a name="l03926"></a>03926         <span class="keywordflow">return</span> output;
<a name="l03927"></a>03927 }
<a name="l03928"></a>03928 }
<a name="l03929"></a>03929 
<a name="l03930"></a>03930 <span class="keyword">inline</span> <span class="keywordtype">void</span> SaveState::RawBytes::set(<span class="keyword">const</span> std::string&amp; stream) {
<a name="l03931"></a>03931         bytes = stream;
<a name="l03932"></a>03932         isCompressed = <span class="keyword">false</span>;
<a name="l03933"></a>03933         dataExists   = <span class="keyword">true</span>;
<a name="l03934"></a>03934 }
<a name="l03935"></a>03935 
<a name="l03936"></a>03936 <span class="keyword">inline</span> std::string SaveState::RawBytes::get()<span class="keyword"> const </span>{ <span class="comment">//throw (Error){</span>
<a name="l03937"></a>03937         <span class="keywordflow">if</span> (isCompressed)
<a name="l03938"></a>03938                 (Util::decompress(bytes)).swap(bytes);
<a name="l03939"></a>03939         isCompressed = <span class="keyword">false</span>;
<a name="l03940"></a>03940         <span class="keywordflow">return</span> bytes;
<a name="l03941"></a>03941 }
<a name="l03942"></a>03942 
<a name="l03943"></a>03943 <span class="keyword">inline</span> <span class="keywordtype">void</span> SaveState::RawBytes::compress()<span class="keyword"> const </span>{ <span class="comment">//throw (Error)</span>
<a name="l03944"></a>03944         <span class="keywordflow">if</span> (!isCompressed)
<a name="l03945"></a>03945                 (Util::compress(bytes)).swap(bytes);
<a name="l03946"></a>03946         isCompressed = <span class="keyword">true</span>;
<a name="l03947"></a>03947 }
<a name="l03948"></a>03948 
<a name="l03949"></a>03949 <span class="keyword">inline</span> <span class="keywordtype">bool</span> SaveState::RawBytes::dataAvailable()<span class="keyword"> const </span>{
<a name="l03950"></a>03950         <span class="keywordflow">return</span> dataExists;
<a name="l03951"></a>03951 }
<a name="l03952"></a>03952 
<a name="l03953"></a>03953 <span class="preprocessor">#define CASESENSITIVITY (0)</span>
<a name="l03954"></a>03954 <span class="preprocessor"></span><span class="preprocessor">#define MAXFILENAME (256)</span>
<a name="l03955"></a>03955 <span class="preprocessor"></span>
<a name="l03956"></a>03956 <span class="keywordtype">int</span> mymkdir(<span class="keyword">const</span> <span class="keywordtype">char</span>* dirname)
<a name="l03957"></a>03957 {
<a name="l03958"></a>03958     <span class="keywordtype">int</span> ret=0;
<a name="l03959"></a>03959 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l03960"></a>03960 <span class="preprocessor"></span>    ret = _mkdir(dirname);
<a name="l03961"></a>03961 <span class="preprocessor">#elif unix</span>
<a name="l03962"></a>03962 <span class="preprocessor"></span>    ret = mkdir (dirname,0775);
<a name="l03963"></a>03963 <span class="preprocessor">#elif __APPLE__</span>
<a name="l03964"></a>03964 <span class="preprocessor"></span>    ret = mkdir (dirname,0775);
<a name="l03965"></a>03965 <span class="preprocessor">#endif</span>
<a name="l03966"></a>03966 <span class="preprocessor"></span>    <span class="keywordflow">return</span> ret;
<a name="l03967"></a>03967 }
<a name="l03968"></a>03968 
<a name="l03969"></a>03969 <span class="keywordtype">int</span> makedir(<span class="keyword">const</span> <span class="keywordtype">char</span> *newdir)
<a name="l03970"></a>03970 {
<a name="l03971"></a>03971   <span class="keywordtype">char</span> *buffer ;
<a name="l03972"></a>03972   <span class="keywordtype">char</span> *p;
<a name="l03973"></a>03973   <span class="keywordtype">int</span>  len = (int)strlen(newdir);
<a name="l03974"></a>03974 
<a name="l03975"></a>03975   <span class="keywordflow">if</span> (len &lt;= 0)
<a name="l03976"></a>03976     <span class="keywordflow">return</span> 0;
<a name="l03977"></a>03977 
<a name="l03978"></a>03978   buffer = (<span class="keywordtype">char</span>*)malloc(len+1);
<a name="l03979"></a>03979         <span class="keywordflow">if</span> (buffer==NULL)
<a name="l03980"></a>03980         {
<a name="l03981"></a>03981                 printf(<span class="stringliteral">&quot;Error allocating memory\n&quot;</span>);
<a name="l03982"></a>03982                 <span class="keywordflow">return</span> UNZ_INTERNALERROR;
<a name="l03983"></a>03983         }
<a name="l03984"></a>03984   strcpy(buffer,newdir);
<a name="l03985"></a>03985 
<a name="l03986"></a>03986   <span class="keywordflow">if</span> (buffer[len-1] == <span class="charliteral">&#39;/&#39;</span>) {
<a name="l03987"></a>03987     buffer[len-1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03988"></a>03988   }
<a name="l03989"></a>03989   <span class="keywordflow">if</span> (mymkdir(buffer) == 0)
<a name="l03990"></a>03990     {
<a name="l03991"></a>03991       free(buffer);
<a name="l03992"></a>03992       <span class="keywordflow">return</span> 1;
<a name="l03993"></a>03993     }
<a name="l03994"></a>03994 
<a name="l03995"></a>03995   p = buffer+1;
<a name="l03996"></a>03996   <span class="keywordflow">while</span> (1)
<a name="l03997"></a>03997     {
<a name="l03998"></a>03998       <span class="keywordtype">char</span> hold;
<a name="l03999"></a>03999 
<a name="l04000"></a>04000       <span class="keywordflow">while</span>(*p &amp;&amp; *p != <span class="charliteral">&#39;\\&#39;</span> &amp;&amp; *p != <span class="charliteral">&#39;/&#39;</span>)
<a name="l04001"></a>04001         p++;
<a name="l04002"></a>04002       hold = *p;
<a name="l04003"></a>04003       *p = 0;
<a name="l04004"></a>04004       <span class="keywordflow">if</span> ((mymkdir(buffer) == -1) &amp;&amp; (errno == ENOENT))
<a name="l04005"></a>04005         {
<a name="l04006"></a>04006           printf(<span class="stringliteral">&quot;couldn&#39;t create directory %s\n&quot;</span>,buffer);
<a name="l04007"></a>04007           free(buffer);
<a name="l04008"></a>04008           <span class="keywordflow">return</span> 0;
<a name="l04009"></a>04009         }
<a name="l04010"></a>04010       <span class="keywordflow">if</span> (hold == 0)
<a name="l04011"></a>04011         <span class="keywordflow">break</span>;
<a name="l04012"></a>04012       *p++ = hold;
<a name="l04013"></a>04013     }
<a name="l04014"></a>04014   free(buffer);
<a name="l04015"></a>04015   <span class="keywordflow">return</span> 1;
<a name="l04016"></a>04016 }
<a name="l04017"></a>04017 
<a name="l04018"></a>04018 <span class="keywordtype">void</span> change_file_date(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, uLong dosdate, <a class="code" href="structtm__unz__s.html">tm_unz</a> tmu_date)
<a name="l04019"></a>04019 {
<a name="l04020"></a>04020     (void)dosdate;
<a name="l04021"></a>04021 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l04022"></a>04022 <span class="preprocessor"></span>  HANDLE hFile;
<a name="l04023"></a>04023   FILETIME ftm,ftLocal,ftCreate,ftLastAcc,ftLastWrite;
<a name="l04024"></a>04024 
<a name="l04025"></a>04025   hFile = CreateFileA(filename,GENERIC_READ | GENERIC_WRITE,
<a name="l04026"></a>04026                       0,NULL,OPEN_EXISTING,0,NULL);
<a name="l04027"></a>04027   GetFileTime(hFile,&amp;ftCreate,&amp;ftLastAcc,&amp;ftLastWrite);
<a name="l04028"></a>04028   DosDateTimeToFileTime((WORD)(dosdate&gt;&gt;16),(WORD)dosdate,&amp;ftLocal);
<a name="l04029"></a>04029   LocalFileTimeToFileTime(&amp;ftLocal,&amp;ftm);
<a name="l04030"></a>04030   SetFileTime(hFile,&amp;ftm,&amp;ftLastAcc,&amp;ftm);
<a name="l04031"></a>04031   CloseHandle(hFile);
<a name="l04032"></a>04032 <span class="preprocessor">#else</span>
<a name="l04033"></a>04033 <span class="preprocessor"></span><span class="preprocessor">#if defined(unix) || defined(__APPLE__)</span>
<a name="l04034"></a>04034 <span class="preprocessor"></span>  <span class="keyword">struct </span>utimbuf ut;
<a name="l04035"></a>04035   <span class="keyword">struct </span>tm newdate;
<a name="l04036"></a>04036   newdate.tm_sec = tmu_date.tm_sec;
<a name="l04037"></a>04037   newdate.tm_min=tmu_date.tm_min;
<a name="l04038"></a>04038   newdate.tm_hour=tmu_date.tm_hour;
<a name="l04039"></a>04039   newdate.tm_mday=tmu_date.tm_mday;
<a name="l04040"></a>04040   newdate.tm_mon=tmu_date.tm_mon;
<a name="l04041"></a>04041   <span class="keywordflow">if</span> (tmu_date.tm_year &gt; 1900)
<a name="l04042"></a>04042       newdate.tm_year=tmu_date.tm_year - 1900;
<a name="l04043"></a>04043   <span class="keywordflow">else</span>
<a name="l04044"></a>04044       newdate.tm_year=tmu_date.tm_year ;
<a name="l04045"></a>04045   newdate.tm_isdst=-1;
<a name="l04046"></a>04046 
<a name="l04047"></a>04047   ut.actime=ut.modtime=mktime(&amp;newdate);
<a name="l04048"></a>04048   utime(filename,&amp;ut);
<a name="l04049"></a>04049 <span class="preprocessor">#endif</span>
<a name="l04050"></a>04050 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04051"></a>04051 <span class="preprocessor"></span>}
<a name="l04052"></a>04052 
<a name="l04053"></a>04053 <span class="keywordtype">int</span> do_extract_currentfile(unzFile uf, <span class="keyword">const</span> <span class="keywordtype">int</span>* popt_extract_without_path, <span class="keywordtype">int</span>* popt_overwrite, <span class="keyword">const</span> <span class="keywordtype">char</span>* password)
<a name="l04054"></a>04054 {
<a name="l04055"></a>04055     <span class="keywordtype">char</span> filename_inzip[256];
<a name="l04056"></a>04056     <span class="keywordtype">char</span>* filename_withoutpath;
<a name="l04057"></a>04057     <span class="keywordtype">char</span>* p;
<a name="l04058"></a>04058     <span class="keywordtype">int</span> err=UNZ_OK;
<a name="l04059"></a>04059     FILE *fout=NULL;
<a name="l04060"></a>04060     <span class="keywordtype">void</span>* buf;
<a name="l04061"></a>04061     uInt size_buf;
<a name="l04062"></a>04062 
<a name="l04063"></a>04063     <a class="code" href="structunz__file__info64__s.html">unz_file_info64</a> file_info;
<a name="l04064"></a>04064     uLong ratio=0;
<a name="l04065"></a>04065     err = unzGetCurrentFileInfo64(uf,&amp;file_info,filename_inzip,<span class="keyword">sizeof</span>(filename_inzip),NULL,0,NULL,0);
<a name="l04066"></a>04066 
<a name="l04067"></a>04067     (void)ratio;
<a name="l04068"></a>04068 
<a name="l04069"></a>04069     <span class="keywordflow">if</span> (err!=UNZ_OK)
<a name="l04070"></a>04070     {
<a name="l04071"></a>04071         printf(<span class="stringliteral">&quot;error %d with zipfile in unzGetCurrentFileInfo\n&quot;</span>,err);
<a name="l04072"></a>04072         <span class="keywordflow">return</span> err;
<a name="l04073"></a>04073     }
<a name="l04074"></a>04074 
<a name="l04075"></a>04075     size_buf = 8192;
<a name="l04076"></a>04076     buf = (<span class="keywordtype">void</span>*)malloc(size_buf);
<a name="l04077"></a>04077     <span class="keywordflow">if</span> (buf==NULL)
<a name="l04078"></a>04078     {
<a name="l04079"></a>04079         printf(<span class="stringliteral">&quot;Error allocating memory\n&quot;</span>);
<a name="l04080"></a>04080         <span class="keywordflow">return</span> UNZ_INTERNALERROR;
<a name="l04081"></a>04081     }
<a name="l04082"></a>04082 
<a name="l04083"></a>04083     p = filename_withoutpath = filename_inzip;
<a name="l04084"></a>04084     <span class="keywordflow">while</span> ((*p) != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l04085"></a>04085     {
<a name="l04086"></a>04086         <span class="keywordflow">if</span> (((*p)==<span class="charliteral">&#39;/&#39;</span>) || ((*p)==<span class="charliteral">&#39;\\&#39;</span>))
<a name="l04087"></a>04087             filename_withoutpath = p+1;
<a name="l04088"></a>04088         p++;
<a name="l04089"></a>04089     }
<a name="l04090"></a>04090 
<a name="l04091"></a>04091     <span class="keywordflow">if</span> ((*filename_withoutpath)==<span class="charliteral">&#39;\0&#39;</span>)
<a name="l04092"></a>04092     {
<a name="l04093"></a>04093         <span class="keywordflow">if</span> ((*popt_extract_without_path)==0)
<a name="l04094"></a>04094         {
<a name="l04095"></a>04095             printf(<span class="stringliteral">&quot;creating directory: %s\n&quot;</span>,filename_inzip);
<a name="l04096"></a>04096             mymkdir(filename_inzip);
<a name="l04097"></a>04097         }
<a name="l04098"></a>04098     }
<a name="l04099"></a>04099     <span class="keywordflow">else</span>
<a name="l04100"></a>04100     {
<a name="l04101"></a>04101         <span class="keyword">const</span> <span class="keywordtype">char</span>* write_filename;
<a name="l04102"></a>04102         <span class="keywordtype">int</span> skip=0;
<a name="l04103"></a>04103 
<a name="l04104"></a>04104         <span class="keywordflow">if</span> ((*popt_extract_without_path)==0)
<a name="l04105"></a>04105             write_filename = filename_inzip;
<a name="l04106"></a>04106         <span class="keywordflow">else</span>
<a name="l04107"></a>04107             write_filename = filename_withoutpath;
<a name="l04108"></a>04108 
<a name="l04109"></a>04109         err = unzOpenCurrentFilePassword(uf,password);
<a name="l04110"></a>04110         <span class="keywordflow">if</span> (err!=UNZ_OK)
<a name="l04111"></a>04111         {
<a name="l04112"></a>04112             printf(<span class="stringliteral">&quot;error %d with zipfile in unzOpenCurrentFilePassword\n&quot;</span>,err);
<a name="l04113"></a>04113         }
<a name="l04114"></a>04114 
<a name="l04115"></a>04115         <span class="keywordflow">if</span> (((*popt_overwrite)==0) &amp;&amp; (err==UNZ_OK))
<a name="l04116"></a>04116         {
<a name="l04117"></a>04117             <span class="keywordtype">char</span> rep=0;
<a name="l04118"></a>04118             FILE* ftestexist;
<a name="l04119"></a>04119             ftestexist = FOPEN_FUNC(write_filename,<span class="stringliteral">&quot;rb&quot;</span>);
<a name="l04120"></a>04120             <span class="keywordflow">if</span> (ftestexist!=NULL)
<a name="l04121"></a>04121             {
<a name="l04122"></a>04122                 fclose(ftestexist);
<a name="l04123"></a>04123                 <span class="keywordflow">do</span>
<a name="l04124"></a>04124                 {
<a name="l04125"></a>04125                     <span class="keywordtype">char</span> answer[128];
<a name="l04126"></a>04126                     <span class="keywordtype">int</span> ret;
<a name="l04127"></a>04127 
<a name="l04128"></a>04128                     printf(<span class="stringliteral">&quot;The file %s exists. Overwrite ? [y]es, [n]o, [A]ll: &quot;</span>,write_filename);
<a name="l04129"></a>04129                     ret = scanf(<span class="stringliteral">&quot;%1s&quot;</span>,answer);
<a name="l04130"></a>04130                     <span class="keywordflow">if</span> (ret != 1)
<a name="l04131"></a>04131                     {
<a name="l04132"></a>04132                        exit(EXIT_FAILURE);
<a name="l04133"></a>04133                     }
<a name="l04134"></a>04134                     rep = answer[0] ;
<a name="l04135"></a>04135                     <span class="keywordflow">if</span> ((rep&gt;=<span class="charliteral">&#39;a&#39;</span>) &amp;&amp; (rep&lt;=<span class="charliteral">&#39;z&#39;</span>))
<a name="l04136"></a>04136                         rep -= 0x20;
<a name="l04137"></a>04137                 }
<a name="l04138"></a>04138                 <span class="keywordflow">while</span> ((rep!=<span class="charliteral">&#39;Y&#39;</span>) &amp;&amp; (rep!=<span class="charliteral">&#39;N&#39;</span>) &amp;&amp; (rep!=<span class="charliteral">&#39;A&#39;</span>));
<a name="l04139"></a>04139             }
<a name="l04140"></a>04140 
<a name="l04141"></a>04141             <span class="keywordflow">if</span> (rep == <span class="charliteral">&#39;N&#39;</span>)
<a name="l04142"></a>04142                 skip = 1;
<a name="l04143"></a>04143 
<a name="l04144"></a>04144             <span class="keywordflow">if</span> (rep == <span class="charliteral">&#39;A&#39;</span>)
<a name="l04145"></a>04145                 *popt_overwrite=1;
<a name="l04146"></a>04146         }
<a name="l04147"></a>04147 
<a name="l04148"></a>04148         <span class="keywordflow">if</span> ((skip==0) &amp;&amp; (err==UNZ_OK))
<a name="l04149"></a>04149         {
<a name="l04150"></a>04150             fout=FOPEN_FUNC(write_filename,<span class="stringliteral">&quot;wb&quot;</span>);
<a name="l04151"></a>04151             <span class="comment">/* some zipfile don&#39;t contain directory alone before file */</span>
<a name="l04152"></a>04152             <span class="keywordflow">if</span> ((fout==NULL) &amp;&amp; ((*popt_extract_without_path)==0) &amp;&amp;
<a name="l04153"></a>04153                                 (filename_withoutpath!=(<span class="keywordtype">char</span>*)filename_inzip))
<a name="l04154"></a>04154             {
<a name="l04155"></a>04155                 <span class="keywordtype">char</span> c=*(filename_withoutpath-1);
<a name="l04156"></a>04156                 *(filename_withoutpath-1)=<span class="charliteral">&#39;\0&#39;</span>;
<a name="l04157"></a>04157                 makedir(write_filename);
<a name="l04158"></a>04158                 *(filename_withoutpath-1)=c;
<a name="l04159"></a>04159                 fout=FOPEN_FUNC(write_filename,<span class="stringliteral">&quot;wb&quot;</span>);
<a name="l04160"></a>04160             }
<a name="l04161"></a>04161 
<a name="l04162"></a>04162             <span class="keywordflow">if</span> (fout==NULL)
<a name="l04163"></a>04163             {
<a name="l04164"></a>04164                 printf(<span class="stringliteral">&quot;error opening %s\n&quot;</span>,write_filename);
<a name="l04165"></a>04165             }
<a name="l04166"></a>04166         }
<a name="l04167"></a>04167 
<a name="l04168"></a>04168         <span class="keywordflow">if</span> (fout!=NULL)
<a name="l04169"></a>04169         {
<a name="l04170"></a>04170             printf(<span class="stringliteral">&quot; extracting: %s\n&quot;</span>,write_filename);
<a name="l04171"></a>04171 
<a name="l04172"></a>04172             <span class="keywordflow">do</span>
<a name="l04173"></a>04173             {
<a name="l04174"></a>04174                 err = unzReadCurrentFile(uf,buf,size_buf);
<a name="l04175"></a>04175                 <span class="keywordflow">if</span> (err&lt;0)
<a name="l04176"></a>04176                 {
<a name="l04177"></a>04177                     printf(<span class="stringliteral">&quot;error %d with zipfile in unzReadCurrentFile\n&quot;</span>,err);
<a name="l04178"></a>04178                     <span class="keywordflow">break</span>;
<a name="l04179"></a>04179                 }
<a name="l04180"></a>04180                 <span class="keywordflow">if</span> (err&gt;0)
<a name="l04181"></a>04181                     <span class="keywordflow">if</span> (fwrite(buf,err,1,fout)!=1)
<a name="l04182"></a>04182                     {
<a name="l04183"></a>04183                         printf(<span class="stringliteral">&quot;error in writing extracted file\n&quot;</span>);
<a name="l04184"></a>04184                         err=UNZ_ERRNO;
<a name="l04185"></a>04185                         <span class="keywordflow">break</span>;
<a name="l04186"></a>04186                     }
<a name="l04187"></a>04187             }
<a name="l04188"></a>04188             <span class="keywordflow">while</span> (err&gt;0);
<a name="l04189"></a>04189             <span class="keywordflow">if</span> (fout)
<a name="l04190"></a>04190                     fclose(fout);
<a name="l04191"></a>04191 
<a name="l04192"></a>04192             <span class="keywordflow">if</span> (err==0)
<a name="l04193"></a>04193                 change_file_date(write_filename,file_info.dosDate,
<a name="l04194"></a>04194                                  file_info.tmu_date);
<a name="l04195"></a>04195         }
<a name="l04196"></a>04196 
<a name="l04197"></a>04197         <span class="keywordflow">if</span> (err==UNZ_OK)
<a name="l04198"></a>04198         {
<a name="l04199"></a>04199             err = unzCloseCurrentFile (uf);
<a name="l04200"></a>04200             <span class="keywordflow">if</span> (err!=UNZ_OK)
<a name="l04201"></a>04201             {
<a name="l04202"></a>04202                 printf(<span class="stringliteral">&quot;error %d with zipfile in unzCloseCurrentFile\n&quot;</span>,err);
<a name="l04203"></a>04203             }
<a name="l04204"></a>04204         }
<a name="l04205"></a>04205         <span class="keywordflow">else</span>
<a name="l04206"></a>04206             unzCloseCurrentFile(uf); <span class="comment">/* don&#39;t lose the error */</span>
<a name="l04207"></a>04207     }
<a name="l04208"></a>04208 
<a name="l04209"></a>04209     free(buf);
<a name="l04210"></a>04210     <span class="keywordflow">return</span> err;
<a name="l04211"></a>04211 }
<a name="l04212"></a>04212 
<a name="l04213"></a>04213 <span class="keywordtype">int</span> do_extract(unzFile uf, <span class="keywordtype">int</span> opt_extract_without_path, <span class="keywordtype">int</span> opt_overwrite, <span class="keyword">const</span> <span class="keywordtype">char</span>* password)
<a name="l04214"></a>04214 {
<a name="l04215"></a>04215     uLong i;
<a name="l04216"></a>04216     <a class="code" href="structunz__global__info64__s.html">unz_global_info64</a> gi;
<a name="l04217"></a>04217     <span class="keywordtype">int</span> err;
<a name="l04218"></a>04218     FILE* fout=NULL;
<a name="l04219"></a>04219 
<a name="l04220"></a>04220     (void)fout;
<a name="l04221"></a>04221 
<a name="l04222"></a>04222     err = unzGetGlobalInfo64(uf,&amp;gi);
<a name="l04223"></a>04223     <span class="keywordflow">if</span> (err!=UNZ_OK) {
<a name="l04224"></a>04224         printf(<span class="stringliteral">&quot;error %d with zipfile in unzGetGlobalInfo \n&quot;</span>,err);
<a name="l04225"></a>04225         <span class="keywordflow">return</span> 0;
<a name="l04226"></a>04226     }
<a name="l04227"></a>04227 
<a name="l04228"></a>04228     <span class="keywordflow">for</span> (i=0;i&lt;gi.number_entry;i++)
<a name="l04229"></a>04229     {
<a name="l04230"></a>04230         <span class="keywordflow">if</span> (do_extract_currentfile(uf,&amp;opt_extract_without_path,
<a name="l04231"></a>04231                                       &amp;opt_overwrite,
<a name="l04232"></a>04232                                       password) != UNZ_OK)
<a name="l04233"></a>04233             <span class="keywordflow">break</span>;
<a name="l04234"></a>04234 
<a name="l04235"></a>04235         <span class="keywordflow">if</span> ((i+1)&lt;gi.number_entry)
<a name="l04236"></a>04236         {
<a name="l04237"></a>04237             err = unzGoToNextFile(uf);
<a name="l04238"></a>04238             <span class="keywordflow">if</span> (err!=UNZ_OK)
<a name="l04239"></a>04239             {
<a name="l04240"></a>04240                 printf(<span class="stringliteral">&quot;error %d with zipfile in unzGoToNextFile\n&quot;</span>,err);
<a name="l04241"></a>04241                 <span class="keywordflow">break</span>;
<a name="l04242"></a>04242             }
<a name="l04243"></a>04243         }
<a name="l04244"></a>04244     }
<a name="l04245"></a>04245 
<a name="l04246"></a>04246     <span class="keywordflow">return</span> 0;
<a name="l04247"></a>04247 }
<a name="l04248"></a>04248 
<a name="l04249"></a>04249 <span class="keywordtype">int</span> do_extract_onefile(unzFile uf, <span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">int</span> opt_extract_without_path, <span class="keywordtype">int</span> opt_overwrite, <span class="keyword">const</span> <span class="keywordtype">char</span>* password)
<a name="l04250"></a>04250 {
<a name="l04251"></a>04251     <span class="keywordtype">int</span> err = UNZ_OK;
<a name="l04252"></a>04252     (void)err;
<a name="l04253"></a>04253     <span class="keywordflow">if</span> (unzLocateFile(uf,filename,CASESENSITIVITY)!=UNZ_OK)
<a name="l04254"></a>04254     {
<a name="l04255"></a>04255         printf(<span class="stringliteral">&quot;file %s not found in the zipfile\n&quot;</span>,filename);
<a name="l04256"></a>04256         <span class="keywordflow">return</span> 2;
<a name="l04257"></a>04257     }
<a name="l04258"></a>04258 
<a name="l04259"></a>04259     <span class="keywordflow">if</span> (do_extract_currentfile(uf,&amp;opt_extract_without_path,
<a name="l04260"></a>04260                                       &amp;opt_overwrite,
<a name="l04261"></a>04261                                       password) == UNZ_OK)
<a name="l04262"></a>04262         <span class="keywordflow">return</span> 0;
<a name="l04263"></a>04263     <span class="keywordflow">else</span>
<a name="l04264"></a>04264         <span class="keywordflow">return</span> 1;
<a name="l04265"></a>04265 }
<a name="l04266"></a>04266 
<a name="l04267"></a>04267 <span class="keywordtype">int</span> my_miniunz(<span class="keywordtype">char</span> ** savefile, <span class="keyword">const</span> <span class="keywordtype">char</span> * savefile2, <span class="keyword">const</span> <span class="keywordtype">char</span> * savedir) {
<a name="l04268"></a>04268     <span class="keyword">const</span> <span class="keywordtype">char</span> *zipfilename=NULL;
<a name="l04269"></a>04269     <span class="keyword">const</span> <span class="keywordtype">char</span> *filename_to_extract=NULL;
<a name="l04270"></a>04270     <span class="keyword">const</span> <span class="keywordtype">char</span> *password=NULL;
<a name="l04271"></a>04271     <span class="keywordtype">char</span> filename_try[MAXFILENAME+16] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l04272"></a>04272     <span class="keywordtype">int</span> ret_value=0;
<a name="l04273"></a>04273     <span class="keywordtype">int</span> opt_do_extract=1;
<a name="l04274"></a>04274     <span class="keywordtype">int</span> opt_do_extract_withoutpath=0;
<a name="l04275"></a>04275     <span class="keywordtype">int</span> opt_overwrite=0;
<a name="l04276"></a>04276     <span class="keywordtype">int</span> opt_extractdir=0;
<a name="l04277"></a>04277     <span class="keyword">const</span> <span class="keywordtype">char</span> *dirname=NULL;
<a name="l04278"></a>04278     unzFile uf=NULL;
<a name="l04279"></a>04279 
<a name="l04280"></a>04280                 opt_do_extract = opt_do_extract_withoutpath = 1;
<a name="l04281"></a>04281                 opt_overwrite=1;
<a name="l04282"></a>04282                 opt_extractdir=1;
<a name="l04283"></a>04283                 dirname=savedir;
<a name="l04284"></a>04284         zipfilename = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)savefile;
<a name="l04285"></a>04285         filename_to_extract = savefile2;
<a name="l04286"></a>04286 
<a name="l04287"></a>04287     <span class="keywordflow">if</span> (zipfilename!=NULL)
<a name="l04288"></a>04288     {
<a name="l04289"></a>04289 
<a name="l04290"></a>04290 <span class="preprocessor">#        ifdef USEWIN32IOAPI</span>
<a name="l04291"></a>04291 <span class="preprocessor"></span>        <a class="code" href="structzlib__filefunc64__def__s.html">zlib_filefunc64_def</a> ffunc;
<a name="l04292"></a>04292 <span class="preprocessor">#        endif</span>
<a name="l04293"></a>04293 <span class="preprocessor"></span>
<a name="l04294"></a>04294         strncpy(filename_try, zipfilename,MAXFILENAME-1);
<a name="l04295"></a>04295         <span class="comment">/* strncpy doesnt append the trailing NULL, of the string is too long. */</span>
<a name="l04296"></a>04296         filename_try[ MAXFILENAME ] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l04297"></a>04297 
<a name="l04298"></a>04298 <span class="preprocessor">#        ifdef USEWIN32IOAPI</span>
<a name="l04299"></a>04299 <span class="preprocessor"></span>        fill_win32_filefunc64A(&amp;ffunc);
<a name="l04300"></a>04300         uf = unzOpen2_64(zipfilename,&amp;ffunc);
<a name="l04301"></a>04301 <span class="preprocessor">#        else</span>
<a name="l04302"></a>04302 <span class="preprocessor"></span>        uf = unzOpen64(zipfilename);
<a name="l04303"></a>04303 <span class="preprocessor">#        endif</span>
<a name="l04304"></a>04304 <span class="preprocessor"></span>    }
<a name="l04305"></a>04305 
<a name="l04306"></a>04306     <span class="keywordflow">if</span> (uf==NULL)
<a name="l04307"></a>04307     {
<a name="l04308"></a>04308         <span class="comment">//printf(&quot;Cannot open %s\n&quot;,zipfilename,zipfilename);</span>
<a name="l04309"></a>04309         <span class="keywordflow">return</span> 1;
<a name="l04310"></a>04310     }
<a name="l04311"></a>04311     <span class="comment">//printf(&quot;%s opened\n&quot;,filename_try);</span>
<a name="l04312"></a>04312 
<a name="l04313"></a>04313         <span class="keywordflow">if</span> (opt_do_extract==1)
<a name="l04314"></a>04314     {
<a name="l04315"></a>04315                 <span class="keywordtype">char</span> cCurrentPath[FILENAME_MAX];
<a name="l04316"></a>04316                 <span class="keywordtype">char</span> *ret=getcwd(cCurrentPath, <span class="keyword">sizeof</span>(cCurrentPath));
<a name="l04317"></a>04317         <span class="keywordflow">if</span> (opt_extractdir &amp;&amp; chdir(dirname))
<a name="l04318"></a>04318         {
<a name="l04319"></a>04319           printf(<span class="stringliteral">&quot;Error changing into %s, aborting\n&quot;</span>, dirname);
<a name="l04320"></a>04320           exit(-1);
<a name="l04321"></a>04321         }
<a name="l04322"></a>04322 
<a name="l04323"></a>04323         <span class="keywordflow">if</span> (filename_to_extract == NULL)
<a name="l04324"></a>04324             ret_value = do_extract(uf, opt_do_extract_withoutpath, opt_overwrite, password);
<a name="l04325"></a>04325         <span class="keywordflow">else</span>
<a name="l04326"></a>04326             ret_value = do_extract_onefile(uf, filename_to_extract, opt_do_extract_withoutpath, opt_overwrite, password);
<a name="l04327"></a>04327                 <span class="keywordflow">if</span> (ret!=NULL) chdir(cCurrentPath);
<a name="l04328"></a>04328     }
<a name="l04329"></a>04329 
<a name="l04330"></a>04330     unzClose(uf);
<a name="l04331"></a>04331 
<a name="l04332"></a>04332     <span class="keywordflow">return</span> ret_value;
<a name="l04333"></a>04333 }
<a name="l04334"></a>04334 
<a name="l04335"></a>04335 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l04336"></a>04336 <span class="preprocessor"></span>uLong filetime(<span class="keywordtype">char</span> *f, <a class="code" href="structtm__zip__s.html">tm_zip</a> *tmzip, uLong *dt)
<a name="l04337"></a>04337 {
<a name="l04338"></a>04338   <span class="keywordtype">int</span> ret = 0;
<a name="l04339"></a>04339   {
<a name="l04340"></a>04340       FILETIME ftLocal;
<a name="l04341"></a>04341       HANDLE hFind;
<a name="l04342"></a>04342       WIN32_FIND_DATAA ff32;
<a name="l04343"></a>04343 
<a name="l04344"></a>04344       hFind = FindFirstFileA(f,&amp;ff32);
<a name="l04345"></a>04345       <span class="keywordflow">if</span> (hFind != INVALID_HANDLE_VALUE)
<a name="l04346"></a>04346       {
<a name="l04347"></a>04347         FileTimeToLocalFileTime(&amp;(ff32.ftLastWriteTime),&amp;ftLocal);
<a name="l04348"></a>04348         FileTimeToDosDateTime(&amp;ftLocal,((LPWORD)dt)+1,((LPWORD)dt)+0);
<a name="l04349"></a>04349         FindClose(hFind);
<a name="l04350"></a>04350         ret = 1;
<a name="l04351"></a>04351       }
<a name="l04352"></a>04352   }
<a name="l04353"></a>04353   <span class="keywordflow">return</span> ret;
<a name="l04354"></a>04354 }
<a name="l04355"></a>04355 <span class="preprocessor">#else</span>
<a name="l04356"></a>04356 <span class="preprocessor"></span><span class="preprocessor">#if defined(unix) || defined(__APPLE__)</span>
<a name="l04357"></a>04357 <span class="preprocessor"></span>uLong filetime(<span class="keywordtype">char</span> *f, <a class="code" href="structtm__zip__s.html">tm_zip</a> *tmzip, uLong *dt)
<a name="l04358"></a>04358 {
<a name="l04359"></a>04359     (void)dt;
<a name="l04360"></a>04360   <span class="keywordtype">int</span> ret=0;
<a name="l04361"></a>04361   <span class="keyword">struct </span>stat s;        <span class="comment">/* results of stat() */</span>
<a name="l04362"></a>04362   <span class="keyword">struct </span>tm* filedate;
<a name="l04363"></a>04363   time_t tm_t=0;
<a name="l04364"></a>04364 
<a name="l04365"></a>04365   <span class="keywordflow">if</span> (strcmp(f,<span class="stringliteral">&quot;-&quot;</span>)!=0)
<a name="l04366"></a>04366   {
<a name="l04367"></a>04367     <span class="keywordtype">char</span> name[MAXFILENAME+1];
<a name="l04368"></a>04368     <span class="keywordtype">int</span> len = strlen(f);
<a name="l04369"></a>04369     <span class="keywordflow">if</span> (len &gt; MAXFILENAME)
<a name="l04370"></a>04370       len = MAXFILENAME;
<a name="l04371"></a>04371 
<a name="l04372"></a>04372     strncpy(name, f,MAXFILENAME-1);
<a name="l04373"></a>04373     <span class="comment">/* strncpy doesnt append the trailing NULL, of the string is too long. */</span>
<a name="l04374"></a>04374     name[ MAXFILENAME ] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l04375"></a>04375 
<a name="l04376"></a>04376     <span class="keywordflow">if</span> (name[len - 1] == <span class="charliteral">&#39;/&#39;</span>)
<a name="l04377"></a>04377       name[len - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l04378"></a>04378     <span class="comment">/* not all systems allow stat&#39;ing a file with / appended */</span>
<a name="l04379"></a>04379     <span class="keywordflow">if</span> (stat(name,&amp;s)==0)
<a name="l04380"></a>04380     {
<a name="l04381"></a>04381       tm_t = s.st_mtime;
<a name="l04382"></a>04382       ret = 1;
<a name="l04383"></a>04383     }
<a name="l04384"></a>04384   }
<a name="l04385"></a>04385   filedate = localtime(&amp;tm_t);
<a name="l04386"></a>04386 
<a name="l04387"></a>04387   tmzip-&gt;tm_sec  = filedate-&gt;tm_sec;
<a name="l04388"></a>04388   tmzip-&gt;tm_min  = filedate-&gt;tm_min;
<a name="l04389"></a>04389   tmzip-&gt;tm_hour = filedate-&gt;tm_hour;
<a name="l04390"></a>04390   tmzip-&gt;tm_mday = filedate-&gt;tm_mday;
<a name="l04391"></a>04391   tmzip-&gt;tm_mon  = filedate-&gt;tm_mon ;
<a name="l04392"></a>04392   tmzip-&gt;tm_year = filedate-&gt;tm_year;
<a name="l04393"></a>04393 
<a name="l04394"></a>04394   <span class="keywordflow">return</span> ret;
<a name="l04395"></a>04395 }
<a name="l04396"></a>04396 <span class="preprocessor">#else</span>
<a name="l04397"></a>04397 <span class="preprocessor"></span>uLong filetime(<span class="keywordtype">char</span> *f, <a class="code" href="structtm__zip__s.html">tm_zip</a> *tmzip, uLong *dt)
<a name="l04398"></a>04398 {
<a name="l04399"></a>04399     <span class="keywordflow">return</span> 0;
<a name="l04400"></a>04400 }
<a name="l04401"></a>04401 <span class="preprocessor">#endif</span>
<a name="l04402"></a>04402 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04403"></a>04403 <span class="preprocessor"></span>
<a name="l04404"></a>04404 <span class="preprocessor">#ifdef __APPLE__</span>
<a name="l04405"></a>04405 <span class="preprocessor"></span><span class="comment">// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions</span>
<a name="l04406"></a>04406 <span class="preprocessor">#define FOPEN_FUNC(filename, mode) fopen(filename, mode)</span>
<a name="l04407"></a>04407 <span class="preprocessor"></span><span class="preprocessor">#define FTELLO_FUNC(stream) ftello(stream)</span>
<a name="l04408"></a>04408 <span class="preprocessor"></span><span class="preprocessor">#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)</span>
<a name="l04409"></a>04409 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l04410"></a>04410 <span class="preprocessor"></span><span class="preprocessor">#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)</span>
<a name="l04411"></a>04411 <span class="preprocessor"></span><span class="preprocessor">#define FTELLO_FUNC(stream) ftello64(stream)</span>
<a name="l04412"></a>04412 <span class="preprocessor"></span><span class="preprocessor">#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)</span>
<a name="l04413"></a>04413 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04414"></a>04414 <span class="preprocessor"></span>
<a name="l04415"></a>04415 <span class="keywordtype">int</span> getFileCrc(<span class="keyword">const</span> <span class="keywordtype">char</span>* filenameinzip,<span class="keywordtype">void</span>*buf,<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size_buf,<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* result_crc)
<a name="l04416"></a>04416 {
<a name="l04417"></a>04417     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> calculate_crc=0;
<a name="l04418"></a>04418     <span class="keywordtype">int</span> err=ZIP_OK;
<a name="l04419"></a>04419     FILE * fin = FOPEN_FUNC(filenameinzip,<span class="stringliteral">&quot;rb&quot;</span>);
<a name="l04420"></a>04420 
<a name="l04421"></a>04421     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size_read = 0;
<a name="l04422"></a>04422     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> total_read = 0;
<a name="l04423"></a>04423     <span class="keywordflow">if</span> (fin==NULL)
<a name="l04424"></a>04424        err = ZIP_ERRNO;
<a name="l04425"></a>04425 
<a name="l04426"></a>04426     <span class="keywordflow">if</span> (err == ZIP_OK)
<a name="l04427"></a>04427         <span class="keywordflow">do</span>
<a name="l04428"></a>04428         {
<a name="l04429"></a>04429             err = ZIP_OK;
<a name="l04430"></a>04430             size_read = (int)fread(buf,1,size_buf,fin);
<a name="l04431"></a>04431             <span class="keywordflow">if</span> (size_read &lt; size_buf)
<a name="l04432"></a>04432                 <span class="keywordflow">if</span> (feof(fin)==0)
<a name="l04433"></a>04433             {
<a name="l04434"></a>04434                 printf(<span class="stringliteral">&quot;error in reading %s\n&quot;</span>,filenameinzip);
<a name="l04435"></a>04435                 err = ZIP_ERRNO;
<a name="l04436"></a>04436             }
<a name="l04437"></a>04437 
<a name="l04438"></a>04438             <span class="keywordflow">if</span> (size_read&gt;0)
<a name="l04439"></a>04439                 calculate_crc = crc32(calculate_crc,(<span class="keyword">const</span> Bytef*)buf,size_read);
<a name="l04440"></a>04440             total_read += size_read;
<a name="l04441"></a>04441 
<a name="l04442"></a>04442         } <span class="keywordflow">while</span> ((err == ZIP_OK) &amp;&amp; (size_read&gt;0));
<a name="l04443"></a>04443 
<a name="l04444"></a>04444     <span class="keywordflow">if</span> (fin)
<a name="l04445"></a>04445         fclose(fin);
<a name="l04446"></a>04446 
<a name="l04447"></a>04447     *result_crc=calculate_crc;
<a name="l04448"></a>04448     printf(<span class="stringliteral">&quot;file %s crc %lx\n&quot;</span>, filenameinzip, calculate_crc);
<a name="l04449"></a>04449     <span class="keywordflow">return</span> err;
<a name="l04450"></a>04450 }
<a name="l04451"></a>04451 
<a name="l04452"></a>04452 <span class="keywordtype">int</span> isLargeFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)
<a name="l04453"></a>04453 {
<a name="l04454"></a>04454   <span class="keywordtype">int</span> largeFile = 0;
<a name="l04455"></a>04455   ZPOS64_T pos = 0;
<a name="l04456"></a>04456   FILE* pFile = FOPEN_FUNC(filename, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l04457"></a>04457 
<a name="l04458"></a>04458   <span class="keywordflow">if</span>(pFile != NULL)
<a name="l04459"></a>04459   {
<a name="l04460"></a>04460     <span class="keywordtype">int</span> n = FSEEKO_FUNC(pFile, 0, SEEK_END);
<a name="l04461"></a>04461     pos = FTELLO_FUNC(pFile);
<a name="l04462"></a>04462     (void)n;
<a name="l04463"></a>04463 
<a name="l04464"></a>04464                 printf(<span class="stringliteral">&quot;File : %s is %lld bytes\n&quot;</span>, filename, pos);
<a name="l04465"></a>04465 
<a name="l04466"></a>04466     <span class="keywordflow">if</span>(pos &gt;= 0xffffffff)
<a name="l04467"></a>04467      largeFile = 1;
<a name="l04468"></a>04468 
<a name="l04469"></a>04469                 fclose(pFile);
<a name="l04470"></a>04470   }
<a name="l04471"></a>04471 
<a name="l04472"></a>04472  <span class="keywordflow">return</span> largeFile;
<a name="l04473"></a>04473 }
<a name="l04474"></a>04474 
<a name="l04475"></a>04475 <span class="keywordtype">int</span> my_minizip(<span class="keywordtype">char</span> ** savefile, <span class="keywordtype">char</span> ** savefile2) {
<a name="l04476"></a>04476     <span class="keywordtype">int</span> opt_overwrite=0;
<a name="l04477"></a>04477     <span class="keywordtype">int</span> opt_compress_level=Z_DEFAULT_COMPRESSION;
<a name="l04478"></a>04478     <span class="keywordtype">int</span> opt_exclude_path=0;
<a name="l04479"></a>04479     <span class="keywordtype">int</span> zipfilenamearg = 0;
<a name="l04480"></a>04480     (void)zipfilenamearg;
<a name="l04481"></a>04481     <span class="comment">//char filename_try[MAXFILENAME16];</span>
<a name="l04482"></a>04482     <span class="keywordtype">int</span> err=0;
<a name="l04483"></a>04483     <span class="keywordtype">int</span> size_buf=0;
<a name="l04484"></a>04484     <span class="keywordtype">void</span>* buf=NULL;
<a name="l04485"></a>04485     <span class="keyword">const</span> <span class="keywordtype">char</span>* password=NULL;
<a name="l04486"></a>04486 
<a name="l04487"></a>04487         opt_overwrite = 2;
<a name="l04488"></a>04488         opt_compress_level = 9;
<a name="l04489"></a>04489         opt_exclude_path = 1;
<a name="l04490"></a>04490 
<a name="l04491"></a>04491     size_buf = 16384;
<a name="l04492"></a>04492     buf = (<span class="keywordtype">void</span>*)malloc(size_buf);
<a name="l04493"></a>04493     <span class="keywordflow">if</span> (buf==NULL)
<a name="l04494"></a>04494     {
<a name="l04495"></a>04495         <span class="comment">//printf(&quot;Error allocating memory\n&quot;);</span>
<a name="l04496"></a>04496         <span class="keywordflow">return</span> ZIP_INTERNALERROR;
<a name="l04497"></a>04497     }
<a name="l04498"></a>04498 
<a name="l04499"></a>04499     {
<a name="l04500"></a>04500         zipFile zf;
<a name="l04501"></a>04501         <span class="keywordtype">int</span> errclose;
<a name="l04502"></a>04502 <span class="preprocessor">#        ifdef USEWIN32IOAPI</span>
<a name="l04503"></a>04503 <span class="preprocessor"></span>        <a class="code" href="structzlib__filefunc64__def__s.html">zlib_filefunc64_def</a> ffunc;
<a name="l04504"></a>04504         fill_win32_filefunc64A(&amp;ffunc);
<a name="l04505"></a>04505         zf = zipOpen2_64(savefile,(opt_overwrite==2) ? 2 : 0,NULL,&amp;ffunc);
<a name="l04506"></a>04506 <span class="preprocessor">#        else</span>
<a name="l04507"></a>04507 <span class="preprocessor"></span>        zf = zipOpen64(savefile,(opt_overwrite==2) ? 2 : 0);
<a name="l04508"></a>04508 <span class="preprocessor">#        endif</span>
<a name="l04509"></a>04509 <span class="preprocessor"></span>
<a name="l04510"></a>04510         <span class="keywordflow">if</span> (zf == NULL)
<a name="l04511"></a>04511         {
<a name="l04512"></a>04512             <span class="comment">//printf(&quot;error opening %s\n&quot;,savefile);</span>
<a name="l04513"></a>04513             err= ZIP_ERRNO;
<a name="l04514"></a>04514         }
<a name="l04515"></a>04515         <span class="keywordflow">else</span>
<a name="l04516"></a>04516             <span class="comment">//printf(&quot;creating %s\n&quot;,savefile);</span>
<a name="l04517"></a>04517 
<a name="l04518"></a>04518             {
<a name="l04519"></a>04519                 FILE *fin = NULL;
<a name="l04520"></a>04520                 <span class="keywordtype">int</span> size_read;
<a name="l04521"></a>04521                 <span class="keywordtype">char</span>* filenameinzip = (<span class="keywordtype">char</span> *)savefile2;
<a name="l04522"></a>04522                 <span class="keyword">const</span> <span class="keywordtype">char</span> *savefilenameinzip;
<a name="l04523"></a>04523                 <a class="code" href="structzip__fileinfo.html">zip_fileinfo</a> zi;
<a name="l04524"></a>04524                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> crcFile=0;
<a name="l04525"></a>04525                 <span class="keywordtype">int</span> zip64 = 0;
<a name="l04526"></a>04526 
<a name="l04527"></a>04527                 zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour =
<a name="l04528"></a>04528                 zi.tmz_date.tm_mday = zi.tmz_date.tm_mon = zi.tmz_date.tm_year = 0;
<a name="l04529"></a>04529                 zi.dosDate = 0;
<a name="l04530"></a>04530                 zi.internal_fa = 0;
<a name="l04531"></a>04531                 zi.external_fa = 0;
<a name="l04532"></a>04532                 filetime(filenameinzip,&amp;zi.tmz_date,&amp;zi.dosDate);
<a name="l04533"></a>04533 
<a name="l04534"></a>04534                 <span class="keywordflow">if</span> ((password != NULL) &amp;&amp; (err==ZIP_OK))
<a name="l04535"></a>04535                     err = getFileCrc(filenameinzip,buf,size_buf,&amp;crcFile);
<a name="l04536"></a>04536 
<a name="l04537"></a>04537                 zip64 = isLargeFile(filenameinzip);
<a name="l04538"></a>04538 
<a name="l04539"></a>04539                                                          <span class="comment">/* The path name saved, should not include a leading slash. */</span>
<a name="l04540"></a>04540                <span class="comment">/*if it did, windows/xp and dynazip couldn&#39;t read the zip file. */</span>
<a name="l04541"></a>04541                  savefilenameinzip = filenameinzip;
<a name="l04542"></a>04542                  <span class="keywordflow">while</span>( savefilenameinzip[0] == <span class="charliteral">&#39;\\&#39;</span> || savefilenameinzip[0] == <span class="charliteral">&#39;/&#39;</span> )
<a name="l04543"></a>04543                  {
<a name="l04544"></a>04544                      savefilenameinzip++;
<a name="l04545"></a>04545                  }
<a name="l04546"></a>04546 
<a name="l04547"></a>04547                  <span class="comment">/*should the zip file contain any path at all?*/</span>
<a name="l04548"></a>04548                  <span class="keywordflow">if</span>( opt_exclude_path )
<a name="l04549"></a>04549                  {
<a name="l04550"></a>04550                      <span class="keyword">const</span> <span class="keywordtype">char</span> *tmpptr;
<a name="l04551"></a>04551                      <span class="keyword">const</span> <span class="keywordtype">char</span> *lastslash = 0;
<a name="l04552"></a>04552                      <span class="keywordflow">for</span>( tmpptr = savefilenameinzip; *tmpptr; tmpptr++)
<a name="l04553"></a>04553                      {
<a name="l04554"></a>04554                          <span class="keywordflow">if</span>( *tmpptr == <span class="charliteral">&#39;\\&#39;</span> || *tmpptr == <span class="charliteral">&#39;/&#39;</span>)
<a name="l04555"></a>04555                          {
<a name="l04556"></a>04556                              lastslash = tmpptr;
<a name="l04557"></a>04557                          }
<a name="l04558"></a>04558                      }
<a name="l04559"></a>04559                      <span class="keywordflow">if</span>( lastslash != NULL )
<a name="l04560"></a>04560                      {
<a name="l04561"></a>04561                          savefilenameinzip = lastslash+1; <span class="comment">// base filename follows last slash.</span>
<a name="l04562"></a>04562                      }
<a name="l04563"></a>04563                  }
<a name="l04564"></a>04564 
<a name="l04565"></a>04565                  
<a name="l04566"></a>04566                 err = zipOpenNewFileInZip3_64(zf,savefilenameinzip,&amp;zi,
<a name="l04567"></a>04567                                  NULL,0,NULL,0,NULL <span class="comment">/* comment*/</span>,
<a name="l04568"></a>04568                                  (opt_compress_level != 0) ? Z_DEFLATED : 0,
<a name="l04569"></a>04569                                  opt_compress_level,0,
<a name="l04570"></a>04570                                  <span class="comment">/* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */</span>
<a name="l04571"></a>04571                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
<a name="l04572"></a>04572                                  password,crcFile, zip64);
<a name="l04573"></a>04573 
<a name="l04574"></a>04574                 <span class="keywordflow">if</span> (err != ZIP_OK) {
<a name="l04575"></a>04575                     <span class="comment">//printf(&quot;error in opening %s in zipfile\n&quot;,filenameinzip);</span>
<a name="l04576"></a>04576                                 }
<a name="l04577"></a>04577                 <span class="keywordflow">else</span>
<a name="l04578"></a>04578                 {
<a name="l04579"></a>04579                     fin = fopen64(filenameinzip,<span class="stringliteral">&quot;rb&quot;</span>);
<a name="l04580"></a>04580                     <span class="keywordflow">if</span> (fin==NULL)
<a name="l04581"></a>04581                     {
<a name="l04582"></a>04582                         err=ZIP_ERRNO;
<a name="l04583"></a>04583                         <span class="comment">//printf(&quot;error in opening %s for reading\n&quot;,filenameinzip);</span>
<a name="l04584"></a>04584                     }
<a name="l04585"></a>04585                 }
<a name="l04586"></a>04586 
<a name="l04587"></a>04587                 <span class="keywordflow">if</span> (err == ZIP_OK)
<a name="l04588"></a>04588                     <span class="keywordflow">do</span>
<a name="l04589"></a>04589                     {
<a name="l04590"></a>04590                         err = ZIP_OK;
<a name="l04591"></a>04591                         size_read = (int)fread(buf,1,size_buf,fin);
<a name="l04592"></a>04592                         <span class="keywordflow">if</span> (size_read &lt; size_buf)
<a name="l04593"></a>04593                             <span class="keywordflow">if</span> (feof(fin)==0)
<a name="l04594"></a>04594                         {
<a name="l04595"></a>04595                             <span class="comment">//printf(&quot;error in reading %s\n&quot;,filenameinzip);</span>
<a name="l04596"></a>04596                             err = ZIP_ERRNO;
<a name="l04597"></a>04597                         }
<a name="l04598"></a>04598 
<a name="l04599"></a>04599                         <span class="keywordflow">if</span> (size_read&gt;0)
<a name="l04600"></a>04600                         {
<a name="l04601"></a>04601                             err = zipWriteInFileInZip (zf,buf,size_read);
<a name="l04602"></a>04602                             <span class="keywordflow">if</span> (err&lt;0)
<a name="l04603"></a>04603                             {
<a name="l04604"></a>04604                                 <span class="comment">//printf(&quot;error in writing %s in the zipfile\n&quot;,</span>
<a name="l04605"></a>04605                                 <span class="comment">//                 filenameinzip);</span>
<a name="l04606"></a>04606                             }
<a name="l04607"></a>04607 
<a name="l04608"></a>04608                         }
<a name="l04609"></a>04609                     } <span class="keywordflow">while</span> ((err == ZIP_OK) &amp;&amp; (size_read&gt;0));
<a name="l04610"></a>04610 
<a name="l04611"></a>04611                 <span class="keywordflow">if</span> (fin)
<a name="l04612"></a>04612                     fclose(fin);
<a name="l04613"></a>04613 
<a name="l04614"></a>04614                 <span class="keywordflow">if</span> (err&lt;0)
<a name="l04615"></a>04615                     err=ZIP_ERRNO;
<a name="l04616"></a>04616                 <span class="keywordflow">else</span>
<a name="l04617"></a>04617                 {
<a name="l04618"></a>04618                     err = zipCloseFileInZip(zf);
<a name="l04619"></a>04619                     <span class="keywordflow">if</span> (err!=ZIP_OK) {
<a name="l04620"></a>04620                         <span class="comment">//printf(&quot;error in closing %s in the zipfile\n&quot;,</span>
<a name="l04621"></a>04621                         <span class="comment">//            filenameinzip);</span>
<a name="l04622"></a>04622                                         }
<a name="l04623"></a>04623                 }
<a name="l04624"></a>04624             }
<a name="l04625"></a>04625         errclose = zipClose(zf,NULL);
<a name="l04626"></a>04626         <span class="keywordflow">if</span> (errclose != ZIP_OK) {
<a name="l04627"></a>04627             <span class="comment">//printf(&quot;error in closing %s\n&quot;,savefile);</span>
<a name="l04628"></a>04628                 }
<a name="l04629"></a>04629     }
<a name="l04630"></a>04630 
<a name="l04631"></a>04631     free(buf);
<a name="l04632"></a>04632     <span class="keywordflow">return</span> 0;
<a name="l04633"></a>04633 }
<a name="l04634"></a>04634 
<a name="l04635"></a>04635 <span class="keywordtype">void</span> SaveState::save(<span class="keywordtype">size_t</span> slot) { <span class="comment">//throw (Error)</span>
<a name="l04636"></a>04636         <span class="keywordflow">if</span> (slot &gt;= SLOT_COUNT)  <span class="keywordflow">return</span>;
<a name="l04637"></a>04637         SDL_PauseAudio(0);
<a name="l04638"></a>04638         <span class="keywordtype">bool</span> save_err=<span class="keyword">false</span>;
<a name="l04639"></a>04639         <span class="keywordflow">if</span>((MEM_TotalPages()*4096/1024/1024)&gt;1000) {
<a name="l04640"></a>04640                 LOG_MSG(<span class="stringliteral">&quot;Stopped. 1000 MB is the maximum memory size for saving/loading states.&quot;</span>);
<a name="l04641"></a>04641 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04642"></a>04642 <span class="preprocessor"></span>                MessageBox(GetHWND(),<span class="stringliteral">&quot;Unsupported memory size.&quot;</span>,<span class="stringliteral">&quot;Error&quot;</span>,MB_OK);
<a name="l04643"></a>04643 <span class="preprocessor">#endif</span>
<a name="l04644"></a>04644 <span class="preprocessor"></span>                <span class="keywordflow">return</span>;
<a name="l04645"></a>04645         }
<a name="l04646"></a>04646         <span class="keywordtype">bool</span> create_version=<span class="keyword">false</span>;
<a name="l04647"></a>04647         <span class="keywordtype">bool</span> create_title=<span class="keyword">false</span>;
<a name="l04648"></a>04648         <span class="keywordtype">bool</span> create_memorysize=<span class="keyword">false</span>;
<a name="l04649"></a>04649         <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* RunningProgram;
<a name="l04650"></a>04650         std::string path;
<a name="l04651"></a>04651         <span class="keywordtype">bool</span> Get_Custom_SaveDir(std::string&amp; savedir);
<a name="l04652"></a>04652         <span class="keywordflow">if</span>(Get_Custom_SaveDir(path)) {
<a name="l04653"></a>04653                 path+=CROSS_FILESPLIT;
<a name="l04654"></a>04654         } <span class="keywordflow">else</span> {
<a name="l04655"></a>04655                 <span class="keyword">extern</span> std::string capturedir;
<a name="l04656"></a>04656                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> last_slash_idx = capturedir.find_last_of(<span class="stringliteral">&quot;\\/&quot;</span>);
<a name="l04657"></a>04657                 <span class="keywordflow">if</span> (std::string::npos != last_slash_idx) {
<a name="l04658"></a>04658                         path = capturedir.substr(0, last_slash_idx);
<a name="l04659"></a>04659                 } <span class="keywordflow">else</span> {
<a name="l04660"></a>04660                         path = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l04661"></a>04661                 }
<a name="l04662"></a>04662                 path+=CROSS_FILESPLIT;
<a name="l04663"></a>04663                 path+=<span class="stringliteral">&quot;save&quot;</span>;
<a name="l04664"></a>04664                 Cross::CreateDir(path);
<a name="l04665"></a>04665                 path+=CROSS_FILESPLIT;
<a name="l04666"></a>04666         }
<a name="l04667"></a>04667 
<a name="l04668"></a>04668         std::string temp, save2;
<a name="l04669"></a>04669         std::stringstream slotname;
<a name="l04670"></a>04670         slotname &lt;&lt; slot+1;
<a name="l04671"></a>04671         temp=path;
<a name="l04672"></a>04672         std::string save=temp+slotname.str()+<span class="stringliteral">&quot;.sav&quot;</span>;
<a name="l04673"></a>04673         <span class="keyword">remove</span>(save.c_str());
<a name="l04674"></a>04674         std::ofstream file (save.c_str());
<a name="l04675"></a>04675         file &lt;&lt; <span class="stringliteral">&quot;&quot;</span>;
<a name="l04676"></a>04676         file.close();
<a name="l04677"></a>04677         <span class="keywordflow">try</span> {
<a name="l04678"></a>04678                 <span class="keywordflow">for</span> (CompEntry::iterator i = components.begin(); i != components.end(); ++i) {
<a name="l04679"></a>04679                         std::ostringstream ss;
<a name="l04680"></a>04680                         i-&gt;second.comp.getBytes(ss);
<a name="l04681"></a>04681                         i-&gt;second.rawBytes[slot].set(ss.str());
<a name="l04682"></a>04682                         
<a name="l04683"></a>04683                         <span class="comment">//LOG_MSG(&quot;Component is %s&quot;,i-&gt;first.c_str());</span>
<a name="l04684"></a>04684 
<a name="l04685"></a>04685                         <span class="keywordflow">if</span>(!create_version) {
<a name="l04686"></a>04686                                 std::string tempname = temp+<span class="stringliteral">&quot;DOSBox-X_Version&quot;</span>;
<a name="l04687"></a>04687                                 std::ofstream emulatorversion (tempname.c_str(), std::ofstream::binary);
<a name="l04688"></a>04688                                 emulatorversion &lt;&lt; <span class="stringliteral">&quot;DOSBox-X &quot;</span> &lt;&lt; VERSION &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; SDL_STRING &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl &lt;&lt; GetPlatform() &lt;&lt; std::endl &lt;&lt; UPDATED_STR;
<a name="l04689"></a>04689                                 create_version=<span class="keyword">true</span>;
<a name="l04690"></a>04690                                 emulatorversion.close();
<a name="l04691"></a>04691                         }
<a name="l04692"></a>04692 
<a name="l04693"></a>04693                         <span class="keywordflow">if</span>(!create_title) {
<a name="l04694"></a>04694                                 std::string tempname = temp+<span class="stringliteral">&quot;Program_Name&quot;</span>;
<a name="l04695"></a>04695                                 std::ofstream programname (tempname.c_str(), std::ofstream::binary);
<a name="l04696"></a>04696                                 programname &lt;&lt; RunningProgram;
<a name="l04697"></a>04697                                 create_title=<span class="keyword">true</span>;
<a name="l04698"></a>04698                                 programname.close();
<a name="l04699"></a>04699                         }
<a name="l04700"></a>04700 
<a name="l04701"></a>04701                         <span class="keywordflow">if</span>(!create_memorysize) {
<a name="l04702"></a>04702                  std::string tempname = temp+<span class="stringliteral">&quot;Memory_Size&quot;</span>;
<a name="l04703"></a>04703                                   std::ofstream memorysize (tempname.c_str(), std::ofstream::binary);
<a name="l04704"></a>04704                                   memorysize &lt;&lt; MEM_TotalPages();
<a name="l04705"></a>04705                                   create_memorysize=<span class="keyword">true</span>;
<a name="l04706"></a>04706                                   memorysize.close();
<a name="l04707"></a>04707                         }
<a name="l04708"></a>04708                         std::string realtemp;
<a name="l04709"></a>04709                         realtemp = temp + i-&gt;first;
<a name="l04710"></a>04710                         std::ofstream outfile (realtemp.c_str(), std::ofstream::binary);
<a name="l04711"></a>04711                         outfile &lt;&lt; (Util::compress(ss.str()));
<a name="l04712"></a>04712                         <span class="comment">//compress all other saved states except position &quot;slot&quot;</span>
<a name="l04713"></a>04713                         <span class="comment">//const std::vector&lt;RawBytes&gt;&amp; rb = i-&gt;second.rawBytes;</span>
<a name="l04714"></a>04714                         <span class="comment">//std::for_each(rb.begin(), rb.begin() + slot, std::mem_fun_ref(&amp;RawBytes::compress));</span>
<a name="l04715"></a>04715                         <span class="comment">//std::for_each(rb.begin() + slot + 1, rb.end(), std::mem_fun_ref(&amp;RawBytes::compress));</span>
<a name="l04716"></a>04716                         outfile.close();
<a name="l04717"></a>04717                         ss.clear();
<a name="l04718"></a>04718                         <span class="keywordflow">if</span>(outfile.fail()) {
<a name="l04719"></a>04719                                 LOG_MSG(<span class="stringliteral">&quot;Save failed! - %s&quot;</span>, realtemp.c_str());
<a name="l04720"></a>04720                                 save_err=<span class="keyword">true</span>;
<a name="l04721"></a>04721                                 <span class="keyword">remove</span>(save.c_str());
<a name="l04722"></a>04722                                 <span class="keywordflow">goto</span> delete_all;
<a name="l04723"></a>04723                         }
<a name="l04724"></a>04724                 }
<a name="l04725"></a>04725         }
<a name="l04726"></a>04726         <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::bad_alloc&amp;) {
<a name="l04727"></a>04727                 LOG_MSG(<span class="stringliteral">&quot;Save failed! Out of Memory!&quot;</span>);
<a name="l04728"></a>04728                 save_err=<span class="keyword">true</span>;
<a name="l04729"></a>04729                 <span class="keyword">remove</span>(save.c_str());
<a name="l04730"></a>04730                 <span class="keywordflow">goto</span> delete_all;
<a name="l04731"></a>04731         }
<a name="l04732"></a>04732 
<a name="l04733"></a>04733         <span class="keywordflow">for</span> (CompEntry::iterator i = components.begin(); i != components.end(); ++i) {
<a name="l04734"></a>04734                 save2=temp+i-&gt;first;
<a name="l04735"></a>04735                 my_minizip((<span class="keywordtype">char</span> **)save.c_str(), (<span class="keywordtype">char</span> **)save2.c_str());
<a name="l04736"></a>04736         }
<a name="l04737"></a>04737         save2=temp+<span class="stringliteral">&quot;DOSBox-X_Version&quot;</span>;
<a name="l04738"></a>04738         my_minizip((<span class="keywordtype">char</span> **)save.c_str(), (<span class="keywordtype">char</span> **)save2.c_str());
<a name="l04739"></a>04739         save2=temp+<span class="stringliteral">&quot;Program_Name&quot;</span>;
<a name="l04740"></a>04740         my_minizip((<span class="keywordtype">char</span> **)save.c_str(), (<span class="keywordtype">char</span> **)save2.c_str());
<a name="l04741"></a>04741         save2=temp+<span class="stringliteral">&quot;Memory_Size&quot;</span>;
<a name="l04742"></a>04742         my_minizip((<span class="keywordtype">char</span> **)save.c_str(), (<span class="keywordtype">char</span> **)save2.c_str());
<a name="l04743"></a>04743 
<a name="l04744"></a>04744 delete_all:
<a name="l04745"></a>04745         <span class="keywordflow">for</span> (CompEntry::iterator i = components.begin(); i != components.end(); ++i) {
<a name="l04746"></a>04746                 save2=temp+i-&gt;first;
<a name="l04747"></a>04747                 <span class="keyword">remove</span>(save2.c_str());
<a name="l04748"></a>04748         }
<a name="l04749"></a>04749         save2=temp+<span class="stringliteral">&quot;DOSBox-X_Version&quot;</span>;
<a name="l04750"></a>04750         <span class="keyword">remove</span>(save2.c_str());
<a name="l04751"></a>04751         save2=temp+<span class="stringliteral">&quot;Program_Name&quot;</span>;
<a name="l04752"></a>04752         <span class="keyword">remove</span>(save2.c_str());
<a name="l04753"></a>04753         save2=temp+<span class="stringliteral">&quot;Memory_Size&quot;</span>;
<a name="l04754"></a>04754         <span class="keyword">remove</span>(save2.c_str());
<a name="l04755"></a>04755         <span class="keywordflow">if</span> (save_err) {
<a name="l04756"></a>04756 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04757"></a>04757 <span class="preprocessor"></span>                MessageBox(GetHWND(),<span class="stringliteral">&quot;Failed to save the current state.&quot;</span>,<span class="stringliteral">&quot;Error&quot;</span>,MB_OK);
<a name="l04758"></a>04758 <span class="preprocessor">#endif</span>
<a name="l04759"></a>04759 <span class="preprocessor"></span>        } <span class="keywordflow">else</span>
<a name="l04760"></a>04760                 LOG_MSG(<span class="stringliteral">&quot;Saved. (Slot %d)&quot;</span>,(<span class="keywordtype">int</span>)slot+1);
<a name="l04761"></a>04761 }
<a name="l04762"></a>04762 
<a name="l04763"></a>04763 <span class="keywordtype">void</span> SaveState::load(<span class="keywordtype">size_t</span> slot)<span class="keyword"> const </span>{ <span class="comment">//throw (Error)</span>
<a name="l04764"></a>04764 <span class="comment">//      if (isEmpty(slot)) return;</span>
<a name="l04765"></a>04765         <span class="keywordtype">bool</span> load_err=<span class="keyword">false</span>;
<a name="l04766"></a>04766         <span class="keywordflow">if</span>((MEM_TotalPages()*4096/1024/1024)&gt;1000) {
<a name="l04767"></a>04767                 LOG_MSG(<span class="stringliteral">&quot;Stopped. 1000 MB is the maximum memory size for saving/loading states.&quot;</span>);
<a name="l04768"></a>04768 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04769"></a>04769 <span class="preprocessor"></span>                MessageBox(GetHWND(),<span class="stringliteral">&quot;Unsupported memory size.&quot;</span>,<span class="stringliteral">&quot;Error&quot;</span>,MB_OK);
<a name="l04770"></a>04770 <span class="preprocessor">#endif</span>
<a name="l04771"></a>04771 <span class="preprocessor"></span>                <span class="keywordflow">return</span>;
<a name="l04772"></a>04772         }
<a name="l04773"></a>04773         SDL_PauseAudio(0);
<a name="l04774"></a>04774         <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* RunningProgram;
<a name="l04775"></a>04775         <span class="keywordtype">bool</span> read_version=<span class="keyword">false</span>;
<a name="l04776"></a>04776         <span class="keywordtype">bool</span> read_title=<span class="keyword">false</span>;
<a name="l04777"></a>04777         <span class="keywordtype">bool</span> read_memorysize=<span class="keyword">false</span>;
<a name="l04778"></a>04778         std::string path;
<a name="l04779"></a>04779         <span class="keywordtype">bool</span> Get_Custom_SaveDir(std::string&amp; savedir);
<a name="l04780"></a>04780         <span class="keywordflow">if</span>(Get_Custom_SaveDir(path)) {
<a name="l04781"></a>04781                 path+=CROSS_FILESPLIT;
<a name="l04782"></a>04782         } <span class="keywordflow">else</span> {
<a name="l04783"></a>04783                 <span class="keyword">extern</span> std::string capturedir;
<a name="l04784"></a>04784                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> last_slash_idx = capturedir.find_last_of(<span class="stringliteral">&quot;\\/&quot;</span>);
<a name="l04785"></a>04785                 <span class="keywordflow">if</span> (std::string::npos != last_slash_idx) {
<a name="l04786"></a>04786                         path = capturedir.substr(0, last_slash_idx);
<a name="l04787"></a>04787                 } <span class="keywordflow">else</span> {
<a name="l04788"></a>04788                         path = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l04789"></a>04789                 }
<a name="l04790"></a>04790                 path += CROSS_FILESPLIT;
<a name="l04791"></a>04791                 path +=<span class="stringliteral">&quot;save&quot;</span>;
<a name="l04792"></a>04792                 path += CROSS_FILESPLIT;
<a name="l04793"></a>04793         }
<a name="l04794"></a>04794         std::string temp;
<a name="l04795"></a>04795         temp = path;
<a name="l04796"></a>04796         std::stringstream slotname;
<a name="l04797"></a>04797         slotname &lt;&lt; slot+1;
<a name="l04798"></a>04798         std::string save=temp+slotname.str()+<span class="stringliteral">&quot;.sav&quot;</span>;
<a name="l04799"></a>04799         std::ifstream check_slot;
<a name="l04800"></a>04800         check_slot.open(save.c_str(), std::ifstream::in);
<a name="l04801"></a>04801         <span class="keywordflow">if</span>(check_slot.fail()) {
<a name="l04802"></a>04802                 LOG_MSG(<span class="stringliteral">&quot;No saved slot - %d (%s)&quot;</span>,(<span class="keywordtype">int</span>)slot+1,save.c_str());
<a name="l04803"></a>04803 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04804"></a>04804 <span class="preprocessor"></span>                MessageBox(GetHWND(),<span class="stringliteral">&quot;The selected save slot is empty.&quot;</span>,<span class="stringliteral">&quot;Error&quot;</span>,MB_OK);
<a name="l04805"></a>04805 <span class="preprocessor">#endif</span>
<a name="l04806"></a>04806 <span class="preprocessor"></span>                load_err=<span class="keyword">true</span>;
<a name="l04807"></a>04807                 <span class="keywordflow">return</span>;
<a name="l04808"></a>04808         }
<a name="l04809"></a>04809 
<a name="l04810"></a>04810         <span class="keywordflow">for</span> (CompEntry::const_iterator i = components.begin(); i != components.end(); ++i) {
<a name="l04811"></a>04811                 std::filebuf * fb;
<a name="l04812"></a>04812                 std::ifstream ss;
<a name="l04813"></a>04813                 std::ifstream check_file;
<a name="l04814"></a>04814                 fb = ss.rdbuf();
<a name="l04815"></a>04815                 
<a name="l04816"></a>04816                 <span class="comment">//LOG_MSG(&quot;Component is %s&quot;,i-&gt;first.c_str());</span>
<a name="l04817"></a>04817 
<a name="l04818"></a>04818                 my_miniunz((<span class="keywordtype">char</span> **)save.c_str(),i-&gt;first.c_str(),temp.c_str());
<a name="l04819"></a>04819 
<a name="l04820"></a>04820                 <span class="keywordflow">if</span>(!read_version) {
<a name="l04821"></a>04821                         my_miniunz((<span class="keywordtype">char</span> **)save.c_str(),<span class="stringliteral">&quot;DOSBox-X_Version&quot;</span>,temp.c_str());
<a name="l04822"></a>04822                         std::ifstream check_version;
<a name="l04823"></a>04823                         <span class="keywordtype">int</span> length = 8;
<a name="l04824"></a>04824 
<a name="l04825"></a>04825                         std::string tempname = temp+<span class="stringliteral">&quot;DOSBox-X_Version&quot;</span>;
<a name="l04826"></a>04826                         check_version.open(tempname.c_str(), std::ifstream::in);
<a name="l04827"></a>04827                         <span class="keywordflow">if</span>(check_version.fail()) {
<a name="l04828"></a>04828                                 LOG_MSG(<span class="stringliteral">&quot;Save state corrupted! Program in inconsistent state! - DOSBox-X_Version&quot;</span>);
<a name="l04829"></a>04829 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04830"></a>04830 <span class="preprocessor"></span>                                MessageBox(GetHWND(),<span class="stringliteral">&quot;Save state corrupted!&quot;</span>,<span class="stringliteral">&quot;Error&quot;</span>,MB_OK);
<a name="l04831"></a>04831 <span class="preprocessor">#endif</span>
<a name="l04832"></a>04832 <span class="preprocessor"></span>                                load_err=<span class="keyword">true</span>;
<a name="l04833"></a>04833                                 <span class="keywordflow">goto</span> delete_all;
<a name="l04834"></a>04834                         }
<a name="l04835"></a>04835                         check_version.seekg (0, std::ios::end);
<a name="l04836"></a>04836                         length = check_version.tellg();
<a name="l04837"></a>04837                         check_version.seekg (0, std::ios::beg);
<a name="l04838"></a>04838 
<a name="l04839"></a>04839                         <span class="keywordtype">char</span> * <span class="keyword">const</span> buffer = (<span class="keywordtype">char</span>*)alloca( (length+1) * <span class="keyword">sizeof</span>(char)); <span class="comment">// char buffer[length];</span>
<a name="l04840"></a>04840                         check_version.read (buffer, length);
<a name="l04841"></a>04841                         check_version.close();
<a name="l04842"></a>04842                         buffer[length]=<span class="charliteral">&#39;\0&#39;</span>;
<a name="l04843"></a>04843                         <span class="keywordtype">char</span> *p=strrchr(buffer, <span class="charliteral">&#39;\n&#39;</span>);
<a name="l04844"></a>04844                         <span class="keywordflow">if</span> (p!=NULL) *p=0;
<a name="l04845"></a>04845                         std::string emulatorversion = std::string(<span class="stringliteral">&quot;DOSBox-X &quot;</span>) + VERSION + std::string(<span class="stringliteral">&quot; (&quot;</span>) + SDL_STRING + std::string(<span class="stringliteral">&quot;)\n&quot;</span>) + GetPlatform();
<a name="l04846"></a>04846                         <span class="keywordflow">if</span> (p==NULL||strcasecmp(buffer,emulatorversion.c_str())) {
<a name="l04847"></a>04847 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04848"></a>04848 <span class="preprocessor"></span>                                <span class="keywordflow">if</span>(!force_load_state&amp;&amp;MessageBox(GetHWND(),<span class="stringliteral">&quot;DOSBox-X version mismatch. Load the state anyway?&quot;</span>,<span class="stringliteral">&quot;Warning&quot;</span>,MB_YESNO|MB_DEFBUTTON2)==IDNO) {
<a name="l04849"></a>04849 <span class="preprocessor">#else</span>
<a name="l04850"></a>04850 <span class="preprocessor"></span>                                <span class="keywordflow">if</span>(!force_load_state) {
<a name="l04851"></a>04851 <span class="preprocessor">#endif</span>
<a name="l04852"></a>04852 <span class="preprocessor"></span>                                        LOG_MSG(<span class="stringliteral">&quot;Aborted. Check your DOSBox-X version: %s&quot;</span>,buffer);
<a name="l04853"></a>04853                                         load_err=<span class="keyword">true</span>;
<a name="l04854"></a>04854                                         <span class="keywordflow">goto</span> delete_all;
<a name="l04855"></a>04855                                 }
<a name="l04856"></a>04856                         }
<a name="l04857"></a>04857                         read_version=<span class="keyword">true</span>;
<a name="l04858"></a>04858                 }
<a name="l04859"></a>04859 
<a name="l04860"></a>04860                 <span class="keywordflow">if</span>(!read_title) {
<a name="l04861"></a>04861                         my_miniunz((<span class="keywordtype">char</span> **)save.c_str(),<span class="stringliteral">&quot;Program_Name&quot;</span>,temp.c_str());
<a name="l04862"></a>04862                         std::ifstream check_title;
<a name="l04863"></a>04863                         <span class="keywordtype">int</span> length = 8;
<a name="l04864"></a>04864 
<a name="l04865"></a>04865                         std::string tempname = temp+<span class="stringliteral">&quot;Program_Name&quot;</span>;
<a name="l04866"></a>04866                         check_title.open(tempname.c_str(), std::ifstream::in);
<a name="l04867"></a>04867                         <span class="keywordflow">if</span>(check_title.fail()) {
<a name="l04868"></a>04868                                 LOG_MSG(<span class="stringliteral">&quot;Save state corrupted! Program in inconsistent state! - Program_Name&quot;</span>);
<a name="l04869"></a>04869 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04870"></a>04870 <span class="preprocessor"></span>                                MessageBox(GetHWND(),<span class="stringliteral">&quot;Save state corrupted!&quot;</span>,<span class="stringliteral">&quot;Error&quot;</span>,MB_OK);
<a name="l04871"></a>04871 <span class="preprocessor">#endif</span>
<a name="l04872"></a>04872 <span class="preprocessor"></span>                                load_err=<span class="keyword">true</span>;
<a name="l04873"></a>04873                                 <span class="keywordflow">goto</span> delete_all;
<a name="l04874"></a>04874                         }
<a name="l04875"></a>04875                         check_title.seekg (0, std::ios::end);
<a name="l04876"></a>04876                         length = check_title.tellg();
<a name="l04877"></a>04877                         check_title.seekg (0, std::ios::beg);
<a name="l04878"></a>04878 
<a name="l04879"></a>04879                         <span class="keywordtype">char</span> * <span class="keyword">const</span> buffer = (<span class="keywordtype">char</span>*)alloca( (length+1) * <span class="keyword">sizeof</span>(char)); <span class="comment">// char buffer[length];</span>
<a name="l04880"></a>04880                         check_title.read (buffer, length);
<a name="l04881"></a>04881                         check_title.close();
<a name="l04882"></a>04882                         <span class="keywordflow">if</span> (strncmp(buffer,RunningProgram,length)||!length) {
<a name="l04883"></a>04883 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04884"></a>04884 <span class="preprocessor"></span>                                <span class="keywordflow">if</span>(!force_load_state&amp;&amp;MessageBox(GetHWND(),<span class="stringliteral">&quot;Program name mismatch. Load the state anyway?&quot;</span>,<span class="stringliteral">&quot;Warning&quot;</span>,MB_YESNO|MB_DEFBUTTON2)==IDNO) {
<a name="l04885"></a>04885 <span class="preprocessor">#else</span>
<a name="l04886"></a>04886 <span class="preprocessor"></span>                                <span class="keywordflow">if</span>(!force_load_state) {
<a name="l04887"></a>04887 <span class="preprocessor">#endif</span>
<a name="l04888"></a>04888 <span class="preprocessor"></span>                                        buffer[length]=<span class="charliteral">&#39;\0&#39;</span>;
<a name="l04889"></a>04889                                         LOG_MSG(<span class="stringliteral">&quot;Aborted. Check your program name: %s&quot;</span>,buffer);
<a name="l04890"></a>04890                                         load_err=<span class="keyword">true</span>;
<a name="l04891"></a>04891                                         <span class="keywordflow">goto</span> delete_all;
<a name="l04892"></a>04892                                 }
<a name="l04893"></a>04893                                 <span class="keywordflow">if</span> (length&lt;9) {
<a name="l04894"></a>04894                                         <span class="keyword">static</span> <span class="keywordtype">char</span> pname[9];
<a name="l04895"></a>04895                                         <span class="keywordflow">if</span> (length) {
<a name="l04896"></a>04896                                                 strncpy(pname,buffer,length);
<a name="l04897"></a>04897                                                 pname[length]=0;
<a name="l04898"></a>04898                                         } <span class="keywordflow">else</span>
<a name="l04899"></a>04899                                                 strcpy(pname, <span class="stringliteral">&quot;DOSBOX-X&quot;</span>);
<a name="l04900"></a>04900                                         RunningProgram=pname;
<a name="l04901"></a>04901                                         GFX_SetTitle(-1,-1,-1,<span class="keyword">false</span>);
<a name="l04902"></a>04902                                 }
<a name="l04903"></a>04903                         }
<a name="l04904"></a>04904                         read_title=<span class="keyword">true</span>;
<a name="l04905"></a>04905                 }
<a name="l04906"></a>04906 
<a name="l04907"></a>04907                 <span class="keywordflow">if</span>(!read_memorysize) {
<a name="l04908"></a>04908                         my_miniunz((<span class="keywordtype">char</span> **)save.c_str(),<span class="stringliteral">&quot;Memory_Size&quot;</span>,temp.c_str());
<a name="l04909"></a>04909                         std::fstream check_memorysize;
<a name="l04910"></a>04910                         <span class="keywordtype">int</span> length = 8;
<a name="l04911"></a>04911 
<a name="l04912"></a>04912                         std::string tempname = temp+<span class="stringliteral">&quot;Memory_Size&quot;</span>;
<a name="l04913"></a>04913                         check_memorysize.open(tempname.c_str(), std::ifstream::in);
<a name="l04914"></a>04914                         <span class="keywordflow">if</span>(check_memorysize.fail()) {
<a name="l04915"></a>04915                                 LOG_MSG(<span class="stringliteral">&quot;Save state corrupted! Program in inconsistent state! - Memory_Size&quot;</span>);
<a name="l04916"></a>04916                                 load_err=<span class="keyword">true</span>;
<a name="l04917"></a>04917                                 <span class="keywordflow">goto</span> delete_all;
<a name="l04918"></a>04918                         }
<a name="l04919"></a>04919                         check_memorysize.seekg (0, std::ios::end);
<a name="l04920"></a>04920                         length = check_memorysize.tellg();
<a name="l04921"></a>04921                         check_memorysize.seekg (0, std::ios::beg);
<a name="l04922"></a>04922 
<a name="l04923"></a>04923                         <span class="keywordtype">char</span> * <span class="keyword">const</span> buffer = (<span class="keywordtype">char</span>*)alloca( (length+1) * <span class="keyword">sizeof</span>(char)); <span class="comment">// char buffer[length];</span>
<a name="l04924"></a>04924                         check_memorysize.read (buffer, length);
<a name="l04925"></a>04925                         check_memorysize.close();
<a name="l04926"></a>04926                         <span class="keywordtype">char</span> str[10];
<a name="l04927"></a>04927                         itoa(MEM_TotalPages(), str, 10);
<a name="l04928"></a>04928                         <span class="keywordflow">if</span>(strncmp(buffer,str,length)) {
<a name="l04929"></a>04929 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04930"></a>04930 <span class="preprocessor"></span>                                <span class="keywordflow">if</span>(!force_load_state&amp;&amp;MessageBox(GetHWND(),<span class="stringliteral">&quot;Memory size mismatch. Load the state anyway?&quot;</span>,<span class="stringliteral">&quot;Warning&quot;</span>,MB_YESNO|MB_DEFBUTTON2)==IDNO) {
<a name="l04931"></a>04931 <span class="preprocessor">#else</span>
<a name="l04932"></a>04932 <span class="preprocessor"></span>                                <span class="keywordflow">if</span>(!force_load_state) {
<a name="l04933"></a>04933 <span class="preprocessor">#endif</span>
<a name="l04934"></a>04934 <span class="preprocessor"></span>                                        buffer[length]=<span class="charliteral">&#39;\0&#39;</span>;
<a name="l04935"></a>04935                                         LOG_MSG(<span class="stringliteral">&quot;Aborted. Check your memory size.&quot;</span>);
<a name="l04936"></a>04936                                         load_err=<span class="keyword">true</span>;
<a name="l04937"></a>04937                                         <span class="keywordflow">goto</span> delete_all;
<a name="l04938"></a>04938                                 }
<a name="l04939"></a>04939                         }
<a name="l04940"></a>04940                         read_memorysize=<span class="keyword">true</span>;
<a name="l04941"></a>04941                 }
<a name="l04942"></a>04942                 std::string realtemp;
<a name="l04943"></a>04943                 realtemp = temp + i-&gt;first;
<a name="l04944"></a>04944                 check_file.open(realtemp.c_str(), std::ifstream::in);
<a name="l04945"></a>04945                 check_file.close();
<a name="l04946"></a>04946                 <span class="keywordflow">if</span>(check_file.fail()) {
<a name="l04947"></a>04947                         LOG_MSG(<span class="stringliteral">&quot;Save state corrupted! Program in inconsistent state! - %s&quot;</span>,i-&gt;first.c_str());
<a name="l04948"></a>04948 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04949"></a>04949 <span class="preprocessor"></span>                        MessageBox(GetHWND(),<span class="stringliteral">&quot;Save state corrupted!&quot;</span>,<span class="stringliteral">&quot;Error&quot;</span>,MB_OK);
<a name="l04950"></a>04950 <span class="preprocessor">#endif</span>
<a name="l04951"></a>04951 <span class="preprocessor"></span>                        load_err=<span class="keyword">true</span>;
<a name="l04952"></a>04952                         <span class="keywordflow">goto</span> delete_all;
<a name="l04953"></a>04953                 }
<a name="l04954"></a>04954 
<a name="l04955"></a>04955                 fb-&gt;open(realtemp.c_str(),std::ios::in | std::ios::binary);
<a name="l04956"></a>04956                 std::string str((std::istreambuf_iterator&lt;char&gt;(ss)), std::istreambuf_iterator&lt;char&gt;());
<a name="l04957"></a>04957                 std::stringstream mystream;
<a name="l04958"></a>04958                 mystream &lt;&lt; (Util::decompress(str));
<a name="l04959"></a>04959                 i-&gt;second.comp.setBytes(mystream);
<a name="l04960"></a>04960                 <span class="keywordflow">if</span> (mystream.rdbuf()-&gt;in_avail() != 0 || mystream.eof()) { <span class="comment">//basic consistency check</span>
<a name="l04961"></a>04961                         LOG_MSG(<span class="stringliteral">&quot;Save state corrupted! Program in inconsistent state! - %s&quot;</span>,i-&gt;first.c_str());
<a name="l04962"></a>04962 <span class="preprocessor">#if defined(WIN32)</span>
<a name="l04963"></a>04963 <span class="preprocessor"></span>                        MessageBox(GetHWND(),<span class="stringliteral">&quot;Save state corrupted!&quot;</span>,<span class="stringliteral">&quot;Error&quot;</span>,MB_OK);
<a name="l04964"></a>04964 <span class="preprocessor">#endif</span>
<a name="l04965"></a>04965 <span class="preprocessor"></span>                        load_err=<span class="keyword">true</span>;
<a name="l04966"></a>04966                         <span class="keywordflow">goto</span> delete_all;
<a name="l04967"></a>04967                 }
<a name="l04968"></a>04968                 <span class="comment">//compress all other saved states except position &quot;slot&quot;</span>
<a name="l04969"></a>04969                 <span class="comment">//const std::vector&lt;RawBytes&gt;&amp; rb = i-&gt;second.rawBytes;</span>
<a name="l04970"></a>04970                 <span class="comment">//std::for_each(rb.begin(), rb.begin() + slot, std::mem_fun_ref(&amp;RawBytes::compress));</span>
<a name="l04971"></a>04971                 <span class="comment">//std::for_each(rb.begin() + slot + 1, rb.end(), std::mem_fun_ref(&amp;RawBytes::compress));</span>
<a name="l04972"></a>04972                 fb-&gt;close();
<a name="l04973"></a>04973                 mystream.clear();
<a name="l04974"></a>04974         }
<a name="l04975"></a>04975 delete_all:
<a name="l04976"></a>04976         std::string save2;
<a name="l04977"></a>04977         <span class="keywordflow">for</span> (CompEntry::const_iterator i = components.begin(); i != components.end(); ++i) {
<a name="l04978"></a>04978                 save2=temp+i-&gt;first;
<a name="l04979"></a>04979                 <span class="keyword">remove</span>(save2.c_str());
<a name="l04980"></a>04980         }
<a name="l04981"></a>04981         save2=temp+<span class="stringliteral">&quot;DOSBox-X_Version&quot;</span>;
<a name="l04982"></a>04982         <span class="keyword">remove</span>(save2.c_str());
<a name="l04983"></a>04983         save2=temp+<span class="stringliteral">&quot;Program_Name&quot;</span>;
<a name="l04984"></a>04984         <span class="keyword">remove</span>(save2.c_str());
<a name="l04985"></a>04985         save2=temp+<span class="stringliteral">&quot;Memory_Size&quot;</span>;
<a name="l04986"></a>04986         <span class="keyword">remove</span>(save2.c_str());
<a name="l04987"></a>04987         <span class="keywordflow">if</span> (!load_err) LOG_MSG(<span class="stringliteral">&quot;Loaded. (Slot %d)&quot;</span>,(<span class="keywordtype">int</span>)slot+1);
<a name="l04988"></a>04988 }
<a name="l04989"></a>04989 
<a name="l04990"></a>04990 <span class="keywordtype">bool</span> SaveState::isEmpty(<span class="keywordtype">size_t</span> slot)<span class="keyword"> const </span>{
<a name="l04991"></a>04991         <span class="keywordflow">if</span> (slot &gt;= SLOT_COUNT) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04992"></a>04992         std::string path;
<a name="l04993"></a>04993         <span class="keywordtype">bool</span> Get_Custom_SaveDir(std::string&amp; savedir);
<a name="l04994"></a>04994         <span class="keywordflow">if</span>(Get_Custom_SaveDir(path)) {
<a name="l04995"></a>04995                 path+=CROSS_FILESPLIT;
<a name="l04996"></a>04996         } <span class="keywordflow">else</span> {
<a name="l04997"></a>04997                 <span class="keyword">extern</span> std::string capturedir;
<a name="l04998"></a>04998                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> last_slash_idx = capturedir.find_last_of(<span class="stringliteral">&quot;\\/&quot;</span>);
<a name="l04999"></a>04999                 <span class="keywordflow">if</span> (std::string::npos != last_slash_idx) {
<a name="l05000"></a>05000                         path = capturedir.substr(0, last_slash_idx);
<a name="l05001"></a>05001                 } <span class="keywordflow">else</span> {
<a name="l05002"></a>05002                         path = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l05003"></a>05003                 }
<a name="l05004"></a>05004                 path += CROSS_FILESPLIT;
<a name="l05005"></a>05005                 path +=<span class="stringliteral">&quot;save&quot;</span>;
<a name="l05006"></a>05006                 path += CROSS_FILESPLIT;
<a name="l05007"></a>05007         }
<a name="l05008"></a>05008         std::string temp;
<a name="l05009"></a>05009         temp = path;
<a name="l05010"></a>05010         std::stringstream slotname;
<a name="l05011"></a>05011         slotname &lt;&lt; slot+1;
<a name="l05012"></a>05012         std::string save=temp+slotname.str()+<span class="stringliteral">&quot;.sav&quot;</span>;
<a name="l05013"></a>05013         std::ifstream check_slot;
<a name="l05014"></a>05014         check_slot.open(save.c_str(), std::ifstream::in);
<a name="l05015"></a>05015         <span class="keywordflow">return</span> check_slot.fail();
<a name="l05016"></a>05016 }
<a name="l05017"></a>05017 
<a name="l05018"></a>05018 std::string SaveState::getName(<span class="keywordtype">size_t</span> slot)<span class="keyword"> const </span>{
<a name="l05019"></a>05019         <span class="keywordflow">if</span> (slot &gt;= SLOT_COUNT) <span class="keywordflow">return</span> <span class="stringliteral">&quot;[Empty]&quot;</span>;
<a name="l05020"></a>05020         std::string path;
<a name="l05021"></a>05021         <span class="keywordtype">bool</span> Get_Custom_SaveDir(std::string&amp; savedir);
<a name="l05022"></a>05022         <span class="keywordflow">if</span>(Get_Custom_SaveDir(path)) {
<a name="l05023"></a>05023                 path+=CROSS_FILESPLIT;
<a name="l05024"></a>05024         } <span class="keywordflow">else</span> {
<a name="l05025"></a>05025                 <span class="keyword">extern</span> std::string capturedir;
<a name="l05026"></a>05026                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> last_slash_idx = capturedir.find_last_of(<span class="stringliteral">&quot;\\/&quot;</span>);
<a name="l05027"></a>05027                 <span class="keywordflow">if</span> (std::string::npos != last_slash_idx) {
<a name="l05028"></a>05028                         path = capturedir.substr(0, last_slash_idx);
<a name="l05029"></a>05029                 } <span class="keywordflow">else</span> {
<a name="l05030"></a>05030                         path = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l05031"></a>05031                 }
<a name="l05032"></a>05032                 path += CROSS_FILESPLIT;
<a name="l05033"></a>05033                 path +=<span class="stringliteral">&quot;save&quot;</span>;
<a name="l05034"></a>05034                 path += CROSS_FILESPLIT;
<a name="l05035"></a>05035         }
<a name="l05036"></a>05036         std::string temp;
<a name="l05037"></a>05037         temp = path;
<a name="l05038"></a>05038         std::stringstream slotname;
<a name="l05039"></a>05039         slotname &lt;&lt; slot+1;
<a name="l05040"></a>05040         std::string save=temp+slotname.str()+<span class="stringliteral">&quot;.sav&quot;</span>;
<a name="l05041"></a>05041         std::ifstream check_slot;
<a name="l05042"></a>05042         check_slot.open(save.c_str(), std::ifstream::in);
<a name="l05043"></a>05043         <span class="keywordflow">if</span> (check_slot.fail()) <span class="keywordflow">return</span> <span class="stringliteral">&quot;[Empty]&quot;</span>;
<a name="l05044"></a>05044         my_miniunz((<span class="keywordtype">char</span> **)save.c_str(),<span class="stringliteral">&quot;Program_Name&quot;</span>,temp.c_str());
<a name="l05045"></a>05045         std::ifstream check_title;
<a name="l05046"></a>05046         <span class="keywordtype">int</span> length = 8;
<a name="l05047"></a>05047         std::string tempname = temp+<span class="stringliteral">&quot;Program_Name&quot;</span>;
<a name="l05048"></a>05048         check_title.open(tempname.c_str(), std::ifstream::in);
<a name="l05049"></a>05049         <span class="keywordflow">if</span> (check_title.fail()) {
<a name="l05050"></a>05050                 <span class="keyword">remove</span>(tempname.c_str());
<a name="l05051"></a>05051                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l05052"></a>05052         }
<a name="l05053"></a>05053         check_title.seekg (0, std::ios::end);
<a name="l05054"></a>05054         length = check_title.tellg();
<a name="l05055"></a>05055         check_title.seekg (0, std::ios::beg);
<a name="l05056"></a>05056         <span class="keywordtype">char</span> * <span class="keyword">const</span> buffer = (<span class="keywordtype">char</span>*)alloca( (length+1) * <span class="keyword">sizeof</span>(char));
<a name="l05057"></a>05057         check_title.read (buffer, length);
<a name="l05058"></a>05058         check_title.close();
<a name="l05059"></a>05059         <span class="keyword">remove</span>(tempname.c_str());
<a name="l05060"></a>05060         buffer[length]=<span class="charliteral">&#39;\0&#39;</span>;
<a name="l05061"></a>05061         <span class="keywordflow">return</span> std::string(buffer);
<a name="l05062"></a>05062 }
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 5 2020 13:11:35 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
