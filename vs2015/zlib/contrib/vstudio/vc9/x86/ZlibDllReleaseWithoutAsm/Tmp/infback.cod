; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\dev\dosbox-x\vs2008\zlib\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateBackEnd@4
; Function compile flags: /Odtp
; File c:\dev\dosbox-x\vs2008\zlib\infback.c
;	COMDAT _inflateBackEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd@4 PROC					; COMDAT

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00003	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00007	74 12		 je	 SHORT $LN1@inflateBac
  00009	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000c	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00010	74 09		 je	 SHORT $LN1@inflateBac
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00015	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00019	75 07		 jne	 SHORT $LN2@inflateBac
$LN1@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  0001b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00020	eb 25		 jmp	 SHORT $LN3@inflateBac
$LN2@inflateBac:

; 636  :     ZFREE(strm, strm->state);

  00022	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00025	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00033	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00036	ff d1		 call	 ecx
  00038	83 c4 08	 add	 esp, 8

; 637  :     strm->state = Z_NULL;

  0003b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003e	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  00045	33 c0		 xor	 eax, eax
$LN3@inflateBac:

; 640  : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
_inflateBackEnd@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 121  :     state->distcode = distfix;

  00017	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001a	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 122  :     state->distbits = 5;

  00021	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00024	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 123  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflateBackInit_@20
; Function compile flags: /Odtp
;	COMDAT _inflateBackInit_@20
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_@20 PROC				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00004	83 7d 14 00	 cmp	 DWORD PTR _version$[ebp], 0
  00008	74 17		 je	 SHORT $LN6@inflateBac@2
  0000a	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  0000d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00010	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR ??_C@_05IAIEPMAK@1?42?48?$AA@
  00017	3b ca		 cmp	 ecx, edx
  00019	75 06		 jne	 SHORT $LN6@inflateBac@2
  0001b	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	74 0a		 je	 SHORT $LN7@inflateBac@2
$LN6@inflateBac@2:

; 39   :         return Z_VERSION_ERROR;

  00021	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00026	e9 d0 00 00 00	 jmp	 $LN8@inflateBac@2
$LN7@inflateBac@2:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  0002b	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0002f	74 12		 je	 SHORT $LN4@inflateBac@2
  00031	83 7d 10 00	 cmp	 DWORD PTR _window$[ebp], 0
  00035	74 0c		 je	 SHORT $LN4@inflateBac@2
  00037	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  0003b	7c 06		 jl	 SHORT $LN4@inflateBac@2
  0003d	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  00041	7e 0a		 jle	 SHORT $LN5@inflateBac@2
$LN4@inflateBac@2:

; 42   :         return Z_STREAM_ERROR;

  00043	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00048	e9 ae 00 00 00	 jmp	 $LN8@inflateBac@2
$LN5@inflateBac@2:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0004d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00050	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00057	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0005e	75 14		 jne	 SHORT $LN3@inflateBac@2

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  00060	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00063	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _zcalloc

; 49   :         strm->opaque = (voidpf)0;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN3@inflateBac@2:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00077	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0007b	75 0a		 jne	 SHORT $LN2@inflateBac@2

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  0007d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00080	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _zcfree
$LN2@inflateBac@2:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 59   :                                                sizeof(struct inflate_state));

  00087	68 cc 1b 00 00	 push	 7116			; 00001bccH
  0008c	6a 01		 push	 1
  0008e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00091	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00094	51		 push	 ecx
  00095	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00098	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0009b	ff d0		 call	 eax
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a3	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  000a7	75 07		 jne	 SHORT $LN1@inflateBac@2
  000a9	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000ae	eb 4b		 jmp	 SHORT $LN8@inflateBac@2
$LN1@inflateBac@2:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000b6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 63   :     state->dmax = 32768U;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000bc	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [eax+20], 32768 ; 00008000H

; 64   :     state->wbits = windowBits;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  000c9	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 65   :     state->wsize = 1U << windowBits;

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000d4	d3 e0		 shl	 eax, cl
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 66   :     state->window = window;

  000dc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000df	8b 45 10	 mov	 eax, DWORD PTR _window$[ebp]
  000e2	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 67   :     state->wnext = 0;

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000e8	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 68   :     state->whave = 0;

  000ef	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000f2	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 69   :     return Z_OK;

  000f9	33 c0		 xor	 eax, eax
$LN8@inflateBac@2:

; 70   : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 14 00	 ret	 20			; 00000014H
_inflateBackInit_@20 ENDP
PUBLIC	_inflateBack@20
; Function compile flags: /Odtp
;	COMDAT _inflateBack@20
_TEXT	SEGMENT
tv137 = -64						; size = 4
tv76 = -60						; size = 4
tv73 = -56						; size = 4
_state$ = -52						; size = 4
_from$ = -48						; size = 4
_copy$ = -44						; size = 4
_hold$ = -40						; size = 4
_ret$ = -36						; size = 4
_next$ = -32						; size = 4
_left$ = -28						; size = 4
_bits$ = -24						; size = 4
_len$ = -20						; size = 4
_have$ = -16						; size = 4
_here$ = -12						; size = 4
_last$ = -8						; size = 4
_put$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack@20 PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN333@inflateBac@3
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN334@inflateBac@3
$LN333@inflateBac@3:

; 274  :         return Z_STREAM_ERROR;

  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 30 13 00 00	 jmp	 $LN335@inflateBac@3
$LN334@inflateBac@3:

; 275  :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 cc	 mov	 DWORD PTR _state$[ebp], edx

; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 279  :     state->mode = TYPE;

  00032	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 280  :     state->last = 0;

  0003b	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0003e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 281  :     state->whave = 0;

  00045	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00048	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 282  :     next = strm->next_in;

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 e0	 mov	 DWORD PTR _next$[ebp], edx

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00057	83 7d e0 00	 cmp	 DWORD PTR _next$[ebp], 0
  0005b	74 0b		 je	 SHORT $LN337@inflateBac@3
  0005d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00060	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00063	89 4d c8	 mov	 DWORD PTR tv73[ebp], ecx
  00066	eb 07		 jmp	 SHORT $LN338@inflateBac@3
$LN337@inflateBac@3:
  00068	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN338@inflateBac@3:
  0006f	8b 55 c8	 mov	 edx, DWORD PTR tv73[ebp]
  00072	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 284  :     hold = 0;

  00075	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0

; 285  :     bits = 0;

  0007c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0

; 286  :     put = state->window;

  00083	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00086	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00089	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx

; 287  :     left = state->wsize;

  0008c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0008f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00092	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
$LN332@inflateBac@3:

; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00095	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	89 55 c4	 mov	 DWORD PTR tv76[ebp], edx
  0009d	8b 45 c4	 mov	 eax, DWORD PTR tv76[ebp]
  000a0	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000a3	89 45 c4	 mov	 DWORD PTR tv76[ebp], eax
  000a6	83 7d c4 12	 cmp	 DWORD PTR tv76[ebp], 18	; 00000012H
  000aa	0f 87 7d 12 00
	00		 ja	 $LN1@inflateBac@3
  000b0	8b 4d c4	 mov	 ecx, DWORD PTR tv76[ebp]
  000b3	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN339@inflateBac@3[ecx]
  000ba	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN340@inflateBac@3[edx*4]
$LN328@inflateBac@3:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000c1	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  000c4	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000c8	74 2e		 je	 SHORT $LN320@inflateBac@3
$LN326@inflateBac@3:

; 295  :                 BYTEBITS();

  000ca	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  000cd	83 e1 07	 and	 ecx, 7
  000d0	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  000d3	d3 ea		 shr	 edx, cl
  000d5	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  000d8	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  000db	83 e0 07	 and	 eax, 7
  000de	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  000e1	2b c8		 sub	 ecx, eax
  000e3	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  000e6	33 d2		 xor	 edx, edx
  000e8	75 e0		 jne	 SHORT $LN326@inflateBac@3

; 296  :                 state->mode = DONE;

  000ea	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  000ed	c7 00 1c 00 00
	00		 mov	 DWORD PTR [eax], 28	; 0000001cH

; 297  :                 break;

  000f3	e9 3e 12 00 00	 jmp	 $LN329@inflateBac@3
$LN320@inflateBac@3:

; 298  :             }
; 299  :             NEEDBITS(3);

  000f8	83 7d e8 03	 cmp	 DWORD PTR _bits$[ebp], 3
  000fc	73 66		 jae	 SHORT $LN322@inflateBac@3
$LN315@inflateBac@3:
  000fe	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00102	75 2a		 jne	 SHORT $LN314@inflateBac@3
  00104	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00107	51		 push	 ecx
  00108	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0010b	52		 push	 edx
  0010c	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0010f	83 c4 08	 add	 esp, 8
  00112	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00115	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00119	75 13		 jne	 SHORT $LN314@inflateBac@3
  0011b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00122	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00129	e9 0d 12 00 00	 jmp	 $inf_leave$77663
$LN314@inflateBac@3:
  0012e	33 c0		 xor	 eax, eax
  00130	75 cc		 jne	 SHORT $LN315@inflateBac@3
  00132	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00135	83 e9 01	 sub	 ecx, 1
  00138	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0013b	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0013e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00141	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00144	d3 e0		 shl	 eax, cl
  00146	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00149	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0014c	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0014f	83 c1 01	 add	 ecx, 1
  00152	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00155	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00158	83 c2 08	 add	 edx, 8
  0015b	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0015e	33 c0		 xor	 eax, eax
  00160	75 9c		 jne	 SHORT $LN315@inflateBac@3
  00162	eb 94		 jmp	 SHORT $LN320@inflateBac@3
$LN322@inflateBac@3:
  00164	33 c9		 xor	 ecx, ecx
  00166	75 90		 jne	 SHORT $LN320@inflateBac@3

; 300  :             state->last = BITS(1);

  00168	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0016b	83 e2 01	 and	 edx, 1
  0016e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00171	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN310@inflateBac@3:

; 301  :             DROPBITS(1);

  00174	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00177	d1 e9		 shr	 ecx, 1
  00179	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  0017c	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0017f	83 ea 01	 sub	 edx, 1
  00182	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00185	33 c0		 xor	 eax, eax
  00187	75 eb		 jne	 SHORT $LN310@inflateBac@3

; 302  :             switch (BITS(2)) {

  00189	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0018c	83 e1 03	 and	 ecx, 3
  0018f	89 4d c0	 mov	 DWORD PTR tv137[ebp], ecx
  00192	83 7d c0 03	 cmp	 DWORD PTR tv137[ebp], 3
  00196	77 4a		 ja	 SHORT $LN301@inflateBac@3
  00198	8b 55 c0	 mov	 edx, DWORD PTR tv137[ebp]
  0019b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN341@inflateBac@3[edx*4]
$LN305@inflateBac@3:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  001a2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  001a5	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 307  :                 break;

  001ab	eb 35		 jmp	 SHORT $LN301@inflateBac@3
$LN304@inflateBac@3:

; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  001ad	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 _fixedtables
  001b6	83 c4 04	 add	 esp, 4

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */

  001b9	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  001bc	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H

; 313  :                 break;

  001c2	eb 1e		 jmp	 SHORT $LN301@inflateBac@3
$LN303@inflateBac@3:

; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;

  001c4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  001c7	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 318  :                 break;

  001cd	eb 13		 jmp	 SHORT $LN301@inflateBac@3
$LN302@inflateBac@3:

; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  001cf	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  001d2	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 321  :                 state->mode = BAD;

  001d9	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  001dc	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH
$LN301@inflateBac@3:

; 322  :             }
; 323  :             DROPBITS(2);

  001e2	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  001e5	c1 e8 02	 shr	 eax, 2
  001e8	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  001eb	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  001ee	83 e9 02	 sub	 ecx, 2
  001f1	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  001f4	33 d2		 xor	 edx, edx
  001f6	75 ea		 jne	 SHORT $LN301@inflateBac@3

; 324  :             break;

  001f8	e9 39 11 00 00	 jmp	 $LN329@inflateBac@3
$LN297@inflateBac@3:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  001fd	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00200	83 e1 07	 and	 ecx, 7
  00203	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00206	d3 e8		 shr	 eax, cl
  00208	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0020b	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0020e	83 e1 07	 and	 ecx, 7
  00211	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00214	2b d1		 sub	 edx, ecx
  00216	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00219	33 c0		 xor	 eax, eax
  0021b	75 e0		 jne	 SHORT $LN297@inflateBac@3
$LN291@inflateBac@3:

; 329  :             NEEDBITS(32);

  0021d	83 7d e8 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00221	73 66		 jae	 SHORT $LN293@inflateBac@3
$LN286@inflateBac@3:
  00223	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00227	75 2a		 jne	 SHORT $LN285@inflateBac@3
  00229	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  0022c	51		 push	 ecx
  0022d	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00230	52		 push	 edx
  00231	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00234	83 c4 08	 add	 esp, 8
  00237	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0023a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0023e	75 13		 jne	 SHORT $LN285@inflateBac@3
  00240	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00247	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0024e	e9 e8 10 00 00	 jmp	 $inf_leave$77663
$LN285@inflateBac@3:
  00253	33 c0		 xor	 eax, eax
  00255	75 cc		 jne	 SHORT $LN286@inflateBac@3
  00257	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0025a	83 e9 01	 sub	 ecx, 1
  0025d	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00260	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00263	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00266	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00269	d3 e0		 shl	 eax, cl
  0026b	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0026e	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00271	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00274	83 c1 01	 add	 ecx, 1
  00277	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0027a	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0027d	83 c2 08	 add	 edx, 8
  00280	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00283	33 c0		 xor	 eax, eax
  00285	75 9c		 jne	 SHORT $LN286@inflateBac@3
  00287	eb 94		 jmp	 SHORT $LN291@inflateBac@3
$LN293@inflateBac@3:
  00289	33 c9		 xor	 ecx, ecx
  0028b	75 90		 jne	 SHORT $LN291@inflateBac@3

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0028d	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00290	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00296	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00299	c1 e8 10	 shr	 eax, 16			; 00000010H
  0029c	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  002a1	3b d0		 cmp	 edx, eax
  002a3	74 18		 je	 SHORT $LN281@inflateBac@3

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  002a8	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 332  :                 state->mode = BAD;

  002af	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  002b2	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 333  :                 break;

  002b8	e9 79 10 00 00	 jmp	 $LN329@inflateBac@3
$LN281@inflateBac@3:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  002bd	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  002c0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  002c5	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  002c8	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN280@inflateBac@3:

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  002cb	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  002d2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  002d9	33 d2		 xor	 edx, edx
  002db	75 ee		 jne	 SHORT $LN280@inflateBac@3
$LN277@inflateBac@3:

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  002dd	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  002e0	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  002e4	0f 84 ec 00 00
	00		 je	 $LN276@inflateBac@3

; 342  :                 copy = state->length;

  002ea	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  002ed	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  002f0	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
$LN275@inflateBac@3:

; 343  :                 PULL();

  002f3	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  002f7	75 2a		 jne	 SHORT $LN274@inflateBac@3
  002f9	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  002fc	50		 push	 eax
  002fd	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00300	51		 push	 ecx
  00301	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00304	83 c4 08	 add	 esp, 8
  00307	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0030a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0030e	75 13		 jne	 SHORT $LN274@inflateBac@3
  00310	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00317	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0031e	e9 18 10 00 00	 jmp	 $inf_leave$77663
$LN274@inflateBac@3:
  00323	33 d2		 xor	 edx, edx
  00325	75 cc		 jne	 SHORT $LN275@inflateBac@3
$LN270@inflateBac@3:

; 344  :                 ROOM();

  00327	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  0032b	75 3d		 jne	 SHORT $LN269@inflateBac@3
  0032d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00330	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00333	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  00336	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00339	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0033c	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  0033f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00342	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  00345	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00348	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  0034b	50		 push	 eax
  0034c	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  0034f	51		 push	 ecx
  00350	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  00353	52		 push	 edx
  00354	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035a	85 c0		 test	 eax, eax
  0035c	74 0c		 je	 SHORT $LN269@inflateBac@3
  0035e	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00365	e9 d1 0f 00 00	 jmp	 $inf_leave$77663
$LN269@inflateBac@3:
  0036a	33 c0		 xor	 eax, eax
  0036c	75 b9		 jne	 SHORT $LN270@inflateBac@3

; 345  :                 if (copy > have) copy = have;

  0036e	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00371	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  00374	76 06		 jbe	 SHORT $LN265@inflateBac@3
  00376	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00379	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
$LN265@inflateBac@3:

; 346  :                 if (copy > left) copy = left;

  0037c	8b 45 d4	 mov	 eax, DWORD PTR _copy$[ebp]
  0037f	3b 45 e4	 cmp	 eax, DWORD PTR _left$[ebp]
  00382	76 06		 jbe	 SHORT $LN264@inflateBac@3
  00384	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  00387	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN264@inflateBac@3:

; 347  :                 zmemcpy(put, next, copy);

  0038a	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  0038d	52		 push	 edx
  0038e	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00391	50		 push	 eax
  00392	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  00395	51		 push	 ecx
  00396	e8 00 00 00 00	 call	 _memcpy
  0039b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  :                 have -= copy;

  0039e	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  003a1	2b 55 d4	 sub	 edx, DWORD PTR _copy$[ebp]
  003a4	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 349  :                 next += copy;

  003a7	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  003aa	03 45 d4	 add	 eax, DWORD PTR _copy$[ebp]
  003ad	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax

; 350  :                 left -= copy;

  003b0	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  003b3	2b 4d d4	 sub	 ecx, DWORD PTR _copy$[ebp]
  003b6	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx

; 351  :                 put += copy;

  003b9	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  003bc	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  003bf	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 352  :                 state->length -= copy;

  003c2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  003c5	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  003c8	2b 4d d4	 sub	 ecx, DWORD PTR _copy$[ebp]
  003cb	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  003ce	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 353  :             }

  003d1	e9 07 ff ff ff	 jmp	 $LN277@inflateBac@3
$LN276@inflateBac@3:

; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  003d6	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  003d9	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 356  :             break;

  003df	e9 52 0f 00 00	 jmp	 $LN329@inflateBac@3
$LN259@inflateBac@3:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  003e4	83 7d e8 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  003e8	73 66		 jae	 SHORT $LN261@inflateBac@3
$LN254@inflateBac@3:
  003ea	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  003ee	75 2a		 jne	 SHORT $LN253@inflateBac@3
  003f0	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  003f3	51		 push	 ecx
  003f4	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  003f7	52		 push	 edx
  003f8	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  003fb	83 c4 08	 add	 esp, 8
  003fe	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00401	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00405	75 13		 jne	 SHORT $LN253@inflateBac@3
  00407	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0040e	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00415	e9 21 0f 00 00	 jmp	 $inf_leave$77663
$LN253@inflateBac@3:
  0041a	33 c0		 xor	 eax, eax
  0041c	75 cc		 jne	 SHORT $LN254@inflateBac@3
  0041e	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00421	83 e9 01	 sub	 ecx, 1
  00424	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00427	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0042a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0042d	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00430	d3 e0		 shl	 eax, cl
  00432	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00435	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00438	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0043b	83 c1 01	 add	 ecx, 1
  0043e	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00441	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00444	83 c2 08	 add	 edx, 8
  00447	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0044a	33 c0		 xor	 eax, eax
  0044c	75 9c		 jne	 SHORT $LN254@inflateBac@3
  0044e	eb 94		 jmp	 SHORT $LN259@inflateBac@3
$LN261@inflateBac@3:
  00450	33 c9		 xor	 ecx, ecx
  00452	75 90		 jne	 SHORT $LN259@inflateBac@3

; 361  :             state->nlen = BITS(5) + 257;

  00454	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00457	83 e2 1f	 and	 edx, 31			; 0000001fH
  0045a	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00460	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00463	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN249@inflateBac@3:

; 362  :             DROPBITS(5);

  00466	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00469	c1 e9 05	 shr	 ecx, 5
  0046c	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  0046f	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00472	83 ea 05	 sub	 edx, 5
  00475	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00478	33 c0		 xor	 eax, eax
  0047a	75 ea		 jne	 SHORT $LN249@inflateBac@3

; 363  :             state->ndist = BITS(5) + 1;

  0047c	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0047f	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00482	83 c1 01	 add	 ecx, 1
  00485	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00488	89 4a 64	 mov	 DWORD PTR [edx+100], ecx
$LN246@inflateBac@3:

; 364  :             DROPBITS(5);

  0048b	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  0048e	c1 e8 05	 shr	 eax, 5
  00491	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00494	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00497	83 e9 05	 sub	 ecx, 5
  0049a	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0049d	33 d2		 xor	 edx, edx
  0049f	75 ea		 jne	 SHORT $LN246@inflateBac@3

; 365  :             state->ncode = BITS(4) + 4;

  004a1	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  004a4	83 e0 0f	 and	 eax, 15			; 0000000fH
  004a7	83 c0 04	 add	 eax, 4
  004aa	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  004ad	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
$LN243@inflateBac@3:

; 366  :             DROPBITS(4);

  004b0	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  004b3	c1 ea 04	 shr	 edx, 4
  004b6	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  004b9	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  004bc	83 e8 04	 sub	 eax, 4
  004bf	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  004c2	33 c9		 xor	 ecx, ecx
  004c4	75 ea		 jne	 SHORT $LN243@inflateBac@3

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  004c6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  004c9	81 7a 60 1e 01
	00 00		 cmp	 DWORD PTR [edx+96], 286	; 0000011eH
  004d0	77 09		 ja	 SHORT $LN239@inflateBac@3
  004d2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  004d5	83 78 64 1e	 cmp	 DWORD PTR [eax+100], 30	; 0000001eH
  004d9	76 18		 jbe	 SHORT $LN240@inflateBac@3
$LN239@inflateBac@3:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  004db	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  004de	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 370  :                 state->mode = BAD;

  004e5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  004e8	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 371  :                 break;

  004ee	e9 43 0e 00 00	 jmp	 $LN329@inflateBac@3
$LN240@inflateBac@3:

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  004f3	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  004f6	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0
$LN238@inflateBac@3:

; 378  :             while (state->have < state->ncode) {

  004fd	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00500	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00503	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00506	3b 42 5c	 cmp	 eax, DWORD PTR [edx+92]
  00509	0f 83 b6 00 00
	00		 jae	 $LN220@inflateBac@3
$LN233@inflateBac@3:

; 379  :                 NEEDBITS(3);

  0050f	83 7d e8 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00513	73 66		 jae	 SHORT $LN235@inflateBac@3
$LN228@inflateBac@3:
  00515	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00519	75 2a		 jne	 SHORT $LN227@inflateBac@3
  0051b	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  0051e	51		 push	 ecx
  0051f	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00522	52		 push	 edx
  00523	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00526	83 c4 08	 add	 esp, 8
  00529	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0052c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00530	75 13		 jne	 SHORT $LN227@inflateBac@3
  00532	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00539	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00540	e9 f6 0d 00 00	 jmp	 $inf_leave$77663
$LN227@inflateBac@3:
  00545	33 c0		 xor	 eax, eax
  00547	75 cc		 jne	 SHORT $LN228@inflateBac@3
  00549	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0054c	83 e9 01	 sub	 ecx, 1
  0054f	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00552	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00555	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00558	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0055b	d3 e0		 shl	 eax, cl
  0055d	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00560	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00563	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00566	83 c1 01	 add	 ecx, 1
  00569	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0056c	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0056f	83 c2 08	 add	 edx, 8
  00572	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00575	33 c0		 xor	 eax, eax
  00577	75 9c		 jne	 SHORT $LN228@inflateBac@3
  00579	eb 94		 jmp	 SHORT $LN233@inflateBac@3
$LN235@inflateBac@3:
  0057b	33 c9		 xor	 ecx, ecx
  0057d	75 90		 jne	 SHORT $LN233@inflateBac@3

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  0057f	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00582	83 e2 07	 and	 edx, 7
  00585	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00588	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0058b	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  00593	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00596	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  0059b	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0059e	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  005a1	83 c0 01	 add	 eax, 1
  005a4	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005a7	89 41 68	 mov	 DWORD PTR [ecx+104], eax
$LN223@inflateBac@3:

; 381  :                 DROPBITS(3);

  005aa	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  005ad	c1 ea 03	 shr	 edx, 3
  005b0	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  005b3	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  005b6	83 e8 03	 sub	 eax, 3
  005b9	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  005bc	33 c9		 xor	 ecx, ecx
  005be	75 ea		 jne	 SHORT $LN223@inflateBac@3

; 382  :             }

  005c0	e9 38 ff ff ff	 jmp	 $LN238@inflateBac@3
$LN220@inflateBac@3:

; 383  :             while (state->have < 19)

  005c5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005c8	83 7a 68 13	 cmp	 DWORD PTR [edx+104], 19	; 00000013H
  005cc	73 29		 jae	 SHORT $LN219@inflateBac@3

; 384  :                 state->lens[order[state->have++]] = 0;

  005ce	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  005d1	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  005d4	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  005dc	33 c0		 xor	 eax, eax
  005de	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005e1	66 89 44 51 70	 mov	 WORD PTR [ecx+edx*2+112], ax
  005e6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005e9	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  005ec	83 c0 01	 add	 eax, 1
  005ef	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005f2	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  005f5	eb ce		 jmp	 SHORT $LN220@inflateBac@3
$LN219@inflateBac@3:

; 385  :             state->next = state->codes;

  005f7	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005fa	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00600	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00603	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 386  :             state->lencode = (code const FAR *)(state->next);

  00606	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00609	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0060c	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0060f	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 387  :             state->lenbits = 7;

  00612	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00615	c7 41 54 07 00
	00 00		 mov	 DWORD PTR [ecx+84], 7

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 389  :                                 &(state->lenbits), state->work);

  0061c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0061f	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  00625	52		 push	 edx
  00626	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00629	83 c0 54	 add	 eax, 84			; 00000054H
  0062c	50		 push	 eax
  0062d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00630	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00633	51		 push	 ecx
  00634	6a 13		 push	 19			; 00000013H
  00636	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00639	83 c2 70	 add	 edx, 112		; 00000070H
  0063c	52		 push	 edx
  0063d	6a 00		 push	 0
  0063f	e8 00 00 00 00	 call	 _inflate_table
  00644	83 c4 18	 add	 esp, 24			; 00000018H
  00647	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 390  :             if (ret) {

  0064a	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0064e	74 18		 je	 SHORT $LN218@inflateBac@3

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  00650	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00653	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 392  :                 state->mode = BAD;

  0065a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0065d	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 393  :                 break;

  00663	e9 ce 0c 00 00	 jmp	 $LN329@inflateBac@3
$LN218@inflateBac@3:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;

  00668	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0066b	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0
$LN217@inflateBac@3:

; 399  :             while (state->have < state->nlen + state->ndist) {

  00672	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00675	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00678	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0067b	03 4a 64	 add	 ecx, DWORD PTR [edx+100]
  0067e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00681	39 48 68	 cmp	 DWORD PTR [eax+104], ecx
  00684	0f 83 c4 03 00
	00		 jae	 $LN216@inflateBac@3
$LN215@inflateBac@3:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  0068a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0068d	ba 01 00 00 00	 mov	 edx, 1
  00692	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00695	d3 e2		 shl	 edx, cl
  00697	83 ea 01	 sub	 edx, 1
  0069a	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  0069d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  006a0	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  006a3	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  006a6	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  006a9	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  006ad	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  006b0	77 02		 ja	 SHORT $LN209@inflateBac@3
  006b2	eb 69		 jmp	 SHORT $LN214@inflateBac@3
$LN209@inflateBac@3:

; 403  :                     PULLBYTE();

  006b4	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  006b8	75 2a		 jne	 SHORT $LN208@inflateBac@3
  006ba	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  006bd	51		 push	 ecx
  006be	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  006c1	52		 push	 edx
  006c2	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  006c5	83 c4 08	 add	 esp, 8
  006c8	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  006cb	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  006cf	75 13		 jne	 SHORT $LN208@inflateBac@3
  006d1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  006d8	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  006df	e9 57 0c 00 00	 jmp	 $inf_leave$77663
$LN208@inflateBac@3:
  006e4	33 c0		 xor	 eax, eax
  006e6	75 cc		 jne	 SHORT $LN209@inflateBac@3
  006e8	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  006eb	83 e9 01	 sub	 ecx, 1
  006ee	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  006f1	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  006f4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  006f7	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  006fa	d3 e0		 shl	 eax, cl
  006fc	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  006ff	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00702	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00705	83 c1 01	 add	 ecx, 1
  00708	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0070b	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0070e	83 c2 08	 add	 edx, 8
  00711	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00714	33 c0		 xor	 eax, eax
  00716	75 9c		 jne	 SHORT $LN209@inflateBac@3

; 404  :                 }

  00718	e9 6d ff ff ff	 jmp	 $LN215@inflateBac@3
$LN214@inflateBac@3:

; 405  :                 if (here.val < 16) {

  0071d	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  00721	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00724	7d 42		 jge	 SHORT $LN204@inflateBac@3
$LN203@inflateBac@3:

; 406  :                     DROPBITS(here.bits);

  00726	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0072a	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0072d	d3 ea		 shr	 edx, cl
  0072f	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00732	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00736	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00739	2b c8		 sub	 ecx, eax
  0073b	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0073e	33 d2		 xor	 edx, edx
  00740	75 e4		 jne	 SHORT $LN203@inflateBac@3

; 407  :                     state->lens[state->have++] = here.val;

  00742	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00745	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00748	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0074b	66 8b 45 f6	 mov	 ax, WORD PTR _here$[ebp+2]
  0074f	66 89 44 4a 70	 mov	 WORD PTR [edx+ecx*2+112], ax
  00754	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00757	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  0075a	83 c2 01	 add	 edx, 1
  0075d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00760	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 408  :                 }
; 409  :                 else {

  00763	e9 e1 02 00 00	 jmp	 $LN200@inflateBac@3
$LN204@inflateBac@3:

; 410  :                     if (here.val == 16) {

  00768	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  0076c	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0076f	0f 85 eb 00 00
	00		 jne	 $LN199@inflateBac@3
$LN195@inflateBac@3:

; 411  :                         NEEDBITS(here.bits + 2);

  00775	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  00779	83 c2 02	 add	 edx, 2
  0077c	39 55 e8	 cmp	 DWORD PTR _bits$[ebp], edx
  0077f	73 66		 jae	 SHORT $LN197@inflateBac@3
$LN190@inflateBac@3:
  00781	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00785	75 2a		 jne	 SHORT $LN189@inflateBac@3
  00787	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  0078a	50		 push	 eax
  0078b	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0078e	51		 push	 ecx
  0078f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00792	83 c4 08	 add	 esp, 8
  00795	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00798	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0079c	75 13		 jne	 SHORT $LN189@inflateBac@3
  0079e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  007a5	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  007ac	e9 8a 0b 00 00	 jmp	 $inf_leave$77663
$LN189@inflateBac@3:
  007b1	33 d2		 xor	 edx, edx
  007b3	75 cc		 jne	 SHORT $LN190@inflateBac@3
  007b5	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  007b8	83 e8 01	 sub	 eax, 1
  007bb	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  007be	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  007c1	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  007c4	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  007c7	d3 e2		 shl	 edx, cl
  007c9	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  007cc	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  007cf	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  007d2	83 c0 01	 add	 eax, 1
  007d5	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  007d8	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  007db	83 c1 08	 add	 ecx, 8
  007de	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  007e1	33 d2		 xor	 edx, edx
  007e3	75 9c		 jne	 SHORT $LN190@inflateBac@3
  007e5	eb 8e		 jmp	 SHORT $LN195@inflateBac@3
$LN197@inflateBac@3:
  007e7	33 c0		 xor	 eax, eax
  007e9	75 8a		 jne	 SHORT $LN195@inflateBac@3
$LN185@inflateBac@3:

; 412  :                         DROPBITS(here.bits);

  007eb	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  007ef	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  007f2	d3 ea		 shr	 edx, cl
  007f4	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  007f7	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  007fb	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  007fe	2b c8		 sub	 ecx, eax
  00800	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00803	33 d2		 xor	 edx, edx
  00805	75 e4		 jne	 SHORT $LN185@inflateBac@3

; 413  :                         if (state->have == 0) {

  00807	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0080a	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  0080e	75 18		 jne	 SHORT $LN182@inflateBac@3

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  00810	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00813	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 415  :                             state->mode = BAD;

  0081a	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0081d	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 416  :                             break;

  00823	e9 26 02 00 00	 jmp	 $LN216@inflateBac@3
$LN182@inflateBac@3:

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);

  00828	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0082b	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0082e	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00831	0f b7 44 4a 6e	 movzx	 eax, WORD PTR [edx+ecx*2+110]
  00836	89 45 ec	 mov	 DWORD PTR _len$[ebp], eax

; 419  :                         copy = 3 + BITS(2);

  00839	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0083c	83 e1 03	 and	 ecx, 3
  0083f	83 c1 03	 add	 ecx, 3
  00842	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN181@inflateBac@3:

; 420  :                         DROPBITS(2);

  00845	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00848	c1 ea 02	 shr	 edx, 2
  0084b	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0084e	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  00851	83 e8 02	 sub	 eax, 2
  00854	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  00857	33 c9		 xor	 ecx, ecx
  00859	75 ea		 jne	 SHORT $LN181@inflateBac@3

; 421  :                     }
; 422  :                     else if (here.val == 17) {

  0085b	e9 88 01 00 00	 jmp	 $LN178@inflateBac@3
$LN199@inflateBac@3:
  00860	0f b7 55 f6	 movzx	 edx, WORD PTR _here$[ebp+2]
  00864	83 fa 11	 cmp	 edx, 17			; 00000011H
  00867	0f 85 c0 00 00
	00		 jne	 $LN153@inflateBac@3
$LN173@inflateBac@3:

; 423  :                         NEEDBITS(here.bits + 3);

  0086d	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00871	83 c0 03	 add	 eax, 3
  00874	39 45 e8	 cmp	 DWORD PTR _bits$[ebp], eax
  00877	73 66		 jae	 SHORT $LN175@inflateBac@3
$LN168@inflateBac@3:
  00879	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0087d	75 2a		 jne	 SHORT $LN167@inflateBac@3
  0087f	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00882	51		 push	 ecx
  00883	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00886	52		 push	 edx
  00887	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0088a	83 c4 08	 add	 esp, 8
  0088d	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00890	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00894	75 13		 jne	 SHORT $LN167@inflateBac@3
  00896	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0089d	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  008a4	e9 92 0a 00 00	 jmp	 $inf_leave$77663
$LN167@inflateBac@3:
  008a9	33 c0		 xor	 eax, eax
  008ab	75 cc		 jne	 SHORT $LN168@inflateBac@3
  008ad	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  008b0	83 e9 01	 sub	 ecx, 1
  008b3	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  008b6	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  008b9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  008bc	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  008bf	d3 e0		 shl	 eax, cl
  008c1	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  008c4	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  008c7	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  008ca	83 c1 01	 add	 ecx, 1
  008cd	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  008d0	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  008d3	83 c2 08	 add	 edx, 8
  008d6	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  008d9	33 c0		 xor	 eax, eax
  008db	75 9c		 jne	 SHORT $LN168@inflateBac@3
  008dd	eb 8e		 jmp	 SHORT $LN173@inflateBac@3
$LN175@inflateBac@3:
  008df	33 c9		 xor	 ecx, ecx
  008e1	75 8a		 jne	 SHORT $LN173@inflateBac@3
$LN163@inflateBac@3:

; 424  :                         DROPBITS(here.bits);

  008e3	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  008e7	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  008ea	d3 ea		 shr	 edx, cl
  008ec	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  008ef	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  008f3	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  008f6	2b c8		 sub	 ecx, eax
  008f8	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  008fb	33 d2		 xor	 edx, edx
  008fd	75 e4		 jne	 SHORT $LN163@inflateBac@3

; 425  :                         len = 0;

  008ff	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 426  :                         copy = 3 + BITS(3);

  00906	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00909	83 e0 07	 and	 eax, 7
  0090c	83 c0 03	 add	 eax, 3
  0090f	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN160@inflateBac@3:

; 427  :                         DROPBITS(3);

  00912	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00915	c1 e9 03	 shr	 ecx, 3
  00918	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  0091b	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0091e	83 ea 03	 sub	 edx, 3
  00921	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00924	33 c0		 xor	 eax, eax
  00926	75 ea		 jne	 SHORT $LN160@inflateBac@3

; 428  :                     }
; 429  :                     else {

  00928	e9 bb 00 00 00	 jmp	 $LN178@inflateBac@3
$LN153@inflateBac@3:

; 430  :                         NEEDBITS(here.bits + 7);

  0092d	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00931	83 c1 07	 add	 ecx, 7
  00934	39 4d e8	 cmp	 DWORD PTR _bits$[ebp], ecx
  00937	73 66		 jae	 SHORT $LN155@inflateBac@3
$LN148@inflateBac@3:
  00939	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0093d	75 2a		 jne	 SHORT $LN147@inflateBac@3
  0093f	8d 55 e0	 lea	 edx, DWORD PTR _next$[ebp]
  00942	52		 push	 edx
  00943	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00946	50		 push	 eax
  00947	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0094a	83 c4 08	 add	 esp, 8
  0094d	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00950	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00954	75 13		 jne	 SHORT $LN147@inflateBac@3
  00956	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0095d	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00964	e9 d2 09 00 00	 jmp	 $inf_leave$77663
$LN147@inflateBac@3:
  00969	33 c9		 xor	 ecx, ecx
  0096b	75 cc		 jne	 SHORT $LN148@inflateBac@3
  0096d	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00970	83 ea 01	 sub	 edx, 1
  00973	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00976	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00979	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0097c	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0097f	d3 e2		 shl	 edx, cl
  00981	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  00984	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00987	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0098a	83 c0 01	 add	 eax, 1
  0098d	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  00990	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00993	83 c1 08	 add	 ecx, 8
  00996	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00999	33 d2		 xor	 edx, edx
  0099b	75 9c		 jne	 SHORT $LN148@inflateBac@3
  0099d	eb 8e		 jmp	 SHORT $LN153@inflateBac@3
$LN155@inflateBac@3:
  0099f	33 c0		 xor	 eax, eax
  009a1	75 8a		 jne	 SHORT $LN153@inflateBac@3
$LN143@inflateBac@3:

; 431  :                         DROPBITS(here.bits);

  009a3	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  009a7	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  009aa	d3 ea		 shr	 edx, cl
  009ac	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  009af	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  009b3	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  009b6	2b c8		 sub	 ecx, eax
  009b8	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  009bb	33 d2		 xor	 edx, edx
  009bd	75 e4		 jne	 SHORT $LN143@inflateBac@3

; 432  :                         len = 0;

  009bf	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 433  :                         copy = 11 + BITS(7);

  009c6	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  009c9	83 e0 7f	 and	 eax, 127		; 0000007fH
  009cc	83 c0 0b	 add	 eax, 11			; 0000000bH
  009cf	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN140@inflateBac@3:

; 434  :                         DROPBITS(7);

  009d2	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  009d5	c1 e9 07	 shr	 ecx, 7
  009d8	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  009db	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  009de	83 ea 07	 sub	 edx, 7
  009e1	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  009e4	33 c0		 xor	 eax, eax
  009e6	75 ea		 jne	 SHORT $LN140@inflateBac@3
$LN178@inflateBac@3:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  009e8	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  009eb	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  009ee	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  009f1	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  009f4	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  009f7	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  009fa	03 48 64	 add	 ecx, DWORD PTR [eax+100]
  009fd	3b d1		 cmp	 edx, ecx
  009ff	76 15		 jbe	 SHORT $LN136@inflateBac@3

; 437  :                         strm->msg = (char *)"invalid bit length repeat";

  00a01	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00a04	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 438  :                         state->mode = BAD;

  00a0b	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a0e	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 439  :                         break;

  00a14	eb 38		 jmp	 SHORT $LN216@inflateBac@3
$LN136@inflateBac@3:

; 440  :                     }
; 441  :                     while (copy--)

  00a16	8b 45 d4	 mov	 eax, DWORD PTR _copy$[ebp]
  00a19	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00a1c	83 e9 01	 sub	 ecx, 1
  00a1f	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
  00a22	85 c0		 test	 eax, eax
  00a24	74 23		 je	 SHORT $LN200@inflateBac@3

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00a26	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a29	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00a2c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a2f	66 8b 55 ec	 mov	 dx, WORD PTR _len$[ebp]
  00a33	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00a38	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a3b	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00a3e	83 c1 01	 add	 ecx, 1
  00a41	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a44	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
  00a47	eb cd		 jmp	 SHORT $LN136@inflateBac@3
$LN200@inflateBac@3:

; 443  :                 }
; 444  :             }

  00a49	e9 24 fc ff ff	 jmp	 $LN217@inflateBac@3
$LN216@inflateBac@3:

; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00a4e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a51	83 38 1d	 cmp	 DWORD PTR [eax], 29	; 0000001dH
  00a54	75 05		 jne	 SHORT $LN134@inflateBac@3
  00a56	e9 db 08 00 00	 jmp	 $LN329@inflateBac@3
$LN134@inflateBac@3:

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  00a5b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a5e	0f b7 91 70 02
	00 00		 movzx	 edx, WORD PTR [ecx+624]
  00a65	85 d2		 test	 edx, edx
  00a67	75 18		 jne	 SHORT $LN133@inflateBac@3

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00a69	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00a6c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 452  :                 state->mode = BAD;

  00a73	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a76	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 453  :                 break;

  00a7c	e9 b5 08 00 00	 jmp	 $LN329@inflateBac@3
$LN133@inflateBac@3:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  00a81	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a84	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00a8a	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a8d	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 460  :             state->lencode = (code const FAR *)(state->next);

  00a90	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a93	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a96	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00a99	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 461  :             state->lenbits = 9;

  00a9c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a9f	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 463  :                                 &(state->lenbits), state->work);

  00aa6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00aa9	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  00aaf	52		 push	 edx
  00ab0	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ab3	83 c0 54	 add	 eax, 84			; 00000054H
  00ab6	50		 push	 eax
  00ab7	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00aba	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00abd	51		 push	 ecx
  00abe	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00ac1	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00ac4	50		 push	 eax
  00ac5	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ac8	83 c1 70	 add	 ecx, 112		; 00000070H
  00acb	51		 push	 ecx
  00acc	6a 01		 push	 1
  00ace	e8 00 00 00 00	 call	 _inflate_table
  00ad3	83 c4 18	 add	 esp, 24			; 00000018H
  00ad6	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 464  :             if (ret) {

  00ad9	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00add	74 18		 je	 SHORT $LN132@inflateBac@3

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  00adf	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00ae2	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 466  :                 state->mode = BAD;

  00ae9	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00aec	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 467  :                 break;

  00af2	e9 3f 08 00 00	 jmp	 $LN329@inflateBac@3
$LN132@inflateBac@3:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  00af7	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00afa	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00afd	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00b00	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 470  :             state->distbits = 6;

  00b03	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b06	c7 41 58 06 00
	00 00		 mov	 DWORD PTR [ecx+88], 6

; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 472  :                             &(state->next), &(state->distbits), state->work);

  00b0d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b10	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  00b16	52		 push	 edx
  00b17	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b1a	83 c0 58	 add	 eax, 88			; 00000058H
  00b1d	50		 push	 eax
  00b1e	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b21	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00b24	51		 push	 ecx
  00b25	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b28	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00b2b	50		 push	 eax
  00b2c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b2f	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00b32	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b35	8d 4c 50 70	 lea	 ecx, DWORD PTR [eax+edx*2+112]
  00b39	51		 push	 ecx
  00b3a	6a 02		 push	 2
  00b3c	e8 00 00 00 00	 call	 _inflate_table
  00b41	83 c4 18	 add	 esp, 24			; 00000018H
  00b44	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 473  :             if (ret) {

  00b47	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00b4b	74 18		 je	 SHORT $LN131@inflateBac@3

; 474  :                 strm->msg = (char *)"invalid distances set";

  00b4d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00b50	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 475  :                 state->mode = BAD;

  00b57	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b5a	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 476  :                 break;

  00b60	e9 d1 07 00 00	 jmp	 $LN329@inflateBac@3
$LN131@inflateBac@3:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  00b65	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b68	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
$LN130@inflateBac@3:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  00b6e	83 7d f0 06	 cmp	 DWORD PTR _have$[ebp], 6
  00b72	0f 82 b4 00 00
	00		 jb	 $LN121@inflateBac@3
  00b78	81 7d e4 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  00b7f	0f 82 a7 00 00
	00		 jb	 $LN121@inflateBac@3
$LN128@inflateBac@3:

; 484  :                 RESTORE();

  00b85	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00b88	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  00b8b	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00b8e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00b91	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  00b94	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00b97	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b9a	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00b9d	89 08		 mov	 DWORD PTR [eax], ecx
  00b9f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00ba2	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00ba5	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00ba8	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00bab	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00bae	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  00bb1	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bb4	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00bb7	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00bba	33 d2		 xor	 edx, edx
  00bbc	75 c7		 jne	 SHORT $LN128@inflateBac@3

; 485  :                 if (state->whave < state->wsize)

  00bbe	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bc1	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00bc4	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00bc7	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  00bca	73 0f		 jae	 SHORT $LN125@inflateBac@3

; 486  :                     state->whave = state->wsize - left;

  00bcc	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bcf	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00bd2	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  00bd5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00bd8	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
$LN125@inflateBac@3:

; 487  :                 inflate_fast(strm, state->wsize);

  00bdb	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bde	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00be1	51		 push	 ecx
  00be2	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00be5	52		 push	 edx
  00be6	e8 00 00 00 00	 call	 _inflate_fast
  00beb	83 c4 08	 add	 esp, 8
$LN124@inflateBac@3:

; 488  :                 LOAD();

  00bee	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00bf1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00bf4	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  00bf7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00bfa	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00bfd	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  00c00	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c03	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c05	89 55 e0	 mov	 DWORD PTR _next$[ebp], edx
  00c08	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c0b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c0e	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00c11	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00c14	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00c17	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00c1a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c1d	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00c20	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00c23	33 c0		 xor	 eax, eax
  00c25	75 c7		 jne	 SHORT $LN124@inflateBac@3

; 489  :                 break;

  00c27	e9 0a 07 00 00	 jmp	 $LN329@inflateBac@3
$LN121@inflateBac@3:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  00c2c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c2f	ba 01 00 00 00	 mov	 edx, 1
  00c34	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00c37	d3 e2		 shl	 edx, cl
  00c39	83 ea 01	 sub	 edx, 1
  00c3c	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00c3f	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c42	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00c45	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00c48	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  00c4b	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00c4f	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  00c52	77 02		 ja	 SHORT $LN115@inflateBac@3
  00c54	eb 69		 jmp	 SHORT $LN120@inflateBac@3
$LN115@inflateBac@3:

; 496  :                 PULLBYTE();

  00c56	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00c5a	75 2a		 jne	 SHORT $LN114@inflateBac@3
  00c5c	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00c5f	51		 push	 ecx
  00c60	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00c63	52		 push	 edx
  00c64	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00c67	83 c4 08	 add	 esp, 8
  00c6a	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00c6d	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00c71	75 13		 jne	 SHORT $LN114@inflateBac@3
  00c73	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00c7a	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00c81	e9 b5 06 00 00	 jmp	 $inf_leave$77663
$LN114@inflateBac@3:
  00c86	33 c0		 xor	 eax, eax
  00c88	75 cc		 jne	 SHORT $LN115@inflateBac@3
  00c8a	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00c8d	83 e9 01	 sub	 ecx, 1
  00c90	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00c93	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00c96	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00c99	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c9c	d3 e0		 shl	 eax, cl
  00c9e	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00ca1	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00ca4	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00ca7	83 c1 01	 add	 ecx, 1
  00caa	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00cad	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00cb0	83 c2 08	 add	 edx, 8
  00cb3	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00cb6	33 c0		 xor	 eax, eax
  00cb8	75 9c		 jne	 SHORT $LN115@inflateBac@3

; 497  :             }

  00cba	e9 6d ff ff ff	 jmp	 $LN121@inflateBac@3
$LN120@inflateBac@3:

; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  00cbf	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00cc3	85 c9		 test	 ecx, ecx
  00cc5	0f 84 db 00 00
	00		 je	 $LN95@inflateBac@3
  00ccb	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  00ccf	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  00cd5	0f 85 cb 00 00
	00		 jne	 $LN95@inflateBac@3

; 499  :                 last = here;

  00cdb	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  00cde	89 45 f8	 mov	 DWORD PTR _last$[ebp], eax
$LN109@inflateBac@3:

; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +
; 502  :                             (BITS(last.bits + last.op) >> last.bits)];

  00ce1	0f b7 55 fa	 movzx	 edx, WORD PTR _last$[ebp+2]
  00ce5	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00ce9	0f b6 45 f8	 movzx	 eax, BYTE PTR _last$[ebp]
  00ced	03 c8		 add	 ecx, eax
  00cef	b8 01 00 00 00	 mov	 eax, 1
  00cf4	d3 e0		 shl	 eax, cl
  00cf6	83 e8 01	 sub	 eax, 1
  00cf9	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  00cfc	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d00	d3 e8		 shr	 eax, cl
  00d02	03 d0		 add	 edx, eax
  00d04	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00d07	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00d0a	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00d0d	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx

; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00d10	0f b6 55 f9	 movzx	 edx, BYTE PTR _last$[ebp+1]
  00d14	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00d18	03 d0		 add	 edx, eax
  00d1a	3b 55 e8	 cmp	 edx, DWORD PTR _bits$[ebp]
  00d1d	77 02		 ja	 SHORT $LN103@inflateBac@3
  00d1f	eb 69		 jmp	 SHORT $LN98@inflateBac@3
$LN103@inflateBac@3:

; 504  :                     PULLBYTE();

  00d21	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d25	75 2a		 jne	 SHORT $LN102@inflateBac@3
  00d27	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00d2a	51		 push	 ecx
  00d2b	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00d2e	52		 push	 edx
  00d2f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00d32	83 c4 08	 add	 esp, 8
  00d35	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00d38	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d3c	75 13		 jne	 SHORT $LN102@inflateBac@3
  00d3e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00d45	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00d4c	e9 ea 05 00 00	 jmp	 $inf_leave$77663
$LN102@inflateBac@3:
  00d51	33 c0		 xor	 eax, eax
  00d53	75 cc		 jne	 SHORT $LN103@inflateBac@3
  00d55	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00d58	83 e9 01	 sub	 ecx, 1
  00d5b	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00d5e	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00d61	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00d64	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d67	d3 e0		 shl	 eax, cl
  00d69	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00d6c	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00d6f	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00d72	83 c1 01	 add	 ecx, 1
  00d75	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00d78	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00d7b	83 c2 08	 add	 edx, 8
  00d7e	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00d81	33 c0		 xor	 eax, eax
  00d83	75 9c		 jne	 SHORT $LN103@inflateBac@3

; 505  :                 }

  00d85	e9 57 ff ff ff	 jmp	 $LN109@inflateBac@3
$LN98@inflateBac@3:

; 506  :                 DROPBITS(last.bits);

  00d8a	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d8e	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00d91	d3 ea		 shr	 edx, cl
  00d93	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00d96	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  00d9a	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d9d	2b c8		 sub	 ecx, eax
  00d9f	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00da2	33 d2		 xor	 edx, edx
  00da4	75 e4		 jne	 SHORT $LN98@inflateBac@3
$LN95@inflateBac@3:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  00da6	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00daa	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00dad	d3 e8		 shr	 eax, cl
  00daf	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00db2	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00db6	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00db9	2b d1		 sub	 edx, ecx
  00dbb	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00dbe	33 c0		 xor	 eax, eax
  00dc0	75 e4		 jne	 SHORT $LN95@inflateBac@3

; 509  :             state->length = (unsigned)here.val;

  00dc2	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  00dc6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00dc9	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  00dcc	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  00dd0	85 c0		 test	 eax, eax
  00dd2	75 72		 jne	 SHORT $LN92@inflateBac@3
$LN91@inflateBac@3:

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00dd4	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  00dd8	75 3d		 jne	 SHORT $LN90@inflateBac@3
  00dda	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ddd	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00de0	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx
  00de3	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00de6	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00de9	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx
  00dec	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00def	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00df2	89 42 2c	 mov	 DWORD PTR [edx+44], eax
  00df5	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  00df8	51		 push	 ecx
  00df9	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00dfc	52		 push	 edx
  00dfd	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00e00	50		 push	 eax
  00e01	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00e04	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e07	85 c0		 test	 eax, eax
  00e09	74 0c		 je	 SHORT $LN90@inflateBac@3
  00e0b	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00e12	e9 24 05 00 00	 jmp	 $inf_leave$77663
$LN90@inflateBac@3:
  00e17	33 c9		 xor	 ecx, ecx
  00e19	75 b9		 jne	 SHORT $LN91@inflateBac@3

; 517  :                 *put++ = (unsigned char)(state->length);

  00e1b	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e1e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e21	8a 48 40	 mov	 cl, BYTE PTR [eax+64]
  00e24	88 0a		 mov	 BYTE PTR [edx], cl
  00e26	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e29	83 c2 01	 add	 edx, 1
  00e2c	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 518  :                 left--;

  00e2f	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00e32	83 e8 01	 sub	 eax, 1
  00e35	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax

; 519  :                 state->mode = LEN;

  00e38	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00e3b	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 520  :                 break;

  00e41	e9 f0 04 00 00	 jmp	 $LN329@inflateBac@3
$LN92@inflateBac@3:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00e46	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  00e4a	83 e2 20	 and	 edx, 32			; 00000020H
  00e4d	74 0e		 je	 SHORT $LN86@inflateBac@3

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;

  00e4f	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e52	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 527  :                 break;

  00e58	e9 d9 04 00 00	 jmp	 $LN329@inflateBac@3
$LN86@inflateBac@3:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00e5d	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00e61	83 e1 40	 and	 ecx, 64			; 00000040H
  00e64	74 18		 je	 SHORT $LN85@inflateBac@3

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00e66	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00e69	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 533  :                 state->mode = BAD;

  00e70	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e73	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 534  :                 break;

  00e79	e9 b8 04 00 00	 jmp	 $LN329@inflateBac@3
$LN85@inflateBac@3:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00e7e	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00e82	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00e85	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00e88	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 539  :             if (state->extra != 0) {

  00e8b	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e8e	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00e92	0f 84 b2 00 00
	00		 je	 $LN67@inflateBac@3
$LN80@inflateBac@3:

; 540  :                 NEEDBITS(state->extra);

  00e98	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00e9b	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00e9e	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  00ea1	73 66		 jae	 SHORT $LN82@inflateBac@3
$LN75@inflateBac@3:
  00ea3	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ea7	75 2a		 jne	 SHORT $LN74@inflateBac@3
  00ea9	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  00eac	50		 push	 eax
  00ead	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00eb0	51		 push	 ecx
  00eb1	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00eb4	83 c4 08	 add	 esp, 8
  00eb7	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00eba	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ebe	75 13		 jne	 SHORT $LN74@inflateBac@3
  00ec0	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00ec7	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00ece	e9 68 04 00 00	 jmp	 $inf_leave$77663
$LN74@inflateBac@3:
  00ed3	33 d2		 xor	 edx, edx
  00ed5	75 cc		 jne	 SHORT $LN75@inflateBac@3
  00ed7	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00eda	83 e8 01	 sub	 eax, 1
  00edd	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00ee0	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00ee3	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00ee6	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ee9	d3 e2		 shl	 edx, cl
  00eeb	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  00eee	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00ef1	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00ef4	83 c0 01	 add	 eax, 1
  00ef7	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  00efa	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00efd	83 c1 08	 add	 ecx, 8
  00f00	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00f03	33 d2		 xor	 edx, edx
  00f05	75 9c		 jne	 SHORT $LN75@inflateBac@3
  00f07	eb 8f		 jmp	 SHORT $LN80@inflateBac@3
$LN82@inflateBac@3:
  00f09	33 c0		 xor	 eax, eax
  00f0b	75 8b		 jne	 SHORT $LN80@inflateBac@3

; 541  :                 state->length += BITS(state->extra);

  00f0d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f10	ba 01 00 00 00	 mov	 edx, 1
  00f15	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  00f18	d3 e2		 shl	 edx, cl
  00f1a	83 ea 01	 sub	 edx, 1
  00f1d	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00f20	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00f23	03 50 40	 add	 edx, DWORD PTR [eax+64]
  00f26	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f29	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$LN70@inflateBac@3:

; 542  :                 DROPBITS(state->extra);

  00f2c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00f2f	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00f32	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  00f35	d3 e8		 shr	 eax, cl
  00f37	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00f3a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f3d	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00f40	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  00f43	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00f46	33 c0		 xor	 eax, eax
  00f48	75 e2		 jne	 SHORT $LN70@inflateBac@3
$LN67@inflateBac@3:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  00f4a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f4d	ba 01 00 00 00	 mov	 edx, 1
  00f52	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00f55	d3 e2		 shl	 edx, cl
  00f57	83 ea 01	 sub	 edx, 1
  00f5a	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  00f5d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00f60	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00f63	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00f66	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00f69	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00f6d	3b 45 e8	 cmp	 eax, DWORD PTR _bits$[ebp]
  00f70	77 02		 ja	 SHORT $LN61@inflateBac@3
  00f72	eb 69		 jmp	 SHORT $LN66@inflateBac@3
$LN61@inflateBac@3:

; 550  :                 PULLBYTE();

  00f74	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f78	75 2a		 jne	 SHORT $LN60@inflateBac@3
  00f7a	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  00f7d	51		 push	 ecx
  00f7e	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00f81	52		 push	 edx
  00f82	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00f85	83 c4 08	 add	 esp, 8
  00f88	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00f8b	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f8f	75 13		 jne	 SHORT $LN60@inflateBac@3
  00f91	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00f98	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00f9f	e9 97 03 00 00	 jmp	 $inf_leave$77663
$LN60@inflateBac@3:
  00fa4	33 c0		 xor	 eax, eax
  00fa6	75 cc		 jne	 SHORT $LN61@inflateBac@3
  00fa8	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00fab	83 e9 01	 sub	 ecx, 1
  00fae	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00fb1	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00fb4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00fb7	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00fba	d3 e0		 shl	 eax, cl
  00fbc	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00fbf	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00fc2	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00fc5	83 c1 01	 add	 ecx, 1
  00fc8	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00fcb	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00fce	83 c2 08	 add	 edx, 8
  00fd1	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00fd4	33 c0		 xor	 eax, eax
  00fd6	75 9c		 jne	 SHORT $LN61@inflateBac@3

; 551  :             }

  00fd8	e9 6d ff ff ff	 jmp	 $LN67@inflateBac@3
$LN66@inflateBac@3:

; 552  :             if ((here.op & 0xf0) == 0) {

  00fdd	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  00fe1	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00fe7	0f 85 cb 00 00
	00		 jne	 $LN41@inflateBac@3

; 553  :                 last = here;

  00fed	8b 55 f4	 mov	 edx, DWORD PTR _here$[ebp]
  00ff0	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx
$LN55@inflateBac@3:

; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +
; 556  :                             (BITS(last.bits + last.op) >> last.bits)];

  00ff3	0f b7 45 fa	 movzx	 eax, WORD PTR _last$[ebp+2]
  00ff7	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00ffb	0f b6 55 f8	 movzx	 edx, BYTE PTR _last$[ebp]
  00fff	03 ca		 add	 ecx, edx
  01001	ba 01 00 00 00	 mov	 edx, 1
  01006	d3 e2		 shl	 edx, cl
  01008	83 ea 01	 sub	 edx, 1
  0100b	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  0100e	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01012	d3 ea		 shr	 edx, cl
  01014	03 c2		 add	 eax, edx
  01016	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01019	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0101c	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0101f	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax

; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01022	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01026	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  0102a	03 ca		 add	 ecx, edx
  0102c	3b 4d e8	 cmp	 ecx, DWORD PTR _bits$[ebp]
  0102f	77 02		 ja	 SHORT $LN49@inflateBac@3
  01031	eb 69		 jmp	 SHORT $LN44@inflateBac@3
$LN49@inflateBac@3:

; 558  :                     PULLBYTE();

  01033	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01037	75 2a		 jne	 SHORT $LN48@inflateBac@3
  01039	8d 45 e0	 lea	 eax, DWORD PTR _next$[ebp]
  0103c	50		 push	 eax
  0103d	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  01040	51		 push	 ecx
  01041	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  01044	83 c4 08	 add	 esp, 8
  01047	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0104a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0104e	75 13		 jne	 SHORT $LN48@inflateBac@3
  01050	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  01057	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0105e	e9 d8 02 00 00	 jmp	 $inf_leave$77663
$LN48@inflateBac@3:
  01063	33 d2		 xor	 edx, edx
  01065	75 cc		 jne	 SHORT $LN49@inflateBac@3
  01067	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  0106a	83 e8 01	 sub	 eax, 1
  0106d	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01070	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  01073	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01076	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01079	d3 e2		 shl	 edx, cl
  0107b	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  0107e	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  01081	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  01084	83 c0 01	 add	 eax, 1
  01087	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  0108a	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0108d	83 c1 08	 add	 ecx, 8
  01090	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  01093	33 d2		 xor	 edx, edx
  01095	75 9c		 jne	 SHORT $LN49@inflateBac@3

; 559  :                 }

  01097	e9 57 ff ff ff	 jmp	 $LN55@inflateBac@3
$LN44@inflateBac@3:

; 560  :                 DROPBITS(last.bits);

  0109c	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010a0	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  010a3	d3 e8		 shr	 eax, cl
  010a5	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  010a8	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010ac	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  010af	2b d1		 sub	 edx, ecx
  010b1	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  010b4	33 c0		 xor	 eax, eax
  010b6	75 e4		 jne	 SHORT $LN44@inflateBac@3
$LN41@inflateBac@3:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  010b8	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  010bc	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  010bf	d3 ea		 shr	 edx, cl
  010c1	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  010c4	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  010c8	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  010cb	2b c8		 sub	 ecx, eax
  010cd	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  010d0	33 d2		 xor	 edx, edx
  010d2	75 e4		 jne	 SHORT $LN41@inflateBac@3

; 563  :             if (here.op & 64) {

  010d4	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  010d8	83 e0 40	 and	 eax, 64			; 00000040H
  010db	74 18		 je	 SHORT $LN38@inflateBac@3

; 564  :                 strm->msg = (char *)"invalid distance code";

  010dd	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  010e0	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 565  :                 state->mode = BAD;

  010e7	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  010ea	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 566  :                 break;

  010f0	e9 41 02 00 00	 jmp	 $LN329@inflateBac@3
$LN38@inflateBac@3:

; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  010f5	0f b7 45 f6	 movzx	 eax, WORD PTR _here$[ebp+2]
  010f9	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  010fc	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  010ff	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  01103	83 e2 0f	 and	 edx, 15			; 0000000fH
  01106	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01109	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 572  :             if (state->extra != 0) {

  0110c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0110f	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  01113	0f 84 b2 00 00
	00		 je	 $LN37@inflateBac@3
$LN33@inflateBac@3:

; 573  :                 NEEDBITS(state->extra);

  01119	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0111c	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  0111f	3b 42 48	 cmp	 eax, DWORD PTR [edx+72]
  01122	73 66		 jae	 SHORT $LN35@inflateBac@3
$LN28@inflateBac@3:
  01124	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01128	75 2a		 jne	 SHORT $LN27@inflateBac@3
  0112a	8d 4d e0	 lea	 ecx, DWORD PTR _next$[ebp]
  0112d	51		 push	 ecx
  0112e	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  01131	52		 push	 edx
  01132	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  01135	83 c4 08	 add	 esp, 8
  01138	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0113b	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0113f	75 13		 jne	 SHORT $LN27@inflateBac@3
  01141	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  01148	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0114f	e9 e7 01 00 00	 jmp	 $inf_leave$77663
$LN27@inflateBac@3:
  01154	33 c0		 xor	 eax, eax
  01156	75 cc		 jne	 SHORT $LN28@inflateBac@3
  01158	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0115b	83 e9 01	 sub	 ecx, 1
  0115e	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01161	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  01164	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01167	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0116a	d3 e0		 shl	 eax, cl
  0116c	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0116f	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  01172	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  01175	83 c1 01	 add	 ecx, 1
  01178	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0117b	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0117e	83 c2 08	 add	 edx, 8
  01181	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  01184	33 c0		 xor	 eax, eax
  01186	75 9c		 jne	 SHORT $LN28@inflateBac@3
  01188	eb 8f		 jmp	 SHORT $LN33@inflateBac@3
$LN35@inflateBac@3:
  0118a	33 c9		 xor	 ecx, ecx
  0118c	75 8b		 jne	 SHORT $LN33@inflateBac@3

; 574  :                 state->offset += BITS(state->extra);

  0118e	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01191	b8 01 00 00 00	 mov	 eax, 1
  01196	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  01199	d3 e0		 shl	 eax, cl
  0119b	83 e8 01	 sub	 eax, 1
  0119e	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  011a1	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  011a4	03 41 44	 add	 eax, DWORD PTR [ecx+68]
  011a7	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  011aa	89 42 44	 mov	 DWORD PTR [edx+68], eax
$LN23@inflateBac@3:

; 575  :                 DROPBITS(state->extra);

  011ad	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  011b0	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  011b3	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  011b6	d3 ea		 shr	 edx, cl
  011b8	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  011bb	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  011be	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  011c1	2b 48 48	 sub	 ecx, DWORD PTR [eax+72]
  011c4	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  011c7	33 d2		 xor	 edx, edx
  011c9	75 e2		 jne	 SHORT $LN23@inflateBac@3
$LN37@inflateBac@3:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 578  :                                                 left : 0)) {

  011cb	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  011ce	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  011d1	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  011d4	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  011d7	1b c0		 sbb	 eax, eax
  011d9	23 45 e4	 and	 eax, DWORD PTR _left$[ebp]
  011dc	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  011df	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  011e2	2b d0		 sub	 edx, eax
  011e4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  011e7	39 50 44	 cmp	 DWORD PTR [eax+68], edx
  011ea	76 18		 jbe	 SHORT $LN16@inflateBac@3

; 579  :                 strm->msg = (char *)"invalid distance too far back";

  011ec	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  011ef	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 580  :                 state->mode = BAD;

  011f6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  011f9	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 581  :                 break;

  011ff	e9 32 01 00 00	 jmp	 $LN329@inflateBac@3
$LN16@inflateBac@3:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  01204	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  01208	75 3d		 jne	 SHORT $LN15@inflateBac@3
  0120a	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0120d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01210	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  01213	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01216	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  01219	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  0121c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0121f	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  01222	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  01225	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  01228	50		 push	 eax
  01229	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  0122c	51		 push	 ecx
  0122d	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  01230	52		 push	 edx
  01231	ff 55 14	 call	 DWORD PTR _out$[ebp]
  01234	83 c4 0c	 add	 esp, 12			; 0000000cH
  01237	85 c0		 test	 eax, eax
  01239	74 0c		 je	 SHORT $LN15@inflateBac@3
  0123b	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  01242	e9 f4 00 00 00	 jmp	 $inf_leave$77663
$LN15@inflateBac@3:
  01247	33 c0		 xor	 eax, eax
  01249	75 b9		 jne	 SHORT $LN16@inflateBac@3

; 588  :                 copy = state->wsize - state->offset;

  0124b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0124e	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01251	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  01254	2b 42 44	 sub	 eax, DWORD PTR [edx+68]
  01257	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax

; 589  :                 if (copy < left) {

  0125a	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  0125d	3b 4d e4	 cmp	 ecx, DWORD PTR _left$[ebp]
  01260	73 14		 jae	 SHORT $LN11@inflateBac@3

; 590  :                     from = put + copy;

  01262	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01265	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  01268	89 55 d0	 mov	 DWORD PTR _from$[ebp], edx

; 591  :                     copy = left - copy;

  0126b	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  0126e	2b 45 d4	 sub	 eax, DWORD PTR _copy$[ebp]
  01271	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax

; 592  :                 }
; 593  :                 else {

  01274	eb 12		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 594  :                     from = put - state->offset;

  01276	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01279	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  0127c	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  0127f	89 55 d0	 mov	 DWORD PTR _from$[ebp], edx

; 595  :                     copy = left;

  01282	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  01285	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN10@inflateBac@3:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  01288	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0128b	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  0128e	3b 51 40	 cmp	 edx, DWORD PTR [ecx+64]
  01291	76 09		 jbe	 SHORT $LN9@inflateBac@3
  01293	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01296	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01299	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN9@inflateBac@3:

; 598  :                 state->length -= copy;

  0129c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0129f	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  012a2	2b 45 d4	 sub	 eax, DWORD PTR _copy$[ebp]
  012a5	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012a8	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 599  :                 left -= copy;

  012ab	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  012ae	2b 55 d4	 sub	 edx, DWORD PTR _copy$[ebp]
  012b1	89 55 e4	 mov	 DWORD PTR _left$[ebp], edx
$LN8@inflateBac@3:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  012b4	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  012b7	8b 4d d0	 mov	 ecx, DWORD PTR _from$[ebp]
  012ba	8a 11		 mov	 dl, BYTE PTR [ecx]
  012bc	88 10		 mov	 BYTE PTR [eax], dl
  012be	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  012c1	83 c0 01	 add	 eax, 1
  012c4	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  012c7	8b 4d d0	 mov	 ecx, DWORD PTR _from$[ebp]
  012ca	83 c1 01	 add	 ecx, 1
  012cd	89 4d d0	 mov	 DWORD PTR _from$[ebp], ecx

; 602  :                 } while (--copy);

  012d0	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  012d3	83 ea 01	 sub	 edx, 1
  012d6	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
  012d9	75 d9		 jne	 SHORT $LN8@inflateBac@3

; 603  :             } while (state->length != 0);

  012db	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  012de	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  012e2	0f 85 1c ff ff
	ff		 jne	 $LN16@inflateBac@3

; 604  :             break;

  012e8	eb 4c		 jmp	 SHORT $LN329@inflateBac@3
$LN5@inflateBac@3:

; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;

  012ea	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 609  :             if (left < state->wsize) {

  012f1	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012f4	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  012f7	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  012fa	73 26		 jae	 SHORT $LN4@inflateBac@3

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  012fc	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  012ff	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  01302	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  01305	51		 push	 ecx
  01306	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01309	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0130c	50		 push	 eax
  0130d	8b 4d 18	 mov	 ecx, DWORD PTR _out_desc$[ebp]
  01310	51		 push	 ecx
  01311	ff 55 14	 call	 DWORD PTR _out$[ebp]
  01314	83 c4 0c	 add	 esp, 12			; 0000000cH
  01317	85 c0		 test	 eax, eax
  01319	74 07		 je	 SHORT $LN4@inflateBac@3

; 611  :                     ret = Z_BUF_ERROR;

  0131b	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN4@inflateBac@3:

; 612  :             }
; 613  :             goto inf_leave;

  01322	eb 17		 jmp	 SHORT $inf_leave$77663
$LN2@inflateBac@3:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  01324	c7 45 dc fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 617  :             goto inf_leave;

  0132b	eb 0e		 jmp	 SHORT $inf_leave$77663
$LN1@inflateBac@3:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  0132d	c7 45 dc fe ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  01334	eb 05		 jmp	 SHORT $inf_leave$77663
$LN329@inflateBac@3:

; 621  :             goto inf_leave;
; 622  :         }

  01336	e9 5a ed ff ff	 jmp	 $LN332@inflateBac@3
$inf_leave$77663:

; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  0133b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0133e	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  01341	89 02		 mov	 DWORD PTR [edx], eax

; 627  :     strm->avail_in = have;

  01343	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01346	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01349	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 628  :     return ret;

  0134c	8b 45 dc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN335@inflateBac@3:

; 629  : }

  0134f	8b e5		 mov	 esp, ebp
  01351	5d		 pop	 ebp
  01352	c2 14 00	 ret	 20			; 00000014H
  01355	8d 49 00	 npad	 3
$LN340@inflateBac@3:
  01358	00 00 00 00	 DD	 $LN328@inflateBac@3
  0135c	00 00 00 00	 DD	 $LN297@inflateBac@3
  01360	00 00 00 00	 DD	 $LN259@inflateBac@3
  01364	00 00 00 00	 DD	 $LN130@inflateBac@3
  01368	00 00 00 00	 DD	 $LN5@inflateBac@3
  0136c	00 00 00 00	 DD	 $LN2@inflateBac@3
  01370	00 00 00 00	 DD	 $LN1@inflateBac@3
$LN339@inflateBac@3:
  01374	00		 DB	 0
  01375	06		 DB	 6
  01376	01		 DB	 1
  01377	06		 DB	 6
  01378	06		 DB	 6
  01379	02		 DB	 2
  0137a	06		 DB	 6
  0137b	06		 DB	 6
  0137c	06		 DB	 6
  0137d	03		 DB	 3
  0137e	06		 DB	 6
  0137f	06		 DB	 6
  01380	06		 DB	 6
  01381	06		 DB	 6
  01382	06		 DB	 6
  01383	06		 DB	 6
  01384	06		 DB	 6
  01385	04		 DB	 4
  01386	05		 DB	 5
  01387	90		 npad	 1
$LN341@inflateBac@3:
  01388	00 00 00 00	 DD	 $LN305@inflateBac@3
  0138c	00 00 00 00	 DD	 $LN304@inflateBac@3
  01390	00 00 00 00	 DD	 $LN303@inflateBac@3
  01394	00 00 00 00	 DD	 $LN302@inflateBac@3
_inflateBack@20 ENDP
END
