; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	c:\dev\dosbox-x\vs2008\zlib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateMark@4
; Function compile flags: /Odtp
; File c:\dev\dosbox-x\vs2008\zlib\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv77 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1504 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN1@inflateMar
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 07		 jne	 SHORT $LN2@inflateMar
$LN1@inflateMar:
  00015	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H
  0001a	eb 54		 jmp	 SHORT $LN3@inflateMar
$LN2@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00022	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1509 :     return ((long)(state->back) << 16) +
; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));

  00025	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00028	83 38 0f	 cmp	 DWORD PTR [eax], 15	; 0000000fH
  0002b	75 0b		 jne	 SHORT $LN7@inflateMar
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00033	89 55 f8	 mov	 DWORD PTR tv77[ebp], edx
  00036	eb 29		 jmp	 SHORT $LN8@inflateMar
$LN7@inflateMar:
  00038	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003b	83 38 18	 cmp	 DWORD PTR [eax], 24	; 00000018H
  0003e	75 14		 jne	 SHORT $LN5@inflateMar
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00043	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00046	8b 81 c8 1b 00
	00		 mov	 eax, DWORD PTR [ecx+7112]
  0004c	2b 42 40	 sub	 eax, DWORD PTR [edx+64]
  0004f	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00052	eb 07		 jmp	 SHORT $LN6@inflateMar
$LN5@inflateMar:
  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN6@inflateMar:
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR tv76[ebp]
  0005e	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
$LN8@inflateMar:
  00061	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00064	8b 82 c4 1b 00
	00		 mov	 eax, DWORD PTR [edx+7108]
  0006a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006d	03 45 f8	 add	 eax, DWORD PTR tv77[ebp]
$LN3@inflateMar:

; 1512 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateUndermine@8
; Function compile flags: /Odtp
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1488 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN1@inflateUnd
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 07		 jne	 SHORT $LN2@inflateUnd
$LN1@inflateUnd:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	eb 2d		 jmp	 SHORT $LN3@inflateUnd
$LN2@inflateUnd:

; 1492 :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00020	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1493 :     state->sane = !subvert;

  00023	33 c0		 xor	 eax, eax
  00025	83 7d 0c 00	 cmp	 DWORD PTR _subvert$[ebp], 0
  00029	0f 94 c0	 sete	 al
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	89 81 c0 1b 00
	00		 mov	 DWORD PTR [ecx+7104], eax

; 1494 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1495 :     return Z_OK;
; 1496 : #else
; 1497 :     state->sane = 1;

  00035	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00038	c7 82 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+7104], 1

; 1498 :     return Z_DATA_ERROR;

  00042	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
$LN3@inflateUnd:

; 1499 : #endif
; 1500 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateCopy@8
; Function compile flags: /Odtp
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_state$ = -16						; size = 4
_copy$ = -12						; size = 4
_wsize$ = -8						; size = 4
_window$ = -4						; size = 4
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1442 :     struct inflate_state FAR *state;
; 1443 :     struct inflate_state FAR *copy;
; 1444 :     unsigned char FAR *window;
; 1445 :     unsigned wsize;
; 1446 : 
; 1447 :     /* check input */
; 1448 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1449 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00006	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  0000a	74 21		 je	 SHORT $LN6@inflateCop
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  00010	74 1b		 je	 SHORT $LN6@inflateCop
  00012	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00015	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00019	74 12		 je	 SHORT $LN6@inflateCop
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  0001e	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00022	74 09		 je	 SHORT $LN6@inflateCop
  00024	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00027	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0002b	75 0a		 jne	 SHORT $LN7@inflateCop
$LN6@inflateCop:

; 1450 :         return Z_STREAM_ERROR;

  0002d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00032	e9 85 01 00 00	 jmp	 $LN8@inflateCop
$LN7@inflateCop:

; 1451 :     state = (struct inflate_state FAR *)source->state;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  0003a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003d	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx

; 1452 : 
; 1453 :     /* allocate space */
; 1454 :     copy = (struct inflate_state FAR *)
; 1455 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  00040	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00045	6a 01		 push	 1
  00047	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  0004a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0004d	50		 push	 eax
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  00051	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00054	ff d2		 call	 edx
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 1456 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0005c	83 7d f4 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00060	75 0a		 jne	 SHORT $LN5@inflateCop
  00062	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00067	e9 50 01 00 00	 jmp	 $LN8@inflateCop
$LN5@inflateCop:

; 1457 :     window = Z_NULL;

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _window$[ebp], 0

; 1458 :     if (state->window != Z_NULL) {

  00073	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00076	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0007a	74 4b		 je	 SHORT $LN4@inflateCop

; 1459 :         window = (unsigned char FAR *)
; 1460 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0007c	6a 01		 push	 1
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00089	d3 e2		 shl	 edx, cl
  0008b	52		 push	 edx
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  0008f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00092	51		 push	 ecx
  00093	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00096	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00099	ff d0		 call	 eax
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	89 45 fc	 mov	 DWORD PTR _window$[ebp], eax

; 1461 :         if (window == Z_NULL) {

  000a1	83 7d fc 00	 cmp	 DWORD PTR _window$[ebp], 0
  000a5	75 20		 jne	 SHORT $LN4@inflateCop

; 1462 :             ZFREE(source, copy);

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  000aa	51		 push	 ecx
  000ab	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  000ae	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000b1	50		 push	 eax
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  000b5	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b8	ff d2		 call	 edx
  000ba	83 c4 08	 add	 esp, 8

; 1463 :             return Z_MEM_ERROR;

  000bd	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000c2	e9 f5 00 00 00	 jmp	 $LN8@inflateCop
$LN4@inflateCop:

; 1464 :         }
; 1465 :     }
; 1466 : 
; 1467 :     /* copy state */
; 1468 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000c7	6a 38		 push	 56			; 00000038H
  000c9	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _memcpy
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1469 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000d9	68 cc 1b 00 00	 push	 7116			; 00001bccH
  000de	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000e1	52		 push	 edx
  000e2	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _memcpy
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1470 :     if (state->lencode >= state->codes &&
; 1471 :         state->lencode <= state->codes + ENOUGH - 1) {

  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000f1	81 c1 30 05 00
	00		 add	 ecx, 1328		; 00000530H
  000f7	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000fa	39 4a 4c	 cmp	 DWORD PTR [edx+76], ecx
  000fd	72 58		 jb	 SHORT $LN2@inflateCop
  000ff	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00102	05 bc 1b 00 00	 add	 eax, 7100		; 00001bbcH
  00107	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0010a	39 41 4c	 cmp	 DWORD PTR [ecx+76], eax
  0010d	77 48		 ja	 SHORT $LN2@inflateCop

; 1472 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  0010f	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00112	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00118	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0011b	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0011e	2b ca		 sub	 ecx, edx
  00120	c1 f9 02	 sar	 ecx, 2
  00123	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  00126	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  0012d	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00130	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1473 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00133	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00136	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  0013c	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0013f	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00142	2b ca		 sub	 ecx, edx
  00144	c1 f9 02	 sar	 ecx, 2
  00147	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  0014a	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  00151	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00154	89 41 50	 mov	 DWORD PTR [ecx+80], eax
$LN2@inflateCop:

; 1474 :     }
; 1475 :     copy->next = copy->codes + (state->next - state->codes);

  00157	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0015a	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00160	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00163	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00166	2b ca		 sub	 ecx, edx
  00168	c1 f9 02	 sar	 ecx, 2
  0016b	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  0016e	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00178	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 1476 :     if (window != Z_NULL) {

  0017b	83 7d fc 00	 cmp	 DWORD PTR _window$[ebp], 0
  0017f	74 27		 je	 SHORT $LN1@inflateCop

; 1477 :         wsize = 1U << state->wbits;

  00181	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00184	b8 01 00 00 00	 mov	 eax, 1
  00189	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0018c	d3 e0		 shl	 eax, cl
  0018e	89 45 f8	 mov	 DWORD PTR _wsize$[ebp], eax

; 1478 :         zmemcpy(window, state->window, wsize);

  00191	8b 4d f8	 mov	 ecx, DWORD PTR _wsize$[ebp]
  00194	51		 push	 ecx
  00195	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00198	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0019b	50		 push	 eax
  0019c	8b 4d fc	 mov	 ecx, DWORD PTR _window$[ebp]
  0019f	51		 push	 ecx
  001a0	e8 00 00 00 00	 call	 _memcpy
  001a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1479 :     }
; 1480 :     copy->window = window;

  001a8	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  001ab	8b 45 fc	 mov	 eax, DWORD PTR _window$[ebp]
  001ae	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 1481 :     dest->state = (struct internal_state FAR *)copy;

  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  001b4	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  001b7	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 1482 :     return Z_OK;

  001ba	33 c0		 xor	 eax, eax
$LN8@inflateCop:

; 1483 : }

  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateSyncPoint@4
; Function compile flags: /Odtp
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
tv71 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN1@inflateSyn
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 07		 jne	 SHORT $LN2@inflateSyn
$LN1@inflateSyn:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	eb 2d		 jmp	 SHORT $LN3@inflateSyn
$LN2@inflateSyn:

; 1434 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00022	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1435 :     return state->mode == STORED && state->bits == 0;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00028	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  0002b	75 12		 jne	 SHORT $LN5@inflateSyn
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00034	75 09		 jne	 SHORT $LN5@inflateSyn
  00036	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0003d	eb 07		 jmp	 SHORT $LN6@inflateSyn
$LN5@inflateSyn:
  0003f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN6@inflateSyn:
  00046	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
$LN3@inflateSyn:

; 1436 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _syncsearch
_TEXT	SEGMENT
_got$ = -8						; size = 4
_next$ = -4						; size = 4
_have$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_syncsearch PROC					; COMDAT

; 1358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1359 :     unsigned got;
; 1360 :     unsigned next;
; 1361 : 
; 1362 :     got = *have;

  00006	8b 45 08	 mov	 eax, DWORD PTR _have$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _got$[ebp], ecx

; 1363 :     next = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN6@syncsearch:

; 1364 :     while (next < len && got < 4) {

  00015	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  00018	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  0001b	73 5c		 jae	 SHORT $LN5@syncsearch
  0001d	83 7d f8 04	 cmp	 DWORD PTR _got$[ebp], 4
  00021	73 56		 jae	 SHORT $LN5@syncsearch

; 1365 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00023	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00026	03 45 fc	 add	 eax, DWORD PTR _next$[ebp]
  00029	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0002c	83 7d f8 02	 cmp	 DWORD PTR _got$[ebp], 2
  00030	1b d2		 sbb	 edx, edx
  00032	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00038	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003e	3b ca		 cmp	 ecx, edx
  00040	75 0b		 jne	 SHORT $LN4@syncsearch

; 1366 :             got++;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _got$[ebp]
  00045	83 c0 01	 add	 eax, 1
  00048	89 45 f8	 mov	 DWORD PTR _got$[ebp], eax
  0004b	eb 21		 jmp	 SHORT $LN3@syncsearch
$LN4@syncsearch:

; 1367 :         else if (buf[next])

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00050	03 4d fc	 add	 ecx, DWORD PTR _next$[ebp]
  00053	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00056	85 d2		 test	 edx, edx
  00058	74 09		 je	 SHORT $LN2@syncsearch

; 1368 :             got = 0;

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0

; 1369 :         else

  00061	eb 0b		 jmp	 SHORT $LN3@syncsearch
$LN2@syncsearch:

; 1370 :             got = 4 - got;

  00063	b8 04 00 00 00	 mov	 eax, 4
  00068	2b 45 f8	 sub	 eax, DWORD PTR _got$[ebp]
  0006b	89 45 f8	 mov	 DWORD PTR _got$[ebp], eax
$LN3@syncsearch:

; 1371 :         next++;

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00071	83 c1 01	 add	 ecx, 1
  00074	89 4d fc	 mov	 DWORD PTR _next$[ebp], ecx

; 1372 :     }

  00077	eb 9c		 jmp	 SHORT $LN6@syncsearch
$LN5@syncsearch:

; 1373 :     *have = got;

  00079	8b 55 08	 mov	 edx, DWORD PTR _have$[ebp]
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _got$[ebp]
  0007f	89 02		 mov	 DWORD PTR [edx], eax

; 1374 :     return next;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]

; 1375 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
PUBLIC	_inflateGetHeader@8
; Function compile flags: /Odtp
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN2@inflateGet
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 07		 jne	 SHORT $LN3@inflateGet
$LN2@inflateGet:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	eb 30		 jmp	 SHORT $LN4@inflateGet
$LN3@inflateGet:

; 1334 :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00020	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1335 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00026	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00029	83 e1 02	 and	 ecx, 2
  0002c	75 07		 jne	 SHORT $LN1@inflateGet
  0002e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00033	eb 15		 jmp	 SHORT $LN4@inflateGet
$LN1@inflateGet:

; 1336 : 
; 1337 :     /* save header structure */
; 1338 :     state->head = head;

  00035	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00038	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0003b	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 1339 :     head->done = 0;

  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  00041	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 1340 :     return Z_OK;

  00048	33 c0		 xor	 eax, eax
$LN4@inflateGet:

; 1341 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateGetDictionary@12
; Function compile flags: /Odtp
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1272 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1273 :     struct inflate_state FAR *state;
; 1274 : 
; 1275 :     /* check state */
; 1276 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN3@inflateGet@2
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 07		 jne	 SHORT $LN4@inflateGet@2
$LN3@inflateGet@2:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	eb 77		 jmp	 SHORT $LN5@inflateGet@2
$LN4@inflateGet@2:

; 1277 :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00020	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1278 : 
; 1279 :     /* copy dictionary */
; 1280 :     if (state->whave && dictionary != Z_NULL) {

  00023	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00026	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0002a	74 52		 je	 SHORT $LN2@inflateGet@2
  0002c	83 7d 0c 00	 cmp	 DWORD PTR _dictionary$[ebp], 0
  00030	74 4c		 je	 SHORT $LN2@inflateGet@2

; 1281 :         zmemcpy(dictionary, state->window + state->wnext,
; 1282 :                 state->whave - state->wnext);

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00038	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0003b	2b 42 30	 sub	 eax, DWORD PTR [edx+48]
  0003e	50		 push	 eax
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00042	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00045	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00048	03 50 30	 add	 edx, DWORD PTR [eax+48]
  0004b	52		 push	 edx
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _memcpy
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1283 :         zmemcpy(dictionary + state->whave - state->wnext,
; 1284 :                 state->window, state->wnext);

  00058	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005b	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0005e	50		 push	 eax
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00062	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00065	52		 push	 edx
  00066	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  0006c	03 48 2c	 add	 ecx, DWORD PTR [eax+44]
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00072	2b 4a 30	 sub	 ecx, DWORD PTR [edx+48]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _memcpy
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@inflateGet@2:

; 1285 :     }
; 1286 :     if (dictLength != Z_NULL)

  0007e	83 7d 10 00	 cmp	 DWORD PTR _dictLength$[ebp], 0
  00082	74 0b		 je	 SHORT $LN1@inflateGet@2

; 1287 :         *dictLength = state->whave;

  00084	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0008a	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0008d	89 10		 mov	 DWORD PTR [eax], edx
$LN1@inflateGet@2:

; 1288 :     return Z_OK;

  0008f	33 c0		 xor	 eax, eax
$LN5@inflateGet@2:

; 1289 : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_inflateEnd@4
; Function compile flags: /Odtp
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1257 :     struct inflate_state FAR *state;
; 1258 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 12		 je	 SHORT $LN2@inflateEnd
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	74 09		 je	 SHORT $LN2@inflateEnd
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00016	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0001a	75 07		 jne	 SHORT $LN3@inflateEnd
$LN2@inflateEnd:

; 1259 :         return Z_STREAM_ERROR;

  0001c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00021	eb 50		 jmp	 SHORT $LN4@inflateEnd
$LN3@inflateEnd:

; 1260 :     state = (struct inflate_state FAR *)strm->state;

  00023	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00026	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00029	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 1261 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00033	74 19		 je	 SHORT $LN1@inflateEnd
  00035	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00038	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00042	52		 push	 edx
  00043	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00046	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00049	ff d1		 call	 ecx
  0004b	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1262 :     ZFREE(strm, strm->state);

  0004e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00051	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00058	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0005b	52		 push	 edx
  0005c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00062	ff d1		 call	 ecx
  00064	83 c4 08	 add	 esp, 8

; 1263 :     strm->state = Z_NULL;

  00067	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0006a	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1264 :     Tracev((stderr, "inflate: end\n"));
; 1265 :     return Z_OK;

  00071	33 c0		 xor	 eax, eax
$LN4@inflateEnd:

; 1266 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _updatewindow
_TEXT	SEGMENT
_state$ = -8						; size = 4
_dist$ = -4						; size = 4
_strm$ = 8						; size = 4
_end$ = 12						; size = 4
_copy$ = 16						; size = 4
_updatewindow PROC					; COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 384  :     struct inflate_state FAR *state;
; 385  :     unsigned dist;
; 386  : 
; 387  :     state = (struct inflate_state FAR *)strm->state;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000c	89 4d f8	 mov	 DWORD PTR _state$[ebp], ecx

; 388  : 
; 389  :     /* if it hasn't been done already, allocate space for the window */
; 390  :     if (state->window == Z_NULL) {

  0000f	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00012	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00016	75 3b		 jne	 SHORT $LN10@updatewind

; 391  :         state->window = (unsigned char FAR *)
; 392  :                         ZALLOC(strm, 1U << state->wbits,
; 393  :                                sizeof(unsigned char));

  00018	6a 01		 push	 1
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0001d	ba 01 00 00 00	 mov	 edx, 1
  00022	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00025	d3 e2		 shl	 edx, cl
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00032	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00035	ff d0		 call	 eax
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0003d	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 394  :         if (state->window == Z_NULL) return 1;

  00040	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00043	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00047	75 0a		 jne	 SHORT $LN10@updatewind
  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	e9 35 01 00 00	 jmp	 $LN11@updatewind
$LN10@updatewind:

; 395  :     }
; 396  : 
; 397  :     /* if window not in use yet, initialize */
; 398  :     if (state->wsize == 0) {

  00053	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00056	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  0005a	75 27		 jne	 SHORT $LN8@updatewind

; 399  :         state->wsize = 1U << state->wbits;

  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00067	d3 e2		 shl	 edx, cl
  00069	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0006c	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 400  :         state->wnext = 0;

  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00072	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 401  :         state->whave = 0;

  00079	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0007c	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0
$LN8@updatewind:

; 402  :     }
; 403  : 
; 404  :     /* copy state->wsize or less output bytes into the circular window */
; 405  :     if (copy >= state->wsize) {

  00083	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00086	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  00089	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  0008c	72 3b		 jb	 SHORT $LN7@updatewind

; 406  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  0008e	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00091	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00094	50		 push	 eax
  00095	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00098	8b 55 0c	 mov	 edx, DWORD PTR _end$[ebp]
  0009b	2b 51 28	 sub	 edx, DWORD PTR [ecx+40]
  0009e	52		 push	 edx
  0009f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 _memcpy
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 407  :         state->wnext = 0;

  000ae	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000b1	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 408  :         state->whave = state->wsize;

  000b8	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000be	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000c1	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 409  :     }
; 410  :     else {

  000c4	e9 bd 00 00 00	 jmp	 $LN6@updatewind
$LN7@updatewind:

; 411  :         dist = state->wsize - state->wnext;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000cf	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  000d2	2b 51 30	 sub	 edx, DWORD PTR [ecx+48]
  000d5	89 55 fc	 mov	 DWORD PTR _dist$[ebp], edx

; 412  :         if (dist > copy) dist = copy;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _dist$[ebp]
  000db	3b 45 10	 cmp	 eax, DWORD PTR _copy$[ebp]
  000de	76 06		 jbe	 SHORT $LN5@updatewind
  000e0	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  000e3	89 4d fc	 mov	 DWORD PTR _dist$[ebp], ecx
$LN5@updatewind:

; 413  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  000e6	8b 55 fc	 mov	 edx, DWORD PTR _dist$[ebp]
  000e9	52		 push	 edx
  000ea	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  000ed	2b 45 10	 sub	 eax, DWORD PTR _copy$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000f4	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000f7	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000fa	03 50 30	 add	 edx, DWORD PTR [eax+48]
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 _memcpy
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH

; 414  :         copy -= dist;

  00106	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  00109	2b 4d fc	 sub	 ecx, DWORD PTR _dist$[ebp]
  0010c	89 4d 10	 mov	 DWORD PTR _copy$[ebp], ecx

; 415  :         if (copy) {

  0010f	74 31		 je	 SHORT $LN4@updatewind

; 416  :             zmemcpy(state->window, end - copy, copy);

  00111	8b 55 10	 mov	 edx, DWORD PTR _copy$[ebp]
  00114	52		 push	 edx
  00115	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  00118	2b 45 10	 sub	 eax, DWORD PTR _copy$[ebp]
  0011b	50		 push	 eax
  0011c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0011f	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 _memcpy
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH

; 417  :             state->wnext = copy;

  0012b	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0012e	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  00131	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 418  :             state->whave = state->wsize;

  00134	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00137	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0013a	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0013d	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 419  :         }
; 420  :         else {

  00140	eb 44		 jmp	 SHORT $LN6@updatewind
$LN4@updatewind:

; 421  :             state->wnext += dist;

  00142	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00145	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00148	03 45 fc	 add	 eax, DWORD PTR _dist$[ebp]
  0014b	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0014e	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 422  :             if (state->wnext == state->wsize) state->wnext = 0;

  00151	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00154	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00157	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  0015a	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  0015d	75 0a		 jne	 SHORT $LN2@updatewind
  0015f	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00162	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
$LN2@updatewind:

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  00169	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0016c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0016f	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00172	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  00175	73 0f		 jae	 SHORT $LN6@updatewind
  00177	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0017a	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0017d	03 4d fc	 add	 ecx, DWORD PTR _dist$[ebp]
  00180	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00183	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
$LN6@updatewind:

; 424  :         }
; 425  :     }
; 426  :     return 0;

  00186	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 427  : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
_updatewindow ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 264  : #ifdef BUILDFIXED
; 265  :     static int virgin = 1;
; 266  :     static code *lenfix, *distfix;
; 267  :     static code fixed[544];
; 268  : 
; 269  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 270  :     if (virgin) {
; 271  :         unsigned sym, bits;
; 272  :         static code *next;
; 273  : 
; 274  :         /* literal/length table */
; 275  :         sym = 0;
; 276  :         while (sym < 144) state->lens[sym++] = 8;
; 277  :         while (sym < 256) state->lens[sym++] = 9;
; 278  :         while (sym < 280) state->lens[sym++] = 7;
; 279  :         while (sym < 288) state->lens[sym++] = 8;
; 280  :         next = fixed;
; 281  :         lenfix = next;
; 282  :         bits = 9;
; 283  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 284  : 
; 285  :         /* distance table */
; 286  :         sym = 0;
; 287  :         while (sym < 32) state->lens[sym++] = 5;
; 288  :         distfix = next;
; 289  :         bits = 5;
; 290  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 291  : 
; 292  :         /* do this just once */
; 293  :         virgin = 0;
; 294  :     }
; 295  : #else /* !BUILDFIXED */
; 296  : #   include "inffixed.h"
; 297  : #endif /* BUILDFIXED */
; 298  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 299  :     state->lenbits = 9;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 300  :     state->distcode = distfix;

  00017	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001a	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 301  :     state->distbits = 5;

  00021	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00024	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 302  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflatePrime@12
; Function compile flags: /Odtp
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN4@inflatePri
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 07		 jne	 SHORT $LN5@inflatePri
$LN4@inflatePri:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	eb 7d		 jmp	 SHORT $LN6@inflatePri
$LN5@inflatePri:

; 238  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00020	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 239  :     if (bits < 0) {

  00023	83 7d 0c 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00027	7d 18		 jge	 SHORT $LN3@inflatePri

; 240  :         state->hold = 0;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0002c	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 241  :         state->bits = 0;

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00036	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 242  :         return Z_OK;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 56		 jmp	 SHORT $LN6@inflatePri
$LN3@inflatePri:

; 243  :     }
; 244  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  00041	83 7d 0c 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00045	7f 0e		 jg	 SHORT $LN1@inflatePri
  00047	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0004d	03 45 0c	 add	 eax, DWORD PTR _bits$[ebp]
  00050	83 f8 20	 cmp	 eax, 32			; 00000020H
  00053	76 07		 jbe	 SHORT $LN2@inflatePri
$LN1@inflatePri:
  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005a	eb 3b		 jmp	 SHORT $LN6@inflatePri
$LN2@inflatePri:

; 245  :     value &= (1L << bits) - 1;

  0005c	ba 01 00 00 00	 mov	 edx, 1
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00064	d3 e2		 shl	 edx, cl
  00066	83 ea 01	 sub	 edx, 1
  00069	23 55 10	 and	 edx, DWORD PTR _value$[ebp]
  0006c	89 55 10	 mov	 DWORD PTR _value$[ebp], edx

; 246  :     state->hold += value << state->bits;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00072	8b 55 10	 mov	 edx, DWORD PTR _value$[ebp]
  00075	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00078	d3 e2		 shl	 edx, cl
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0007d	03 50 38	 add	 edx, DWORD PTR [eax+56]
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00083	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 247  :     state->bits += bits;

  00086	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00089	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0008c	03 45 0c	 add	 eax, DWORD PTR _bits$[ebp]
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00092	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 248  :     return Z_OK;

  00095	33 c0		 xor	 eax, eax
$LN6@inflatePri:

; 249  : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
PUBLIC	_inflateResetKeep@4
; Function compile flags: /Odtp
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN2@inflateRes
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 0a		 jne	 SHORT $LN3@inflateRes
$LN2@inflateRes:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	e9 d0 00 00 00	 jmp	 $LN4@inflateRes
$LN3@inflateRes:

; 110  :     state = (struct inflate_state FAR *)strm->state;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00020	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00023	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 111  :     strm->total_in = strm->total_out = state->total = 0;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00029	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00033	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0003a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 112  :     strm->msg = Z_NULL;

  00044	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00047	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 113  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00051	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00055	74 0f		 je	 SHORT $LN1@inflateRes

; 114  :         strm->adler = state->wrap & 1;

  00057	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005d	83 e0 01	 and	 eax, 1
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00063	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN1@inflateRes:

; 115  :     state->mode = HEAD;

  00066	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00069	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 116  :     state->last = 0;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00072	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 117  :     state->havedict = 0;

  00079	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 118  :     state->dmax = 32768U;

  00083	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00086	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [edx+20], 32768 ; 00008000H

; 119  :     state->head = Z_NULL;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00090	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 120  :     state->hold = 0;

  00097	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0009a	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 121  :     state->bits = 0;

  000a1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000a4	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 122  :     state->lencode = state->distcode = state->next = state->codes;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000ae	05 30 05 00 00	 add	 eax, 1328		; 00000530H
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000b6	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  000b9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000bc	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000bf	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  000c2	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
  000c5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000c8	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000cb	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000ce	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 123  :     state->sane = 1;

  000d1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000d4	c7 82 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+7104], 1

; 124  :     state->back = -1;

  000de	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000e1	c7 80 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7108], -1

; 125  :     Tracev((stderr, "inflate: reset\n"));
; 126  :     return Z_OK;

  000eb	33 c0		 xor	 eax, eax
$LN4@inflateRes:

; 127  : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
PUBLIC	_inflateSetDictionary@12
; Function compile flags: /Odtp
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_state$ = -12						; size = 4
_ret$ = -8						; size = 4
_dictid$ = -4						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN5@inflateSet
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN6@inflateSet
$LN5@inflateSet:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 99 00 00 00	 jmp	 $LN7@inflateSet
$LN6@inflateSet:

; 1302 :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 f4	 mov	 DWORD PTR _state$[ebp], edx

; 1303 :     if (state->wrap != 0 && state->mode != DICT)

  00028	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002f	74 0f		 je	 SHORT $LN4@inflateSet
  00031	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00034	83 39 0a	 cmp	 DWORD PTR [ecx], 10	; 0000000aH
  00037	74 07		 je	 SHORT $LN4@inflateSet

; 1304 :         return Z_STREAM_ERROR;

  00039	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003e	eb 78		 jmp	 SHORT $LN7@inflateSet
$LN4@inflateSet:

; 1305 : 
; 1306 :     /* check for correct dictionary identifier */
; 1307 :     if (state->mode == DICT) {

  00040	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00043	83 3a 0a	 cmp	 DWORD PTR [edx], 10	; 0000000aH
  00046	75 34		 jne	 SHORT $LN3@inflateSet

; 1308 :         dictid = adler32(0L, Z_NULL, 0);

  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	e8 00 00 00 00	 call	 _adler32@12
  00053	89 45 fc	 mov	 DWORD PTR _dictid$[ebp], eax

; 1309 :         dictid = adler32(dictid, dictionary, dictLength);

  00056	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _dictid$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 _adler32@12
  00067	89 45 fc	 mov	 DWORD PTR _dictid$[ebp], eax

; 1310 :         if (dictid != state->check)

  0006a	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _dictid$[ebp]
  00070	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00073	74 07		 je	 SHORT $LN3@inflateSet

; 1311 :             return Z_DATA_ERROR;

  00075	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0007a	eb 3c		 jmp	 SHORT $LN7@inflateSet
$LN3@inflateSet:

; 1312 :     }
; 1313 : 
; 1314 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1315 :        existing dictionary if appropriate */
; 1316 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0007c	8b 55 10	 mov	 edx, DWORD PTR _dictLength$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 0c	 mov	 eax, DWORD PTR _dictionary$[ebp]
  00083	03 45 10	 add	 eax, DWORD PTR _dictLength$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 _updatewindow
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 1317 :     if (ret) {

  00096	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0009a	74 10		 je	 SHORT $LN1@inflateSet

; 1318 :         state->mode = MEM;

  0009c	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0009f	c7 02 1e 00 00
	00		 mov	 DWORD PTR [edx], 30	; 0000001eH

; 1319 :         return Z_MEM_ERROR;

  000a5	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000aa	eb 0c		 jmp	 SHORT $LN7@inflateSet
$LN1@inflateSet:

; 1320 :     }
; 1321 :     state->havedict = 1;

  000ac	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000af	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 1322 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1323 :     return Z_OK;

  000b6	33 c0		 xor	 eax, eax
$LN7@inflateSet:

; 1324 : }

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_inflate@8
; Function compile flags: /Odtp
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv1329 = -92						; size = 4
tv1317 = -88						; size = 4
tv1238 = -84						; size = 4
tv1224 = -80						; size = 4
tv556 = -76						; size = 4
tv351 = -72						; size = 4
tv80 = -68						; size = 4
_state$ = -64						; size = 4
_out$ = -60						; size = 4
_from$ = -56						; size = 4
_copy$ = -52						; size = 4
_hbuf$ = -48						; size = 4
_hold$ = -44						; size = 4
_ret$ = -40						; size = 4
_next$ = -36						; size = 4
_left$ = -32						; size = 4
_bits$ = -28						; size = 4
_len$ = -24						; size = 4
_in$ = -20						; size = 4
_have$ = -16						; size = 4
_here$ = -12						; size = 4
_last$ = -8						; size = 4
_put$ = -4						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 609  :     struct inflate_state FAR *state;
; 610  :     z_const unsigned char FAR *next;    /* next input */
; 611  :     unsigned char FAR *put;     /* next output */
; 612  :     unsigned have, left;        /* available input and output */
; 613  :     unsigned long hold;         /* bit buffer */
; 614  :     unsigned bits;              /* bits in bit buffer */
; 615  :     unsigned in, out;           /* save starting available input and output */
; 616  :     unsigned copy;              /* number of stored or match bytes to copy */
; 617  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 618  :     code here;                  /* current decoding table entry */
; 619  :     code last;                  /* parent table entry */
; 620  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 621  :     int ret;                    /* return code */
; 622  : #ifdef GUNZIP
; 623  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 624  : #endif
; 625  :     static const unsigned short order[19] = /* permutation of code lengths */
; 626  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 627  : 
; 628  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 629  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 23		 je	 SHORT $LN498@inflate
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	74 1a		 je	 SHORT $LN498@inflate
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00018	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0001c	74 11		 je	 SHORT $LN498@inflate
  0001e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00021	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00024	75 13		 jne	 SHORT $LN499@inflate
  00026	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00029	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002d	74 0a		 je	 SHORT $LN499@inflate
$LN498@inflate:

; 630  :         return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	e9 5c 1f 00 00	 jmp	 $LN500@inflate
$LN499@inflate:

; 631  : 
; 632  :     state = (struct inflate_state FAR *)strm->state;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0003f	89 55 c0	 mov	 DWORD PTR _state$[ebp], edx

; 633  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00042	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00045	83 38 0b	 cmp	 DWORD PTR [eax], 11	; 0000000bH
  00048	75 09		 jne	 SHORT $LN496@inflate
  0004a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0004d	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
$LN496@inflate:

; 634  :     LOAD();

  00053	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00056	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00059	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00062	89 55 e0	 mov	 DWORD PTR _left$[ebp], edx
  00065	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  0006d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00070	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00073	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00076	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00079	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0007c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0007f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00082	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00085	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00088	33 d2		 xor	 edx, edx
  0008a	75 c7		 jne	 SHORT $LN496@inflate

; 635  :     in = have;

  0008c	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  0008f	89 45 ec	 mov	 DWORD PTR _in$[ebp], eax

; 636  :     out = left;

  00092	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00095	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 637  :     ret = Z_OK;

  00098	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN493@inflate:

; 638  :     for (;;)
; 639  :         switch (state->mode) {

  0009f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  000a2	8b 02		 mov	 eax, DWORD PTR [edx]
  000a4	89 45 bc	 mov	 DWORD PTR tv80[ebp], eax
  000a7	83 7d bc 1e	 cmp	 DWORD PTR tv80[ebp], 30	; 0000001eH
  000ab	0f 87 1d 1d 00
	00		 ja	 $LN12@inflate
  000b1	8b 4d bc	 mov	 ecx, DWORD PTR tv80[ebp]
  000b4	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN512@inflate[ecx*4]
$LN489@inflate:

; 640  :         case HEAD:
; 641  :             if (state->wrap == 0) {

  000bb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  000be	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000c2	75 0e		 jne	 SHORT $LN484@inflate

; 642  :                 state->mode = TYPEDO;

  000c4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  000c7	c7 00 0c 00 00
	00		 mov	 DWORD PTR [eax], 12	; 0000000cH

; 643  :                 break;

  000cd	e9 06 1d 00 00	 jmp	 $LN490@inflate
$LN484@inflate:

; 644  :             }
; 645  :             NEEDBITS(16);

  000d2	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  000d6	73 3d		 jae	 SHORT $LN486@inflate
$LN482@inflate:
  000d8	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  000dc	75 05		 jne	 SHORT $LN479@inflate
  000de	e9 fa 1c 00 00	 jmp	 $inf_leave$77745
$LN479@inflate:
  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  000e6	83 e9 01	 sub	 ecx, 1
  000e9	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  000ec	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  000ef	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000f2	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  000f5	d3 e0		 shl	 eax, cl
  000f7	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  000fa	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  000fd	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00100	83 c1 01	 add	 ecx, 1
  00103	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00106	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00109	83 c2 08	 add	 edx, 8
  0010c	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0010f	33 c0		 xor	 eax, eax
  00111	75 c5		 jne	 SHORT $LN482@inflate
  00113	eb bd		 jmp	 SHORT $LN484@inflate
$LN486@inflate:
  00115	33 c9		 xor	 ecx, ecx
  00117	75 b9		 jne	 SHORT $LN484@inflate

; 646  : #ifdef GUNZIP
; 647  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00119	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0011c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011f	83 e0 02	 and	 eax, 2
  00122	74 65		 je	 SHORT $LN478@inflate
  00124	81 7d d4 1f 8b
	00 00		 cmp	 DWORD PTR _hold$[ebp], 35615 ; 00008b1fH
  0012b	75 5c		 jne	 SHORT $LN478@inflate

; 648  :                 state->check = crc32(0L, Z_NULL, 0);

  0012d	6a 00		 push	 0
  0012f	6a 00		 push	 0
  00131	6a 00		 push	 0
  00133	e8 00 00 00 00	 call	 _crc32@12
  00138	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0013b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN477@inflate:

; 649  :                 CRC2(state->check, hold);

  0013e	8a 55 d4	 mov	 dl, BYTE PTR _hold$[ebp]
  00141	88 55 d0	 mov	 BYTE PTR _hbuf$[ebp], dl
  00144	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00147	c1 e8 08	 shr	 eax, 8
  0014a	88 45 d1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  0014d	6a 02		 push	 2
  0014f	8d 4d d0	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00152	51		 push	 ecx
  00153	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00156	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _crc32@12
  0015f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00162	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00165	33 d2		 xor	 edx, edx
  00167	75 d5		 jne	 SHORT $LN477@inflate
$LN474@inflate:

; 650  :                 INITBITS();

  00169	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00170	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00177	33 c0		 xor	 eax, eax
  00179	75 ee		 jne	 SHORT $LN474@inflate

; 651  :                 state->mode = FLAGS;

  0017b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0017e	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 652  :                 break;

  00184	e9 4f 1c 00 00	 jmp	 $LN490@inflate
$LN478@inflate:

; 653  :             }
; 654  :             state->flags = 0;           /* expect zlib header */

  00189	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0018c	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 655  :             if (state->head != Z_NULL)

  00193	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00196	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0019a	74 0d		 je	 SHORT $LN471@inflate

; 656  :                 state->head->done = -1;

  0019c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0019f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001a2	c7 42 30 ff ff
	ff ff		 mov	 DWORD PTR [edx+48], -1
$LN471@inflate:

; 657  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 658  : #else
; 659  :             if (
; 660  : #endif
; 661  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  001a9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  001ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001af	83 e1 01	 and	 ecx, 1
  001b2	74 20		 je	 SHORT $LN469@inflate
  001b4	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  001b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001bc	c1 e0 08	 shl	 eax, 8
  001bf	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  001c2	c1 ea 08	 shr	 edx, 8
  001c5	03 c2		 add	 eax, edx
  001c7	33 d2		 xor	 edx, edx
  001c9	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  001ce	f7 f1		 div	 ecx
  001d0	85 d2		 test	 edx, edx
  001d2	74 18		 je	 SHORT $LN470@inflate
$LN469@inflate:

; 662  :                 strm->msg = (char *)"incorrect header check";

  001d4	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001d7	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 663  :                 state->mode = BAD;

  001de	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  001e1	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 664  :                 break;

  001e7	e9 ec 1b 00 00	 jmp	 $LN490@inflate
$LN470@inflate:

; 665  :             }
; 666  :             if (BITS(4) != Z_DEFLATED) {

  001ec	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  001ef	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001f2	83 f9 08	 cmp	 ecx, 8
  001f5	74 18		 je	 SHORT $LN467@inflate

; 667  :                 strm->msg = (char *)"unknown compression method";

  001f7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001fa	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 668  :                 state->mode = BAD;

  00201	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00204	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 669  :                 break;

  0020a	e9 c9 1b 00 00	 jmp	 $LN490@inflate
$LN467@inflate:

; 670  :             }
; 671  :             DROPBITS(4);

  0020f	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00212	c1 e9 04	 shr	 ecx, 4
  00215	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00218	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  0021b	83 ea 04	 sub	 edx, 4
  0021e	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00221	33 c0		 xor	 eax, eax
  00223	75 ea		 jne	 SHORT $LN467@inflate

; 672  :             len = BITS(4) + 8;

  00225	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00228	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0022b	83 c1 08	 add	 ecx, 8
  0022e	89 4d e8	 mov	 DWORD PTR _len$[ebp], ecx

; 673  :             if (state->wbits == 0)

  00231	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00234	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00238	75 0b		 jne	 SHORT $LN464@inflate

; 674  :                 state->wbits = len;

  0023a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0023d	8b 4d e8	 mov	 ecx, DWORD PTR _len$[ebp]
  00240	89 48 24	 mov	 DWORD PTR [eax+36], ecx
  00243	eb 23		 jmp	 SHORT $LN463@inflate
$LN464@inflate:

; 675  :             else if (len > state->wbits) {

  00245	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00248	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  0024b	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  0024e	76 18		 jbe	 SHORT $LN463@inflate

; 676  :                 strm->msg = (char *)"invalid window size";

  00250	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00253	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 677  :                 state->mode = BAD;

  0025a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0025d	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 678  :                 break;

  00263	e9 70 1b 00 00	 jmp	 $LN490@inflate
$LN463@inflate:

; 679  :             }
; 680  :             state->dmax = 1U << len;

  00268	b8 01 00 00 00	 mov	 eax, 1
  0026d	8b 4d e8	 mov	 ecx, DWORD PTR _len$[ebp]
  00270	d3 e0		 shl	 eax, cl
  00272	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00275	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 681  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 682  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00278	6a 00		 push	 0
  0027a	6a 00		 push	 0
  0027c	6a 00		 push	 0
  0027e	e8 00 00 00 00	 call	 _adler32@12
  00283	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00286	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00289	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0028c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0028f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00292	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 683  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00295	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00298	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0029d	f7 d8		 neg	 eax
  0029f	1b c0		 sbb	 eax, eax
  002a1	83 e0 fe	 and	 eax, -2			; fffffffeH
  002a4	83 c0 0b	 add	 eax, 11			; 0000000bH
  002a7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  002aa	89 01		 mov	 DWORD PTR [ecx], eax
$LN461@inflate:

; 684  :             INITBITS();

  002ac	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  002b3	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  002ba	33 d2		 xor	 edx, edx
  002bc	75 ee		 jne	 SHORT $LN461@inflate

; 685  :             break;

  002be	e9 15 1b 00 00	 jmp	 $LN490@inflate
$LN454@inflate:

; 686  : #ifdef GUNZIP
; 687  :         case FLAGS:
; 688  :             NEEDBITS(16);

  002c3	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  002c7	73 3d		 jae	 SHORT $LN456@inflate
$LN452@inflate:
  002c9	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  002cd	75 05		 jne	 SHORT $LN449@inflate
  002cf	e9 09 1b 00 00	 jmp	 $inf_leave$77745
$LN449@inflate:
  002d4	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  002d7	83 e8 01	 sub	 eax, 1
  002da	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  002dd	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  002e0	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  002e3	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  002e6	d3 e2		 shl	 edx, cl
  002e8	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  002eb	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  002ee	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  002f1	83 c0 01	 add	 eax, 1
  002f4	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  002f7	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  002fa	83 c1 08	 add	 ecx, 8
  002fd	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00300	33 d2		 xor	 edx, edx
  00302	75 c5		 jne	 SHORT $LN452@inflate
  00304	eb bd		 jmp	 SHORT $LN454@inflate
$LN456@inflate:
  00306	33 c0		 xor	 eax, eax
  00308	75 b9		 jne	 SHORT $LN454@inflate

; 689  :             state->flags = (int)(hold);

  0030a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0030d	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00310	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 690  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00313	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00316	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00319	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0031f	83 f9 08	 cmp	 ecx, 8
  00322	74 18		 je	 SHORT $LN448@inflate

; 691  :                 strm->msg = (char *)"unknown compression method";

  00324	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00327	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 692  :                 state->mode = BAD;

  0032e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00331	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 693  :                 break;

  00337	e9 9c 1a 00 00	 jmp	 $LN490@inflate
$LN448@inflate:

; 694  :             }
; 695  :             if (state->flags & 0xe000) {

  0033c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0033f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00342	81 e2 00 e0 00
	00		 and	 edx, 57344		; 0000e000H
  00348	74 18		 je	 SHORT $LN447@inflate

; 696  :                 strm->msg = (char *)"unknown header flags set";

  0034a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0034d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 697  :                 state->mode = BAD;

  00354	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00357	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 698  :                 break;

  0035d	e9 76 1a 00 00	 jmp	 $LN490@inflate
$LN447@inflate:

; 699  :             }
; 700  :             if (state->head != Z_NULL)

  00362	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00365	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00369	74 11		 je	 SHORT $LN446@inflate

; 701  :                 state->head->text = (int)((hold >> 8) & 1);

  0036b	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0036e	c1 e8 08	 shr	 eax, 8
  00371	83 e0 01	 and	 eax, 1
  00374	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00377	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0037a	89 02		 mov	 DWORD PTR [edx], eax
$LN446@inflate:

; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  0037c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0037f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00382	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00388	74 2b		 je	 SHORT $LN441@inflate
$LN444@inflate:
  0038a	8a 55 d4	 mov	 dl, BYTE PTR _hold$[ebp]
  0038d	88 55 d0	 mov	 BYTE PTR _hbuf$[ebp], dl
  00390	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00393	c1 e8 08	 shr	 eax, 8
  00396	88 45 d1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00399	6a 02		 push	 2
  0039b	8d 4d d0	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  0039e	51		 push	 ecx
  0039f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  003a2	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  003a5	50		 push	 eax
  003a6	e8 00 00 00 00	 call	 _crc32@12
  003ab	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  003ae	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  003b1	33 d2		 xor	 edx, edx
  003b3	75 d5		 jne	 SHORT $LN444@inflate
$LN441@inflate:

; 703  :             INITBITS();

  003b5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  003bc	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  003c3	33 c0		 xor	 eax, eax
  003c5	75 ee		 jne	 SHORT $LN441@inflate

; 704  :             state->mode = TIME;

  003c7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  003ca	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
$LN434@inflate:

; 705  :         case TIME:
; 706  :             NEEDBITS(32);

  003d0	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  003d4	73 3d		 jae	 SHORT $LN436@inflate
$LN432@inflate:
  003d6	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  003da	75 05		 jne	 SHORT $LN429@inflate
  003dc	e9 fc 19 00 00	 jmp	 $inf_leave$77745
$LN429@inflate:
  003e1	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  003e4	83 ea 01	 sub	 edx, 1
  003e7	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  003ea	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  003ed	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  003f0	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  003f3	d3 e2		 shl	 edx, cl
  003f5	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  003f8	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  003fb	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  003fe	83 c0 01	 add	 eax, 1
  00401	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00404	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00407	83 c1 08	 add	 ecx, 8
  0040a	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0040d	33 d2		 xor	 edx, edx
  0040f	75 c5		 jne	 SHORT $LN432@inflate
  00411	eb bd		 jmp	 SHORT $LN434@inflate
$LN436@inflate:
  00413	33 c0		 xor	 eax, eax
  00415	75 b9		 jne	 SHORT $LN434@inflate

; 707  :             if (state->head != Z_NULL)

  00417	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0041a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0041e	74 0c		 je	 SHORT $LN428@inflate

; 708  :                 state->head->time = hold;

  00420	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00423	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00426	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00429	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN428@inflate:

; 709  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  0042c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0042f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00432	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00437	74 3d		 je	 SHORT $LN423@inflate
$LN426@inflate:
  00439	8a 4d d4	 mov	 cl, BYTE PTR _hold$[ebp]
  0043c	88 4d d0	 mov	 BYTE PTR _hbuf$[ebp], cl
  0043f	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00442	c1 ea 08	 shr	 edx, 8
  00445	88 55 d1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00448	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0044b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0044e	88 45 d2	 mov	 BYTE PTR _hbuf$[ebp+2], al
  00451	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00454	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00457	88 4d d3	 mov	 BYTE PTR _hbuf$[ebp+3], cl
  0045a	6a 04		 push	 4
  0045c	8d 55 d0	 lea	 edx, DWORD PTR _hbuf$[ebp]
  0045f	52		 push	 edx
  00460	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00463	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00466	51		 push	 ecx
  00467	e8 00 00 00 00	 call	 _crc32@12
  0046c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0046f	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00472	33 c0		 xor	 eax, eax
  00474	75 c3		 jne	 SHORT $LN426@inflate
$LN423@inflate:

; 710  :             INITBITS();

  00476	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0047d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00484	33 c9		 xor	 ecx, ecx
  00486	75 ee		 jne	 SHORT $LN423@inflate

; 711  :             state->mode = OS;

  00488	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0048b	c7 02 03 00 00
	00		 mov	 DWORD PTR [edx], 3
$LN416@inflate:

; 712  :         case OS:
; 713  :             NEEDBITS(16);

  00491	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00495	73 3d		 jae	 SHORT $LN418@inflate
$LN414@inflate:
  00497	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0049b	75 05		 jne	 SHORT $LN411@inflate
  0049d	e9 3b 19 00 00	 jmp	 $inf_leave$77745
$LN411@inflate:
  004a2	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  004a5	83 e8 01	 sub	 eax, 1
  004a8	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  004ab	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  004ae	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  004b1	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  004b4	d3 e2		 shl	 edx, cl
  004b6	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  004b9	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  004bc	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  004bf	83 c0 01	 add	 eax, 1
  004c2	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  004c5	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  004c8	83 c1 08	 add	 ecx, 8
  004cb	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  004ce	33 d2		 xor	 edx, edx
  004d0	75 c5		 jne	 SHORT $LN414@inflate
  004d2	eb bd		 jmp	 SHORT $LN416@inflate
$LN418@inflate:
  004d4	33 c0		 xor	 eax, eax
  004d6	75 b9		 jne	 SHORT $LN416@inflate

; 714  :             if (state->head != Z_NULL) {

  004d8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  004db	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  004df	74 21		 je	 SHORT $LN410@inflate

; 715  :                 state->head->xflags = (int)(hold & 0xff);

  004e1	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  004e4	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  004ea	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  004ed	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  004f0	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 716  :                 state->head->os = (int)(hold >> 8);

  004f3	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  004f6	c1 ea 08	 shr	 edx, 8
  004f9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  004fc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  004ff	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN410@inflate:

; 717  :             }
; 718  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00502	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00505	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00508	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0050d	74 2b		 je	 SHORT $LN405@inflate
$LN408@inflate:
  0050f	8a 4d d4	 mov	 cl, BYTE PTR _hold$[ebp]
  00512	88 4d d0	 mov	 BYTE PTR _hbuf$[ebp], cl
  00515	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00518	c1 ea 08	 shr	 edx, 8
  0051b	88 55 d1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  0051e	6a 02		 push	 2
  00520	8d 45 d0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00523	50		 push	 eax
  00524	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00527	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0052a	52		 push	 edx
  0052b	e8 00 00 00 00	 call	 _crc32@12
  00530	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00533	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00536	33 d2		 xor	 edx, edx
  00538	75 d5		 jne	 SHORT $LN408@inflate
$LN405@inflate:

; 719  :             INITBITS();

  0053a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00541	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00548	33 c0		 xor	 eax, eax
  0054a	75 ee		 jne	 SHORT $LN405@inflate

; 720  :             state->mode = EXLEN;

  0054c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0054f	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
$LN402@inflate:

; 721  :         case EXLEN:
; 722  :             if (state->flags & 0x0400) {

  00555	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00558	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0055b	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00560	0f 84 b1 00 00
	00		 je	 $LN401@inflate
$LN397@inflate:

; 723  :                 NEEDBITS(16);

  00566	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  0056a	73 3d		 jae	 SHORT $LN399@inflate
$LN395@inflate:
  0056c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00570	75 05		 jne	 SHORT $LN392@inflate
  00572	e9 66 18 00 00	 jmp	 $inf_leave$77745
$LN392@inflate:
  00577	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0057a	83 e9 01	 sub	 ecx, 1
  0057d	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00580	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00583	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00586	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00589	d3 e0		 shl	 eax, cl
  0058b	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  0058e	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00591	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00594	83 c1 01	 add	 ecx, 1
  00597	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  0059a	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  0059d	83 c2 08	 add	 edx, 8
  005a0	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  005a3	33 c0		 xor	 eax, eax
  005a5	75 c5		 jne	 SHORT $LN395@inflate
  005a7	eb bd		 jmp	 SHORT $LN397@inflate
$LN399@inflate:
  005a9	33 c9		 xor	 ecx, ecx
  005ab	75 b9		 jne	 SHORT $LN397@inflate

; 724  :                 state->length = (unsigned)(hold);

  005ad	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005b0	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  005b3	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 725  :                 if (state->head != Z_NULL)

  005b6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005b9	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  005bd	74 0c		 je	 SHORT $LN391@inflate

; 726  :                     state->head->extra_len = (unsigned)hold;

  005bf	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005c2	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  005c5	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  005c8	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN391@inflate:

; 727  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  005cb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005ce	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  005d1	25 00 02 00 00	 and	 eax, 512		; 00000200H
  005d6	74 2b		 je	 SHORT $LN386@inflate
$LN389@inflate:
  005d8	8a 4d d4	 mov	 cl, BYTE PTR _hold$[ebp]
  005db	88 4d d0	 mov	 BYTE PTR _hbuf$[ebp], cl
  005de	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  005e1	c1 ea 08	 shr	 edx, 8
  005e4	88 55 d1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  005e7	6a 02		 push	 2
  005e9	8d 45 d0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  005ec	50		 push	 eax
  005ed	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005f0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  005f3	52		 push	 edx
  005f4	e8 00 00 00 00	 call	 _crc32@12
  005f9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005fc	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  005ff	33 d2		 xor	 edx, edx
  00601	75 d5		 jne	 SHORT $LN389@inflate
$LN386@inflate:

; 728  :                 INITBITS();

  00603	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0060a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00611	33 c0		 xor	 eax, eax
  00613	75 ee		 jne	 SHORT $LN386@inflate

; 729  :             }
; 730  :             else if (state->head != Z_NULL)

  00615	eb 16		 jmp	 SHORT $LN383@inflate
$LN401@inflate:
  00617	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0061a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0061e	74 0d		 je	 SHORT $LN383@inflate

; 731  :                 state->head->extra = Z_NULL;

  00620	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00623	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00626	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN383@inflate:

; 732  :             state->mode = EXTRA;

  0062d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00630	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN381@inflate:

; 733  :         case EXTRA:
; 734  :             if (state->flags & 0x0400) {

  00636	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00639	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0063c	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00641	0f 84 e4 00 00
	00		 je	 $LN380@inflate

; 735  :                 copy = state->length;

  00647	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0064a	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0064d	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 736  :                 if (copy > have) copy = have;

  00650	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  00653	3b 45 f0	 cmp	 eax, DWORD PTR _have$[ebp]
  00656	76 06		 jbe	 SHORT $LN379@inflate
  00658	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0065b	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN379@inflate:

; 737  :                 if (copy) {

  0065e	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00662	0f 84 b5 00 00
	00		 je	 $LN378@inflate

; 738  :                     if (state->head != Z_NULL &&
; 739  :                         state->head->extra != Z_NULL) {

  00668	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0066b	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0066f	74 63		 je	 SHORT $LN377@inflate
  00671	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00674	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00677	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0067b	74 57		 je	 SHORT $LN377@inflate

; 740  :                         len = state->head->extra_len - state->length;

  0067d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00680	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00683	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00686	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00689	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  0068c	89 55 e8	 mov	 DWORD PTR _len$[ebp], edx

; 741  :                         zmemcpy(state->head->extra + len, next,
; 742  :                                 len + copy > state->head->extra_max ?
; 743  :                                 state->head->extra_max - len : copy);

  0068f	8b 45 e8	 mov	 eax, DWORD PTR _len$[ebp]
  00692	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00695	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00698	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0069b	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  0069e	76 11		 jbe	 SHORT $LN502@inflate
  006a0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006a3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  006a6	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006a9	2b 55 e8	 sub	 edx, DWORD PTR _len$[ebp]
  006ac	89 55 b8	 mov	 DWORD PTR tv351[ebp], edx
  006af	eb 06		 jmp	 SHORT $LN503@inflate
$LN502@inflate:
  006b1	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  006b4	89 45 b8	 mov	 DWORD PTR tv351[ebp], eax
$LN503@inflate:
  006b7	8b 4d b8	 mov	 ecx, DWORD PTR tv351[ebp]
  006ba	51		 push	 ecx
  006bb	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  006be	52		 push	 edx
  006bf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006c2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  006c5	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  006c8	03 55 e8	 add	 edx, DWORD PTR _len$[ebp]
  006cb	52		 push	 edx
  006cc	e8 00 00 00 00	 call	 _memcpy
  006d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN377@inflate:

; 744  :                     }
; 745  :                     if (state->flags & 0x0200)

  006d4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006d7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  006da	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  006e0	74 1a		 je	 SHORT $LN376@inflate

; 746  :                         state->check = crc32(state->check, next, copy);

  006e2	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  006e5	52		 push	 edx
  006e6	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  006e9	50		 push	 eax
  006ea	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006ed	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006f0	52		 push	 edx
  006f1	e8 00 00 00 00	 call	 _crc32@12
  006f6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006f9	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN376@inflate:

; 747  :                     have -= copy;

  006fc	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  006ff	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00702	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 748  :                     next += copy;

  00705	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00708	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  0070b	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 749  :                     state->length -= copy;

  0070e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00711	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00714	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00717	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0071a	89 50 40	 mov	 DWORD PTR [eax+64], edx
$LN378@inflate:

; 750  :                 }
; 751  :                 if (state->length) goto inf_leave;

  0071d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00720	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  00724	74 05		 je	 SHORT $LN380@inflate
  00726	e9 b2 16 00 00	 jmp	 $inf_leave$77745
$LN380@inflate:

; 752  :             }
; 753  :             state->length = 0;

  0072b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0072e	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 754  :             state->mode = NAME;

  00735	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00738	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
$LN374@inflate:

; 755  :         case NAME:
; 756  :             if (state->flags & 0x0800) {

  0073e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00741	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00744	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  0074a	0f 84 c6 00 00
	00		 je	 $LN373@inflate

; 757  :                 if (have == 0) goto inf_leave;

  00750	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00754	75 05		 jne	 SHORT $LN372@inflate
  00756	e9 82 16 00 00	 jmp	 $inf_leave$77745
$LN372@inflate:

; 758  :                 copy = 0;

  0075b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN371@inflate:

; 759  :                 do {
; 760  :                     len = (unsigned)(next[copy++]);

  00762	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00765	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00768	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0076b	89 4d e8	 mov	 DWORD PTR _len$[ebp], ecx
  0076e	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  00771	83 c2 01	 add	 edx, 1
  00774	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 761  :                     if (state->head != Z_NULL &&
; 762  :                             state->head->name != Z_NULL &&
; 763  :                             state->length < state->head->name_max)

  00777	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0077a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0077e	74 41		 je	 SHORT $LN370@inflate
  00780	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00783	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00786	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0078a	74 35		 je	 SHORT $LN370@inflate
  0078c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0078f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00792	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00795	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00798	3b 41 20	 cmp	 eax, DWORD PTR [ecx+32]
  0079b	73 24		 jae	 SHORT $LN370@inflate

; 764  :                         state->head->name[state->length++] = len;

  0079d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007a0	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  007a3	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  007a6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007a9	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  007ac	8a 4d e8	 mov	 cl, BYTE PTR _len$[ebp]
  007af	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  007b2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  007b5	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  007b8	83 c0 01	 add	 eax, 1
  007bb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007be	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN370@inflate:

; 765  :                 } while (len && copy < have);

  007c1	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  007c5	74 08		 je	 SHORT $LN369@inflate
  007c7	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  007ca	3b 55 f0	 cmp	 edx, DWORD PTR _have$[ebp]
  007cd	72 93		 jb	 SHORT $LN371@inflate
$LN369@inflate:

; 766  :                 if (state->flags & 0x0200)

  007cf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  007d2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  007d5	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  007db	74 1a		 je	 SHORT $LN366@inflate

; 767  :                     state->check = crc32(state->check, next, copy);

  007dd	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  007e0	52		 push	 edx
  007e1	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  007e4	50		 push	 eax
  007e5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007e8	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  007eb	52		 push	 edx
  007ec	e8 00 00 00 00	 call	 _crc32@12
  007f1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007f4	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN366@inflate:

; 768  :                 have -= copy;

  007f7	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  007fa	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  007fd	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 769  :                 next += copy;

  00800	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00803	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00806	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 770  :                 if (len) goto inf_leave;

  00809	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0080d	74 05		 je	 SHORT $LN365@inflate
  0080f	e9 c9 15 00 00	 jmp	 $inf_leave$77745
$LN365@inflate:

; 771  :             }
; 772  :             else if (state->head != Z_NULL)

  00814	eb 16		 jmp	 SHORT $LN364@inflate
$LN373@inflate:
  00816	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00819	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0081d	74 0d		 je	 SHORT $LN364@inflate

; 773  :                 state->head->name = Z_NULL;

  0081f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00822	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00825	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN364@inflate:

; 774  :             state->length = 0;

  0082c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0082f	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 775  :             state->mode = COMMENT;

  00836	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00839	c7 02 07 00 00
	00		 mov	 DWORD PTR [edx], 7
$LN362@inflate:

; 776  :         case COMMENT:
; 777  :             if (state->flags & 0x1000) {

  0083f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00842	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00845	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  0084b	0f 84 c5 00 00
	00		 je	 $LN361@inflate

; 778  :                 if (have == 0) goto inf_leave;

  00851	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00855	75 05		 jne	 SHORT $LN360@inflate
  00857	e9 81 15 00 00	 jmp	 $inf_leave$77745
$LN360@inflate:

; 779  :                 copy = 0;

  0085c	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN359@inflate:

; 780  :                 do {
; 781  :                     len = (unsigned)(next[copy++]);

  00863	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00866	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  00869	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0086c	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax
  0086f	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  00872	83 c1 01	 add	 ecx, 1
  00875	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 782  :                     if (state->head != Z_NULL &&
; 783  :                             state->head->comment != Z_NULL &&
; 784  :                             state->length < state->head->comm_max)

  00878	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0087b	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0087f	74 41		 je	 SHORT $LN358@inflate
  00881	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00884	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00887	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0088b	74 35		 je	 SHORT $LN358@inflate
  0088d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00890	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00893	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00896	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00899	3b 50 28	 cmp	 edx, DWORD PTR [eax+40]
  0089c	73 24		 jae	 SHORT $LN358@inflate

; 785  :                         state->head->comment[state->length++] = len;

  0089e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008a1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  008a4	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  008a7	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008aa	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  008ad	8a 45 e8	 mov	 al, BYTE PTR _len$[ebp]
  008b0	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  008b3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  008b6	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  008b9	83 c2 01	 add	 edx, 1
  008bc	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008bf	89 50 40	 mov	 DWORD PTR [eax+64], edx
$LN358@inflate:

; 786  :                 } while (len && copy < have);

  008c2	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  008c6	74 08		 je	 SHORT $LN357@inflate
  008c8	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  008cb	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  008ce	72 93		 jb	 SHORT $LN359@inflate
$LN357@inflate:

; 787  :                 if (state->flags & 0x0200)

  008d0	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  008d3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  008d6	25 00 02 00 00	 and	 eax, 512		; 00000200H
  008db	74 1a		 je	 SHORT $LN354@inflate

; 788  :                     state->check = crc32(state->check, next, copy);

  008dd	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  008e0	51		 push	 ecx
  008e1	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  008e4	52		 push	 edx
  008e5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008e8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  008eb	51		 push	 ecx
  008ec	e8 00 00 00 00	 call	 _crc32@12
  008f1	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  008f4	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN354@inflate:

; 789  :                 have -= copy;

  008f7	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  008fa	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  008fd	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax

; 790  :                 next += copy;

  00900	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00903	03 4d cc	 add	 ecx, DWORD PTR _copy$[ebp]
  00906	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx

; 791  :                 if (len) goto inf_leave;

  00909	83 7d e8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0090d	74 05		 je	 SHORT $LN353@inflate
  0090f	e9 c9 14 00 00	 jmp	 $inf_leave$77745
$LN353@inflate:

; 792  :             }
; 793  :             else if (state->head != Z_NULL)

  00914	eb 16		 jmp	 SHORT $LN352@inflate
$LN361@inflate:
  00916	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00919	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0091d	74 0d		 je	 SHORT $LN352@inflate

; 794  :                 state->head->comment = Z_NULL;

  0091f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00922	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00925	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$LN352@inflate:

; 795  :             state->mode = HCRC;

  0092c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0092f	c7 02 08 00 00
	00		 mov	 DWORD PTR [edx], 8
$LN350@inflate:

; 796  :         case HCRC:
; 797  :             if (state->flags & 0x0200) {

  00935	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00938	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0093b	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00941	0f 84 82 00 00
	00		 je	 $LN349@inflate
$LN345@inflate:

; 798  :                 NEEDBITS(16);

  00947	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  0094b	73 3d		 jae	 SHORT $LN347@inflate
$LN343@inflate:
  0094d	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00951	75 05		 jne	 SHORT $LN340@inflate
  00953	e9 85 14 00 00	 jmp	 $inf_leave$77745
$LN340@inflate:
  00958	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  0095b	83 ea 01	 sub	 edx, 1
  0095e	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00961	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00964	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00967	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0096a	d3 e2		 shl	 edx, cl
  0096c	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  0096f	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00972	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00975	83 c0 01	 add	 eax, 1
  00978	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  0097b	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0097e	83 c1 08	 add	 ecx, 8
  00981	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00984	33 d2		 xor	 edx, edx
  00986	75 c5		 jne	 SHORT $LN343@inflate
  00988	eb bd		 jmp	 SHORT $LN345@inflate
$LN347@inflate:
  0098a	33 c0		 xor	 eax, eax
  0098c	75 b9		 jne	 SHORT $LN345@inflate

; 799  :                 if (hold != (state->check & 0xffff)) {

  0098e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00991	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00994	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0099a	39 55 d4	 cmp	 DWORD PTR _hold$[ebp], edx
  0099d	74 18		 je	 SHORT $LN338@inflate

; 800  :                     strm->msg = (char *)"header crc mismatch";

  0099f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  009a2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 801  :                     state->mode = BAD;

  009a9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  009ac	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 802  :                     break;

  009b2	e9 21 14 00 00	 jmp	 $LN490@inflate
$LN338@inflate:

; 803  :                 }
; 804  :                 INITBITS();

  009b7	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  009be	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  009c5	33 d2		 xor	 edx, edx
  009c7	75 ee		 jne	 SHORT $LN338@inflate
$LN349@inflate:

; 805  :             }
; 806  :             if (state->head != Z_NULL) {

  009c9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  009cc	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  009d0	74 22		 je	 SHORT $LN335@inflate

; 807  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  009d2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  009d5	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  009d8	c1 fa 09	 sar	 edx, 9
  009db	83 e2 01	 and	 edx, 1
  009de	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  009e1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  009e4	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 808  :                 state->head->done = 1;

  009e7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  009ea	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  009ed	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN335@inflate:

; 809  :             }
; 810  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  009f4	6a 00		 push	 0
  009f6	6a 00		 push	 0
  009f8	6a 00		 push	 0
  009fa	e8 00 00 00 00	 call	 _crc32@12
  009ff	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00a02	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00a05	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00a08	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00a0b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00a0e	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 811  :             state->mode = TYPE;

  00a11	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00a14	c7 02 0b 00 00
	00		 mov	 DWORD PTR [edx], 11	; 0000000bH

; 812  :             break;

  00a1a	e9 b9 13 00 00	 jmp	 $LN490@inflate
$LN330@inflate:

; 813  : #endif
; 814  :         case DICTID:
; 815  :             NEEDBITS(32);

  00a1f	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00a23	73 3d		 jae	 SHORT $LN332@inflate
$LN328@inflate:
  00a25	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00a29	75 05		 jne	 SHORT $LN325@inflate
  00a2b	e9 ad 13 00 00	 jmp	 $inf_leave$77745
$LN325@inflate:
  00a30	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00a33	83 e8 01	 sub	 eax, 1
  00a36	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00a39	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00a3c	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00a3f	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a42	d3 e2		 shl	 edx, cl
  00a44	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  00a47	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00a4a	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00a4d	83 c0 01	 add	 eax, 1
  00a50	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00a53	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a56	83 c1 08	 add	 ecx, 8
  00a59	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00a5c	33 d2		 xor	 edx, edx
  00a5e	75 c5		 jne	 SHORT $LN328@inflate
  00a60	eb bd		 jmp	 SHORT $LN330@inflate
$LN332@inflate:
  00a62	33 c0		 xor	 eax, eax
  00a64	75 b9		 jne	 SHORT $LN330@inflate

; 816  :             strm->adler = state->check = ZSWAP32(hold);

  00a66	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00a69	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00a6c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a72	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00a75	c1 ea 08	 shr	 edx, 8
  00a78	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  00a7e	03 ca		 add	 ecx, edx
  00a80	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00a83	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00a88	c1 e0 08	 shl	 eax, 8
  00a8b	03 c8		 add	 ecx, eax
  00a8d	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00a90	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00a96	c1 e2 18	 shl	 edx, 24			; 00000018H
  00a99	03 ca		 add	 ecx, edx
  00a9b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00a9e	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00aa1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00aa4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00aa7	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00aaa	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN324@inflate:

; 817  :             INITBITS();

  00aad	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00ab4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00abb	33 c9		 xor	 ecx, ecx
  00abd	75 ee		 jne	 SHORT $LN324@inflate

; 818  :             state->mode = DICT;

  00abf	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00ac2	c7 02 0a 00 00
	00		 mov	 DWORD PTR [edx], 10	; 0000000aH
$LN321@inflate:

; 819  :         case DICT:
; 820  :             if (state->havedict == 0) {

  00ac8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00acb	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00acf	75 43		 jne	 SHORT $LN320@inflate
$LN319@inflate:

; 821  :                 RESTORE();

  00ad1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00ad4	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00ad7	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00ada	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00add	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00ae0	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00ae3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00ae6	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00ae9	89 02		 mov	 DWORD PTR [edx], eax
  00aeb	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00aee	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00af1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00af4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00af7	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00afa	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  00afd	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00b00	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00b03	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  00b06	33 c9		 xor	 ecx, ecx
  00b08	75 c7		 jne	 SHORT $LN319@inflate

; 822  :                 return Z_NEED_DICT;

  00b0a	b8 02 00 00 00	 mov	 eax, 2
  00b0f	e9 81 14 00 00	 jmp	 $LN500@inflate
$LN320@inflate:

; 823  :             }
; 824  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00b14	6a 00		 push	 0
  00b16	6a 00		 push	 0
  00b18	6a 00		 push	 0
  00b1a	e8 00 00 00 00	 call	 _adler32@12
  00b1f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00b22	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00b25	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b28	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00b2b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00b2e	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 825  :             state->mode = TYPE;

  00b31	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b34	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH
$LN316@inflate:

; 826  :         case TYPE:
; 827  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00b3a	83 7d 0c 05	 cmp	 DWORD PTR _flush$[ebp], 5
  00b3e	74 06		 je	 SHORT $LN314@inflate
  00b40	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00b44	75 05		 jne	 SHORT $LN313@inflate
$LN314@inflate:
  00b46	e9 92 12 00 00	 jmp	 $inf_leave$77745
$LN313@inflate:

; 828  :         case TYPEDO:
; 829  :             if (state->last) {

  00b4b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00b4e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00b52	74 2e		 je	 SHORT $LN305@inflate
$LN311@inflate:

; 830  :                 BYTEBITS();

  00b54	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00b57	83 e1 07	 and	 ecx, 7
  00b5a	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00b5d	d3 ea		 shr	 edx, cl
  00b5f	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00b62	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00b65	83 e0 07	 and	 eax, 7
  00b68	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00b6b	2b c8		 sub	 ecx, eax
  00b6d	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00b70	33 d2		 xor	 edx, edx
  00b72	75 e0		 jne	 SHORT $LN311@inflate

; 831  :                 state->mode = CHECK;

  00b74	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b77	c7 00 1a 00 00
	00		 mov	 DWORD PTR [eax], 26	; 0000001aH

; 832  :                 break;

  00b7d	e9 56 12 00 00	 jmp	 $LN490@inflate
$LN305@inflate:

; 833  :             }
; 834  :             NEEDBITS(3);

  00b82	83 7d e4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00b86	73 3d		 jae	 SHORT $LN307@inflate
$LN303@inflate:
  00b88	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b8c	75 05		 jne	 SHORT $LN300@inflate
  00b8e	e9 4a 12 00 00	 jmp	 $inf_leave$77745
$LN300@inflate:
  00b93	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00b96	83 e9 01	 sub	 ecx, 1
  00b99	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00b9c	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00b9f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00ba2	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ba5	d3 e0		 shl	 eax, cl
  00ba7	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00baa	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00bad	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00bb0	83 c1 01	 add	 ecx, 1
  00bb3	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00bb6	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00bb9	83 c2 08	 add	 edx, 8
  00bbc	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00bbf	33 c0		 xor	 eax, eax
  00bc1	75 c5		 jne	 SHORT $LN303@inflate
  00bc3	eb bd		 jmp	 SHORT $LN305@inflate
$LN307@inflate:
  00bc5	33 c9		 xor	 ecx, ecx
  00bc7	75 b9		 jne	 SHORT $LN305@inflate

; 835  :             state->last = BITS(1);

  00bc9	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00bcc	83 e2 01	 and	 edx, 1
  00bcf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00bd2	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN299@inflate:

; 836  :             DROPBITS(1);

  00bd5	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00bd8	d1 e9		 shr	 ecx, 1
  00bda	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00bdd	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00be0	83 ea 01	 sub	 edx, 1
  00be3	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00be6	33 c0		 xor	 eax, eax
  00be8	75 eb		 jne	 SHORT $LN299@inflate

; 837  :             switch (BITS(2)) {

  00bea	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00bed	83 e1 03	 and	 ecx, 3
  00bf0	89 4d b4	 mov	 DWORD PTR tv556[ebp], ecx
  00bf3	83 7d b4 03	 cmp	 DWORD PTR tv556[ebp], 3
  00bf7	77 6b		 ja	 SHORT $LN286@inflate
  00bf9	8b 55 b4	 mov	 edx, DWORD PTR tv556[ebp]
  00bfc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN513@inflate[edx*4]
$LN294@inflate:

; 838  :             case 0:                             /* stored block */
; 839  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 840  :                         state->last ? " (last)" : ""));
; 841  :                 state->mode = STORED;

  00c03	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00c06	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 842  :                 break;

  00c0c	eb 56		 jmp	 SHORT $LN286@inflate
$LN293@inflate:

; 843  :             case 1:                             /* fixed block */
; 844  :                 fixedtables(state);

  00c0e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00c11	51		 push	 ecx
  00c12	e8 00 00 00 00	 call	 _fixedtables
  00c17	83 c4 04	 add	 esp, 4

; 845  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 846  :                         state->last ? " (last)" : ""));
; 847  :                 state->mode = LEN_;             /* decode codes */

  00c1a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00c1d	c7 02 13 00 00
	00		 mov	 DWORD PTR [edx], 19	; 00000013H

; 848  :                 if (flush == Z_TREES) {

  00c23	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00c27	75 1b		 jne	 SHORT $LN292@inflate
$LN291@inflate:

; 849  :                     DROPBITS(2);

  00c29	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00c2c	c1 e8 02	 shr	 eax, 2
  00c2f	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00c32	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c35	83 e9 02	 sub	 ecx, 2
  00c38	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00c3b	33 d2		 xor	 edx, edx
  00c3d	75 ea		 jne	 SHORT $LN291@inflate

; 850  :                     goto inf_leave;

  00c3f	e9 99 11 00 00	 jmp	 $inf_leave$77745
$LN292@inflate:

; 851  :                 }
; 852  :                 break;

  00c44	eb 1e		 jmp	 SHORT $LN286@inflate
$LN288@inflate:

; 853  :             case 2:                             /* dynamic block */
; 854  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 855  :                         state->last ? " (last)" : ""));
; 856  :                 state->mode = TABLE;

  00c46	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00c49	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 857  :                 break;

  00c4f	eb 13		 jmp	 SHORT $LN286@inflate
$LN287@inflate:

; 858  :             case 3:
; 859  :                 strm->msg = (char *)"invalid block type";

  00c51	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c54	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 860  :                 state->mode = BAD;

  00c5b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00c5e	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH
$LN286@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  00c64	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00c67	c1 e8 02	 shr	 eax, 2
  00c6a	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00c6d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c70	83 e9 02	 sub	 ecx, 2
  00c73	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00c76	33 d2		 xor	 edx, edx
  00c78	75 ea		 jne	 SHORT $LN286@inflate

; 863  :             break;

  00c7a	e9 59 11 00 00	 jmp	 $LN490@inflate
$LN282@inflate:

; 864  :         case STORED:
; 865  :             BYTEBITS();                         /* go to byte boundary */

  00c7f	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c82	83 e1 07	 and	 ecx, 7
  00c85	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00c88	d3 e8		 shr	 eax, cl
  00c8a	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00c8d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c90	83 e1 07	 and	 ecx, 7
  00c93	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00c96	2b d1		 sub	 edx, ecx
  00c98	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00c9b	33 c0		 xor	 eax, eax
  00c9d	75 e0		 jne	 SHORT $LN282@inflate
$LN276@inflate:

; 866  :             NEEDBITS(32);

  00c9f	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00ca3	73 3d		 jae	 SHORT $LN278@inflate
$LN274@inflate:
  00ca5	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ca9	75 05		 jne	 SHORT $LN271@inflate
  00cab	e9 2d 11 00 00	 jmp	 $inf_leave$77745
$LN271@inflate:
  00cb0	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00cb3	83 e9 01	 sub	 ecx, 1
  00cb6	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00cb9	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00cbc	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00cbf	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00cc2	d3 e0		 shl	 eax, cl
  00cc4	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00cc7	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00cca	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00ccd	83 c1 01	 add	 ecx, 1
  00cd0	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00cd3	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00cd6	83 c2 08	 add	 edx, 8
  00cd9	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00cdc	33 c0		 xor	 eax, eax
  00cde	75 c5		 jne	 SHORT $LN274@inflate
  00ce0	eb bd		 jmp	 SHORT $LN276@inflate
$LN278@inflate:
  00ce2	33 c9		 xor	 ecx, ecx
  00ce4	75 b9		 jne	 SHORT $LN276@inflate

; 867  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00ce6	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00ce9	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00cef	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00cf2	c1 e8 10	 shr	 eax, 16			; 00000010H
  00cf5	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  00cfa	3b d0		 cmp	 edx, eax
  00cfc	74 18		 je	 SHORT $LN270@inflate

; 868  :                 strm->msg = (char *)"invalid stored block lengths";

  00cfe	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00d01	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 869  :                 state->mode = BAD;

  00d08	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00d0b	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 870  :                 break;

  00d11	e9 c2 10 00 00	 jmp	 $LN490@inflate
$LN270@inflate:

; 871  :             }
; 872  :             state->length = (unsigned)hold & 0xffff;

  00d16	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00d19	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00d1e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00d21	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN269@inflate:

; 873  :             Tracev((stderr, "inflate:       stored length %u\n",
; 874  :                     state->length));
; 875  :             INITBITS();

  00d24	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00d2b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00d32	33 d2		 xor	 edx, edx
  00d34	75 ee		 jne	 SHORT $LN269@inflate

; 876  :             state->mode = COPY_;

  00d36	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00d39	c7 00 0e 00 00
	00		 mov	 DWORD PTR [eax], 14	; 0000000eH

; 877  :             if (flush == Z_TREES) goto inf_leave;

  00d3f	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00d43	75 05		 jne	 SHORT $LN265@inflate
  00d45	e9 93 10 00 00	 jmp	 $inf_leave$77745
$LN265@inflate:

; 878  :         case COPY_:
; 879  :             state->mode = COPY;

  00d4a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00d4d	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$LN264@inflate:

; 880  :         case COPY:
; 881  :             copy = state->length;

  00d53	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00d56	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00d59	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax

; 882  :             if (copy) {

  00d5c	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00d60	74 73		 je	 SHORT $LN263@inflate

; 883  :                 if (copy > have) copy = have;

  00d62	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  00d65	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  00d68	76 06		 jbe	 SHORT $LN262@inflate
  00d6a	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00d6d	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN262@inflate:

; 884  :                 if (copy > left) copy = left;

  00d70	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  00d73	3b 45 e0	 cmp	 eax, DWORD PTR _left$[ebp]
  00d76	76 06		 jbe	 SHORT $LN261@inflate
  00d78	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00d7b	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN261@inflate:

; 885  :                 if (copy == 0) goto inf_leave;

  00d7e	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00d82	75 05		 jne	 SHORT $LN260@inflate
  00d84	e9 54 10 00 00	 jmp	 $inf_leave$77745
$LN260@inflate:

; 886  :                 zmemcpy(put, next, copy);

  00d89	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  00d8c	52		 push	 edx
  00d8d	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00d90	50		 push	 eax
  00d91	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  00d94	51		 push	 ecx
  00d95	e8 00 00 00 00	 call	 _memcpy
  00d9a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 887  :                 have -= copy;

  00d9d	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00da0	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00da3	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 888  :                 next += copy;

  00da6	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00da9	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00dac	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax

; 889  :                 left -= copy;

  00daf	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  00db2	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  00db5	89 4d e0	 mov	 DWORD PTR _left$[ebp], ecx

; 890  :                 put += copy;

  00db8	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00dbb	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  00dbe	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 891  :                 state->length -= copy;

  00dc1	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00dc4	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00dc7	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  00dca	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00dcd	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 892  :                 break;

  00dd0	e9 03 10 00 00	 jmp	 $LN490@inflate
$LN263@inflate:

; 893  :             }
; 894  :             Tracev((stderr, "inflate:       stored end\n"));
; 895  :             state->mode = TYPE;

  00dd5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00dd8	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 896  :             break;

  00dde	e9 f5 0f 00 00	 jmp	 $LN490@inflate
$LN255@inflate:

; 897  :         case TABLE:
; 898  :             NEEDBITS(14);

  00de3	83 7d e4 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  00de7	73 3d		 jae	 SHORT $LN257@inflate
$LN253@inflate:
  00de9	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ded	75 05		 jne	 SHORT $LN250@inflate
  00def	e9 e9 0f 00 00	 jmp	 $inf_leave$77745
$LN250@inflate:
  00df4	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00df7	83 e9 01	 sub	 ecx, 1
  00dfa	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00dfd	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  00e00	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00e03	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e06	d3 e0		 shl	 eax, cl
  00e08	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  00e0b	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00e0e	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  00e11	83 c1 01	 add	 ecx, 1
  00e14	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  00e17	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00e1a	83 c2 08	 add	 edx, 8
  00e1d	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00e20	33 c0		 xor	 eax, eax
  00e22	75 c5		 jne	 SHORT $LN253@inflate
  00e24	eb bd		 jmp	 SHORT $LN255@inflate
$LN257@inflate:
  00e26	33 c9		 xor	 ecx, ecx
  00e28	75 b9		 jne	 SHORT $LN255@inflate

; 899  :             state->nlen = BITS(5) + 257;

  00e2a	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00e2d	83 e2 1f	 and	 edx, 31			; 0000001fH
  00e30	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00e36	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00e39	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN249@inflate:

; 900  :             DROPBITS(5);

  00e3c	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00e3f	c1 e9 05	 shr	 ecx, 5
  00e42	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00e45	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00e48	83 ea 05	 sub	 edx, 5
  00e4b	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00e4e	33 c0		 xor	 eax, eax
  00e50	75 ea		 jne	 SHORT $LN249@inflate

; 901  :             state->ndist = BITS(5) + 1;

  00e52	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00e55	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00e58	83 c1 01	 add	 ecx, 1
  00e5b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00e5e	89 4a 64	 mov	 DWORD PTR [edx+100], ecx
$LN246@inflate:

; 902  :             DROPBITS(5);

  00e61	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00e64	c1 e8 05	 shr	 eax, 5
  00e67	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  00e6a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e6d	83 e9 05	 sub	 ecx, 5
  00e70	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00e73	33 d2		 xor	 edx, edx
  00e75	75 ea		 jne	 SHORT $LN246@inflate

; 903  :             state->ncode = BITS(4) + 4;

  00e77	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  00e7a	83 e0 0f	 and	 eax, 15			; 0000000fH
  00e7d	83 c0 04	 add	 eax, 4
  00e80	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00e83	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
$LN243@inflate:

; 904  :             DROPBITS(4);

  00e86	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  00e89	c1 ea 04	 shr	 edx, 4
  00e8c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00e8f	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00e92	83 e8 04	 sub	 eax, 4
  00e95	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  00e98	33 c9		 xor	 ecx, ecx
  00e9a	75 ea		 jne	 SHORT $LN243@inflate

; 905  : #ifndef PKZIP_BUG_WORKAROUND
; 906  :             if (state->nlen > 286 || state->ndist > 30) {

  00e9c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00e9f	81 7a 60 1e 01
	00 00		 cmp	 DWORD PTR [edx+96], 286	; 0000011eH
  00ea6	77 09		 ja	 SHORT $LN239@inflate
  00ea8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00eab	83 78 64 1e	 cmp	 DWORD PTR [eax+100], 30	; 0000001eH
  00eaf	76 18		 jbe	 SHORT $LN240@inflate
$LN239@inflate:

; 907  :                 strm->msg = (char *)"too many length or distance symbols";

  00eb1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00eb4	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 908  :                 state->mode = BAD;

  00ebb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00ebe	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 909  :                 break;

  00ec4	e9 0f 0f 00 00	 jmp	 $LN490@inflate
$LN240@inflate:

; 910  :             }
; 911  : #endif
; 912  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 913  :             state->have = 0;

  00ec9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00ecc	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 914  :             state->mode = LENLENS;

  00ed3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00ed6	c7 01 11 00 00
	00		 mov	 DWORD PTR [ecx], 17	; 00000011H
$LN237@inflate:

; 915  :         case LENLENS:
; 916  :             while (state->have < state->ncode) {

  00edc	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00edf	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00ee2	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  00ee5	3b 48 5c	 cmp	 ecx, DWORD PTR [eax+92]
  00ee8	0f 83 8d 00 00
	00		 jae	 $LN223@inflate
$LN232@inflate:

; 917  :                 NEEDBITS(3);

  00eee	83 7d e4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00ef2	73 3d		 jae	 SHORT $LN234@inflate
$LN230@inflate:
  00ef4	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ef8	75 05		 jne	 SHORT $LN227@inflate
  00efa	e9 de 0e 00 00	 jmp	 $inf_leave$77745
$LN227@inflate:
  00eff	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00f02	83 ea 01	 sub	 edx, 1
  00f05	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00f08	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00f0b	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00f0e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f11	d3 e2		 shl	 edx, cl
  00f13	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  00f16	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  00f19	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  00f1c	83 c0 01	 add	 eax, 1
  00f1f	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  00f22	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f25	83 c1 08	 add	 ecx, 8
  00f28	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00f2b	33 d2		 xor	 edx, edx
  00f2d	75 c5		 jne	 SHORT $LN230@inflate
  00f2f	eb bd		 jmp	 SHORT $LN232@inflate
$LN234@inflate:
  00f31	33 c0		 xor	 eax, eax
  00f33	75 b9		 jne	 SHORT $LN232@inflate

; 918  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00f35	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00f38	83 e1 07	 and	 ecx, 7
  00f3b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f3e	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00f41	0f b7 14 45 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00f49	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f4c	66 89 4c 50 70	 mov	 WORD PTR [eax+edx*2+112], cx
  00f51	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f54	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00f57	83 c2 01	 add	 edx, 1
  00f5a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f5d	89 50 68	 mov	 DWORD PTR [eax+104], edx
$LN226@inflate:

; 919  :                 DROPBITS(3);

  00f60	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  00f63	c1 e9 03	 shr	 ecx, 3
  00f66	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  00f69	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00f6c	83 ea 03	 sub	 edx, 3
  00f6f	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00f72	33 c0		 xor	 eax, eax
  00f74	75 ea		 jne	 SHORT $LN226@inflate

; 920  :             }

  00f76	e9 61 ff ff ff	 jmp	 $LN237@inflate
$LN223@inflate:

; 921  :             while (state->have < 19)

  00f7b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f7e	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00f82	73 29		 jae	 SHORT $LN222@inflate

; 922  :                 state->lens[order[state->have++]] = 0;

  00f84	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f87	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00f8a	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00f92	33 d2		 xor	 edx, edx
  00f94	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f97	66 89 54 48 70	 mov	 WORD PTR [eax+ecx*2+112], dx
  00f9c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f9f	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00fa2	83 c2 01	 add	 edx, 1
  00fa5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fa8	89 50 68	 mov	 DWORD PTR [eax+104], edx
  00fab	eb ce		 jmp	 SHORT $LN223@inflate
$LN222@inflate:

; 923  :             state->next = state->codes;

  00fad	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fb0	81 c1 30 05 00
	00		 add	 ecx, 1328		; 00000530H
  00fb6	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00fb9	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx

; 924  :             state->lencode = (const code FAR *)(state->next);

  00fbc	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fbf	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fc2	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00fc5	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 925  :             state->lenbits = 7;

  00fc8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fcb	c7 40 54 07 00
	00 00		 mov	 DWORD PTR [eax+84], 7

; 926  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 927  :                                 &(state->lenbits), state->work);

  00fd2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fd5	81 c1 f0 02 00
	00		 add	 ecx, 752		; 000002f0H
  00fdb	51		 push	 ecx
  00fdc	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00fdf	83 c2 54	 add	 edx, 84			; 00000054H
  00fe2	52		 push	 edx
  00fe3	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fe6	83 c0 6c	 add	 eax, 108		; 0000006cH
  00fe9	50		 push	 eax
  00fea	6a 13		 push	 19			; 00000013H
  00fec	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fef	83 c1 70	 add	 ecx, 112		; 00000070H
  00ff2	51		 push	 ecx
  00ff3	6a 00		 push	 0
  00ff5	e8 00 00 00 00	 call	 _inflate_table
  00ffa	83 c4 18	 add	 esp, 24			; 00000018H
  00ffd	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 928  :             if (ret) {

  01000	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  01004	74 18		 je	 SHORT $LN221@inflate

; 929  :                 strm->msg = (char *)"invalid code lengths set";

  01006	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01009	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 930  :                 state->mode = BAD;

  01010	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01013	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 931  :                 break;

  01019	e9 ba 0d 00 00	 jmp	 $LN490@inflate
$LN221@inflate:

; 932  :             }
; 933  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 934  :             state->have = 0;

  0101e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01021	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 935  :             state->mode = CODELENS;

  01028	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0102b	c7 02 12 00 00
	00		 mov	 DWORD PTR [edx], 18	; 00000012H
$LN219@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  01031	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01034	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01037	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0103a	03 4a 64	 add	 ecx, DWORD PTR [edx+100]
  0103d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01040	39 48 68	 cmp	 DWORD PTR [eax+104], ecx
  01043	0f 83 1d 03 00
	00		 jae	 $LN218@inflate
$LN217@inflate:

; 938  :                 for (;;) {
; 939  :                     here = state->lencode[BITS(state->lenbits)];

  01049	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0104c	ba 01 00 00 00	 mov	 edx, 1
  01051	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  01054	d3 e2		 shl	 edx, cl
  01056	83 ea 01	 sub	 edx, 1
  01059	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  0105c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0105f	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01062	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  01065	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 940  :                     if ((unsigned)(here.bits) <= bits) break;

  01068	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0106c	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  0106f	77 02		 ja	 SHORT $LN214@inflate
  01071	eb 3d		 jmp	 SHORT $LN216@inflate
$LN214@inflate:

; 941  :                     PULLBYTE();

  01073	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01077	75 05		 jne	 SHORT $LN211@inflate
  01079	e9 5f 0d 00 00	 jmp	 $inf_leave$77745
$LN211@inflate:
  0107e	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01081	83 e9 01	 sub	 ecx, 1
  01084	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01087	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  0108a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0108d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01090	d3 e0		 shl	 eax, cl
  01092	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01095	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01098	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0109b	83 c1 01	 add	 ecx, 1
  0109e	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  010a1	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  010a4	83 c2 08	 add	 edx, 8
  010a7	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  010aa	33 c0		 xor	 eax, eax
  010ac	75 c5		 jne	 SHORT $LN214@inflate

; 942  :                 }

  010ae	eb 99		 jmp	 SHORT $LN217@inflate
$LN216@inflate:

; 943  :                 if (here.val < 16) {

  010b0	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  010b4	83 f9 10	 cmp	 ecx, 16			; 00000010H
  010b7	7d 42		 jge	 SHORT $LN210@inflate
$LN209@inflate:

; 944  :                     DROPBITS(here.bits);

  010b9	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  010bd	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  010c0	d3 ea		 shr	 edx, cl
  010c2	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  010c5	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  010c9	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  010cc	2b c8		 sub	 ecx, eax
  010ce	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  010d1	33 d2		 xor	 edx, edx
  010d3	75 e4		 jne	 SHORT $LN209@inflate

; 945  :                     state->lens[state->have++] = here.val;

  010d5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  010d8	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  010db	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  010de	66 8b 45 f6	 mov	 ax, WORD PTR _here$[ebp+2]
  010e2	66 89 44 4a 70	 mov	 WORD PTR [edx+ecx*2+112], ax
  010e7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  010ea	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  010ed	83 c2 01	 add	 edx, 1
  010f0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  010f3	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 946  :                 }
; 947  :                 else {

  010f6	e9 66 02 00 00	 jmp	 $LN206@inflate
$LN210@inflate:

; 948  :                     if (here.val == 16) {

  010fb	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  010ff	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01102	0f 85 c2 00 00
	00		 jne	 $LN205@inflate
$LN201@inflate:

; 949  :                         NEEDBITS(here.bits + 2);

  01108	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  0110c	83 c2 02	 add	 edx, 2
  0110f	39 55 e4	 cmp	 DWORD PTR _bits$[ebp], edx
  01112	73 3d		 jae	 SHORT $LN203@inflate
$LN199@inflate:
  01114	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01118	75 05		 jne	 SHORT $LN196@inflate
  0111a	e9 be 0c 00 00	 jmp	 $inf_leave$77745
$LN196@inflate:
  0111f	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  01122	83 e8 01	 sub	 eax, 1
  01125	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01128	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0112b	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0112e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01131	d3 e2		 shl	 edx, cl
  01133	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01136	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01139	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0113c	83 c0 01	 add	 eax, 1
  0113f	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  01142	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01145	83 c1 08	 add	 ecx, 8
  01148	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0114b	33 d2		 xor	 edx, edx
  0114d	75 c5		 jne	 SHORT $LN199@inflate
  0114f	eb b7		 jmp	 SHORT $LN201@inflate
$LN203@inflate:
  01151	33 c0		 xor	 eax, eax
  01153	75 b3		 jne	 SHORT $LN201@inflate
$LN195@inflate:

; 950  :                         DROPBITS(here.bits);

  01155	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01159	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  0115c	d3 ea		 shr	 edx, cl
  0115e	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01161	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01165	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01168	2b c8		 sub	 ecx, eax
  0116a	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0116d	33 d2		 xor	 edx, edx
  0116f	75 e4		 jne	 SHORT $LN195@inflate

; 951  :                         if (state->have == 0) {

  01171	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01174	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  01178	75 18		 jne	 SHORT $LN192@inflate

; 952  :                             strm->msg = (char *)"invalid bit length repeat";

  0117a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0117d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 953  :                             state->mode = BAD;

  01184	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01187	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 954  :                             break;

  0118d	e9 d4 01 00 00	 jmp	 $LN218@inflate
$LN192@inflate:

; 955  :                         }
; 956  :                         len = state->lens[state->have - 1];

  01192	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01195	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  01198	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0119b	0f b7 44 4a 6e	 movzx	 eax, WORD PTR [edx+ecx*2+110]
  011a0	89 45 e8	 mov	 DWORD PTR _len$[ebp], eax

; 957  :                         copy = 3 + BITS(2);

  011a3	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  011a6	83 e1 03	 and	 ecx, 3
  011a9	83 c1 03	 add	 ecx, 3
  011ac	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN191@inflate:

; 958  :                         DROPBITS(2);

  011af	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  011b2	c1 ea 02	 shr	 edx, 2
  011b5	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  011b8	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  011bb	83 e8 02	 sub	 eax, 2
  011be	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  011c1	33 c9		 xor	 ecx, ecx
  011c3	75 ea		 jne	 SHORT $LN191@inflate

; 959  :                     }
; 960  :                     else if (here.val == 17) {

  011c5	e9 36 01 00 00	 jmp	 $LN188@inflate
$LN205@inflate:
  011ca	0f b7 55 f6	 movzx	 edx, WORD PTR _here$[ebp+2]
  011ce	83 fa 11	 cmp	 edx, 17			; 00000011H
  011d1	0f 85 97 00 00
	00		 jne	 $LN167@inflate
$LN183@inflate:

; 961  :                         NEEDBITS(here.bits + 3);

  011d7	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  011db	83 c0 03	 add	 eax, 3
  011de	39 45 e4	 cmp	 DWORD PTR _bits$[ebp], eax
  011e1	73 3d		 jae	 SHORT $LN185@inflate
$LN181@inflate:
  011e3	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  011e7	75 05		 jne	 SHORT $LN178@inflate
  011e9	e9 ef 0b 00 00	 jmp	 $inf_leave$77745
$LN178@inflate:
  011ee	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  011f1	83 e9 01	 sub	 ecx, 1
  011f4	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  011f7	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  011fa	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011fd	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01200	d3 e0		 shl	 eax, cl
  01202	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01205	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01208	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0120b	83 c1 01	 add	 ecx, 1
  0120e	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01211	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01214	83 c2 08	 add	 edx, 8
  01217	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0121a	33 c0		 xor	 eax, eax
  0121c	75 c5		 jne	 SHORT $LN181@inflate
  0121e	eb b7		 jmp	 SHORT $LN183@inflate
$LN185@inflate:
  01220	33 c9		 xor	 ecx, ecx
  01222	75 b3		 jne	 SHORT $LN183@inflate
$LN177@inflate:

; 962  :                         DROPBITS(here.bits);

  01224	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01228	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  0122b	d3 ea		 shr	 edx, cl
  0122d	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01230	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01234	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01237	2b c8		 sub	 ecx, eax
  01239	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0123c	33 d2		 xor	 edx, edx
  0123e	75 e4		 jne	 SHORT $LN177@inflate

; 963  :                         len = 0;

  01240	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 964  :                         copy = 3 + BITS(3);

  01247	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  0124a	83 e0 07	 and	 eax, 7
  0124d	83 c0 03	 add	 eax, 3
  01250	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN174@inflate:

; 965  :                         DROPBITS(3);

  01253	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01256	c1 e9 03	 shr	 ecx, 3
  01259	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  0125c	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  0125f	83 ea 03	 sub	 edx, 3
  01262	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01265	33 c0		 xor	 eax, eax
  01267	75 ea		 jne	 SHORT $LN174@inflate

; 966  :                     }
; 967  :                     else {

  01269	e9 92 00 00 00	 jmp	 $LN188@inflate
$LN167@inflate:

; 968  :                         NEEDBITS(here.bits + 7);

  0126e	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01272	83 c1 07	 add	 ecx, 7
  01275	39 4d e4	 cmp	 DWORD PTR _bits$[ebp], ecx
  01278	73 3d		 jae	 SHORT $LN169@inflate
$LN165@inflate:
  0127a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0127e	75 05		 jne	 SHORT $LN162@inflate
  01280	e9 58 0b 00 00	 jmp	 $inf_leave$77745
$LN162@inflate:
  01285	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01288	83 ea 01	 sub	 edx, 1
  0128b	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  0128e	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01291	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01294	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01297	d3 e2		 shl	 edx, cl
  01299	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  0129c	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0129f	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  012a2	83 c0 01	 add	 eax, 1
  012a5	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  012a8	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  012ab	83 c1 08	 add	 ecx, 8
  012ae	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  012b1	33 d2		 xor	 edx, edx
  012b3	75 c5		 jne	 SHORT $LN165@inflate
  012b5	eb b7		 jmp	 SHORT $LN167@inflate
$LN169@inflate:
  012b7	33 c0		 xor	 eax, eax
  012b9	75 b3		 jne	 SHORT $LN167@inflate
$LN161@inflate:

; 969  :                         DROPBITS(here.bits);

  012bb	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  012bf	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  012c2	d3 ea		 shr	 edx, cl
  012c4	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  012c7	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  012cb	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  012ce	2b c8		 sub	 ecx, eax
  012d0	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  012d3	33 d2		 xor	 edx, edx
  012d5	75 e4		 jne	 SHORT $LN161@inflate

; 970  :                         len = 0;

  012d7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 971  :                         copy = 11 + BITS(7);

  012de	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  012e1	83 e0 7f	 and	 eax, 127		; 0000007fH
  012e4	83 c0 0b	 add	 eax, 11			; 0000000bH
  012e7	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN158@inflate:

; 972  :                         DROPBITS(7);

  012ea	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  012ed	c1 e9 07	 shr	 ecx, 7
  012f0	89 4d d4	 mov	 DWORD PTR _hold$[ebp], ecx
  012f3	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  012f6	83 ea 07	 sub	 edx, 7
  012f9	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  012fc	33 c0		 xor	 eax, eax
  012fe	75 ea		 jne	 SHORT $LN158@inflate
$LN188@inflate:

; 973  :                     }
; 974  :                     if (state->have + copy > state->nlen + state->ndist) {

  01300	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01303	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  01306	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  01309	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0130c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0130f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01312	03 48 64	 add	 ecx, DWORD PTR [eax+100]
  01315	3b d1		 cmp	 edx, ecx
  01317	76 15		 jbe	 SHORT $LN154@inflate

; 975  :                         strm->msg = (char *)"invalid bit length repeat";

  01319	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0131c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 976  :                         state->mode = BAD;

  01323	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01326	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 977  :                         break;

  0132c	eb 38		 jmp	 SHORT $LN218@inflate
$LN154@inflate:

; 978  :                     }
; 979  :                     while (copy--)

  0132e	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01331	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01334	83 e9 01	 sub	 ecx, 1
  01337	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
  0133a	85 c0		 test	 eax, eax
  0133c	74 23		 je	 SHORT $LN206@inflate

; 980  :                         state->lens[state->have++] = (unsigned short)len;

  0133e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01341	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  01344	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01347	66 8b 55 e8	 mov	 dx, WORD PTR _len$[ebp]
  0134b	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  01350	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01353	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  01356	83 c1 01	 add	 ecx, 1
  01359	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0135c	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
  0135f	eb cd		 jmp	 SHORT $LN154@inflate
$LN206@inflate:

; 981  :                 }
; 982  :             }

  01361	e9 cb fc ff ff	 jmp	 $LN219@inflate
$LN218@inflate:

; 983  : 
; 984  :             /* handle error breaks in while */
; 985  :             if (state->mode == BAD) break;

  01366	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01369	83 38 1d	 cmp	 DWORD PTR [eax], 29	; 0000001dH
  0136c	75 05		 jne	 SHORT $LN152@inflate
  0136e	e9 65 0a 00 00	 jmp	 $LN490@inflate
$LN152@inflate:

; 986  : 
; 987  :             /* check for end-of-block code (better have one) */
; 988  :             if (state->lens[256] == 0) {

  01373	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01376	0f b7 91 70 02
	00 00		 movzx	 edx, WORD PTR [ecx+624]
  0137d	85 d2		 test	 edx, edx
  0137f	75 18		 jne	 SHORT $LN151@inflate

; 989  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  01381	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01384	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 990  :                 state->mode = BAD;

  0138b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0138e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 991  :                 break;

  01394	e9 3f 0a 00 00	 jmp	 $LN490@inflate
$LN151@inflate:

; 992  :             }
; 993  : 
; 994  :             /* build code tables -- note: do not change the lenbits or distbits
; 995  :                values here (9 and 6) without reading the comments in inftrees.h
; 996  :                concerning the ENOUGH constants, which depend on those values */
; 997  :             state->next = state->codes;

  01399	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0139c	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  013a2	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013a5	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 998  :             state->lencode = (const code FAR *)(state->next);

  013a8	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013ab	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013ae	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  013b1	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 999  :             state->lenbits = 9;

  013b4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013b7	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 1000 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 1001 :                                 &(state->lenbits), state->work);

  013be	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013c1	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  013c7	52		 push	 edx
  013c8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013cb	83 c0 54	 add	 eax, 84			; 00000054H
  013ce	50		 push	 eax
  013cf	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013d2	83 c1 6c	 add	 ecx, 108		; 0000006cH
  013d5	51		 push	 ecx
  013d6	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013d9	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  013dc	50		 push	 eax
  013dd	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013e0	83 c1 70	 add	 ecx, 112		; 00000070H
  013e3	51		 push	 ecx
  013e4	6a 01		 push	 1
  013e6	e8 00 00 00 00	 call	 _inflate_table
  013eb	83 c4 18	 add	 esp, 24			; 00000018H
  013ee	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 1002 :             if (ret) {

  013f1	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  013f5	74 18		 je	 SHORT $LN150@inflate

; 1003 :                 strm->msg = (char *)"invalid literal/lengths set";

  013f7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  013fa	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 1004 :                 state->mode = BAD;

  01401	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01404	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 1005 :                 break;

  0140a	e9 c9 09 00 00	 jmp	 $LN490@inflate
$LN150@inflate:

; 1006 :             }
; 1007 :             state->distcode = (const code FAR *)(state->next);

  0140f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01412	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01415	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  01418	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1008 :             state->distbits = 6;

  0141b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0141e	c7 41 58 06 00
	00 00		 mov	 DWORD PTR [ecx+88], 6

; 1009 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 1010 :                             &(state->next), &(state->distbits), state->work);

  01425	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01428	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  0142e	52		 push	 edx
  0142f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01432	83 c0 58	 add	 eax, 88			; 00000058H
  01435	50		 push	 eax
  01436	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01439	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0143c	51		 push	 ecx
  0143d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01440	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  01443	50		 push	 eax
  01444	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01447	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0144a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0144d	8d 4c 50 70	 lea	 ecx, DWORD PTR [eax+edx*2+112]
  01451	51		 push	 ecx
  01452	6a 02		 push	 2
  01454	e8 00 00 00 00	 call	 _inflate_table
  01459	83 c4 18	 add	 esp, 24			; 00000018H
  0145c	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax

; 1011 :             if (ret) {

  0145f	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  01463	74 18		 je	 SHORT $LN149@inflate

; 1012 :                 strm->msg = (char *)"invalid distances set";

  01465	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01468	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1013 :                 state->mode = BAD;

  0146f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01472	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 1014 :                 break;

  01478	e9 5b 09 00 00	 jmp	 $LN490@inflate
$LN149@inflate:

; 1015 :             }
; 1016 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1017 :             state->mode = LEN_;

  0147d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01480	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H

; 1018 :             if (flush == Z_TREES) goto inf_leave;

  01486	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0148a	75 05		 jne	 SHORT $LN147@inflate
  0148c	e9 4c 09 00 00	 jmp	 $inf_leave$77745
$LN147@inflate:

; 1019 :         case LEN_:
; 1020 :             state->mode = LEN;

  01491	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01494	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H
$LN146@inflate:

; 1021 :         case LEN:
; 1022 :             if (have >= 6 && left >= 258) {

  0149a	83 7d f0 06	 cmp	 DWORD PTR _have$[ebp], 6
  0149e	0f 82 a9 00 00
	00		 jb	 $LN145@inflate
  014a4	81 7d e0 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  014ab	0f 82 9c 00 00
	00		 jb	 $LN145@inflate
$LN144@inflate:

; 1023 :                 RESTORE();

  014b1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014b4	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  014b7	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  014ba	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014bd	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  014c0	89 42 10	 mov	 DWORD PTR [edx+16], eax
  014c3	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  014c6	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  014c9	89 11		 mov	 DWORD PTR [ecx], edx
  014cb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014ce	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  014d1	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  014d4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  014d7	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  014da	89 42 38	 mov	 DWORD PTR [edx+56], eax
  014dd	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  014e0	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  014e3	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  014e6	33 c0		 xor	 eax, eax
  014e8	75 c7		 jne	 SHORT $LN144@inflate

; 1024 :                 inflate_fast(strm, out);

  014ea	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  014ed	51		 push	 ecx
  014ee	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014f1	52		 push	 edx
  014f2	e8 00 00 00 00	 call	 _inflate_fast
  014f7	83 c4 08	 add	 esp, 8
$LN141@inflate:

; 1025 :                 LOAD();

  014fa	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014fd	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01500	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  01503	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01506	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01509	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax
  0150c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0150f	8b 11		 mov	 edx, DWORD PTR [ecx]
  01511	89 55 dc	 mov	 DWORD PTR _next$[ebp], edx
  01514	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01517	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0151a	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  0151d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01520	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01523	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01526	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01529	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0152c	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0152f	33 c0		 xor	 eax, eax
  01531	75 c7		 jne	 SHORT $LN141@inflate

; 1026 :                 if (state->mode == TYPE)

  01533	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01536	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  01539	75 0d		 jne	 SHORT $LN138@inflate

; 1027 :                     state->back = -1;

  0153b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0153e	c7 82 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+7108], -1
$LN138@inflate:

; 1028 :                 break;

  01548	e9 8b 08 00 00	 jmp	 $LN490@inflate
$LN145@inflate:

; 1029 :             }
; 1030 :             state->back = 0;

  0154d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01550	c7 80 c4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+7108], 0
$LN137@inflate:

; 1031 :             for (;;) {
; 1032 :                 here = state->lencode[BITS(state->lenbits)];

  0155a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0155d	ba 01 00 00 00	 mov	 edx, 1
  01562	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  01565	d3 e2		 shl	 edx, cl
  01567	83 ea 01	 sub	 edx, 1
  0156a	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  0156d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01570	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01573	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  01576	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 1033 :                 if ((unsigned)(here.bits) <= bits) break;

  01579	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0157d	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  01580	77 02		 ja	 SHORT $LN134@inflate
  01582	eb 3d		 jmp	 SHORT $LN136@inflate
$LN134@inflate:

; 1034 :                 PULLBYTE();

  01584	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01588	75 05		 jne	 SHORT $LN131@inflate
  0158a	e9 4e 08 00 00	 jmp	 $inf_leave$77745
$LN131@inflate:
  0158f	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01592	83 e9 01	 sub	 ecx, 1
  01595	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01598	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  0159b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0159e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  015a1	d3 e0		 shl	 eax, cl
  015a3	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  015a6	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  015a9	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  015ac	83 c1 01	 add	 ecx, 1
  015af	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  015b2	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  015b5	83 c2 08	 add	 edx, 8
  015b8	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  015bb	33 c0		 xor	 eax, eax
  015bd	75 c5		 jne	 SHORT $LN134@inflate

; 1035 :             }

  015bf	eb 99		 jmp	 SHORT $LN137@inflate
$LN136@inflate:

; 1036 :             if (here.op && (here.op & 0xf0) == 0) {

  015c1	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  015c5	85 c9		 test	 ecx, ecx
  015c7	0f 84 c5 00 00
	00		 je	 $LN119@inflate
  015cd	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  015d1	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  015d7	0f 85 b5 00 00
	00		 jne	 $LN119@inflate

; 1037 :                 last = here;

  015dd	8b 45 f4	 mov	 eax, DWORD PTR _here$[ebp]
  015e0	89 45 f8	 mov	 DWORD PTR _last$[ebp], eax
$LN129@inflate:

; 1038 :                 for (;;) {
; 1039 :                     here = state->lencode[last.val +
; 1040 :                             (BITS(last.bits + last.op) >> last.bits)];

  015e3	0f b7 55 fa	 movzx	 edx, WORD PTR _last$[ebp+2]
  015e7	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  015eb	0f b6 45 f8	 movzx	 eax, BYTE PTR _last$[ebp]
  015ef	03 c8		 add	 ecx, eax
  015f1	b8 01 00 00 00	 mov	 eax, 1
  015f6	d3 e0		 shl	 eax, cl
  015f8	83 e8 01	 sub	 eax, 1
  015fb	23 45 d4	 and	 eax, DWORD PTR _hold$[ebp]
  015fe	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01602	d3 e8		 shr	 eax, cl
  01604	03 d0		 add	 edx, eax
  01606	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01609	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0160c	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0160f	89 4d f4	 mov	 DWORD PTR _here$[ebp], ecx

; 1041 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01612	0f b6 55 f9	 movzx	 edx, BYTE PTR _last$[ebp+1]
  01616	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0161a	03 d0		 add	 edx, eax
  0161c	3b 55 e4	 cmp	 edx, DWORD PTR _bits$[ebp]
  0161f	77 02		 ja	 SHORT $LN126@inflate
  01621	eb 3d		 jmp	 SHORT $LN122@inflate
$LN126@inflate:

; 1042 :                     PULLBYTE();

  01623	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01627	75 05		 jne	 SHORT $LN123@inflate
  01629	e9 af 07 00 00	 jmp	 $inf_leave$77745
$LN123@inflate:
  0162e	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01631	83 e9 01	 sub	 ecx, 1
  01634	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01637	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  0163a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0163d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01640	d3 e0		 shl	 eax, cl
  01642	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01645	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01648	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  0164b	83 c1 01	 add	 ecx, 1
  0164e	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01651	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01654	83 c2 08	 add	 edx, 8
  01657	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0165a	33 c0		 xor	 eax, eax
  0165c	75 c5		 jne	 SHORT $LN126@inflate

; 1043 :                 }

  0165e	eb 83		 jmp	 SHORT $LN129@inflate
$LN122@inflate:

; 1044 :                 DROPBITS(last.bits);

  01660	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01664	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01667	d3 ea		 shr	 edx, cl
  01669	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0166c	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  01670	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01673	2b c8		 sub	 ecx, eax
  01675	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01678	33 d2		 xor	 edx, edx
  0167a	75 e4		 jne	 SHORT $LN122@inflate

; 1045 :                 state->back += last.bits;

  0167c	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  01680	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01683	03 81 c4 1b 00
	00		 add	 eax, DWORD PTR [ecx+7108]
  01689	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0168c	89 82 c4 1b 00
	00		 mov	 DWORD PTR [edx+7108], eax
$LN119@inflate:

; 1046 :             }
; 1047 :             DROPBITS(here.bits);

  01692	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01696	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01699	d3 e8		 shr	 eax, cl
  0169b	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  0169e	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  016a2	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  016a5	2b d1		 sub	 edx, ecx
  016a7	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  016aa	33 c0		 xor	 eax, eax
  016ac	75 e4		 jne	 SHORT $LN119@inflate

; 1048 :             state->back += here.bits;

  016ae	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  016b2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  016b5	03 8a c4 1b 00
	00		 add	 ecx, DWORD PTR [edx+7108]
  016bb	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  016be	89 88 c4 1b 00
	00		 mov	 DWORD PTR [eax+7108], ecx

; 1049 :             state->length = (unsigned)here.val;

  016c4	0f b7 4d f6	 movzx	 ecx, WORD PTR _here$[ebp+2]
  016c8	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  016cb	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 1050 :             if ((int)(here.op) == 0) {

  016ce	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  016d2	85 c0		 test	 eax, eax
  016d4	75 0e		 jne	 SHORT $LN116@inflate

; 1051 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1052 :                         "inflate:         literal '%c'\n" :
; 1053 :                         "inflate:         literal 0x%02x\n", here.val));
; 1054 :                 state->mode = LIT;

  016d6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  016d9	c7 01 19 00 00
	00		 mov	 DWORD PTR [ecx], 25	; 00000019H

; 1055 :                 break;

  016df	e9 f4 06 00 00	 jmp	 $LN490@inflate
$LN116@inflate:

; 1056 :             }
; 1057 :             if (here.op & 32) {

  016e4	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  016e8	83 e2 20	 and	 edx, 32			; 00000020H
  016eb	74 1b		 je	 SHORT $LN115@inflate

; 1058 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1059 :                 state->back = -1;

  016ed	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  016f0	c7 80 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7108], -1

; 1060 :                 state->mode = TYPE;

  016fa	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  016fd	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1061 :                 break;

  01703	e9 d0 06 00 00	 jmp	 $LN490@inflate
$LN115@inflate:

; 1062 :             }
; 1063 :             if (here.op & 64) {

  01708	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  0170c	83 e2 40	 and	 edx, 64			; 00000040H
  0170f	74 18		 je	 SHORT $LN114@inflate

; 1064 :                 strm->msg = (char *)"invalid literal/length code";

  01711	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01714	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 1065 :                 state->mode = BAD;

  0171b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0171e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 1066 :                 break;

  01724	e9 af 06 00 00	 jmp	 $LN490@inflate
$LN114@inflate:

; 1067 :             }
; 1068 :             state->extra = (unsigned)(here.op) & 15;

  01729	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  0172d	83 e2 0f	 and	 edx, 15			; 0000000fH
  01730	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01733	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1069 :             state->mode = LENEXT;

  01736	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01739	c7 01 15 00 00
	00		 mov	 DWORD PTR [ecx], 21	; 00000015H
$LN113@inflate:

; 1070 :         case LENEXT:
; 1071 :             if (state->extra) {

  0173f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01742	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  01746	0f 84 a1 00 00
	00		 je	 $LN112@inflate
$LN108@inflate:

; 1072 :                 NEEDBITS(state->extra);

  0174c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0174f	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01752	3b 48 48	 cmp	 ecx, DWORD PTR [eax+72]
  01755	73 3d		 jae	 SHORT $LN110@inflate
$LN106@inflate:
  01757	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0175b	75 05		 jne	 SHORT $LN103@inflate
  0175d	e9 7b 06 00 00	 jmp	 $inf_leave$77745
$LN103@inflate:
  01762	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01765	83 ea 01	 sub	 edx, 1
  01768	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  0176b	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0176e	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01771	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01774	d3 e2		 shl	 edx, cl
  01776	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01779	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0177c	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  0177f	83 c0 01	 add	 eax, 1
  01782	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  01785	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01788	83 c1 08	 add	 ecx, 8
  0178b	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0178e	33 d2		 xor	 edx, edx
  01790	75 c5		 jne	 SHORT $LN106@inflate
  01792	eb b8		 jmp	 SHORT $LN108@inflate
$LN110@inflate:
  01794	33 c0		 xor	 eax, eax
  01796	75 b4		 jne	 SHORT $LN108@inflate

; 1073 :                 state->length += BITS(state->extra);

  01798	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0179b	ba 01 00 00 00	 mov	 edx, 1
  017a0	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  017a3	d3 e2		 shl	 edx, cl
  017a5	83 ea 01	 sub	 edx, 1
  017a8	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  017ab	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  017ae	03 50 40	 add	 edx, DWORD PTR [eax+64]
  017b1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017b4	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$LN102@inflate:

; 1074 :                 DROPBITS(state->extra);

  017b7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  017ba	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  017bd	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  017c0	d3 e8		 shr	 eax, cl
  017c2	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  017c5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017c8	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  017cb	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  017ce	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  017d1	33 c0		 xor	 eax, eax
  017d3	75 e2		 jne	 SHORT $LN102@inflate

; 1075 :                 state->back += state->extra;

  017d5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017d8	8b 91 c4 1b 00
	00		 mov	 edx, DWORD PTR [ecx+7108]
  017de	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  017e1	03 50 48	 add	 edx, DWORD PTR [eax+72]
  017e4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017e7	89 91 c4 1b 00
	00		 mov	 DWORD PTR [ecx+7108], edx
$LN112@inflate:

; 1076 :             }
; 1077 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1078 :             state->was = state->length;

  017ed	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  017f0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  017f3	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  017f6	89 8a c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], ecx

; 1079 :             state->mode = DIST;

  017fc	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  017ff	c7 02 16 00 00
	00		 mov	 DWORD PTR [edx], 22	; 00000016H
$LN98@inflate:

; 1080 :         case DIST:
; 1081 :             for (;;) {
; 1082 :                 here = state->distcode[BITS(state->distbits)];

  01805	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01808	ba 01 00 00 00	 mov	 edx, 1
  0180d	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  01810	d3 e2		 shl	 edx, cl
  01812	83 ea 01	 sub	 edx, 1
  01815	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01818	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0181b	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0181e	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  01821	89 55 f4	 mov	 DWORD PTR _here$[ebp], edx

; 1083 :                 if ((unsigned)(here.bits) <= bits) break;

  01824	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01828	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  0182b	77 02		 ja	 SHORT $LN95@inflate
  0182d	eb 3d		 jmp	 SHORT $LN97@inflate
$LN95@inflate:

; 1084 :                 PULLBYTE();

  0182f	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01833	75 05		 jne	 SHORT $LN92@inflate
  01835	e9 a3 05 00 00	 jmp	 $inf_leave$77745
$LN92@inflate:
  0183a	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0183d	83 e9 01	 sub	 ecx, 1
  01840	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01843	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01846	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01849	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0184c	d3 e0		 shl	 eax, cl
  0184e	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01851	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01854	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01857	83 c1 01	 add	 ecx, 1
  0185a	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  0185d	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01860	83 c2 08	 add	 edx, 8
  01863	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01866	33 c0		 xor	 eax, eax
  01868	75 c5		 jne	 SHORT $LN95@inflate

; 1085 :             }

  0186a	eb 99		 jmp	 SHORT $LN98@inflate
$LN97@inflate:

; 1086 :             if ((here.op & 0xf0) == 0) {

  0186c	0f b6 4d f4	 movzx	 ecx, BYTE PTR _here$[ebp]
  01870	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  01876	0f 85 b5 00 00
	00		 jne	 $LN80@inflate

; 1087 :                 last = here;

  0187c	8b 55 f4	 mov	 edx, DWORD PTR _here$[ebp]
  0187f	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx
$LN90@inflate:

; 1088 :                 for (;;) {
; 1089 :                     here = state->distcode[last.val +
; 1090 :                             (BITS(last.bits + last.op) >> last.bits)];

  01882	0f b7 45 fa	 movzx	 eax, WORD PTR _last$[ebp+2]
  01886	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0188a	0f b6 55 f8	 movzx	 edx, BYTE PTR _last$[ebp]
  0188e	03 ca		 add	 ecx, edx
  01890	ba 01 00 00 00	 mov	 edx, 1
  01895	d3 e2		 shl	 edx, cl
  01897	83 ea 01	 sub	 edx, 1
  0189a	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  0189d	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  018a1	d3 ea		 shr	 edx, cl
  018a3	03 c2		 add	 eax, edx
  018a5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  018a8	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  018ab	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  018ae	89 45 f4	 mov	 DWORD PTR _here$[ebp], eax

; 1091 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  018b1	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  018b5	0f b6 55 f5	 movzx	 edx, BYTE PTR _here$[ebp+1]
  018b9	03 ca		 add	 ecx, edx
  018bb	3b 4d e4	 cmp	 ecx, DWORD PTR _bits$[ebp]
  018be	77 02		 ja	 SHORT $LN87@inflate
  018c0	eb 3d		 jmp	 SHORT $LN83@inflate
$LN87@inflate:

; 1092 :                     PULLBYTE();

  018c2	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  018c6	75 05		 jne	 SHORT $LN84@inflate
  018c8	e9 10 05 00 00	 jmp	 $inf_leave$77745
$LN84@inflate:
  018cd	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  018d0	83 e8 01	 sub	 eax, 1
  018d3	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  018d6	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  018d9	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  018dc	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  018df	d3 e2		 shl	 edx, cl
  018e1	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  018e4	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  018e7	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  018ea	83 c0 01	 add	 eax, 1
  018ed	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  018f0	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  018f3	83 c1 08	 add	 ecx, 8
  018f6	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  018f9	33 d2		 xor	 edx, edx
  018fb	75 c5		 jne	 SHORT $LN87@inflate

; 1093 :                 }

  018fd	eb 83		 jmp	 SHORT $LN90@inflate
$LN83@inflate:

; 1094 :                 DROPBITS(last.bits);

  018ff	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01903	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01906	d3 e8		 shr	 eax, cl
  01908	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  0190b	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0190f	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01912	2b d1		 sub	 edx, ecx
  01914	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01917	33 c0		 xor	 eax, eax
  01919	75 e4		 jne	 SHORT $LN83@inflate

; 1095 :                 state->back += last.bits;

  0191b	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0191f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01922	03 8a c4 1b 00
	00		 add	 ecx, DWORD PTR [edx+7108]
  01928	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0192b	89 88 c4 1b 00
	00		 mov	 DWORD PTR [eax+7108], ecx
$LN80@inflate:

; 1096 :             }
; 1097 :             DROPBITS(here.bits);

  01931	0f b6 4d f5	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01935	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01938	d3 ea		 shr	 edx, cl
  0193a	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  0193d	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01941	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01944	2b c8		 sub	 ecx, eax
  01946	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01949	33 d2		 xor	 edx, edx
  0194b	75 e4		 jne	 SHORT $LN80@inflate

; 1098 :             state->back += here.bits;

  0194d	0f b6 45 f5	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01951	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01954	03 81 c4 1b 00
	00		 add	 eax, DWORD PTR [ecx+7108]
  0195a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0195d	89 82 c4 1b 00
	00		 mov	 DWORD PTR [edx+7108], eax

; 1099 :             if (here.op & 64) {

  01963	0f b6 45 f4	 movzx	 eax, BYTE PTR _here$[ebp]
  01967	83 e0 40	 and	 eax, 64			; 00000040H
  0196a	74 18		 je	 SHORT $LN77@inflate

; 1100 :                 strm->msg = (char *)"invalid distance code";

  0196c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0196f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 1101 :                 state->mode = BAD;

  01976	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01979	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 1102 :                 break;

  0197f	e9 54 04 00 00	 jmp	 $LN490@inflate
$LN77@inflate:

; 1103 :             }
; 1104 :             state->offset = (unsigned)here.val;

  01984	0f b7 45 f6	 movzx	 eax, WORD PTR _here$[ebp+2]
  01988	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0198b	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 1105 :             state->extra = (unsigned)(here.op) & 15;

  0198e	0f b6 55 f4	 movzx	 edx, BYTE PTR _here$[ebp]
  01992	83 e2 0f	 and	 edx, 15			; 0000000fH
  01995	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01998	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1106 :             state->mode = DISTEXT;

  0199b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0199e	c7 01 17 00 00
	00		 mov	 DWORD PTR [ecx], 23	; 00000017H
$LN76@inflate:

; 1107 :         case DISTEXT:
; 1108 :             if (state->extra) {

  019a4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  019a7	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  019ab	0f 84 a1 00 00
	00		 je	 $LN75@inflate
$LN71@inflate:

; 1109 :                 NEEDBITS(state->extra);

  019b1	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  019b4	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  019b7	3b 48 48	 cmp	 ecx, DWORD PTR [eax+72]
  019ba	73 3d		 jae	 SHORT $LN73@inflate
$LN69@inflate:
  019bc	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  019c0	75 05		 jne	 SHORT $LN66@inflate
  019c2	e9 16 04 00 00	 jmp	 $inf_leave$77745
$LN66@inflate:
  019c7	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  019ca	83 ea 01	 sub	 edx, 1
  019cd	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  019d0	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  019d3	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  019d6	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  019d9	d3 e2		 shl	 edx, cl
  019db	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  019de	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  019e1	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  019e4	83 c0 01	 add	 eax, 1
  019e7	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  019ea	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  019ed	83 c1 08	 add	 ecx, 8
  019f0	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  019f3	33 d2		 xor	 edx, edx
  019f5	75 c5		 jne	 SHORT $LN69@inflate
  019f7	eb b8		 jmp	 SHORT $LN71@inflate
$LN73@inflate:
  019f9	33 c0		 xor	 eax, eax
  019fb	75 b4		 jne	 SHORT $LN71@inflate

; 1110 :                 state->offset += BITS(state->extra);

  019fd	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a00	ba 01 00 00 00	 mov	 edx, 1
  01a05	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  01a08	d3 e2		 shl	 edx, cl
  01a0a	83 ea 01	 sub	 edx, 1
  01a0d	23 55 d4	 and	 edx, DWORD PTR _hold$[ebp]
  01a10	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a13	03 50 44	 add	 edx, DWORD PTR [eax+68]
  01a16	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a19	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN65@inflate:

; 1111 :                 DROPBITS(state->extra);

  01a1c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a1f	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01a22	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  01a25	d3 e8		 shr	 eax, cl
  01a27	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01a2a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a2d	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01a30	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  01a33	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01a36	33 c0		 xor	 eax, eax
  01a38	75 e2		 jne	 SHORT $LN65@inflate

; 1112 :                 state->back += state->extra;

  01a3a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a3d	8b 91 c4 1b 00
	00		 mov	 edx, DWORD PTR [ecx+7108]
  01a43	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a46	03 50 48	 add	 edx, DWORD PTR [eax+72]
  01a49	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a4c	89 91 c4 1b 00
	00		 mov	 DWORD PTR [ecx+7108], edx
$LN75@inflate:

; 1113 :             }
; 1114 : #ifdef INFLATE_STRICT
; 1115 :             if (state->offset > state->dmax) {
; 1116 :                 strm->msg = (char *)"invalid distance too far back";
; 1117 :                 state->mode = BAD;
; 1118 :                 break;
; 1119 :             }
; 1120 : #endif
; 1121 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1122 :             state->mode = MATCH;

  01a52	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a55	c7 02 18 00 00
	00		 mov	 DWORD PTR [edx], 24	; 00000018H
$LN62@inflate:

; 1123 :         case MATCH:
; 1124 :             if (left == 0) goto inf_leave;

  01a5b	83 7d e0 00	 cmp	 DWORD PTR _left$[ebp], 0
  01a5f	75 05		 jne	 SHORT $LN61@inflate
  01a61	e9 77 03 00 00	 jmp	 $inf_leave$77745
$LN61@inflate:

; 1125 :             copy = out - left;

  01a66	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01a69	2b 45 e0	 sub	 eax, DWORD PTR _left$[ebp]
  01a6c	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax

; 1126 :             if (state->offset > copy) {         /* copy from window */

  01a6f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a72	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  01a75	3b 55 cc	 cmp	 edx, DWORD PTR _copy$[ebp]
  01a78	0f 86 8e 00 00
	00		 jbe	 $LN60@inflate

; 1127 :                 copy = state->offset - copy;

  01a7e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a81	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  01a84	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  01a87	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 1128 :                 if (copy > state->whave) {

  01a8a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a8d	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01a90	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  01a93	76 24		 jbe	 SHORT $LN59@inflate

; 1129 :                     if (state->sane) {

  01a95	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a98	83 b9 c0 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7104], 0
  01a9f	74 18		 je	 SHORT $LN59@inflate

; 1130 :                         strm->msg = (char *)"invalid distance too far back";

  01aa1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01aa4	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1131 :                         state->mode = BAD;

  01aab	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01aae	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 1132 :                         break;

  01ab4	e9 1f 03 00 00	 jmp	 $LN490@inflate
$LN59@inflate:

; 1133 :                     }
; 1134 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1135 :                     Trace((stderr, "inflate.c too far\n"));
; 1136 :                     copy -= state->whave;
; 1137 :                     if (copy > state->length) copy = state->length;
; 1138 :                     if (copy > left) copy = left;
; 1139 :                     left -= copy;
; 1140 :                     state->length -= copy;
; 1141 :                     do {
; 1142 :                         *put++ = 0;
; 1143 :                     } while (--copy);
; 1144 :                     if (state->length == 0) state->mode = LEN;
; 1145 :                     break;
; 1146 : #endif
; 1147 :                 }
; 1148 :                 if (copy > state->wnext) {

  01ab9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01abc	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  01abf	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  01ac2	76 20		 jbe	 SHORT $LN57@inflate

; 1149 :                     copy -= state->wnext;

  01ac4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01ac7	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01aca	2b 48 30	 sub	 ecx, DWORD PTR [eax+48]
  01acd	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 1150 :                     from = state->window + (state->wsize - copy);

  01ad0	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ad3	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  01ad6	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01ad9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01adc	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  01adf	89 45 c8	 mov	 DWORD PTR _from$[ebp], eax

; 1151 :                 }
; 1152 :                 else

  01ae2	eb 12		 jmp	 SHORT $LN56@inflate
$LN57@inflate:

; 1153 :                     from = state->window + (state->wnext - copy);

  01ae4	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ae7	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  01aea	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01aed	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01af0	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  01af3	89 45 c8	 mov	 DWORD PTR _from$[ebp], eax
$LN56@inflate:

; 1154 :                 if (copy > state->length) copy = state->length;

  01af6	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01af9	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01afc	3b 42 40	 cmp	 eax, DWORD PTR [edx+64]
  01aff	76 09		 jbe	 SHORT $LN55@inflate
  01b01	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b04	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  01b07	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN55@inflate:

; 1155 :             }
; 1156 :             else {                              /* copy from output */

  01b0a	eb 15		 jmp	 SHORT $LN54@inflate
$LN60@inflate:

; 1157 :                 from = put - state->offset;

  01b0c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b0f	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01b12	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  01b15	89 4d c8	 mov	 DWORD PTR _from$[ebp], ecx

; 1158 :                 copy = state->length;

  01b18	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b1b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  01b1e	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN54@inflate:

; 1159 :             }
; 1160 :             if (copy > left) copy = left;

  01b21	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01b24	3b 4d e0	 cmp	 ecx, DWORD PTR _left$[ebp]
  01b27	76 06		 jbe	 SHORT $LN53@inflate
  01b29	8b 55 e0	 mov	 edx, DWORD PTR _left$[ebp]
  01b2c	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN53@inflate:

; 1161 :             left -= copy;

  01b2f	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  01b32	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  01b35	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax

; 1162 :             state->length -= copy;

  01b38	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b3b	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  01b3e	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  01b41	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b44	89 50 40	 mov	 DWORD PTR [eax+64], edx
$LN52@inflate:

; 1163 :             do {
; 1164 :                 *put++ = *from++;

  01b47	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01b4a	8b 55 c8	 mov	 edx, DWORD PTR _from$[ebp]
  01b4d	8a 02		 mov	 al, BYTE PTR [edx]
  01b4f	88 01		 mov	 BYTE PTR [ecx], al
  01b51	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01b54	83 c1 01	 add	 ecx, 1
  01b57	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  01b5a	8b 55 c8	 mov	 edx, DWORD PTR _from$[ebp]
  01b5d	83 c2 01	 add	 edx, 1
  01b60	89 55 c8	 mov	 DWORD PTR _from$[ebp], edx

; 1165 :             } while (--copy);

  01b63	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01b66	83 e8 01	 sub	 eax, 1
  01b69	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
  01b6c	75 d9		 jne	 SHORT $LN52@inflate

; 1166 :             if (state->length == 0) state->mode = LEN;

  01b6e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b71	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  01b75	75 09		 jne	 SHORT $LN49@inflate
  01b77	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b7a	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H
$LN49@inflate:

; 1167 :             break;

  01b80	e9 53 02 00 00	 jmp	 $LN490@inflate
$LN48@inflate:

; 1168 :         case LIT:
; 1169 :             if (left == 0) goto inf_leave;

  01b85	83 7d e0 00	 cmp	 DWORD PTR _left$[ebp], 0
  01b89	75 05		 jne	 SHORT $LN47@inflate
  01b8b	e9 4d 02 00 00	 jmp	 $inf_leave$77745
$LN47@inflate:

; 1170 :             *put++ = (unsigned char)(state->length);

  01b90	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01b93	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b96	8a 51 40	 mov	 dl, BYTE PTR [ecx+64]
  01b99	88 10		 mov	 BYTE PTR [eax], dl
  01b9b	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01b9e	83 c0 01	 add	 eax, 1
  01ba1	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax

; 1171 :             left--;

  01ba4	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01ba7	83 e9 01	 sub	 ecx, 1
  01baa	89 4d e0	 mov	 DWORD PTR _left$[ebp], ecx

; 1172 :             state->mode = LEN;

  01bad	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01bb0	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H

; 1173 :             break;

  01bb6	e9 1d 02 00 00	 jmp	 $LN490@inflate
$LN46@inflate:

; 1174 :         case CHECK:
; 1175 :             if (state->wrap) {

  01bbb	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01bbe	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  01bc2	0f 84 49 01 00
	00		 je	 $LN45@inflate
$LN41@inflate:

; 1176 :                 NEEDBITS(32);

  01bc8	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01bcc	73 3d		 jae	 SHORT $LN43@inflate
$LN39@inflate:
  01bce	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01bd2	75 05		 jne	 SHORT $LN36@inflate
  01bd4	e9 04 02 00 00	 jmp	 $inf_leave$77745
$LN36@inflate:
  01bd9	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01bdc	83 e9 01	 sub	 ecx, 1
  01bdf	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01be2	8b 55 dc	 mov	 edx, DWORD PTR _next$[ebp]
  01be5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01be8	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01beb	d3 e0		 shl	 eax, cl
  01bed	03 45 d4	 add	 eax, DWORD PTR _hold$[ebp]
  01bf0	89 45 d4	 mov	 DWORD PTR _hold$[ebp], eax
  01bf3	8b 4d dc	 mov	 ecx, DWORD PTR _next$[ebp]
  01bf6	83 c1 01	 add	 ecx, 1
  01bf9	89 4d dc	 mov	 DWORD PTR _next$[ebp], ecx
  01bfc	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01bff	83 c2 08	 add	 edx, 8
  01c02	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01c05	33 c0		 xor	 eax, eax
  01c07	75 c5		 jne	 SHORT $LN39@inflate
  01c09	eb bd		 jmp	 SHORT $LN41@inflate
$LN43@inflate:
  01c0b	33 c9		 xor	 ecx, ecx
  01c0d	75 b9		 jne	 SHORT $LN41@inflate

; 1177 :                 out -= left;

  01c0f	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01c12	2b 55 e0	 sub	 edx, DWORD PTR _left$[ebp]
  01c15	89 55 c4	 mov	 DWORD PTR _out$[ebp], edx

; 1178 :                 strm->total_out += out;

  01c18	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01c1b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01c1e	03 4d c4	 add	 ecx, DWORD PTR _out$[ebp]
  01c21	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01c24	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1179 :                 state->total += out;

  01c27	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c2a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01c2d	03 4d c4	 add	 ecx, DWORD PTR _out$[ebp]
  01c30	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01c33	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 1180 :                 if (out)

  01c36	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01c3a	74 51		 je	 SHORT $LN35@inflate

; 1181 :                     strm->adler = state->check =
; 1182 :                         UPDATE(state->check, put - out, out);

  01c3c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c3f	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  01c43	74 1c		 je	 SHORT $LN504@inflate
  01c45	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01c48	51		 push	 ecx
  01c49	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01c4c	2b 55 c4	 sub	 edx, DWORD PTR _out$[ebp]
  01c4f	52		 push	 edx
  01c50	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c53	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01c56	51		 push	 ecx
  01c57	e8 00 00 00 00	 call	 _crc32@12
  01c5c	89 45 b0	 mov	 DWORD PTR tv1224[ebp], eax
  01c5f	eb 1a		 jmp	 SHORT $LN505@inflate
$LN504@inflate:
  01c61	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01c64	52		 push	 edx
  01c65	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01c68	2b 45 c4	 sub	 eax, DWORD PTR _out$[ebp]
  01c6b	50		 push	 eax
  01c6c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01c6f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01c72	52		 push	 edx
  01c73	e8 00 00 00 00	 call	 _adler32@12
  01c78	89 45 b0	 mov	 DWORD PTR tv1224[ebp], eax
$LN505@inflate:
  01c7b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c7e	8b 4d b0	 mov	 ecx, DWORD PTR tv1224[ebp]
  01c81	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  01c84	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01c87	8b 45 b0	 mov	 eax, DWORD PTR tv1224[ebp]
  01c8a	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN35@inflate:

; 1183 :                 out = left;

  01c8d	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01c90	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 1184 :                 if ((
; 1185 : #ifdef GUNZIP
; 1186 :                      state->flags ? hold :
; 1187 : #endif
; 1188 :                      ZSWAP32(hold)) != state->check) {

  01c93	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01c96	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  01c9a	74 08		 je	 SHORT $LN506@inflate
  01c9c	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01c9f	89 45 ac	 mov	 DWORD PTR tv1238[ebp], eax
  01ca2	eb 38		 jmp	 SHORT $LN507@inflate
$LN506@inflate:
  01ca4	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01ca7	c1 e9 18	 shr	 ecx, 24			; 00000018H
  01caa	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01cb0	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01cb3	c1 ea 08	 shr	 edx, 8
  01cb6	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  01cbc	03 ca		 add	 ecx, edx
  01cbe	8b 45 d4	 mov	 eax, DWORD PTR _hold$[ebp]
  01cc1	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01cc6	c1 e0 08	 shl	 eax, 8
  01cc9	03 c8		 add	 ecx, eax
  01ccb	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01cce	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01cd4	c1 e2 18	 shl	 edx, 24			; 00000018H
  01cd7	03 ca		 add	 ecx, edx
  01cd9	89 4d ac	 mov	 DWORD PTR tv1238[ebp], ecx
$LN507@inflate:
  01cdc	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01cdf	8b 4d ac	 mov	 ecx, DWORD PTR tv1238[ebp]
  01ce2	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  01ce5	74 18		 je	 SHORT $LN33@inflate

; 1189 :                     strm->msg = (char *)"incorrect data check";

  01ce7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01cea	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1190 :                     state->mode = BAD;

  01cf1	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01cf4	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 1191 :                     break;

  01cfa	e9 d9 00 00 00	 jmp	 $LN490@inflate
$LN33@inflate:

; 1192 :                 }
; 1193 :                 INITBITS();

  01cff	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01d06	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01d0d	33 c9		 xor	 ecx, ecx
  01d0f	75 ee		 jne	 SHORT $LN33@inflate
$LN45@inflate:

; 1194 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1195 :             }
; 1196 : #ifdef GUNZIP
; 1197 :             state->mode = LENGTH;

  01d11	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01d14	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH
$LN30@inflate:

; 1198 :         case LENGTH:
; 1199 :             if (state->wrap && state->flags) {

  01d1a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d1d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  01d21	0f 84 82 00 00
	00		 je	 $LN29@inflate
  01d27	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01d2a	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01d2e	74 79		 je	 SHORT $LN29@inflate
$LN25@inflate:

; 1200 :                 NEEDBITS(32);

  01d30	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01d34	73 3d		 jae	 SHORT $LN27@inflate
$LN23@inflate:
  01d36	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01d3a	75 05		 jne	 SHORT $LN20@inflate
  01d3c	e9 9c 00 00 00	 jmp	 $inf_leave$77745
$LN20@inflate:
  01d41	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01d44	83 ea 01	 sub	 edx, 1
  01d47	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  01d4a	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01d4d	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01d50	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01d53	d3 e2		 shl	 edx, cl
  01d55	03 55 d4	 add	 edx, DWORD PTR _hold$[ebp]
  01d58	89 55 d4	 mov	 DWORD PTR _hold$[ebp], edx
  01d5b	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01d5e	83 c0 01	 add	 eax, 1
  01d61	89 45 dc	 mov	 DWORD PTR _next$[ebp], eax
  01d64	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01d67	83 c1 08	 add	 ecx, 8
  01d6a	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01d6d	33 d2		 xor	 edx, edx
  01d6f	75 c5		 jne	 SHORT $LN23@inflate
  01d71	eb bd		 jmp	 SHORT $LN25@inflate
$LN27@inflate:
  01d73	33 c0		 xor	 eax, eax
  01d75	75 b9		 jne	 SHORT $LN25@inflate

; 1201 :                 if (hold != (state->total & 0xffffffffUL)) {

  01d77	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01d7a	8b 55 d4	 mov	 edx, DWORD PTR _hold$[ebp]
  01d7d	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  01d80	74 15		 je	 SHORT $LN18@inflate

; 1202 :                     strm->msg = (char *)"incorrect length check";

  01d82	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01d85	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@

; 1203 :                     state->mode = BAD;

  01d8c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01d8f	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 1204 :                     break;

  01d95	eb 41		 jmp	 SHORT $LN490@inflate
$LN18@inflate:

; 1205 :                 }
; 1206 :                 INITBITS();

  01d97	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01d9e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01da5	33 d2		 xor	 edx, edx
  01da7	75 ee		 jne	 SHORT $LN18@inflate
$LN29@inflate:

; 1207 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1208 :             }
; 1209 : #endif
; 1210 :             state->mode = DONE;

  01da9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01dac	c7 00 1c 00 00
	00		 mov	 DWORD PTR [eax], 28	; 0000001cH
$LN15@inflate:

; 1211 :         case DONE:
; 1212 :             ret = Z_STREAM_END;

  01db2	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 1213 :             goto inf_leave;

  01db9	eb 22		 jmp	 SHORT $inf_leave$77745
$LN14@inflate:

; 1214 :         case BAD:
; 1215 :             ret = Z_DATA_ERROR;

  01dbb	c7 45 d8 fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 1216 :             goto inf_leave;

  01dc2	eb 19		 jmp	 SHORT $inf_leave$77745
$LN13@inflate:

; 1217 :         case MEM:
; 1218 :             return Z_MEM_ERROR;

  01dc4	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01dc9	e9 c7 01 00 00	 jmp	 $LN500@inflate
$LN12@inflate:

; 1219 :         case SYNC:
; 1220 :         default:
; 1221 :             return Z_STREAM_ERROR;

  01dce	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01dd3	e9 bd 01 00 00	 jmp	 $LN500@inflate
$LN490@inflate:

; 1222 :         }

  01dd8	e9 c2 e2 ff ff	 jmp	 $LN493@inflate
$inf_leave$77745:

; 1223 : 
; 1224 :     /*
; 1225 :        Return from inflate(), updating the total counts and the check value.
; 1226 :        If there was no progress during the inflate() call, return a buffer
; 1227 :        error.  Call updatewindow() to create and/or update the window state.
; 1228 :        Note: a memory error from inflate() is non-recoverable.
; 1229 :      */
; 1230 :   inf_leave:
; 1231 :     RESTORE();

  01ddd	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01de0	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01de3	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  01de6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01de9	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  01dec	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01def	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01df2	8b 45 dc	 mov	 eax, DWORD PTR _next$[ebp]
  01df5	89 02		 mov	 DWORD PTR [edx], eax
  01df7	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01dfa	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01dfd	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01e00	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01e03	8b 4d d4	 mov	 ecx, DWORD PTR _hold$[ebp]
  01e06	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  01e09	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01e0c	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  01e0f	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  01e12	33 c9		 xor	 ecx, ecx
  01e14	75 c7		 jne	 SHORT $inf_leave$77745

; 1232 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
; 1233 :             (state->mode < CHECK || flush != Z_FINISH)))

  01e16	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01e19	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  01e1d	75 21		 jne	 SHORT $LN7@inflate
  01e1f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01e22	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01e25	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  01e28	74 4a		 je	 SHORT $LN8@inflate
  01e2a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01e2d	83 3a 1d	 cmp	 DWORD PTR [edx], 29	; 0000001dH
  01e30	7d 42		 jge	 SHORT $LN8@inflate
  01e32	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01e35	83 38 1a	 cmp	 DWORD PTR [eax], 26	; 0000001aH
  01e38	7c 06		 jl	 SHORT $LN7@inflate
  01e3a	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01e3e	74 34		 je	 SHORT $LN8@inflate
$LN7@inflate:

; 1234 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  01e40	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e43	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  01e46	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  01e49	52		 push	 edx
  01e4a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01e4d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01e50	51		 push	 ecx
  01e51	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01e54	52		 push	 edx
  01e55	e8 00 00 00 00	 call	 _updatewindow
  01e5a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01e5d	85 c0		 test	 eax, eax
  01e5f	74 13		 je	 SHORT $LN8@inflate

; 1235 :             state->mode = MEM;

  01e61	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01e64	c7 00 1e 00 00
	00		 mov	 DWORD PTR [eax], 30	; 0000001eH

; 1236 :             return Z_MEM_ERROR;

  01e6a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01e6f	e9 21 01 00 00	 jmp	 $LN500@inflate
$LN8@inflate:

; 1237 :         }
; 1238 :     in -= strm->avail_in;

  01e74	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e77	8b 55 ec	 mov	 edx, DWORD PTR _in$[ebp]
  01e7a	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  01e7d	89 55 ec	 mov	 DWORD PTR _in$[ebp], edx

; 1239 :     out -= strm->avail_out;

  01e80	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01e83	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01e86	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  01e89	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 1240 :     strm->total_in += in;

  01e8c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01e8f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01e92	03 45 ec	 add	 eax, DWORD PTR _in$[ebp]
  01e95	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e98	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1241 :     strm->total_out += out;

  01e9b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01e9e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01ea1	03 45 c4	 add	 eax, DWORD PTR _out$[ebp]
  01ea4	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01ea7	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1242 :     state->total += out;

  01eaa	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ead	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  01eb0	03 45 c4	 add	 eax, DWORD PTR _out$[ebp]
  01eb3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01eb6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1243 :     if (state->wrap && out)

  01eb9	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ebc	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  01ec0	74 5d		 je	 SHORT $LN4@inflate
  01ec2	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01ec6	74 57		 je	 SHORT $LN4@inflate

; 1244 :         strm->adler = state->check =
; 1245 :             UPDATE(state->check, strm->next_out - out, out);

  01ec8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01ecb	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  01ecf	74 1f		 je	 SHORT $LN508@inflate
  01ed1	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01ed4	51		 push	 ecx
  01ed5	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01ed8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01edb	2b 45 c4	 sub	 eax, DWORD PTR _out$[ebp]
  01ede	50		 push	 eax
  01edf	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01ee2	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01ee5	52		 push	 edx
  01ee6	e8 00 00 00 00	 call	 _crc32@12
  01eeb	89 45 a8	 mov	 DWORD PTR tv1317[ebp], eax
  01eee	eb 1d		 jmp	 SHORT $LN509@inflate
$LN508@inflate:
  01ef0	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01ef3	50		 push	 eax
  01ef4	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01ef7	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01efa	2b 55 c4	 sub	 edx, DWORD PTR _out$[ebp]
  01efd	52		 push	 edx
  01efe	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01f01	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01f04	51		 push	 ecx
  01f05	e8 00 00 00 00	 call	 _adler32@12
  01f0a	89 45 a8	 mov	 DWORD PTR tv1317[ebp], eax
$LN509@inflate:
  01f0d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01f10	8b 45 a8	 mov	 eax, DWORD PTR tv1317[ebp]
  01f13	89 42 18	 mov	 DWORD PTR [edx+24], eax
  01f16	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01f19	8b 55 a8	 mov	 edx, DWORD PTR tv1317[ebp]
  01f1c	89 51 30	 mov	 DWORD PTR [ecx+48], edx
$LN4@inflate:

; 1246 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1247 :                       (state->mode == TYPE ? 128 : 0) +
; 1248 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  01f1f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01f22	83 38 13	 cmp	 DWORD PTR [eax], 19	; 00000013H
  01f25	74 11		 je	 SHORT $LN510@inflate
  01f27	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01f2a	83 39 0e	 cmp	 DWORD PTR [ecx], 14	; 0000000eH
  01f2d	74 09		 je	 SHORT $LN510@inflate
  01f2f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv1329[ebp], 0
  01f36	eb 07		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  01f38	c7 45 a4 00 01
	00 00		 mov	 DWORD PTR tv1329[ebp], 256 ; 00000100H
$LN511@inflate:
  01f3f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01f42	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01f45	f7 d8		 neg	 eax
  01f47	1b c0		 sbb	 eax, eax
  01f49	83 e0 40	 and	 eax, 64			; 00000040H
  01f4c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01f4f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  01f52	03 d0		 add	 edx, eax
  01f54	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01f57	33 c9		 xor	 ecx, ecx
  01f59	83 38 0b	 cmp	 DWORD PTR [eax], 11	; 0000000bH
  01f5c	0f 95 c1	 setne	 cl
  01f5f	83 e9 01	 sub	 ecx, 1
  01f62	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  01f68	03 55 a4	 add	 edx, DWORD PTR tv1329[ebp]
  01f6b	03 ca		 add	 ecx, edx
  01f6d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01f70	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 1249 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01f73	83 7d ec 00	 cmp	 DWORD PTR _in$[ebp], 0
  01f77	75 06		 jne	 SHORT $LN1@inflate
  01f79	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01f7d	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  01f7f	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01f83	75 0d		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  01f85	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  01f89	75 07		 jne	 SHORT $LN3@inflate

; 1250 :         ret = Z_BUF_ERROR;

  01f8b	c7 45 d8 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN3@inflate:

; 1251 :     return ret;

  01f92	8b 45 d8	 mov	 eax, DWORD PTR _ret$[ebp]
$LN500@inflate:

; 1252 : }

  01f95	8b e5		 mov	 esp, ebp
  01f97	5d		 pop	 ebp
  01f98	c2 08 00	 ret	 8
  01f9b	90		 npad	 1
$LN512@inflate:
  01f9c	00 00 00 00	 DD	 $LN489@inflate
  01fa0	00 00 00 00	 DD	 $LN454@inflate
  01fa4	00 00 00 00	 DD	 $LN434@inflate
  01fa8	00 00 00 00	 DD	 $LN416@inflate
  01fac	00 00 00 00	 DD	 $LN402@inflate
  01fb0	00 00 00 00	 DD	 $LN381@inflate
  01fb4	00 00 00 00	 DD	 $LN374@inflate
  01fb8	00 00 00 00	 DD	 $LN362@inflate
  01fbc	00 00 00 00	 DD	 $LN350@inflate
  01fc0	00 00 00 00	 DD	 $LN330@inflate
  01fc4	00 00 00 00	 DD	 $LN321@inflate
  01fc8	00 00 00 00	 DD	 $LN316@inflate
  01fcc	00 00 00 00	 DD	 $LN313@inflate
  01fd0	00 00 00 00	 DD	 $LN282@inflate
  01fd4	00 00 00 00	 DD	 $LN265@inflate
  01fd8	00 00 00 00	 DD	 $LN264@inflate
  01fdc	00 00 00 00	 DD	 $LN255@inflate
  01fe0	00 00 00 00	 DD	 $LN237@inflate
  01fe4	00 00 00 00	 DD	 $LN219@inflate
  01fe8	00 00 00 00	 DD	 $LN147@inflate
  01fec	00 00 00 00	 DD	 $LN146@inflate
  01ff0	00 00 00 00	 DD	 $LN113@inflate
  01ff4	00 00 00 00	 DD	 $LN98@inflate
  01ff8	00 00 00 00	 DD	 $LN76@inflate
  01ffc	00 00 00 00	 DD	 $LN62@inflate
  02000	00 00 00 00	 DD	 $LN48@inflate
  02004	00 00 00 00	 DD	 $LN46@inflate
  02008	00 00 00 00	 DD	 $LN30@inflate
  0200c	00 00 00 00	 DD	 $LN15@inflate
  02010	00 00 00 00	 DD	 $LN14@inflate
  02014	00 00 00 00	 DD	 $LN13@inflate
$LN513@inflate:
  02018	00 00 00 00	 DD	 $LN294@inflate
  0201c	00 00 00 00	 DD	 $LN293@inflate
  02020	00 00 00 00	 DD	 $LN288@inflate
  02024	00 00 00 00	 DD	 $LN287@inflate
_inflate@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateReset@4
; Function compile flags: /Odtp
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN1@inflateRes@2
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 07		 jne	 SHORT $LN2@inflateRes@2
$LN1@inflateRes@2:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	eb 30		 jmp	 SHORT $LN3@inflateRes@2
$LN2@inflateRes@2:

; 135  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00020	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 136  :     state->wsize = 0;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00026	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0

; 137  :     state->whave = 0;

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 138  :     state->wnext = 0;

  00037	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0003a	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 139  :     return inflateResetKeep(strm);

  00041	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _inflateResetKeep@4
$LN3@inflateRes@2:

; 140  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
_inflateReset@4 ENDP
PUBLIC	_inflateSync@4
; Function compile flags: /Odtp
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_state$ = -20						; size = 4
_out$ = -16						; size = 4
_buf$ = -12						; size = 4
_len$ = -8						; size = 4
_in$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN6@inflateSyn@2
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN7@inflateSyn@2
$LN6@inflateSyn@2:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 61 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN7@inflateSyn@2:

; 1387 :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 ec	 mov	 DWORD PTR _state$[ebp], edx

; 1388 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002f	75 13		 jne	 SHORT $LN5@inflateSyn@2
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00034	83 79 3c 08	 cmp	 DWORD PTR [ecx+60], 8
  00038	73 0a		 jae	 SHORT $LN5@inflateSyn@2
  0003a	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0003f	e9 3c 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN5@inflateSyn@2:

; 1389 : 
; 1390 :     /* if first time, start search in bit buffer */
; 1391 :     if (state->mode != SYNC) {

  00044	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00047	83 3a 1f	 cmp	 DWORD PTR [edx], 31	; 0000001fH
  0004a	0f 84 9e 00 00
	00		 je	 $LN4@inflateSyn@2

; 1392 :         state->mode = SYNC;

  00050	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00053	c7 00 1f 00 00
	00		 mov	 DWORD PTR [eax], 31	; 0000001fH

; 1393 :         state->hold <<= state->bits & 7;

  00059	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0005c	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0005f	83 e1 07	 and	 ecx, 7
  00062	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00065	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00068	d3 e0		 shl	 eax, cl
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0006d	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 1394 :         state->bits -= state->bits & 7;

  00070	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00073	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00076	83 e0 07	 and	 eax, 7
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0007f	2b d0		 sub	 edx, eax
  00081	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00084	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 1395 :         len = 0;

  00087	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN3@inflateSyn@2:

; 1396 :         while (state->bits >= 8) {

  0008e	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00091	83 79 3c 08	 cmp	 DWORD PTR [ecx+60], 8
  00095	72 36		 jb	 SHORT $LN2@inflateSyn@2

; 1397 :             buf[len++] = (unsigned char)(state->hold);

  00097	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  0009a	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	8a 48 38	 mov	 cl, BYTE PTR [eax+56]
  000a0	88 4c 15 f4	 mov	 BYTE PTR _buf$[ebp+edx], cl
  000a4	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  000a7	83 c2 01	 add	 edx, 1
  000aa	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 1398 :             state->hold >>= 8;

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000b0	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b3	c1 e9 08	 shr	 ecx, 8
  000b6	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000b9	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 1399 :             state->bits -= 8;

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000bf	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000c2	83 e9 08	 sub	 ecx, 8
  000c5	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000c8	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 1400 :         }

  000cb	eb c1		 jmp	 SHORT $LN3@inflateSyn@2
$LN2@inflateSyn@2:

; 1401 :         state->have = 0;

  000cd	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d0	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 1402 :         syncsearch(&(state->have), buf, len);

  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  000da	51		 push	 ecx
  000db	8d 55 f4	 lea	 edx, DWORD PTR _buf$[ebp]
  000de	52		 push	 edx
  000df	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000e2	83 c0 68	 add	 eax, 104		; 00000068H
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _syncsearch
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@inflateSyn@2:

; 1403 :     }
; 1404 : 
; 1405 :     /* search available input */
; 1406 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000f1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f4	52		 push	 edx
  000f5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000fe	83 c2 68	 add	 edx, 104		; 00000068H
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 _syncsearch
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 1407 :     strm->avail_in -= len;

  0010d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00110	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00113	2b 4d f8	 sub	 ecx, DWORD PTR _len$[ebp]
  00116	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00119	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1408 :     strm->next_in += len;

  0011c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00124	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00127	89 0a		 mov	 DWORD PTR [edx], ecx

; 1409 :     strm->total_in += len;

  00129	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0012c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012f	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00132	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00135	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1410 : 
; 1411 :     /* return no joy or set up to restart inflate() on a new block */
; 1412 :     if (state->have != 4) return Z_DATA_ERROR;

  00138	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0013b	83 78 68 04	 cmp	 DWORD PTR [eax+104], 4
  0013f	74 07		 je	 SHORT $LN1@inflateSyn@2
  00141	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00146	eb 38		 jmp	 SHORT $LN8@inflateSyn@2
$LN1@inflateSyn@2:

; 1413 :     in = strm->total_in;  out = strm->total_out;

  00148	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0014b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0014e	89 55 fc	 mov	 DWORD PTR _in$[ebp], edx
  00151	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00154	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00157	89 4d f0	 mov	 DWORD PTR _out$[ebp], ecx

; 1414 :     inflateReset(strm);

  0015a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 _inflateReset@4

; 1415 :     strm->total_in = in;  strm->total_out = out;

  00163	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00166	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  00169	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0016c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0016f	8b 45 f0	 mov	 eax, DWORD PTR _out$[ebp]
  00172	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1416 :     state->mode = TYPE;

  00175	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00178	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1417 :     return Z_OK;

  0017e	33 c0		 xor	 eax, eax
$LN8@inflateSyn@2:

; 1418 : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateReset2@8
; Function compile flags: /Odtp
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_state$ = -8						; size = 4
_wrap$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 146  :     int wrap;
; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     /* get the state */
; 150  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN7@inflateRes@3
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN8@inflateRes@3
$LN7@inflateRes@3:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 a6 00 00 00	 jmp	 $LN9@inflateRes@3
$LN8@inflateRes@3:

; 151  :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 f8	 mov	 DWORD PTR _state$[ebp], edx

; 152  : 
; 153  :     /* extract wrap request from windowBits parameter */
; 154  :     if (windowBits < 0) {

  00028	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  0002c	7d 11		 jge	 SHORT $LN6@inflateRes@3

; 155  :         wrap = 0;

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _wrap$[ebp], 0

; 156  :         windowBits = -windowBits;

  00035	8b 45 0c	 mov	 eax, DWORD PTR _windowBits$[ebp]
  00038	f7 d8		 neg	 eax
  0003a	89 45 0c	 mov	 DWORD PTR _windowBits$[ebp], eax

; 157  :     }
; 158  :     else {

  0003d	eb 1b		 jmp	 SHORT $LN5@inflateRes@3
$LN6@inflateRes@3:

; 159  :         wrap = (windowBits >> 4) + 1;

  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  00042	c1 f9 04	 sar	 ecx, 4
  00045	83 c1 01	 add	 ecx, 1
  00048	89 4d fc	 mov	 DWORD PTR _wrap$[ebp], ecx

; 160  : #ifdef GUNZIP
; 161  :         if (windowBits < 48)

  0004b	83 7d 0c 30	 cmp	 DWORD PTR _windowBits$[ebp], 48 ; 00000030H
  0004f	7d 09		 jge	 SHORT $LN5@inflateRes@3

; 162  :             windowBits &= 15;

  00051	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  00054	83 e2 0f	 and	 edx, 15			; 0000000fH
  00057	89 55 0c	 mov	 DWORD PTR _windowBits$[ebp], edx
$LN5@inflateRes@3:

; 163  : #endif
; 164  :     }
; 165  : 
; 166  :     /* set number of window bits, free window if different */
; 167  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0005a	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  0005e	74 13		 je	 SHORT $LN3@inflateRes@3
  00060	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  00064	7c 06		 jl	 SHORT $LN2@inflateRes@3
  00066	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  0006a	7e 07		 jle	 SHORT $LN3@inflateRes@3
$LN2@inflateRes@3:

; 168  :         return Z_STREAM_ERROR;

  0006c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00071	eb 52		 jmp	 SHORT $LN9@inflateRes@3
$LN3@inflateRes@3:

; 169  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00073	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00076	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0007a	74 2e		 je	 SHORT $LN1@inflateRes@3
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0007f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00082	3b 55 0c	 cmp	 edx, DWORD PTR _windowBits$[ebp]
  00085	74 23		 je	 SHORT $LN1@inflateRes@3

; 170  :         ZFREE(strm, state->window);

  00087	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0008d	51		 push	 ecx
  0008e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00091	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00094	50		 push	 eax
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00098	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0009b	ff d2		 call	 edx
  0009d	83 c4 08	 add	 esp, 8

; 171  :         state->window = Z_NULL;

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a3	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0
$LN1@inflateRes@3:

; 172  :     }
; 173  : 
; 174  :     /* update state and reset the rest of it */
; 175  :     state->wrap = wrap;

  000aa	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _wrap$[ebp]
  000b0	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 176  :     state->wbits = (unsigned)windowBits;

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000b9	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 177  :     return inflateReset(strm);

  000bc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _inflateReset@4
$LN9@inflateRes@3:

; 178  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
PUBLIC	_inflateInit2_@16
; Function compile flags: /Odtp
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 186  :     int ret;
; 187  :     struct inflate_state FAR *state;
; 188  : 
; 189  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 190  :         stream_size != (int)(sizeof(z_stream)))

  00006	83 7d 10 00	 cmp	 DWORD PTR _version$[ebp], 0
  0000a	74 17		 je	 SHORT $LN6@inflateIni
  0000c	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  0000f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00012	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR ??_C@_05IAIEPMAK@1?42?48?$AA@
  00019	3b ca		 cmp	 ecx, edx
  0001b	75 06		 jne	 SHORT $LN6@inflateIni
  0001d	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  00021	74 0a		 je	 SHORT $LN7@inflateIni
$LN6@inflateIni:

; 191  :         return Z_VERSION_ERROR;

  00023	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00028	e9 bf 00 00 00	 jmp	 $LN8@inflateIni
$LN7@inflateIni:

; 192  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002d	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00031	75 0a		 jne	 SHORT $LN5@inflateIni
  00033	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00038	e9 af 00 00 00	 jmp	 $LN8@inflateIni
$LN5@inflateIni:

; 193  :     strm->msg = Z_NULL;                 /* in case we return an error */

  0003d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00040	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 194  :     if (strm->zalloc == (alloc_func)0) {

  00047	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0004a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0004e	75 14		 jne	 SHORT $LN4@inflateIni

; 195  : #ifdef Z_SOLO
; 196  :         return Z_STREAM_ERROR;
; 197  : #else
; 198  :         strm->zalloc = zcalloc;

  00050	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00053	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _zcalloc

; 199  :         strm->opaque = (voidpf)0;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN4@inflateIni:

; 200  : #endif
; 201  :     }
; 202  :     if (strm->zfree == (free_func)0)

  00064	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00067	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0006b	75 0a		 jne	 SHORT $LN3@inflateIni

; 203  : #ifdef Z_SOLO
; 204  :         return Z_STREAM_ERROR;
; 205  : #else
; 206  :         strm->zfree = zcfree;

  0006d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00070	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _zcfree
$LN3@inflateIni:

; 207  : #endif
; 208  :     state = (struct inflate_state FAR *)
; 209  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00077	68 cc 1b 00 00	 push	 7116			; 00001bccH
  0007c	6a 01		 push	 1
  0007e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00081	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00084	51		 push	 ecx
  00085	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00088	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0008b	ff d0		 call	 eax
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00090	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 210  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00093	83 7d f8 00	 cmp	 DWORD PTR _state$[ebp], 0
  00097	75 07		 jne	 SHORT $LN2@inflateIni
  00099	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0009e	eb 4c		 jmp	 SHORT $LN8@inflateIni
$LN2@inflateIni:

; 211  :     Tracev((stderr, "inflate: allocated\n"));
; 212  :     strm->state = (struct internal_state FAR *)state;

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000a6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 213  :     state->window = Z_NULL;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000ac	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 214  :     ret = inflateReset2(strm, windowBits);

  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000b6	51		 push	 ecx
  000b7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 _inflateReset2@8
  000c0	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 215  :     if (ret != Z_OK) {

  000c3	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000c7	74 20		 je	 SHORT $LN1@inflateIni

; 216  :         ZFREE(strm, state);

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000d0	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000d3	52		 push	 edx
  000d4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000d7	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000da	ff d1		 call	 ecx
  000dc	83 c4 08	 add	 esp, 8

; 217  :         strm->state = Z_NULL;

  000df	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000e2	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0
$LN1@inflateIni:

; 218  :     }
; 219  :     return ret;

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN8@inflateIni:

; 220  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
PUBLIC	_inflateInit_@12
; Function compile flags: /Odtp
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 227  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	8b 45 10	 mov	 eax, DWORD PTR _stream_size$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _version$[ebp]
  0000a	51		 push	 ecx
  0000b	6a 0f		 push	 15			; 0000000fH
  0000d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _inflateInit2_@16

; 228  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
END
